(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_inject();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      init_inject();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c2 = Math.pow(2, -e)) < 1) {
            e--;
            c2 *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c2;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c2 >= 2) {
            e++;
            c2 /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c2 - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      init_inject();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer5;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer5.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer5.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer5.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer5.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer5.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer5.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer5.prototype);
        return buf;
      }
      function Buffer5(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer5.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer5.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer5.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer5.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer5.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer5, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer5.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer5.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer5.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer5.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer5.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer5.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer5.alloc(+length);
      }
      Buffer5.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer5.prototype;
      };
      Buffer5.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer5.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer5.from(b, b.offset, b.byteLength);
        if (!Buffer5.isBuffer(a) || !Buffer5.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x2 = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x2, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x2 = a[i];
            y = b[i];
            break;
          }
        }
        if (x2 < y)
          return -1;
        if (y < x2)
          return 1;
        return 0;
      };
      Buffer5.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer5.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer5.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer5.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer5.isBuffer(buf))
                buf = Buffer5.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer5.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer5.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer5.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer5.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer5.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer5.prototype.swap32 = function swap322() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer5.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer5.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer5.prototype.toLocaleString = Buffer5.prototype.toString;
      Buffer5.prototype.equals = function equals(b) {
        if (!Buffer5.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer5.compare(this, b) === 0;
      };
      Buffer5.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer5.prototype[customInspectSymbol] = Buffer5.prototype.inspect;
      }
      Buffer5.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer5.from(target, target.offset, target.byteLength);
        }
        if (!Buffer5.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x2 = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x2, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x2 = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x2 < y)
          return -1;
        if (y < x2)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer5.from(val, encoding);
        }
        if (Buffer5.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read2(arr, i + j) !== read2(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer5.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer5.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer5.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer5.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer5.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer5.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer5.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer5.prototype.readUintLE = Buffer5.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer5.prototype.readUintBE = Buffer5.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer5.prototype.readUint8 = Buffer5.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer5.prototype.readUint16LE = Buffer5.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer5.prototype.readUint16BE = Buffer5.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer5.prototype.readUint32LE = Buffer5.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer5.prototype.readUint32BE = Buffer5.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer5.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer5.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer5.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer5.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer5.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer5.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer5.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer5.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer5.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer5.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer5.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer5.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer5.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer5.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer5.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer5.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer5.prototype.writeUintLE = Buffer5.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer5.prototype.writeUintBE = Buffer5.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer5.prototype.writeUint8 = Buffer5.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer5.prototype.writeUint16LE = Buffer5.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer5.prototype.writeUint16BE = Buffer5.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer5.prototype.writeUint32LE = Buffer5.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer5.prototype.writeUint32BE = Buffer5.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer5.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer5.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer5.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer5.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer5.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer5.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer5.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer5.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer5.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer5.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer5.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer5.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer5.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer5.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer5.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer5.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer5.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer5.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer5.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer5.isBuffer(val) ? val : Buffer5.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c2, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c2 = str.charCodeAt(i);
          hi = c2 >> 8;
          lo = c2 % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // inject.js
  var import_buffer, Buffer2;
  var init_inject = __esm({
    "inject.js"() {
      import_buffer = __toESM(require_buffer(), 1);
      Buffer2 = import_buffer.Buffer;
    }
  });

  // node_modules/jsbn/index.js
  var require_jsbn = __commonJS({
    "node_modules/jsbn/index.js"(exports, module) {
      init_inject();
      (function() {
        var dbits;
        var canary = 244837814094590;
        var j_lm = (canary & 16777215) == 15715070;
        function BigInteger(a, b, c2) {
          if (a != null)
            if ("number" == typeof a)
              this.fromNumber(a, b, c2);
            else if (b == null && "string" != typeof a)
              this.fromString(a, 256);
            else
              this.fromString(a, b);
        }
        function nbi() {
          return new BigInteger(null);
        }
        function am1(i, x2, w, j, c2, n) {
          while (--n >= 0) {
            var v = x2 * this[i++] + w[j] + c2;
            c2 = Math.floor(v / 67108864);
            w[j++] = v & 67108863;
          }
          return c2;
        }
        function am2(i, x2, w, j, c2, n) {
          var xl = x2 & 32767, xh = x2 >> 15;
          while (--n >= 0) {
            var l = this[i] & 32767;
            var h = this[i++] >> 15;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 32767) << 15) + w[j] + (c2 & 1073741823);
            c2 = (l >>> 30) + (m >>> 15) + xh * h + (c2 >>> 30);
            w[j++] = l & 1073741823;
          }
          return c2;
        }
        function am3(i, x2, w, j, c2, n) {
          var xl = x2 & 16383, xh = x2 >> 14;
          while (--n >= 0) {
            var l = this[i] & 16383;
            var h = this[i++] >> 14;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 16383) << 14) + w[j] + c2;
            c2 = (l >> 28) + (m >> 14) + xh * h;
            w[j++] = l & 268435455;
          }
          return c2;
        }
        var inBrowser = typeof navigator !== "undefined";
        if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
          BigInteger.prototype.am = am2;
          dbits = 30;
        } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
          BigInteger.prototype.am = am1;
          dbits = 26;
        } else {
          BigInteger.prototype.am = am3;
          dbits = 28;
        }
        BigInteger.prototype.DB = dbits;
        BigInteger.prototype.DM = (1 << dbits) - 1;
        BigInteger.prototype.DV = 1 << dbits;
        var BI_FP = 52;
        BigInteger.prototype.FV = Math.pow(2, BI_FP);
        BigInteger.prototype.F1 = BI_FP - dbits;
        BigInteger.prototype.F2 = 2 * dbits - BI_FP;
        var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
        var BI_RC = new Array();
        var rr, vv;
        rr = "0".charCodeAt(0);
        for (vv = 0; vv <= 9; ++vv)
          BI_RC[rr++] = vv;
        rr = "a".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv)
          BI_RC[rr++] = vv;
        rr = "A".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv)
          BI_RC[rr++] = vv;
        function int2char(n) {
          return BI_RM.charAt(n);
        }
        function intAt(s, i) {
          var c2 = BI_RC[s.charCodeAt(i)];
          return c2 == null ? -1 : c2;
        }
        function bnpCopyTo(r2) {
          for (var i = this.t - 1; i >= 0; --i)
            r2[i] = this[i];
          r2.t = this.t;
          r2.s = this.s;
        }
        function bnpFromInt(x2) {
          this.t = 1;
          this.s = x2 < 0 ? -1 : 0;
          if (x2 > 0)
            this[0] = x2;
          else if (x2 < -1)
            this[0] = x2 + this.DV;
          else
            this.t = 0;
        }
        function nbv(i) {
          var r2 = nbi();
          r2.fromInt(i);
          return r2;
        }
        function bnpFromString(s, b) {
          var k;
          if (b == 16)
            k = 4;
          else if (b == 8)
            k = 3;
          else if (b == 256)
            k = 8;
          else if (b == 2)
            k = 1;
          else if (b == 32)
            k = 5;
          else if (b == 4)
            k = 2;
          else {
            this.fromRadix(s, b);
            return;
          }
          this.t = 0;
          this.s = 0;
          var i = s.length, mi = false, sh = 0;
          while (--i >= 0) {
            var x2 = k == 8 ? s[i] & 255 : intAt(s, i);
            if (x2 < 0) {
              if (s.charAt(i) == "-")
                mi = true;
              continue;
            }
            mi = false;
            if (sh == 0)
              this[this.t++] = x2;
            else if (sh + k > this.DB) {
              this[this.t - 1] |= (x2 & (1 << this.DB - sh) - 1) << sh;
              this[this.t++] = x2 >> this.DB - sh;
            } else
              this[this.t - 1] |= x2 << sh;
            sh += k;
            if (sh >= this.DB)
              sh -= this.DB;
          }
          if (k == 8 && (s[0] & 128) != 0) {
            this.s = -1;
            if (sh > 0)
              this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
          }
          this.clamp();
          if (mi)
            BigInteger.ZERO.subTo(this, this);
        }
        function bnpClamp() {
          var c2 = this.s & this.DM;
          while (this.t > 0 && this[this.t - 1] == c2)
            --this.t;
        }
        function bnToString(b) {
          if (this.s < 0)
            return "-" + this.negate().toString(b);
          var k;
          if (b == 16)
            k = 4;
          else if (b == 8)
            k = 3;
          else if (b == 2)
            k = 1;
          else if (b == 32)
            k = 5;
          else if (b == 4)
            k = 2;
          else
            return this.toRadix(b);
          var km = (1 << k) - 1, d, m = false, r2 = "", i = this.t;
          var p = this.DB - i * this.DB % k;
          if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
              m = true;
              r2 = int2char(d);
            }
            while (i >= 0) {
              if (p < k) {
                d = (this[i] & (1 << p) - 1) << k - p;
                d |= this[--i] >> (p += this.DB - k);
              } else {
                d = this[i] >> (p -= k) & km;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if (d > 0)
                m = true;
              if (m)
                r2 += int2char(d);
            }
          }
          return m ? r2 : "0";
        }
        function bnNegate() {
          var r2 = nbi();
          BigInteger.ZERO.subTo(this, r2);
          return r2;
        }
        function bnAbs() {
          return this.s < 0 ? this.negate() : this;
        }
        function bnCompareTo(a) {
          var r2 = this.s - a.s;
          if (r2 != 0)
            return r2;
          var i = this.t;
          r2 = i - a.t;
          if (r2 != 0)
            return this.s < 0 ? -r2 : r2;
          while (--i >= 0)
            if ((r2 = this[i] - a[i]) != 0)
              return r2;
          return 0;
        }
        function nbits(x2) {
          var r2 = 1, t2;
          if ((t2 = x2 >>> 16) != 0) {
            x2 = t2;
            r2 += 16;
          }
          if ((t2 = x2 >> 8) != 0) {
            x2 = t2;
            r2 += 8;
          }
          if ((t2 = x2 >> 4) != 0) {
            x2 = t2;
            r2 += 4;
          }
          if ((t2 = x2 >> 2) != 0) {
            x2 = t2;
            r2 += 2;
          }
          if ((t2 = x2 >> 1) != 0) {
            x2 = t2;
            r2 += 1;
          }
          return r2;
        }
        function bnBitLength() {
          if (this.t <= 0)
            return 0;
          return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
        }
        function bnpDLShiftTo(n, r2) {
          var i;
          for (i = this.t - 1; i >= 0; --i)
            r2[i + n] = this[i];
          for (i = n - 1; i >= 0; --i)
            r2[i] = 0;
          r2.t = this.t + n;
          r2.s = this.s;
        }
        function bnpDRShiftTo(n, r2) {
          for (var i = n; i < this.t; ++i)
            r2[i - n] = this[i];
          r2.t = Math.max(this.t - n, 0);
          r2.s = this.s;
        }
        function bnpLShiftTo(n, r2) {
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << cbs) - 1;
          var ds = Math.floor(n / this.DB), c2 = this.s << bs & this.DM, i;
          for (i = this.t - 1; i >= 0; --i) {
            r2[i + ds + 1] = this[i] >> cbs | c2;
            c2 = (this[i] & bm) << bs;
          }
          for (i = ds - 1; i >= 0; --i)
            r2[i] = 0;
          r2[ds] = c2;
          r2.t = this.t + ds + 1;
          r2.s = this.s;
          r2.clamp();
        }
        function bnpRShiftTo(n, r2) {
          r2.s = this.s;
          var ds = Math.floor(n / this.DB);
          if (ds >= this.t) {
            r2.t = 0;
            return;
          }
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << bs) - 1;
          r2[0] = this[ds] >> bs;
          for (var i = ds + 1; i < this.t; ++i) {
            r2[i - ds - 1] |= (this[i] & bm) << cbs;
            r2[i - ds] = this[i] >> bs;
          }
          if (bs > 0)
            r2[this.t - ds - 1] |= (this.s & bm) << cbs;
          r2.t = this.t - ds;
          r2.clamp();
        }
        function bnpSubTo(a, r2) {
          var i = 0, c2 = 0, m = Math.min(a.t, this.t);
          while (i < m) {
            c2 += this[i] - a[i];
            r2[i++] = c2 & this.DM;
            c2 >>= this.DB;
          }
          if (a.t < this.t) {
            c2 -= a.s;
            while (i < this.t) {
              c2 += this[i];
              r2[i++] = c2 & this.DM;
              c2 >>= this.DB;
            }
            c2 += this.s;
          } else {
            c2 += this.s;
            while (i < a.t) {
              c2 -= a[i];
              r2[i++] = c2 & this.DM;
              c2 >>= this.DB;
            }
            c2 -= a.s;
          }
          r2.s = c2 < 0 ? -1 : 0;
          if (c2 < -1)
            r2[i++] = this.DV + c2;
          else if (c2 > 0)
            r2[i++] = c2;
          r2.t = i;
          r2.clamp();
        }
        function bnpMultiplyTo(a, r2) {
          var x2 = this.abs(), y = a.abs();
          var i = x2.t;
          r2.t = i + y.t;
          while (--i >= 0)
            r2[i] = 0;
          for (i = 0; i < y.t; ++i)
            r2[i + x2.t] = x2.am(0, y[i], r2, i, 0, x2.t);
          r2.s = 0;
          r2.clamp();
          if (this.s != a.s)
            BigInteger.ZERO.subTo(r2, r2);
        }
        function bnpSquareTo(r2) {
          var x2 = this.abs();
          var i = r2.t = 2 * x2.t;
          while (--i >= 0)
            r2[i] = 0;
          for (i = 0; i < x2.t - 1; ++i) {
            var c2 = x2.am(i, x2[i], r2, 2 * i, 0, 1);
            if ((r2[i + x2.t] += x2.am(i + 1, 2 * x2[i], r2, 2 * i + 1, c2, x2.t - i - 1)) >= x2.DV) {
              r2[i + x2.t] -= x2.DV;
              r2[i + x2.t + 1] = 1;
            }
          }
          if (r2.t > 0)
            r2[r2.t - 1] += x2.am(i, x2[i], r2, 2 * i, 0, 1);
          r2.s = 0;
          r2.clamp();
        }
        function bnpDivRemTo(m, q, r2) {
          var pm = m.abs();
          if (pm.t <= 0)
            return;
          var pt = this.abs();
          if (pt.t < pm.t) {
            if (q != null)
              q.fromInt(0);
            if (r2 != null)
              this.copyTo(r2);
            return;
          }
          if (r2 == null)
            r2 = nbi();
          var y = nbi(), ts = this.s, ms = m.s;
          var nsh = this.DB - nbits(pm[pm.t - 1]);
          if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r2);
          } else {
            pm.copyTo(y);
            pt.copyTo(r2);
          }
          var ys = y.t;
          var y0 = y[ys - 1];
          if (y0 == 0)
            return;
          var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
          var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
          var i = r2.t, j = i - ys, t2 = q == null ? nbi() : q;
          y.dlShiftTo(j, t2);
          if (r2.compareTo(t2) >= 0) {
            r2[r2.t++] = 1;
            r2.subTo(t2, r2);
          }
          BigInteger.ONE.dlShiftTo(ys, t2);
          t2.subTo(y, y);
          while (y.t < ys)
            y[y.t++] = 0;
          while (--j >= 0) {
            var qd = r2[--i] == y0 ? this.DM : Math.floor(r2[i] * d1 + (r2[i - 1] + e) * d2);
            if ((r2[i] += y.am(0, qd, r2, j, 0, ys)) < qd) {
              y.dlShiftTo(j, t2);
              r2.subTo(t2, r2);
              while (r2[i] < --qd)
                r2.subTo(t2, r2);
            }
          }
          if (q != null) {
            r2.drShiftTo(ys, q);
            if (ts != ms)
              BigInteger.ZERO.subTo(q, q);
          }
          r2.t = ys;
          r2.clamp();
          if (nsh > 0)
            r2.rShiftTo(nsh, r2);
          if (ts < 0)
            BigInteger.ZERO.subTo(r2, r2);
        }
        function bnMod(a) {
          var r2 = nbi();
          this.abs().divRemTo(a, null, r2);
          if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
            a.subTo(r2, r2);
          return r2;
        }
        function Classic(m) {
          this.m = m;
        }
        function cConvert(x2) {
          if (x2.s < 0 || x2.compareTo(this.m) >= 0)
            return x2.mod(this.m);
          else
            return x2;
        }
        function cRevert(x2) {
          return x2;
        }
        function cReduce(x2) {
          x2.divRemTo(this.m, null, x2);
        }
        function cMulTo(x2, y, r2) {
          x2.multiplyTo(y, r2);
          this.reduce(r2);
        }
        function cSqrTo(x2, r2) {
          x2.squareTo(r2);
          this.reduce(r2);
        }
        Classic.prototype.convert = cConvert;
        Classic.prototype.revert = cRevert;
        Classic.prototype.reduce = cReduce;
        Classic.prototype.mulTo = cMulTo;
        Classic.prototype.sqrTo = cSqrTo;
        function bnpInvDigit() {
          if (this.t < 1)
            return 0;
          var x2 = this[0];
          if ((x2 & 1) == 0)
            return 0;
          var y = x2 & 3;
          y = y * (2 - (x2 & 15) * y) & 15;
          y = y * (2 - (x2 & 255) * y) & 255;
          y = y * (2 - ((x2 & 65535) * y & 65535)) & 65535;
          y = y * (2 - x2 * y % this.DV) % this.DV;
          return y > 0 ? this.DV - y : -y;
        }
        function Montgomery(m) {
          this.m = m;
          this.mp = m.invDigit();
          this.mpl = this.mp & 32767;
          this.mph = this.mp >> 15;
          this.um = (1 << m.DB - 15) - 1;
          this.mt2 = 2 * m.t;
        }
        function montConvert(x2) {
          var r2 = nbi();
          x2.abs().dlShiftTo(this.m.t, r2);
          r2.divRemTo(this.m, null, r2);
          if (x2.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
            this.m.subTo(r2, r2);
          return r2;
        }
        function montRevert(x2) {
          var r2 = nbi();
          x2.copyTo(r2);
          this.reduce(r2);
          return r2;
        }
        function montReduce(x2) {
          while (x2.t <= this.mt2)
            x2[x2.t++] = 0;
          for (var i = 0; i < this.m.t; ++i) {
            var j = x2[i] & 32767;
            var u0 = j * this.mpl + ((j * this.mph + (x2[i] >> 15) * this.mpl & this.um) << 15) & x2.DM;
            j = i + this.m.t;
            x2[j] += this.m.am(0, u0, x2, i, 0, this.m.t);
            while (x2[j] >= x2.DV) {
              x2[j] -= x2.DV;
              x2[++j]++;
            }
          }
          x2.clamp();
          x2.drShiftTo(this.m.t, x2);
          if (x2.compareTo(this.m) >= 0)
            x2.subTo(this.m, x2);
        }
        function montSqrTo(x2, r2) {
          x2.squareTo(r2);
          this.reduce(r2);
        }
        function montMulTo(x2, y, r2) {
          x2.multiplyTo(y, r2);
          this.reduce(r2);
        }
        Montgomery.prototype.convert = montConvert;
        Montgomery.prototype.revert = montRevert;
        Montgomery.prototype.reduce = montReduce;
        Montgomery.prototype.mulTo = montMulTo;
        Montgomery.prototype.sqrTo = montSqrTo;
        function bnpIsEven() {
          return (this.t > 0 ? this[0] & 1 : this.s) == 0;
        }
        function bnpExp(e, z2) {
          if (e > 4294967295 || e < 1)
            return BigInteger.ONE;
          var r2 = nbi(), r22 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
          g.copyTo(r2);
          while (--i >= 0) {
            z2.sqrTo(r2, r22);
            if ((e & 1 << i) > 0)
              z2.mulTo(r22, g, r2);
            else {
              var t2 = r2;
              r2 = r22;
              r22 = t2;
            }
          }
          return z2.revert(r2);
        }
        function bnModPowInt(e, m) {
          var z2;
          if (e < 256 || m.isEven())
            z2 = new Classic(m);
          else
            z2 = new Montgomery(m);
          return this.exp(e, z2);
        }
        BigInteger.prototype.copyTo = bnpCopyTo;
        BigInteger.prototype.fromInt = bnpFromInt;
        BigInteger.prototype.fromString = bnpFromString;
        BigInteger.prototype.clamp = bnpClamp;
        BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
        BigInteger.prototype.drShiftTo = bnpDRShiftTo;
        BigInteger.prototype.lShiftTo = bnpLShiftTo;
        BigInteger.prototype.rShiftTo = bnpRShiftTo;
        BigInteger.prototype.subTo = bnpSubTo;
        BigInteger.prototype.multiplyTo = bnpMultiplyTo;
        BigInteger.prototype.squareTo = bnpSquareTo;
        BigInteger.prototype.divRemTo = bnpDivRemTo;
        BigInteger.prototype.invDigit = bnpInvDigit;
        BigInteger.prototype.isEven = bnpIsEven;
        BigInteger.prototype.exp = bnpExp;
        BigInteger.prototype.toString = bnToString;
        BigInteger.prototype.negate = bnNegate;
        BigInteger.prototype.abs = bnAbs;
        BigInteger.prototype.compareTo = bnCompareTo;
        BigInteger.prototype.bitLength = bnBitLength;
        BigInteger.prototype.mod = bnMod;
        BigInteger.prototype.modPowInt = bnModPowInt;
        BigInteger.ZERO = nbv(0);
        BigInteger.ONE = nbv(1);
        function bnClone() {
          var r2 = nbi();
          this.copyTo(r2);
          return r2;
        }
        function bnIntValue() {
          if (this.s < 0) {
            if (this.t == 1)
              return this[0] - this.DV;
            else if (this.t == 0)
              return -1;
          } else if (this.t == 1)
            return this[0];
          else if (this.t == 0)
            return 0;
          return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
        }
        function bnByteValue() {
          return this.t == 0 ? this.s : this[0] << 24 >> 24;
        }
        function bnShortValue() {
          return this.t == 0 ? this.s : this[0] << 16 >> 16;
        }
        function bnpChunkSize(r2) {
          return Math.floor(Math.LN2 * this.DB / Math.log(r2));
        }
        function bnSigNum() {
          if (this.s < 0)
            return -1;
          else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
            return 0;
          else
            return 1;
        }
        function bnpToRadix(b) {
          if (b == null)
            b = 10;
          if (this.signum() == 0 || b < 2 || b > 36)
            return "0";
          var cs = this.chunkSize(b);
          var a = Math.pow(b, cs);
          var d = nbv(a), y = nbi(), z2 = nbi(), r2 = "";
          this.divRemTo(d, y, z2);
          while (y.signum() > 0) {
            r2 = (a + z2.intValue()).toString(b).substr(1) + r2;
            y.divRemTo(d, y, z2);
          }
          return z2.intValue().toString(b) + r2;
        }
        function bnpFromRadix(s, b) {
          this.fromInt(0);
          if (b == null)
            b = 10;
          var cs = this.chunkSize(b);
          var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
          for (var i = 0; i < s.length; ++i) {
            var x2 = intAt(s, i);
            if (x2 < 0) {
              if (s.charAt(i) == "-" && this.signum() == 0)
                mi = true;
              continue;
            }
            w = b * w + x2;
            if (++j >= cs) {
              this.dMultiply(d);
              this.dAddOffset(w, 0);
              j = 0;
              w = 0;
            }
          }
          if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
          }
          if (mi)
            BigInteger.ZERO.subTo(this, this);
        }
        function bnpFromNumber(a, b, c2) {
          if ("number" == typeof b) {
            if (a < 2)
              this.fromInt(1);
            else {
              this.fromNumber(a, c2);
              if (!this.testBit(a - 1))
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
              if (this.isEven())
                this.dAddOffset(1, 0);
              while (!this.isProbablePrime(b)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() > a)
                  this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
              }
            }
          } else {
            var x2 = new Array(), t2 = a & 7;
            x2.length = (a >> 3) + 1;
            b.nextBytes(x2);
            if (t2 > 0)
              x2[0] &= (1 << t2) - 1;
            else
              x2[0] = 0;
            this.fromString(x2, 256);
          }
        }
        function bnToByteArray() {
          var i = this.t, r2 = new Array();
          r2[0] = this.s;
          var p = this.DB - i * this.DB % 8, d, k = 0;
          if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
              r2[k++] = d | this.s << this.DB - p;
            while (i >= 0) {
              if (p < 8) {
                d = (this[i] & (1 << p) - 1) << 8 - p;
                d |= this[--i] >> (p += this.DB - 8);
              } else {
                d = this[i] >> (p -= 8) & 255;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if ((d & 128) != 0)
                d |= -256;
              if (k == 0 && (this.s & 128) != (d & 128))
                ++k;
              if (k > 0 || d != this.s)
                r2[k++] = d;
            }
          }
          return r2;
        }
        function bnEquals(a) {
          return this.compareTo(a) == 0;
        }
        function bnMin(a) {
          return this.compareTo(a) < 0 ? this : a;
        }
        function bnMax(a) {
          return this.compareTo(a) > 0 ? this : a;
        }
        function bnpBitwiseTo(a, op, r2) {
          var i, f, m = Math.min(a.t, this.t);
          for (i = 0; i < m; ++i)
            r2[i] = op(this[i], a[i]);
          if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i)
              r2[i] = op(this[i], f);
            r2.t = this.t;
          } else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i)
              r2[i] = op(f, a[i]);
            r2.t = a.t;
          }
          r2.s = op(this.s, a.s);
          r2.clamp();
        }
        function op_and(x2, y) {
          return x2 & y;
        }
        function bnAnd(a) {
          var r2 = nbi();
          this.bitwiseTo(a, op_and, r2);
          return r2;
        }
        function op_or(x2, y) {
          return x2 | y;
        }
        function bnOr(a) {
          var r2 = nbi();
          this.bitwiseTo(a, op_or, r2);
          return r2;
        }
        function op_xor(x2, y) {
          return x2 ^ y;
        }
        function bnXor(a) {
          var r2 = nbi();
          this.bitwiseTo(a, op_xor, r2);
          return r2;
        }
        function op_andnot(x2, y) {
          return x2 & ~y;
        }
        function bnAndNot(a) {
          var r2 = nbi();
          this.bitwiseTo(a, op_andnot, r2);
          return r2;
        }
        function bnNot() {
          var r2 = nbi();
          for (var i = 0; i < this.t; ++i)
            r2[i] = this.DM & ~this[i];
          r2.t = this.t;
          r2.s = ~this.s;
          return r2;
        }
        function bnShiftLeft(n) {
          var r2 = nbi();
          if (n < 0)
            this.rShiftTo(-n, r2);
          else
            this.lShiftTo(n, r2);
          return r2;
        }
        function bnShiftRight(n) {
          var r2 = nbi();
          if (n < 0)
            this.lShiftTo(-n, r2);
          else
            this.rShiftTo(n, r2);
          return r2;
        }
        function lbit(x2) {
          if (x2 == 0)
            return -1;
          var r2 = 0;
          if ((x2 & 65535) == 0) {
            x2 >>= 16;
            r2 += 16;
          }
          if ((x2 & 255) == 0) {
            x2 >>= 8;
            r2 += 8;
          }
          if ((x2 & 15) == 0) {
            x2 >>= 4;
            r2 += 4;
          }
          if ((x2 & 3) == 0) {
            x2 >>= 2;
            r2 += 2;
          }
          if ((x2 & 1) == 0)
            ++r2;
          return r2;
        }
        function bnGetLowestSetBit() {
          for (var i = 0; i < this.t; ++i)
            if (this[i] != 0)
              return i * this.DB + lbit(this[i]);
          if (this.s < 0)
            return this.t * this.DB;
          return -1;
        }
        function cbit(x2) {
          var r2 = 0;
          while (x2 != 0) {
            x2 &= x2 - 1;
            ++r2;
          }
          return r2;
        }
        function bnBitCount() {
          var r2 = 0, x2 = this.s & this.DM;
          for (var i = 0; i < this.t; ++i)
            r2 += cbit(this[i] ^ x2);
          return r2;
        }
        function bnTestBit(n) {
          var j = Math.floor(n / this.DB);
          if (j >= this.t)
            return this.s != 0;
          return (this[j] & 1 << n % this.DB) != 0;
        }
        function bnpChangeBit(n, op) {
          var r2 = BigInteger.ONE.shiftLeft(n);
          this.bitwiseTo(r2, op, r2);
          return r2;
        }
        function bnSetBit(n) {
          return this.changeBit(n, op_or);
        }
        function bnClearBit(n) {
          return this.changeBit(n, op_andnot);
        }
        function bnFlipBit(n) {
          return this.changeBit(n, op_xor);
        }
        function bnpAddTo(a, r2) {
          var i = 0, c2 = 0, m = Math.min(a.t, this.t);
          while (i < m) {
            c2 += this[i] + a[i];
            r2[i++] = c2 & this.DM;
            c2 >>= this.DB;
          }
          if (a.t < this.t) {
            c2 += a.s;
            while (i < this.t) {
              c2 += this[i];
              r2[i++] = c2 & this.DM;
              c2 >>= this.DB;
            }
            c2 += this.s;
          } else {
            c2 += this.s;
            while (i < a.t) {
              c2 += a[i];
              r2[i++] = c2 & this.DM;
              c2 >>= this.DB;
            }
            c2 += a.s;
          }
          r2.s = c2 < 0 ? -1 : 0;
          if (c2 > 0)
            r2[i++] = c2;
          else if (c2 < -1)
            r2[i++] = this.DV + c2;
          r2.t = i;
          r2.clamp();
        }
        function bnAdd(a) {
          var r2 = nbi();
          this.addTo(a, r2);
          return r2;
        }
        function bnSubtract(a) {
          var r2 = nbi();
          this.subTo(a, r2);
          return r2;
        }
        function bnMultiply(a) {
          var r2 = nbi();
          this.multiplyTo(a, r2);
          return r2;
        }
        function bnSquare() {
          var r2 = nbi();
          this.squareTo(r2);
          return r2;
        }
        function bnDivide(a) {
          var r2 = nbi();
          this.divRemTo(a, r2, null);
          return r2;
        }
        function bnRemainder(a) {
          var r2 = nbi();
          this.divRemTo(a, null, r2);
          return r2;
        }
        function bnDivideAndRemainder(a) {
          var q = nbi(), r2 = nbi();
          this.divRemTo(a, q, r2);
          return new Array(q, r2);
        }
        function bnpDMultiply(n) {
          this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
          ++this.t;
          this.clamp();
        }
        function bnpDAddOffset(n, w) {
          if (n == 0)
            return;
          while (this.t <= w)
            this[this.t++] = 0;
          this[w] += n;
          while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t)
              this[this.t++] = 0;
            ++this[w];
          }
        }
        function NullExp() {
        }
        function nNop(x2) {
          return x2;
        }
        function nMulTo(x2, y, r2) {
          x2.multiplyTo(y, r2);
        }
        function nSqrTo(x2, r2) {
          x2.squareTo(r2);
        }
        NullExp.prototype.convert = nNop;
        NullExp.prototype.revert = nNop;
        NullExp.prototype.mulTo = nMulTo;
        NullExp.prototype.sqrTo = nSqrTo;
        function bnPow(e) {
          return this.exp(e, new NullExp());
        }
        function bnpMultiplyLowerTo(a, n, r2) {
          var i = Math.min(this.t + a.t, n);
          r2.s = 0;
          r2.t = i;
          while (i > 0)
            r2[--i] = 0;
          var j;
          for (j = r2.t - this.t; i < j; ++i)
            r2[i + this.t] = this.am(0, a[i], r2, i, 0, this.t);
          for (j = Math.min(a.t, n); i < j; ++i)
            this.am(0, a[i], r2, i, 0, n - i);
          r2.clamp();
        }
        function bnpMultiplyUpperTo(a, n, r2) {
          --n;
          var i = r2.t = this.t + a.t - n;
          r2.s = 0;
          while (--i >= 0)
            r2[i] = 0;
          for (i = Math.max(n - this.t, 0); i < a.t; ++i)
            r2[this.t + i - n] = this.am(n - i, a[i], r2, 0, 0, this.t + i - n);
          r2.clamp();
          r2.drShiftTo(1, r2);
        }
        function Barrett(m) {
          this.r2 = nbi();
          this.q3 = nbi();
          BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
          this.mu = this.r2.divide(m);
          this.m = m;
        }
        function barrettConvert(x2) {
          if (x2.s < 0 || x2.t > 2 * this.m.t)
            return x2.mod(this.m);
          else if (x2.compareTo(this.m) < 0)
            return x2;
          else {
            var r2 = nbi();
            x2.copyTo(r2);
            this.reduce(r2);
            return r2;
          }
        }
        function barrettRevert(x2) {
          return x2;
        }
        function barrettReduce(x2) {
          x2.drShiftTo(this.m.t - 1, this.r2);
          if (x2.t > this.m.t + 1) {
            x2.t = this.m.t + 1;
            x2.clamp();
          }
          this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
          this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
          while (x2.compareTo(this.r2) < 0)
            x2.dAddOffset(1, this.m.t + 1);
          x2.subTo(this.r2, x2);
          while (x2.compareTo(this.m) >= 0)
            x2.subTo(this.m, x2);
        }
        function barrettSqrTo(x2, r2) {
          x2.squareTo(r2);
          this.reduce(r2);
        }
        function barrettMulTo(x2, y, r2) {
          x2.multiplyTo(y, r2);
          this.reduce(r2);
        }
        Barrett.prototype.convert = barrettConvert;
        Barrett.prototype.revert = barrettRevert;
        Barrett.prototype.reduce = barrettReduce;
        Barrett.prototype.mulTo = barrettMulTo;
        Barrett.prototype.sqrTo = barrettSqrTo;
        function bnModPow(e, m) {
          var i = e.bitLength(), k, r2 = nbv(1), z2;
          if (i <= 0)
            return r2;
          else if (i < 18)
            k = 1;
          else if (i < 48)
            k = 3;
          else if (i < 144)
            k = 4;
          else if (i < 768)
            k = 5;
          else
            k = 6;
          if (i < 8)
            z2 = new Classic(m);
          else if (m.isEven())
            z2 = new Barrett(m);
          else
            z2 = new Montgomery(m);
          var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
          g[1] = z2.convert(this);
          if (k > 1) {
            var g2 = nbi();
            z2.sqrTo(g[1], g2);
            while (n <= km) {
              g[n] = nbi();
              z2.mulTo(g2, g[n - 2], g[n]);
              n += 2;
            }
          }
          var j = e.t - 1, w, is1 = true, r22 = nbi(), t2;
          i = nbits(e[j]) - 1;
          while (j >= 0) {
            if (i >= k1)
              w = e[j] >> i - k1 & km;
            else {
              w = (e[j] & (1 << i + 1) - 1) << k1 - i;
              if (j > 0)
                w |= e[j - 1] >> this.DB + i - k1;
            }
            n = k;
            while ((w & 1) == 0) {
              w >>= 1;
              --n;
            }
            if ((i -= n) < 0) {
              i += this.DB;
              --j;
            }
            if (is1) {
              g[w].copyTo(r2);
              is1 = false;
            } else {
              while (n > 1) {
                z2.sqrTo(r2, r22);
                z2.sqrTo(r22, r2);
                n -= 2;
              }
              if (n > 0)
                z2.sqrTo(r2, r22);
              else {
                t2 = r2;
                r2 = r22;
                r22 = t2;
              }
              z2.mulTo(r22, g[w], r2);
            }
            while (j >= 0 && (e[j] & 1 << i) == 0) {
              z2.sqrTo(r2, r22);
              t2 = r2;
              r2 = r22;
              r22 = t2;
              if (--i < 0) {
                i = this.DB - 1;
                --j;
              }
            }
          }
          return z2.revert(r2);
        }
        function bnGCD(a) {
          var x2 = this.s < 0 ? this.negate() : this.clone();
          var y = a.s < 0 ? a.negate() : a.clone();
          if (x2.compareTo(y) < 0) {
            var t2 = x2;
            x2 = y;
            y = t2;
          }
          var i = x2.getLowestSetBit(), g = y.getLowestSetBit();
          if (g < 0)
            return x2;
          if (i < g)
            g = i;
          if (g > 0) {
            x2.rShiftTo(g, x2);
            y.rShiftTo(g, y);
          }
          while (x2.signum() > 0) {
            if ((i = x2.getLowestSetBit()) > 0)
              x2.rShiftTo(i, x2);
            if ((i = y.getLowestSetBit()) > 0)
              y.rShiftTo(i, y);
            if (x2.compareTo(y) >= 0) {
              x2.subTo(y, x2);
              x2.rShiftTo(1, x2);
            } else {
              y.subTo(x2, y);
              y.rShiftTo(1, y);
            }
          }
          if (g > 0)
            y.lShiftTo(g, y);
          return y;
        }
        function bnpModInt(n) {
          if (n <= 0)
            return 0;
          var d = this.DV % n, r2 = this.s < 0 ? n - 1 : 0;
          if (this.t > 0)
            if (d == 0)
              r2 = this[0] % n;
            else
              for (var i = this.t - 1; i >= 0; --i)
                r2 = (d * r2 + this[i]) % n;
          return r2;
        }
        function bnModInverse(m) {
          var ac = m.isEven();
          if (this.isEven() && ac || m.signum() == 0)
            return BigInteger.ZERO;
          var u2 = m.clone(), v = this.clone();
          var a = nbv(1), b = nbv(0), c2 = nbv(0), d = nbv(1);
          while (u2.signum() != 0) {
            while (u2.isEven()) {
              u2.rShiftTo(1, u2);
              if (ac) {
                if (!a.isEven() || !b.isEven()) {
                  a.addTo(this, a);
                  b.subTo(m, b);
                }
                a.rShiftTo(1, a);
              } else if (!b.isEven())
                b.subTo(m, b);
              b.rShiftTo(1, b);
            }
            while (v.isEven()) {
              v.rShiftTo(1, v);
              if (ac) {
                if (!c2.isEven() || !d.isEven()) {
                  c2.addTo(this, c2);
                  d.subTo(m, d);
                }
                c2.rShiftTo(1, c2);
              } else if (!d.isEven())
                d.subTo(m, d);
              d.rShiftTo(1, d);
            }
            if (u2.compareTo(v) >= 0) {
              u2.subTo(v, u2);
              if (ac)
                a.subTo(c2, a);
              b.subTo(d, b);
            } else {
              v.subTo(u2, v);
              if (ac)
                c2.subTo(a, c2);
              d.subTo(b, d);
            }
          }
          if (v.compareTo(BigInteger.ONE) != 0)
            return BigInteger.ZERO;
          if (d.compareTo(m) >= 0)
            return d.subtract(m);
          if (d.signum() < 0)
            d.addTo(m, d);
          else
            return d;
          if (d.signum() < 0)
            return d.add(m);
          else
            return d;
        }
        var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
        var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
        function bnIsProbablePrime(t2) {
          var i, x2 = this.abs();
          if (x2.t == 1 && x2[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i)
              if (x2[0] == lowprimes[i])
                return true;
            return false;
          }
          if (x2.isEven())
            return false;
          i = 1;
          while (i < lowprimes.length) {
            var m = lowprimes[i], j = i + 1;
            while (j < lowprimes.length && m < lplim)
              m *= lowprimes[j++];
            m = x2.modInt(m);
            while (i < j)
              if (m % lowprimes[i++] == 0)
                return false;
          }
          return x2.millerRabin(t2);
        }
        function bnpMillerRabin(t2) {
          var n1 = this.subtract(BigInteger.ONE);
          var k = n1.getLowestSetBit();
          if (k <= 0)
            return false;
          var r2 = n1.shiftRight(k);
          t2 = t2 + 1 >> 1;
          if (t2 > lowprimes.length)
            t2 = lowprimes.length;
          var a = nbi();
          for (var i = 0; i < t2; ++i) {
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r2, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
              var j = 1;
              while (j++ < k && y.compareTo(n1) != 0) {
                y = y.modPowInt(2, this);
                if (y.compareTo(BigInteger.ONE) == 0)
                  return false;
              }
              if (y.compareTo(n1) != 0)
                return false;
            }
          }
          return true;
        }
        BigInteger.prototype.chunkSize = bnpChunkSize;
        BigInteger.prototype.toRadix = bnpToRadix;
        BigInteger.prototype.fromRadix = bnpFromRadix;
        BigInteger.prototype.fromNumber = bnpFromNumber;
        BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
        BigInteger.prototype.changeBit = bnpChangeBit;
        BigInteger.prototype.addTo = bnpAddTo;
        BigInteger.prototype.dMultiply = bnpDMultiply;
        BigInteger.prototype.dAddOffset = bnpDAddOffset;
        BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
        BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
        BigInteger.prototype.modInt = bnpModInt;
        BigInteger.prototype.millerRabin = bnpMillerRabin;
        BigInteger.prototype.clone = bnClone;
        BigInteger.prototype.intValue = bnIntValue;
        BigInteger.prototype.byteValue = bnByteValue;
        BigInteger.prototype.shortValue = bnShortValue;
        BigInteger.prototype.signum = bnSigNum;
        BigInteger.prototype.toByteArray = bnToByteArray;
        BigInteger.prototype.equals = bnEquals;
        BigInteger.prototype.min = bnMin;
        BigInteger.prototype.max = bnMax;
        BigInteger.prototype.and = bnAnd;
        BigInteger.prototype.or = bnOr;
        BigInteger.prototype.xor = bnXor;
        BigInteger.prototype.andNot = bnAndNot;
        BigInteger.prototype.not = bnNot;
        BigInteger.prototype.shiftLeft = bnShiftLeft;
        BigInteger.prototype.shiftRight = bnShiftRight;
        BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
        BigInteger.prototype.bitCount = bnBitCount;
        BigInteger.prototype.testBit = bnTestBit;
        BigInteger.prototype.setBit = bnSetBit;
        BigInteger.prototype.clearBit = bnClearBit;
        BigInteger.prototype.flipBit = bnFlipBit;
        BigInteger.prototype.add = bnAdd;
        BigInteger.prototype.subtract = bnSubtract;
        BigInteger.prototype.multiply = bnMultiply;
        BigInteger.prototype.divide = bnDivide;
        BigInteger.prototype.remainder = bnRemainder;
        BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
        BigInteger.prototype.modPow = bnModPow;
        BigInteger.prototype.modInverse = bnModInverse;
        BigInteger.prototype.pow = bnPow;
        BigInteger.prototype.gcd = bnGCD;
        BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
        BigInteger.prototype.square = bnSquare;
        BigInteger.prototype.Barrett = Barrett;
        var rng_state;
        var rng_pool;
        var rng_pptr;
        function rng_seed_int(x2) {
          rng_pool[rng_pptr++] ^= x2 & 255;
          rng_pool[rng_pptr++] ^= x2 >> 8 & 255;
          rng_pool[rng_pptr++] ^= x2 >> 16 & 255;
          rng_pool[rng_pptr++] ^= x2 >> 24 & 255;
          if (rng_pptr >= rng_psize)
            rng_pptr -= rng_psize;
        }
        function rng_seed_time() {
          rng_seed_int(new Date().getTime());
        }
        if (rng_pool == null) {
          rng_pool = new Array();
          rng_pptr = 0;
          var t;
          if (typeof window !== "undefined" && window.crypto) {
            if (window.crypto.getRandomValues) {
              var ua = new Uint8Array(32);
              window.crypto.getRandomValues(ua);
              for (t = 0; t < 32; ++t)
                rng_pool[rng_pptr++] = ua[t];
            } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
              var z = window.crypto.random(32);
              for (t = 0; t < z.length; ++t)
                rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
            }
          }
          while (rng_pptr < rng_psize) {
            t = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = t >>> 8;
            rng_pool[rng_pptr++] = t & 255;
          }
          rng_pptr = 0;
          rng_seed_time();
        }
        function rng_get_byte() {
          if (rng_state == null) {
            rng_seed_time();
            rng_state = prng_newstate();
            rng_state.init(rng_pool);
            for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
              rng_pool[rng_pptr] = 0;
            rng_pptr = 0;
          }
          return rng_state.next();
        }
        function rng_get_bytes(ba) {
          var i;
          for (i = 0; i < ba.length; ++i)
            ba[i] = rng_get_byte();
        }
        function SecureRandom() {
        }
        SecureRandom.prototype.nextBytes = rng_get_bytes;
        function Arcfour() {
          this.i = 0;
          this.j = 0;
          this.S = new Array();
        }
        function ARC4init(key) {
          var i, j, t2;
          for (i = 0; i < 256; ++i)
            this.S[i] = i;
          j = 0;
          for (i = 0; i < 256; ++i) {
            j = j + this.S[i] + key[i % key.length] & 255;
            t2 = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t2;
          }
          this.i = 0;
          this.j = 0;
        }
        function ARC4next() {
          var t2;
          this.i = this.i + 1 & 255;
          this.j = this.j + this.S[this.i] & 255;
          t2 = this.S[this.i];
          this.S[this.i] = this.S[this.j];
          this.S[this.j] = t2;
          return this.S[t2 + this.S[this.i] & 255];
        }
        Arcfour.prototype.init = ARC4init;
        Arcfour.prototype.next = ARC4next;
        function prng_newstate() {
          return new Arcfour();
        }
        var rng_psize = 256;
        if (typeof exports !== "undefined") {
          exports = module.exports = {
            default: BigInteger,
            BigInteger,
            SecureRandom
          };
        } else {
          this.jsbn = {
            BigInteger,
            SecureRandom
          };
        }
      }).call(exports);
    }
  });

  // node_modules/long/src/long.js
  var require_long = __commonJS({
    "node_modules/long/src/long.js"(exports, module) {
      init_inject();
      module.exports = Long4;
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          13,
          2,
          96,
          0,
          1,
          127,
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          3,
          7,
          6,
          0,
          1,
          1,
          1,
          1,
          1,
          6,
          6,
          1,
          127,
          1,
          65,
          0,
          11,
          7,
          50,
          6,
          3,
          109,
          117,
          108,
          0,
          1,
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          10,
          191,
          1,
          6,
          4,
          0,
          35,
          0,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch (e) {
      }
      function Long4(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long4.prototype.__isLong__;
      Object.defineProperty(Long4.prototype, "__isLong__", { value: true });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      Long4.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long4.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long4.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long4(lowBits, highBits, unsigned);
      }
      Long4.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return ZERO;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long4.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number")
          return fromNumber(val, unsigned);
        if (typeof val === "string")
          return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long4.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long4.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long4.UZERO = UZERO;
      var ONE = fromInt(1);
      Long4.ONE = ONE;
      var UONE = fromInt(1, true);
      Long4.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long4.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long4.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long4.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long4.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long4.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(other);
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(other) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(other) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(other) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(other) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
          return ZERO;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm.mul(
            this.low,
            this.high,
            multiplier.low,
            multiplier.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (multiplier.isZero())
          return ZERO;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
          else
            return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      Long4.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long4.fromBytesLE(bytes, unsigned) : Long4.fromBytesBE(bytes, unsigned);
      };
      Long4.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long4(
          bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
          bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
          unsigned
        );
      };
      Long4.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long4(
          bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
          bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
          unsigned
        );
      };
    }
  });

  // node_modules/jpeg-js/lib/encoder.js
  var require_encoder = __commonJS({
    "node_modules/jpeg-js/lib/encoder.js"(exports, module) {
      init_inject();
      var btoa = btoa || function(buf) {
        return new Buffer2(buf).toString("base64");
      };
      function JPEGEncoder(quality) {
        var self = this;
        var fround = Math.round;
        var ffloor = Math.floor;
        var YTable = new Array(64);
        var UVTable = new Array(64);
        var fdtbl_Y = new Array(64);
        var fdtbl_UV = new Array(64);
        var YDC_HT;
        var UVDC_HT;
        var YAC_HT;
        var UVAC_HT;
        var bitcode = new Array(65535);
        var category = new Array(65535);
        var outputfDCTQuant = new Array(64);
        var DU = new Array(64);
        var byteout = [];
        var bytenew = 0;
        var bytepos = 7;
        var YDU = new Array(64);
        var UDU = new Array(64);
        var VDU = new Array(64);
        var clt = new Array(256);
        var RGB_YUV_TABLE = new Array(2048);
        var currentQuality;
        var ZigZag = [
          0,
          1,
          5,
          6,
          14,
          15,
          27,
          28,
          2,
          4,
          7,
          13,
          16,
          26,
          29,
          42,
          3,
          8,
          12,
          17,
          25,
          30,
          41,
          43,
          9,
          11,
          18,
          24,
          31,
          40,
          44,
          53,
          10,
          19,
          23,
          32,
          39,
          45,
          52,
          54,
          20,
          22,
          33,
          38,
          46,
          51,
          55,
          60,
          21,
          34,
          37,
          47,
          50,
          56,
          59,
          61,
          35,
          36,
          48,
          49,
          57,
          58,
          62,
          63
        ];
        var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
        var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
        var std_ac_luminance_values = [
          1,
          2,
          3,
          0,
          4,
          17,
          5,
          18,
          33,
          49,
          65,
          6,
          19,
          81,
          97,
          7,
          34,
          113,
          20,
          50,
          129,
          145,
          161,
          8,
          35,
          66,
          177,
          193,
          21,
          82,
          209,
          240,
          36,
          51,
          98,
          114,
          130,
          9,
          10,
          22,
          23,
          24,
          25,
          26,
          37,
          38,
          39,
          40,
          41,
          42,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          67,
          68,
          69,
          70,
          71,
          72,
          73,
          74,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          131,
          132,
          133,
          134,
          135,
          136,
          137,
          138,
          146,
          147,
          148,
          149,
          150,
          151,
          152,
          153,
          154,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          178,
          179,
          180,
          181,
          182,
          183,
          184,
          185,
          186,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250
        ];
        var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
        var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
        var std_ac_chrominance_values = [
          0,
          1,
          2,
          3,
          17,
          4,
          5,
          33,
          49,
          6,
          18,
          65,
          81,
          7,
          97,
          113,
          19,
          34,
          50,
          129,
          8,
          20,
          66,
          145,
          161,
          177,
          193,
          9,
          35,
          51,
          82,
          240,
          21,
          98,
          114,
          209,
          10,
          22,
          36,
          52,
          225,
          37,
          241,
          23,
          24,
          25,
          26,
          38,
          39,
          40,
          41,
          42,
          53,
          54,
          55,
          56,
          57,
          58,
          67,
          68,
          69,
          70,
          71,
          72,
          73,
          74,
          83,
          84,
          85,
          86,
          87,
          88,
          89,
          90,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          130,
          131,
          132,
          133,
          134,
          135,
          136,
          137,
          138,
          146,
          147,
          148,
          149,
          150,
          151,
          152,
          153,
          154,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          178,
          179,
          180,
          181,
          182,
          183,
          184,
          185,
          186,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250
        ];
        function initQuantTables(sf) {
          var YQT = [
            16,
            11,
            10,
            16,
            24,
            40,
            51,
            61,
            12,
            12,
            14,
            19,
            26,
            58,
            60,
            55,
            14,
            13,
            16,
            24,
            40,
            57,
            69,
            56,
            14,
            17,
            22,
            29,
            51,
            87,
            80,
            62,
            18,
            22,
            37,
            56,
            68,
            109,
            103,
            77,
            24,
            35,
            55,
            64,
            81,
            104,
            113,
            92,
            49,
            64,
            78,
            87,
            103,
            121,
            120,
            101,
            72,
            92,
            95,
            98,
            112,
            100,
            103,
            99
          ];
          for (var i = 0; i < 64; i++) {
            var t = ffloor((YQT[i] * sf + 50) / 100);
            if (t < 1) {
              t = 1;
            } else if (t > 255) {
              t = 255;
            }
            YTable[ZigZag[i]] = t;
          }
          var UVQT = [
            17,
            18,
            24,
            47,
            99,
            99,
            99,
            99,
            18,
            21,
            26,
            66,
            99,
            99,
            99,
            99,
            24,
            26,
            56,
            99,
            99,
            99,
            99,
            99,
            47,
            66,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99,
            99
          ];
          for (var j = 0; j < 64; j++) {
            var u2 = ffloor((UVQT[j] * sf + 50) / 100);
            if (u2 < 1) {
              u2 = 1;
            } else if (u2 > 255) {
              u2 = 255;
            }
            UVTable[ZigZag[j]] = u2;
          }
          var aasf = [
            1,
            1.387039845,
            1.306562965,
            1.175875602,
            1,
            0.785694958,
            0.5411961,
            0.275899379
          ];
          var k = 0;
          for (var row = 0; row < 8; row++) {
            for (var col = 0; col < 8; col++) {
              fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
              fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
              k++;
            }
          }
        }
        function computeHuffmanTbl(nrcodes, std_table) {
          var codevalue = 0;
          var pos_in_table = 0;
          var HT = new Array();
          for (var k = 1; k <= 16; k++) {
            for (var j = 1; j <= nrcodes[k]; j++) {
              HT[std_table[pos_in_table]] = [];
              HT[std_table[pos_in_table]][0] = codevalue;
              HT[std_table[pos_in_table]][1] = k;
              pos_in_table++;
              codevalue++;
            }
            codevalue *= 2;
          }
          return HT;
        }
        function initHuffmanTbl() {
          YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
          UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
          YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
          UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
        }
        function initCategoryNumber() {
          var nrlower = 1;
          var nrupper = 2;
          for (var cat = 1; cat <= 15; cat++) {
            for (var nr = nrlower; nr < nrupper; nr++) {
              category[32767 + nr] = cat;
              bitcode[32767 + nr] = [];
              bitcode[32767 + nr][1] = cat;
              bitcode[32767 + nr][0] = nr;
            }
            for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
              category[32767 + nrneg] = cat;
              bitcode[32767 + nrneg] = [];
              bitcode[32767 + nrneg][1] = cat;
              bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
            }
            nrlower <<= 1;
            nrupper <<= 1;
          }
        }
        function initRGBYUVTable() {
          for (var i = 0; i < 256; i++) {
            RGB_YUV_TABLE[i] = 19595 * i;
            RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
            RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
            RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
            RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
            RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
            RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
            RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
          }
        }
        function writeBits(bs) {
          var value = bs[0];
          var posval = bs[1] - 1;
          while (posval >= 0) {
            if (value & 1 << posval) {
              bytenew |= 1 << bytepos;
            }
            posval--;
            bytepos--;
            if (bytepos < 0) {
              if (bytenew == 255) {
                writeByte(255);
                writeByte(0);
              } else {
                writeByte(bytenew);
              }
              bytepos = 7;
              bytenew = 0;
            }
          }
        }
        function writeByte(value) {
          byteout.push(value);
        }
        function writeWord(value) {
          writeByte(value >> 8 & 255);
          writeByte(value & 255);
        }
        function fDCTQuant(data, fdtbl) {
          var d0, d1, d2, d3, d4, d5, d6, d7;
          var dataOff = 0;
          var i;
          var I8 = 8;
          var I64 = 64;
          for (i = 0; i < I8; ++i) {
            d0 = data[dataOff];
            d1 = data[dataOff + 1];
            d2 = data[dataOff + 2];
            d3 = data[dataOff + 3];
            d4 = data[dataOff + 4];
            d5 = data[dataOff + 5];
            d6 = data[dataOff + 6];
            d7 = data[dataOff + 7];
            var tmp0 = d0 + d7;
            var tmp7 = d0 - d7;
            var tmp1 = d1 + d6;
            var tmp6 = d1 - d6;
            var tmp2 = d2 + d5;
            var tmp5 = d2 - d5;
            var tmp3 = d3 + d4;
            var tmp4 = d3 - d4;
            var tmp10 = tmp0 + tmp3;
            var tmp13 = tmp0 - tmp3;
            var tmp11 = tmp1 + tmp2;
            var tmp12 = tmp1 - tmp2;
            data[dataOff] = tmp10 + tmp11;
            data[dataOff + 4] = tmp10 - tmp11;
            var z1 = (tmp12 + tmp13) * 0.707106781;
            data[dataOff + 2] = tmp13 + z1;
            data[dataOff + 6] = tmp13 - z1;
            tmp10 = tmp4 + tmp5;
            tmp11 = tmp5 + tmp6;
            tmp12 = tmp6 + tmp7;
            var z5 = (tmp10 - tmp12) * 0.382683433;
            var z2 = 0.5411961 * tmp10 + z5;
            var z4 = 1.306562965 * tmp12 + z5;
            var z3 = tmp11 * 0.707106781;
            var z11 = tmp7 + z3;
            var z13 = tmp7 - z3;
            data[dataOff + 5] = z13 + z2;
            data[dataOff + 3] = z13 - z2;
            data[dataOff + 1] = z11 + z4;
            data[dataOff + 7] = z11 - z4;
            dataOff += 8;
          }
          dataOff = 0;
          for (i = 0; i < I8; ++i) {
            d0 = data[dataOff];
            d1 = data[dataOff + 8];
            d2 = data[dataOff + 16];
            d3 = data[dataOff + 24];
            d4 = data[dataOff + 32];
            d5 = data[dataOff + 40];
            d6 = data[dataOff + 48];
            d7 = data[dataOff + 56];
            var tmp0p2 = d0 + d7;
            var tmp7p2 = d0 - d7;
            var tmp1p2 = d1 + d6;
            var tmp6p2 = d1 - d6;
            var tmp2p2 = d2 + d5;
            var tmp5p2 = d2 - d5;
            var tmp3p2 = d3 + d4;
            var tmp4p2 = d3 - d4;
            var tmp10p2 = tmp0p2 + tmp3p2;
            var tmp13p2 = tmp0p2 - tmp3p2;
            var tmp11p2 = tmp1p2 + tmp2p2;
            var tmp12p2 = tmp1p2 - tmp2p2;
            data[dataOff] = tmp10p2 + tmp11p2;
            data[dataOff + 32] = tmp10p2 - tmp11p2;
            var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
            data[dataOff + 16] = tmp13p2 + z1p2;
            data[dataOff + 48] = tmp13p2 - z1p2;
            tmp10p2 = tmp4p2 + tmp5p2;
            tmp11p2 = tmp5p2 + tmp6p2;
            tmp12p2 = tmp6p2 + tmp7p2;
            var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
            var z2p2 = 0.5411961 * tmp10p2 + z5p2;
            var z4p2 = 1.306562965 * tmp12p2 + z5p2;
            var z3p2 = tmp11p2 * 0.707106781;
            var z11p2 = tmp7p2 + z3p2;
            var z13p2 = tmp7p2 - z3p2;
            data[dataOff + 40] = z13p2 + z2p2;
            data[dataOff + 24] = z13p2 - z2p2;
            data[dataOff + 8] = z11p2 + z4p2;
            data[dataOff + 56] = z11p2 - z4p2;
            dataOff++;
          }
          var fDCTQuant2;
          for (i = 0; i < I64; ++i) {
            fDCTQuant2 = data[i] * fdtbl[i];
            outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
          }
          return outputfDCTQuant;
        }
        function writeAPP0() {
          writeWord(65504);
          writeWord(16);
          writeByte(74);
          writeByte(70);
          writeByte(73);
          writeByte(70);
          writeByte(0);
          writeByte(1);
          writeByte(1);
          writeByte(0);
          writeWord(1);
          writeWord(1);
          writeByte(0);
          writeByte(0);
        }
        function writeSOF0(width, height) {
          writeWord(65472);
          writeWord(17);
          writeByte(8);
          writeWord(height);
          writeWord(width);
          writeByte(3);
          writeByte(1);
          writeByte(17);
          writeByte(0);
          writeByte(2);
          writeByte(17);
          writeByte(1);
          writeByte(3);
          writeByte(17);
          writeByte(1);
        }
        function writeDQT() {
          writeWord(65499);
          writeWord(132);
          writeByte(0);
          for (var i = 0; i < 64; i++) {
            writeByte(YTable[i]);
          }
          writeByte(1);
          for (var j = 0; j < 64; j++) {
            writeByte(UVTable[j]);
          }
        }
        function writeDHT() {
          writeWord(65476);
          writeWord(418);
          writeByte(0);
          for (var i = 0; i < 16; i++) {
            writeByte(std_dc_luminance_nrcodes[i + 1]);
          }
          for (var j = 0; j <= 11; j++) {
            writeByte(std_dc_luminance_values[j]);
          }
          writeByte(16);
          for (var k = 0; k < 16; k++) {
            writeByte(std_ac_luminance_nrcodes[k + 1]);
          }
          for (var l = 0; l <= 161; l++) {
            writeByte(std_ac_luminance_values[l]);
          }
          writeByte(1);
          for (var m = 0; m < 16; m++) {
            writeByte(std_dc_chrominance_nrcodes[m + 1]);
          }
          for (var n = 0; n <= 11; n++) {
            writeByte(std_dc_chrominance_values[n]);
          }
          writeByte(17);
          for (var o = 0; o < 16; o++) {
            writeByte(std_ac_chrominance_nrcodes[o + 1]);
          }
          for (var p = 0; p <= 161; p++) {
            writeByte(std_ac_chrominance_values[p]);
          }
        }
        function writeSOS() {
          writeWord(65498);
          writeWord(12);
          writeByte(3);
          writeByte(1);
          writeByte(0);
          writeByte(2);
          writeByte(17);
          writeByte(3);
          writeByte(17);
          writeByte(0);
          writeByte(63);
          writeByte(0);
        }
        function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
          var EOB = HTAC[0];
          var M16zeroes = HTAC[240];
          var pos;
          var I16 = 16;
          var I63 = 63;
          var I64 = 64;
          var DU_DCT = fDCTQuant(CDU, fdtbl);
          for (var j = 0; j < I64; ++j) {
            DU[ZigZag[j]] = DU_DCT[j];
          }
          var Diff = DU[0] - DC;
          DC = DU[0];
          if (Diff == 0) {
            writeBits(HTDC[0]);
          } else {
            pos = 32767 + Diff;
            writeBits(HTDC[category[pos]]);
            writeBits(bitcode[pos]);
          }
          var end0pos = 63;
          for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
          }
          ;
          if (end0pos == 0) {
            writeBits(EOB);
            return DC;
          }
          var i = 1;
          var lng;
          while (i <= end0pos) {
            var startpos = i;
            for (; DU[i] == 0 && i <= end0pos; ++i) {
            }
            var nrzeroes = i - startpos;
            if (nrzeroes >= I16) {
              lng = nrzeroes >> 4;
              for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
                writeBits(M16zeroes);
              nrzeroes = nrzeroes & 15;
            }
            pos = 32767 + DU[i];
            writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
            writeBits(bitcode[pos]);
            i++;
          }
          if (end0pos != I63) {
            writeBits(EOB);
          }
          return DC;
        }
        function initCharLookupTable() {
          var sfcc = String.fromCharCode;
          for (var i = 0; i < 256; i++) {
            clt[i] = sfcc(i);
          }
        }
        this.encode = function(image, quality2) {
          var time_start = new Date().getTime();
          if (quality2)
            setQuality(quality2);
          byteout = new Array();
          bytenew = 0;
          bytepos = 7;
          writeWord(65496);
          writeAPP0();
          writeDQT();
          writeSOF0(image.width, image.height);
          writeDHT();
          writeSOS();
          var DCY = 0;
          var DCU = 0;
          var DCV = 0;
          bytenew = 0;
          bytepos = 7;
          this.encode.displayName = "_encode_";
          var imageData = image.data;
          var width = image.width;
          var height = image.height;
          var quadWidth = width * 4;
          var tripleWidth = width * 3;
          var x2, y = 0;
          var r2, g, b;
          var start, p, col, row, pos;
          while (y < height) {
            x2 = 0;
            while (x2 < quadWidth) {
              start = quadWidth * y + x2;
              p = start;
              col = -1;
              row = 0;
              for (pos = 0; pos < 64; pos++) {
                row = pos >> 3;
                col = (pos & 7) * 4;
                p = start + row * quadWidth + col;
                if (y + row >= height) {
                  p -= quadWidth * (y + 1 + row - height);
                }
                if (x2 + col >= quadWidth) {
                  p -= x2 + col - quadWidth + 4;
                }
                r2 = imageData[p++];
                g = imageData[p++];
                b = imageData[p++];
                YDU[pos] = (RGB_YUV_TABLE[r2] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
                UDU[pos] = (RGB_YUV_TABLE[r2 + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
                VDU[pos] = (RGB_YUV_TABLE[r2 + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
              }
              DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
              DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
              DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
              x2 += 32;
            }
            y += 8;
          }
          if (bytepos >= 0) {
            var fillbits = [];
            fillbits[1] = bytepos + 1;
            fillbits[0] = (1 << bytepos + 1) - 1;
            writeBits(fillbits);
          }
          writeWord(65497);
          return new Buffer2(byteout);
          var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
          byteout = [];
          var duration = new Date().getTime() - time_start;
          return jpegDataUri;
        };
        function setQuality(quality2) {
          if (quality2 <= 0) {
            quality2 = 1;
          }
          if (quality2 > 100) {
            quality2 = 100;
          }
          if (currentQuality == quality2)
            return;
          var sf = 0;
          if (quality2 < 50) {
            sf = Math.floor(5e3 / quality2);
          } else {
            sf = Math.floor(200 - quality2 * 2);
          }
          initQuantTables(sf);
          currentQuality = quality2;
        }
        function init() {
          var time_start = new Date().getTime();
          if (!quality)
            quality = 50;
          initCharLookupTable();
          initHuffmanTbl();
          initCategoryNumber();
          initRGBYUVTable();
          setQuality(quality);
          var duration = new Date().getTime() - time_start;
        }
        init();
      }
      if (typeof module !== void 0) {
        module.exports = encode;
      }
      function encode(imgData, qu) {
        if (typeof qu === "undefined")
          qu = 50;
        var encoder = new JPEGEncoder(qu);
        var data = encoder.encode(imgData, qu);
        return {
          data,
          width: imgData.width,
          height: imgData.height
        };
      }
    }
  });

  // node_modules/jpeg-js/lib/decoder.js
  var require_decoder = __commonJS({
    "node_modules/jpeg-js/lib/decoder.js"(exports, module) {
      init_inject();
      var JpegImage = function jpegImage() {
        "use strict";
        var dctZigZag = new Int32Array([
          0,
          1,
          8,
          16,
          9,
          2,
          3,
          10,
          17,
          24,
          32,
          25,
          18,
          11,
          4,
          5,
          12,
          19,
          26,
          33,
          40,
          48,
          41,
          34,
          27,
          20,
          13,
          6,
          7,
          14,
          21,
          28,
          35,
          42,
          49,
          56,
          57,
          50,
          43,
          36,
          29,
          22,
          15,
          23,
          30,
          37,
          44,
          51,
          58,
          59,
          52,
          45,
          38,
          31,
          39,
          46,
          53,
          60,
          61,
          54,
          47,
          55,
          62,
          63
        ]);
        var dctCos1 = 4017;
        var dctSin1 = 799;
        var dctCos3 = 3406;
        var dctSin3 = 2276;
        var dctCos6 = 1567;
        var dctSin6 = 3784;
        var dctSqrt2 = 5793;
        var dctSqrt1d2 = 2896;
        function constructor() {
        }
        function buildHuffmanTable(codeLengths, values) {
          var k = 0, code = [], i, j, length = 16;
          while (length > 0 && !codeLengths[length - 1])
            length--;
          code.push({ children: [], index: 0 });
          var p = code[0], q;
          for (i = 0; i < length; i++) {
            for (j = 0; j < codeLengths[i]; j++) {
              p = code.pop();
              p.children[p.index] = values[k];
              while (p.index > 0) {
                if (code.length === 0)
                  throw new Error("Could not recreate Huffman Table");
                p = code.pop();
              }
              p.index++;
              code.push(p);
              while (code.length <= i) {
                code.push(q = { children: [], index: 0 });
                p.children[p.index] = q.children;
                p = q;
              }
              k++;
            }
            if (i + 1 < length) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
          }
          return code[0].children;
        }
        function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
          var precision = frame.precision;
          var samplesPerLine = frame.samplesPerLine;
          var scanLines = frame.scanLines;
          var mcusPerLine = frame.mcusPerLine;
          var progressive = frame.progressive;
          var maxH = frame.maxH, maxV = frame.maxV;
          var startOffset = offset, bitsData = 0, bitsCount = 0;
          function readBit() {
            if (bitsCount > 0) {
              bitsCount--;
              return bitsData >> bitsCount & 1;
            }
            bitsData = data[offset++];
            if (bitsData == 255) {
              var nextByte = data[offset++];
              if (nextByte) {
                throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
              }
            }
            bitsCount = 7;
            return bitsData >>> 7;
          }
          function decodeHuffman(tree) {
            var node = tree, bit;
            while ((bit = readBit()) !== null) {
              node = node[bit];
              if (typeof node === "number")
                return node;
              if (typeof node !== "object")
                throw new Error("invalid huffman sequence");
            }
            return null;
          }
          function receive(length) {
            var n2 = 0;
            while (length > 0) {
              var bit = readBit();
              if (bit === null)
                return;
              n2 = n2 << 1 | bit;
              length--;
            }
            return n2;
          }
          function receiveAndExtend(length) {
            var n2 = receive(length);
            if (n2 >= 1 << length - 1)
              return n2;
            return n2 + (-1 << length) + 1;
          }
          function decodeBaseline(component2, zz) {
            var t = decodeHuffman(component2.huffmanTableDC);
            var diff = t === 0 ? 0 : receiveAndExtend(t);
            zz[0] = component2.pred += diff;
            var k2 = 1;
            while (k2 < 64) {
              var rs = decodeHuffman(component2.huffmanTableAC);
              var s = rs & 15, r2 = rs >> 4;
              if (s === 0) {
                if (r2 < 15)
                  break;
                k2 += 16;
                continue;
              }
              k2 += r2;
              var z = dctZigZag[k2];
              zz[z] = receiveAndExtend(s);
              k2++;
            }
          }
          function decodeDCFirst(component2, zz) {
            var t = decodeHuffman(component2.huffmanTableDC);
            var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
            zz[0] = component2.pred += diff;
          }
          function decodeDCSuccessive(component2, zz) {
            zz[0] |= readBit() << successive;
          }
          var eobrun = 0;
          function decodeACFirst(component2, zz) {
            if (eobrun > 0) {
              eobrun--;
              return;
            }
            var k2 = spectralStart, e = spectralEnd;
            while (k2 <= e) {
              var rs = decodeHuffman(component2.huffmanTableAC);
              var s = rs & 15, r2 = rs >> 4;
              if (s === 0) {
                if (r2 < 15) {
                  eobrun = receive(r2) + (1 << r2) - 1;
                  break;
                }
                k2 += 16;
                continue;
              }
              k2 += r2;
              var z = dctZigZag[k2];
              zz[z] = receiveAndExtend(s) * (1 << successive);
              k2++;
            }
          }
          var successiveACState = 0, successiveACNextValue;
          function decodeACSuccessive(component2, zz) {
            var k2 = spectralStart, e = spectralEnd, r2 = 0;
            while (k2 <= e) {
              var z = dctZigZag[k2];
              var direction = zz[z] < 0 ? -1 : 1;
              switch (successiveACState) {
                case 0:
                  var rs = decodeHuffman(component2.huffmanTableAC);
                  var s = rs & 15, r2 = rs >> 4;
                  if (s === 0) {
                    if (r2 < 15) {
                      eobrun = receive(r2) + (1 << r2);
                      successiveACState = 4;
                    } else {
                      r2 = 16;
                      successiveACState = 1;
                    }
                  } else {
                    if (s !== 1)
                      throw new Error("invalid ACn encoding");
                    successiveACNextValue = receiveAndExtend(s);
                    successiveACState = r2 ? 2 : 3;
                  }
                  continue;
                case 1:
                case 2:
                  if (zz[z])
                    zz[z] += (readBit() << successive) * direction;
                  else {
                    r2--;
                    if (r2 === 0)
                      successiveACState = successiveACState == 2 ? 3 : 0;
                  }
                  break;
                case 3:
                  if (zz[z])
                    zz[z] += (readBit() << successive) * direction;
                  else {
                    zz[z] = successiveACNextValue << successive;
                    successiveACState = 0;
                  }
                  break;
                case 4:
                  if (zz[z])
                    zz[z] += (readBit() << successive) * direction;
                  break;
              }
              k2++;
            }
            if (successiveACState === 4) {
              eobrun--;
              if (eobrun === 0)
                successiveACState = 0;
            }
          }
          function decodeMcu(component2, decode3, mcu2, row, col) {
            var mcuRow = mcu2 / mcusPerLine | 0;
            var mcuCol = mcu2 % mcusPerLine;
            var blockRow = mcuRow * component2.v + row;
            var blockCol = mcuCol * component2.h + col;
            decode3(component2, component2.blocks[blockRow][blockCol]);
          }
          function decodeBlock(component2, decode3, mcu2) {
            var blockRow = mcu2 / component2.blocksPerLine | 0;
            var blockCol = mcu2 % component2.blocksPerLine;
            decode3(component2, component2.blocks[blockRow][blockCol]);
          }
          var componentsLength = components.length;
          var component, i, j, k, n;
          var decodeFn;
          if (progressive) {
            if (spectralStart === 0)
              decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
            else
              decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
          } else {
            decodeFn = decodeBaseline;
          }
          var mcu = 0, marker;
          var mcuExpected;
          if (componentsLength == 1) {
            mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
          } else {
            mcuExpected = mcusPerLine * frame.mcusPerColumn;
          }
          if (!resetInterval)
            resetInterval = mcuExpected;
          var h, v;
          while (mcu < mcuExpected) {
            for (i = 0; i < componentsLength; i++)
              components[i].pred = 0;
            eobrun = 0;
            if (componentsLength == 1) {
              component = components[0];
              for (n = 0; n < resetInterval; n++) {
                decodeBlock(component, decodeFn, mcu);
                mcu++;
              }
            } else {
              for (n = 0; n < resetInterval; n++) {
                for (i = 0; i < componentsLength; i++) {
                  component = components[i];
                  h = component.h;
                  v = component.v;
                  for (j = 0; j < v; j++) {
                    for (k = 0; k < h; k++) {
                      decodeMcu(component, decodeFn, mcu, j, k);
                    }
                  }
                }
                mcu++;
                if (mcu === mcuExpected)
                  break;
              }
            }
            bitsCount = 0;
            marker = data[offset] << 8 | data[offset + 1];
            if (marker < 65280) {
              throw new Error("marker was not found");
            }
            if (marker >= 65488 && marker <= 65495) {
              offset += 2;
            } else
              break;
          }
          return offset - startOffset;
        }
        function buildComponentData(frame, component) {
          var lines = [];
          var blocksPerLine = component.blocksPerLine;
          var blocksPerColumn = component.blocksPerColumn;
          var samplesPerLine = blocksPerLine << 3;
          var R = new Int32Array(64), r2 = new Uint8Array(64);
          function quantizeAndInverse(zz, dataOut, dataIn) {
            var qt = component.quantizationTable;
            var v0, v1, v2, v3, v4, v5, v6, v7, t;
            var p = dataIn;
            var i2;
            for (i2 = 0; i2 < 64; i2++)
              p[i2] = zz[i2] * qt[i2];
            for (i2 = 0; i2 < 8; ++i2) {
              var row = 8 * i2;
              if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
                t = dctSqrt2 * p[0 + row] + 512 >> 10;
                p[0 + row] = t;
                p[1 + row] = t;
                p[2 + row] = t;
                p[3 + row] = t;
                p[4 + row] = t;
                p[5 + row] = t;
                p[6 + row] = t;
                p[7 + row] = t;
                continue;
              }
              v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
              v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
              v2 = p[2 + row];
              v3 = p[6 + row];
              v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
              v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
              v5 = p[3 + row] << 4;
              v6 = p[5 + row] << 4;
              t = v0 - v1 + 1 >> 1;
              v0 = v0 + v1 + 1 >> 1;
              v1 = t;
              t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
              v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
              v3 = t;
              t = v4 - v6 + 1 >> 1;
              v4 = v4 + v6 + 1 >> 1;
              v6 = t;
              t = v7 + v5 + 1 >> 1;
              v5 = v7 - v5 + 1 >> 1;
              v7 = t;
              t = v0 - v3 + 1 >> 1;
              v0 = v0 + v3 + 1 >> 1;
              v3 = t;
              t = v1 - v2 + 1 >> 1;
              v1 = v1 + v2 + 1 >> 1;
              v2 = t;
              t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
              v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
              v7 = t;
              t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
              v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
              v6 = t;
              p[0 + row] = v0 + v7;
              p[7 + row] = v0 - v7;
              p[1 + row] = v1 + v6;
              p[6 + row] = v1 - v6;
              p[2 + row] = v2 + v5;
              p[5 + row] = v2 - v5;
              p[3 + row] = v3 + v4;
              p[4 + row] = v3 - v4;
            }
            for (i2 = 0; i2 < 8; ++i2) {
              var col = i2;
              if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
                t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
                p[0 * 8 + col] = t;
                p[1 * 8 + col] = t;
                p[2 * 8 + col] = t;
                p[3 * 8 + col] = t;
                p[4 * 8 + col] = t;
                p[5 * 8 + col] = t;
                p[6 * 8 + col] = t;
                p[7 * 8 + col] = t;
                continue;
              }
              v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
              v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
              v2 = p[2 * 8 + col];
              v3 = p[6 * 8 + col];
              v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
              v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
              v5 = p[3 * 8 + col];
              v6 = p[5 * 8 + col];
              t = v0 - v1 + 1 >> 1;
              v0 = v0 + v1 + 1 >> 1;
              v1 = t;
              t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
              v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
              v3 = t;
              t = v4 - v6 + 1 >> 1;
              v4 = v4 + v6 + 1 >> 1;
              v6 = t;
              t = v7 + v5 + 1 >> 1;
              v5 = v7 - v5 + 1 >> 1;
              v7 = t;
              t = v0 - v3 + 1 >> 1;
              v0 = v0 + v3 + 1 >> 1;
              v3 = t;
              t = v1 - v2 + 1 >> 1;
              v1 = v1 + v2 + 1 >> 1;
              v2 = t;
              t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
              v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
              v7 = t;
              t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
              v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
              v6 = t;
              p[0 * 8 + col] = v0 + v7;
              p[7 * 8 + col] = v0 - v7;
              p[1 * 8 + col] = v1 + v6;
              p[6 * 8 + col] = v1 - v6;
              p[2 * 8 + col] = v2 + v5;
              p[5 * 8 + col] = v2 - v5;
              p[3 * 8 + col] = v3 + v4;
              p[4 * 8 + col] = v3 - v4;
            }
            for (i2 = 0; i2 < 64; ++i2) {
              var sample2 = 128 + (p[i2] + 8 >> 4);
              dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
            }
          }
          var i, j;
          for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
            var scanLine = blockRow << 3;
            for (i = 0; i < 8; i++)
              lines.push(new Uint8Array(samplesPerLine));
            for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
              quantizeAndInverse(component.blocks[blockRow][blockCol], r2, R);
              var offset = 0, sample = blockCol << 3;
              for (j = 0; j < 8; j++) {
                var line = lines[scanLine + j];
                for (i = 0; i < 8; i++)
                  line[sample + i] = r2[offset++];
              }
            }
          }
          return lines;
        }
        function clampTo8bit(a) {
          return a < 0 ? 0 : a > 255 ? 255 : a;
        }
        constructor.prototype = {
          load: function load(path) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", path, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = function() {
              var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
              this.parse(data);
              if (this.onload)
                this.onload();
            }.bind(this);
            xhr.send(null);
          },
          parse: function parse2(data) {
            var offset = 0, length = data.length;
            function readUint16() {
              var value = data[offset] << 8 | data[offset + 1];
              offset += 2;
              return value;
            }
            function readDataBlock() {
              var length2 = readUint16();
              var array = data.subarray(offset, offset + length2 - 2);
              offset += array.length;
              return array;
            }
            function prepareComponents(frame2) {
              var maxH2 = 0, maxV2 = 0;
              var component2, componentId2;
              for (componentId2 in frame2.components) {
                if (frame2.components.hasOwnProperty(componentId2)) {
                  component2 = frame2.components[componentId2];
                  if (maxH2 < component2.h)
                    maxH2 = component2.h;
                  if (maxV2 < component2.v)
                    maxV2 = component2.v;
                }
              }
              var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
              var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
              for (componentId2 in frame2.components) {
                if (frame2.components.hasOwnProperty(componentId2)) {
                  component2 = frame2.components[componentId2];
                  var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                  var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                  var blocksPerLineForMcu = mcusPerLine * component2.h;
                  var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                  var blocks = [];
                  for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                    var row = [];
                    for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                      row.push(new Int32Array(64));
                    blocks.push(row);
                  }
                  component2.blocksPerLine = blocksPerLine;
                  component2.blocksPerColumn = blocksPerColumn;
                  component2.blocks = blocks;
                }
              }
              frame2.maxH = maxH2;
              frame2.maxV = maxV2;
              frame2.mcusPerLine = mcusPerLine;
              frame2.mcusPerColumn = mcusPerColumn;
            }
            var jfif = null;
            var adobe = null;
            var pixels = null;
            var frame, resetInterval;
            var quantizationTables = [], frames = [];
            var huffmanTablesAC = [], huffmanTablesDC = [];
            var fileMarker = readUint16();
            if (fileMarker != 65496) {
              throw new Error("SOI not found");
            }
            fileMarker = readUint16();
            while (fileMarker != 65497) {
              var i, j, l;
              switch (fileMarker) {
                case 65280:
                  break;
                case 65504:
                case 65505:
                case 65506:
                case 65507:
                case 65508:
                case 65509:
                case 65510:
                case 65511:
                case 65512:
                case 65513:
                case 65514:
                case 65515:
                case 65516:
                case 65517:
                case 65518:
                case 65519:
                case 65534:
                  var appData = readDataBlock();
                  if (fileMarker === 65504) {
                    if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                      jfif = {
                        version: { major: appData[5], minor: appData[6] },
                        densityUnits: appData[7],
                        xDensity: appData[8] << 8 | appData[9],
                        yDensity: appData[10] << 8 | appData[11],
                        thumbWidth: appData[12],
                        thumbHeight: appData[13],
                        thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                      };
                    }
                  }
                  if (fileMarker === 65518) {
                    if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                      adobe = {
                        version: appData[6],
                        flags0: appData[7] << 8 | appData[8],
                        flags1: appData[9] << 8 | appData[10],
                        transformCode: appData[11]
                      };
                    }
                  }
                  break;
                case 65499:
                  var quantizationTablesLength = readUint16();
                  var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                  while (offset < quantizationTablesEnd) {
                    var quantizationTableSpec = data[offset++];
                    var tableData = new Int32Array(64);
                    if (quantizationTableSpec >> 4 === 0) {
                      for (j = 0; j < 64; j++) {
                        var z = dctZigZag[j];
                        tableData[z] = data[offset++];
                      }
                    } else if (quantizationTableSpec >> 4 === 1) {
                      for (j = 0; j < 64; j++) {
                        var z = dctZigZag[j];
                        tableData[z] = readUint16();
                      }
                    } else
                      throw new Error("DQT: invalid table spec");
                    quantizationTables[quantizationTableSpec & 15] = tableData;
                  }
                  break;
                case 65472:
                case 65473:
                case 65474:
                  readUint16();
                  frame = {};
                  frame.extended = fileMarker === 65473;
                  frame.progressive = fileMarker === 65474;
                  frame.precision = data[offset++];
                  frame.scanLines = readUint16();
                  frame.samplesPerLine = readUint16();
                  frame.components = {};
                  frame.componentsOrder = [];
                  var componentsCount = data[offset++], componentId;
                  var maxH = 0, maxV = 0;
                  for (i = 0; i < componentsCount; i++) {
                    componentId = data[offset];
                    var h = data[offset + 1] >> 4;
                    var v = data[offset + 1] & 15;
                    var qId = data[offset + 2];
                    frame.componentsOrder.push(componentId);
                    frame.components[componentId] = {
                      h,
                      v,
                      quantizationIdx: qId
                    };
                    offset += 3;
                  }
                  prepareComponents(frame);
                  frames.push(frame);
                  break;
                case 65476:
                  var huffmanLength = readUint16();
                  for (i = 2; i < huffmanLength; ) {
                    var huffmanTableSpec = data[offset++];
                    var codeLengths = new Uint8Array(16);
                    var codeLengthSum = 0;
                    for (j = 0; j < 16; j++, offset++)
                      codeLengthSum += codeLengths[j] = data[offset];
                    var huffmanValues = new Uint8Array(codeLengthSum);
                    for (j = 0; j < codeLengthSum; j++, offset++)
                      huffmanValues[j] = data[offset];
                    i += 17 + codeLengthSum;
                    (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                  }
                  break;
                case 65501:
                  readUint16();
                  resetInterval = readUint16();
                  break;
                case 65498:
                  var scanLength = readUint16();
                  var selectorsCount = data[offset++];
                  var components = [], component;
                  for (i = 0; i < selectorsCount; i++) {
                    component = frame.components[data[offset++]];
                    var tableSpec = data[offset++];
                    component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                    component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                    components.push(component);
                  }
                  var spectralStart = data[offset++];
                  var spectralEnd = data[offset++];
                  var successiveApproximation = data[offset++];
                  var processed = decodeScan(
                    data,
                    offset,
                    frame,
                    components,
                    resetInterval,
                    spectralStart,
                    spectralEnd,
                    successiveApproximation >> 4,
                    successiveApproximation & 15
                  );
                  offset += processed;
                  break;
                case 65535:
                  if (data[offset] !== 255) {
                    offset--;
                  }
                  break;
                default:
                  if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                    offset -= 3;
                    break;
                  }
                  throw new Error("unknown JPEG marker " + fileMarker.toString(16));
              }
              fileMarker = readUint16();
            }
            if (frames.length != 1)
              throw new Error("only single frame JPEGs supported");
            for (var i = 0; i < frames.length; i++) {
              var cp = frames[i].components;
              for (var j in cp) {
                cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
                delete cp[j].quantizationIdx;
              }
            }
            this.width = frame.samplesPerLine;
            this.height = frame.scanLines;
            this.jfif = jfif;
            this.adobe = adobe;
            this.components = [];
            for (var i = 0; i < frame.componentsOrder.length; i++) {
              var component = frame.components[frame.componentsOrder[i]];
              this.components.push({
                lines: buildComponentData(frame, component),
                scaleX: component.h / frame.maxH,
                scaleY: component.v / frame.maxV
              });
            }
          },
          getData: function getData(width, height) {
            var scaleX = this.width / width, scaleY = this.height / height;
            var component1, component2, component3, component4;
            var component1Line, component2Line, component3Line, component4Line;
            var x2, y;
            var offset = 0;
            var Y, Cb, Cr, K, C, M, Ye, R, G, B;
            var colorTransform;
            var dataLength = width * height * this.components.length;
            var data = new Uint8Array(dataLength);
            switch (this.components.length) {
              case 1:
                component1 = this.components[0];
                for (y = 0; y < height; y++) {
                  component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                  for (x2 = 0; x2 < width; x2++) {
                    Y = component1Line[0 | x2 * component1.scaleX * scaleX];
                    data[offset++] = Y;
                  }
                }
                break;
              case 2:
                component1 = this.components[0];
                component2 = this.components[1];
                for (y = 0; y < height; y++) {
                  component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                  component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                  for (x2 = 0; x2 < width; x2++) {
                    Y = component1Line[0 | x2 * component1.scaleX * scaleX];
                    data[offset++] = Y;
                    Y = component2Line[0 | x2 * component2.scaleX * scaleX];
                    data[offset++] = Y;
                  }
                }
                break;
              case 3:
                colorTransform = true;
                if (this.adobe && this.adobe.transformCode)
                  colorTransform = true;
                else if (typeof this.colorTransform !== "undefined")
                  colorTransform = !!this.colorTransform;
                component1 = this.components[0];
                component2 = this.components[1];
                component3 = this.components[2];
                for (y = 0; y < height; y++) {
                  component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                  component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                  component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                  for (x2 = 0; x2 < width; x2++) {
                    if (!colorTransform) {
                      R = component1Line[0 | x2 * component1.scaleX * scaleX];
                      G = component2Line[0 | x2 * component2.scaleX * scaleX];
                      B = component3Line[0 | x2 * component3.scaleX * scaleX];
                    } else {
                      Y = component1Line[0 | x2 * component1.scaleX * scaleX];
                      Cb = component2Line[0 | x2 * component2.scaleX * scaleX];
                      Cr = component3Line[0 | x2 * component3.scaleX * scaleX];
                      R = clampTo8bit(Y + 1.402 * (Cr - 128));
                      G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                      B = clampTo8bit(Y + 1.772 * (Cb - 128));
                    }
                    data[offset++] = R;
                    data[offset++] = G;
                    data[offset++] = B;
                  }
                }
                break;
              case 4:
                if (!this.adobe)
                  throw new Error("Unsupported color mode (4 components)");
                colorTransform = false;
                if (this.adobe && this.adobe.transformCode)
                  colorTransform = true;
                else if (typeof this.colorTransform !== "undefined")
                  colorTransform = !!this.colorTransform;
                component1 = this.components[0];
                component2 = this.components[1];
                component3 = this.components[2];
                component4 = this.components[3];
                for (y = 0; y < height; y++) {
                  component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                  component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                  component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                  component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                  for (x2 = 0; x2 < width; x2++) {
                    if (!colorTransform) {
                      C = component1Line[0 | x2 * component1.scaleX * scaleX];
                      M = component2Line[0 | x2 * component2.scaleX * scaleX];
                      Ye = component3Line[0 | x2 * component3.scaleX * scaleX];
                      K = component4Line[0 | x2 * component4.scaleX * scaleX];
                    } else {
                      Y = component1Line[0 | x2 * component1.scaleX * scaleX];
                      Cb = component2Line[0 | x2 * component2.scaleX * scaleX];
                      Cr = component3Line[0 | x2 * component3.scaleX * scaleX];
                      K = component4Line[0 | x2 * component4.scaleX * scaleX];
                      C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                      M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                      Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                    }
                    data[offset++] = 255 - C;
                    data[offset++] = 255 - M;
                    data[offset++] = 255 - Ye;
                    data[offset++] = 255 - K;
                  }
                }
                break;
              default:
                throw new Error("Unsupported color mode");
            }
            return data;
          },
          copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
            var width = imageData.width, height = imageData.height;
            var imageDataArray = imageData.data;
            var data = this.getData(width, height);
            var i = 0, j = 0, x2, y;
            var Y, K, C, M, R, G, B;
            switch (this.components.length) {
              case 1:
                for (y = 0; y < height; y++) {
                  for (x2 = 0; x2 < width; x2++) {
                    Y = data[i++];
                    imageDataArray[j++] = Y;
                    imageDataArray[j++] = Y;
                    imageDataArray[j++] = Y;
                    if (formatAsRGBA) {
                      imageDataArray[j++] = 255;
                    }
                  }
                }
                break;
              case 3:
                for (y = 0; y < height; y++) {
                  for (x2 = 0; x2 < width; x2++) {
                    R = data[i++];
                    G = data[i++];
                    B = data[i++];
                    imageDataArray[j++] = R;
                    imageDataArray[j++] = G;
                    imageDataArray[j++] = B;
                    if (formatAsRGBA) {
                      imageDataArray[j++] = 255;
                    }
                  }
                }
                break;
              case 4:
                for (y = 0; y < height; y++) {
                  for (x2 = 0; x2 < width; x2++) {
                    C = data[i++];
                    M = data[i++];
                    Y = data[i++];
                    K = data[i++];
                    R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                    G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                    B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                    imageDataArray[j++] = R;
                    imageDataArray[j++] = G;
                    imageDataArray[j++] = B;
                    if (formatAsRGBA) {
                      imageDataArray[j++] = 255;
                    }
                  }
                }
                break;
              default:
                throw new Error("Unsupported color mode");
            }
          }
        };
        return constructor;
      }();
      module.exports = decode2;
      function decode2(jpegData, opts) {
        var defaultOpts = {
          useTArray: false,
          colorTransform: void 0,
          formatAsRGBA: true
        };
        if (opts) {
          if (typeof opts === "object") {
            opts = {
              useTArray: typeof opts.useTArray === "undefined" ? defaultOpts.useTArray : opts.useTArray,
              colorTransform: typeof opts.colorTransform === "undefined" ? defaultOpts.colorTransform : opts.colorTransform,
              formatAsRGBA: typeof opts.formatAsRGBA === "undefined" ? defaultOpts.formatAsRGBA : opts.formatAsRGBA
            };
          } else {
            opts = defaultOpts;
            opts.useTArray = true;
          }
        } else {
          opts = defaultOpts;
        }
        var arr = new Uint8Array(jpegData);
        var decoder = new JpegImage();
        decoder.parse(arr);
        decoder.colorTransform = opts.colorTransform;
        var channels = opts.formatAsRGBA ? 4 : 3;
        var bytesNeeded = decoder.width * decoder.height * channels;
        try {
          var image = {
            width: decoder.width,
            height: decoder.height,
            data: opts.useTArray ? new Uint8Array(bytesNeeded) : new Buffer2(bytesNeeded)
          };
        } catch (err) {
          if (err instanceof RangeError) {
            throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
          } else {
            throw err;
          }
        }
        decoder.copyToImageData(image, opts.formatAsRGBA);
        return image;
      }
    }
  });

  // node_modules/jpeg-js/index.js
  var require_jpeg_js = __commonJS({
    "node_modules/jpeg-js/index.js"(exports, module) {
      init_inject();
      var encode = require_encoder();
      var decode2 = require_decoder();
      module.exports = {
        encode,
        decode: decode2
      };
    }
  });

  // node_modules/pako/lib/utils/common.js
  var require_common = __commonJS({
    "node_modules/pako/lib/utils/common.js"(exports) {
      "use strict";
      init_inject();
      var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
      function _has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (var p in source) {
            if (_has(source, p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf;
        }
        if (buf.subarray) {
          return buf.subarray(0, size);
        }
        buf.length = size;
        return buf;
      };
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return;
          }
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        flattenChunks: function(chunks) {
          var i, l, len, pos, chunk, result;
          len = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks);
        }
      };
      exports.setTyped = function(on) {
        if (on) {
          exports.Buf8 = Uint8Array;
          exports.Buf16 = Uint16Array;
          exports.Buf32 = Int32Array;
          exports.assign(exports, fnTyped);
        } else {
          exports.Buf8 = Array;
          exports.Buf16 = Array;
          exports.Buf32 = Array;
          exports.assign(exports, fnUntyped);
        }
      };
      exports.setTyped(TYPED_OK);
    }
  });

  // node_modules/pako/lib/zlib/trees.js
  var require_trees = __commonJS({
    "node_modules/pako/lib/zlib/trees.js"(exports) {
      "use strict";
      init_inject();
      var utils = require_common();
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH2 = 3;
      var MAX_MATCH2 = 258;
      var LENGTH_CODES2 = 29;
      var LITERALS2 = 256;
      var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
      var D_CODES2 = 30;
      var BL_CODES2 = 19;
      var HEAP_SIZE2 = 2 * L_CODES2 + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS2 = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
      var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
      var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES2 + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES2 * 2);
      zero(static_dtree);
      var _dist_code2 = new Array(DIST_CODE_LEN);
      zero(_dist_code2);
      var _length_code = new Array(MAX_MATCH2 - MIN_MATCH2 + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES2);
      zero(base_length);
      var base_dist = new Array(D_CODES2);
      zero(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      function d_code(dist) {
        return dist < 256 ? _dist_code2[dist] : _dist_code2[256 + (dist >>> 7)];
      }
      function put_short(s, w) {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
      }
      function send_bits(s, value, length) {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length;
        }
      }
      function send_code(s, c2, tree) {
        send_bits(s, tree[c2 * 2], tree[c2 * 2 + 1]);
      }
      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      }
      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      }
      function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE2; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      }
      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      }
      function tr_static_init() {
        var n;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES2 - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code;
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code2[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES2; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code2[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES2 + 1, bl_count);
        for (n = 0; n < D_CODES2; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS2 + 1, L_CODES2, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES2, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES2, MAX_BL_BITS2);
      }
      function init_block(s) {
        var n;
        for (n = 0; n < L_CODES2; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES2; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES2; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      }
      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      }
      function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len);
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
      }
      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      }
      function pqdownheap(s, tree, k) {
        var v = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v;
      }
      function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS2 + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
              }
            }
          } while (lx < s.last_lit);
        }
        send_code(s, END_BLOCK, ltree);
      }
      function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE2;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[1];
          s.heap[1] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1);
          m = s.heap[1];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[1] = node++;
          pqdownheap(s, tree, 1);
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      }
      function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES2 - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      }
      function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      }
      function detect_data_type(s) {
        var black_mask = 4093624447;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS2; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      }
      var static_init_done = false;
      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      }
      function _tr_stored_block(s, buf, stored_len, last) {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true);
      }
      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      }
      function _tr_flush_block(s, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      }
      function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS2 + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.last_lit === s.lit_bufsize - 1;
      }
      exports._tr_init = _tr_init;
      exports._tr_stored_block = _tr_stored_block;
      exports._tr_flush_block = _tr_flush_block;
      exports._tr_tally = _tr_tally;
      exports._tr_align = _tr_align;
    }
  });

  // node_modules/pako/lib/zlib/adler32.js
  var require_adler32 = __commonJS({
    "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
      "use strict";
      init_inject();
      function adler32(adler, buf, len, pos) {
        var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      }
      module.exports = adler32;
    }
  });

  // node_modules/pako/lib/zlib/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
      "use strict";
      init_inject();
      function makeTable() {
        var c2, table = [];
        for (var n = 0; n < 256; n++) {
          c2 = n;
          for (var k = 0; k < 8; k++) {
            c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
          }
          table[n] = c2;
        }
        return table;
      }
      var crcTable = makeTable();
      function crc322(crc, buf, len, pos) {
        var t = crcTable, end = pos + len;
        crc ^= -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      }
      module.exports = crc322;
    }
  });

  // node_modules/pako/lib/zlib/messages.js
  var require_messages = __commonJS({
    "node_modules/pako/lib/zlib/messages.js"(exports, module) {
      "use strict";
      init_inject();
      module.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      };
    }
  });

  // node_modules/pako/lib/zlib/deflate.js
  var require_deflate = __commonJS({
    "node_modules/pako/lib/zlib/deflate.js"(exports) {
      "use strict";
      init_inject();
      var utils = require_common();
      var trees = require_trees();
      var adler32 = require_adler32();
      var crc322 = require_crc32();
      var msg = require_messages();
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES2 = 29;
      var LITERALS2 = 256;
      var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
      var D_CODES2 = 30;
      var BL_CODES2 = 19;
      var HEAP_SIZE2 = 2 * L_CODES2 + 1;
      var MAX_BITS = 15;
      var MIN_MATCH2 = 3;
      var MAX_MATCH2 = 258;
      var MIN_LOOKAHEAD2 = MAX_MATCH2 + MIN_MATCH2 + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
      }
      function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0);
      }
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      }
      function flush_block_only(s, last) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      }
      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
      }
      function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
      }
      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc322(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      }
      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD2 ? s.strstart - (s.w_size - MIN_LOOKAHEAD2) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH2;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH2 - (strend - scan);
          scan = strend - MAX_MATCH2;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      }
      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD2)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH2) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
            while (s.insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH2 - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH2) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD2 && s.strm.avail_in !== 0);
      }
      function deflate_stored(s, flush) {
        var max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }
        for (; ; ) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          var max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD2) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_NEED_MORE;
      }
      function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD2) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH2) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD2) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH2) {
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH2);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH2) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
            }
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH2 - 1 ? s.strstart : MIN_MATCH2 - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD2) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH2) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH2 - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD2) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH2 && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH2 - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH2 && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH2;
            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH2);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH2 - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH2 - 1 ? s.strstart : MIN_MATCH2 - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH2) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH2 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH2 && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH2;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH2 - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH2) {
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH2);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_huff(s, flush) {
        var bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table;
      configuration_table = [
        new Config(0, 0, 0, 0, deflate_stored),
        new Config(4, 4, 8, 4, deflate_fast),
        new Config(4, 5, 16, 8, deflate_fast),
        new Config(4, 6, 32, 32, deflate_fast),
        new Config(4, 4, 16, 16, deflate_slow),
        new Config(8, 16, 32, 32, deflate_slow),
        new Config(8, 16, 128, 128, deflate_slow),
        new Config(8, 32, 128, 256, deflate_slow),
        new Config(32, 128, 258, 1024, deflate_slow),
        new Config(32, 258, 258, 4096, deflate_slow)
      ];
      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH2 - 1;
        s.match_available = 0;
        s.ins_h = 0;
      }
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE2 * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES2 + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES2 + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES2 + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES2 + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK;
      }
      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      }
      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      }
      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        var s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      }
      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      }
      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(
                s,
                (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
              );
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255);
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc322(strm.adler, s.pending_buf, s.pending, 0);
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s);
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      }
      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      }
      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        s = strm.state;
        wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          tmpDict = new utils.Buf8(s.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH2) {
          str = s.strstart;
          n = s.lookahead - (MIN_MATCH2 - 1);
          do {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH2 - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH2 - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH2 - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      }
      exports.deflateInit = deflateInit;
      exports.deflateInit2 = deflateInit2;
      exports.deflateReset = deflateReset;
      exports.deflateResetKeep = deflateResetKeep;
      exports.deflateSetHeader = deflateSetHeader;
      exports.deflate = deflate;
      exports.deflateEnd = deflateEnd;
      exports.deflateSetDictionary = deflateSetDictionary;
      exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/utils/strings.js
  var require_strings = __commonJS({
    "node_modules/pako/lib/utils/strings.js"(exports) {
      "use strict";
      init_inject();
      var utils = require_common();
      var STR_APPLY_OK = true;
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (__) {
        STR_APPLY_OK = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new utils.Buf8(256);
      for (q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      var q;
      _utf8len[254] = _utf8len[254] = 1;
      exports.string2buf = function(str) {
        var buf, c2, c22, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c2 = str.charCodeAt(m_pos);
          if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
            c22 = str.charCodeAt(m_pos + 1);
            if ((c22 & 64512) === 56320) {
              c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
              m_pos++;
            }
          }
          buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
        }
        buf = new utils.Buf8(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c2 = str.charCodeAt(m_pos);
          if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
            c22 = str.charCodeAt(m_pos + 1);
            if ((c22 & 64512) === 56320) {
              c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
              m_pos++;
            }
          }
          if (c2 < 128) {
            buf[i++] = c2;
          } else if (c2 < 2048) {
            buf[i++] = 192 | c2 >>> 6;
            buf[i++] = 128 | c2 & 63;
          } else if (c2 < 65536) {
            buf[i++] = 224 | c2 >>> 12;
            buf[i++] = 128 | c2 >>> 6 & 63;
            buf[i++] = 128 | c2 & 63;
          } else {
            buf[i++] = 240 | c2 >>> 18;
            buf[i++] = 128 | c2 >>> 12 & 63;
            buf[i++] = 128 | c2 >>> 6 & 63;
            buf[i++] = 128 | c2 & 63;
          }
        }
        return buf;
      };
      function buf2binstring(buf, len) {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
          }
        }
        var result = "";
        for (var i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      }
      exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length);
      };
      exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i = 0, len = buf.length; i < len; i++) {
          buf[i] = str.charCodeAt(i);
        }
        return buf;
      };
      exports.buf2string = function(buf, max) {
        var i, out, c2, c_len;
        var len = max || buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
          c2 = buf[i++];
          if (c2 < 128) {
            utf16buf[out++] = c2;
            continue;
          }
          c_len = _utf8len[c2];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c2 = c2 << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c2 < 65536) {
            utf16buf[out++] = c2;
          } else {
            c2 -= 65536;
            utf16buf[out++] = 55296 | c2 >> 10 & 1023;
            utf16buf[out++] = 56320 | c2 & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      exports.utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
    }
  });

  // node_modules/pako/lib/zlib/zstream.js
  var require_zstream = __commonJS({
    "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
      "use strict";
      init_inject();
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }
  });

  // node_modules/pako/lib/deflate.js
  var require_deflate2 = __commonJS({
    "node_modules/pako/lib/deflate.js"(exports) {
      "use strict";
      init_inject();
      var zlib_deflate = require_deflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var toString = Object.prototype.toString;
      var Z_NO_FLUSH = 0;
      var Z_FINISH = 4;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_SYNC_FLUSH = 2;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_DEFLATED = 8;
      function Deflate(options) {
        if (!(this instanceof Deflate))
          return new Deflate(options);
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_deflate.deflateInit2(
          this.strm,
          opt.level,
          opt.method,
          opt.windowBits,
          opt.memLevel,
          opt.strategy
        );
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          var dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_deflate.deflate(strm, _mode);
          if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        if (_mode === Z_FINISH) {
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (_mode === Z_SYNC_FLUSH) {
          this.onEnd(Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        var deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      exports.Deflate = Deflate;
      exports.deflate = deflate;
      exports.deflateRaw = deflateRaw;
      exports.gzip = gzip;
    }
  });

  // node_modules/pako/lib/zlib/inffast.js
  var require_inffast = __commonJS({
    "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
      "use strict";
      init_inject();
      var BAD = 30;
      var TYPE = 12;
      module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;
        var last;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len;
        var dist;
        var from;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                          } else {
                            from += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                          while (len > 2) {
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            len -= 3;
                          }
                          if (len) {
                            output[_out++] = from_source[from++];
                            if (len > 1) {
                              output[_out++] = from_source[from++];
                            }
                          }
                        } else {
                          from = _out - dist;
                          do {
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output[_out++] = output[from++];
                            if (len > 1) {
                              output[_out++] = output[from++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }
  });

  // node_modules/pako/lib/zlib/inftrees.js
  var require_inftrees = __commonJS({
    "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
      "use strict";
      init_inject();
      var utils = require_common();
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ];
      var lext = [
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ];
      var dbase = [
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ];
      var dext = [
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min = 0, max = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root > max) {
          root = max;
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root < min) {
          root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19;
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;
        } else {
          base = dbase;
          extra = dext;
          end = -1;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        for (; ; ) {
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      };
    }
  });

  // node_modules/pako/lib/zlib/inflate.js
  var require_inflate = __commonJS({
    "node_modules/pako/lib/zlib/inflate.js"(exports) {
      "use strict";
      init_inject();
      var utils = require_common();
      var adler32 = require_adler32();
      var crc322 = require_crc32();
      var inflate_fast = require_inffast();
      var inflate_table = require_inftrees();
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5;
      var Z_DEFLATED = 8;
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;
      function zswap32(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      }
      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      }
      function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      }
      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      }
      function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        state = new InflateState();
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      }
      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
      }
      var virgin = true;
      var lenfix;
      var distfix;
      function fixedtables(state) {
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      }
      function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize);
        }
        if (copy >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy;
          }
          utils.arraySet(state.window, src, end - copy, dist, state.wnext);
          copy -= dist;
          if (copy) {
            utils.arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      }
      function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy;
        var from;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc322(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                state.flags = 0;
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                  state.wbits = len;
                } else if (len > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << len;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc322(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc322(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc322(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc322(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              case EXTRA:
                if (state.flags & 1024) {
                  copy = state.length;
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Array(state.head.extra_len);
                      }
                      utils.arraySet(
                        state.head.extra,
                        input,
                        next,
                        copy,
                        len
                      );
                    }
                    if (state.flags & 512) {
                      state.check = crc322(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    state.length -= copy;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512) {
                    state.check = crc322(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512) {
                    state.check = crc322(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy = state.length;
                if (copy) {
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  if (copy === 0) {
                    break inf_leave;
                  }
                  utils.arraySet(output, input, next, copy, put);
                  have -= copy;
                  next += copy;
                  left -= copy;
                  put += copy;
                  state.length -= copy;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                  copy = state.offset - copy;
                  if (copy > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy > state.wnext) {
                    copy -= state.wnext;
                    from = state.wsize - copy;
                  } else {
                    from = state.wnext - copy;
                  }
                  if (copy > state.length) {
                    copy = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from = put - state.offset;
                  copy = state.length;
                }
                if (copy > left) {
                  copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                  output[put++] = from_source[from++];
                } while (--copy);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (_out) {
                    strm.adler = state.check = state.flags ? crc322(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                  }
                  _out = left;
                  if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = state.flags ? crc322(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      }
      function inflateEnd(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        var state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      }
      function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      }
      function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      }
      exports.inflateReset = inflateReset;
      exports.inflateReset2 = inflateReset2;
      exports.inflateResetKeep = inflateResetKeep;
      exports.inflateInit = inflateInit;
      exports.inflateInit2 = inflateInit2;
      exports.inflate = inflate;
      exports.inflateEnd = inflateEnd;
      exports.inflateGetHeader = inflateGetHeader;
      exports.inflateSetDictionary = inflateSetDictionary;
      exports.inflateInfo = "pako inflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/zlib/constants.js
  var require_constants = __commonJS({
    "node_modules/pako/lib/zlib/constants.js"(exports, module) {
      "use strict";
      init_inject();
      module.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      };
    }
  });

  // node_modules/pako/lib/zlib/gzheader.js
  var require_gzheader = __commonJS({
    "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
      "use strict";
      init_inject();
      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
      module.exports = GZheader;
    }
  });

  // node_modules/pako/lib/inflate.js
  var require_inflate2 = __commonJS({
    "node_modules/pako/lib/inflate.js"(exports) {
      "use strict";
      init_inject();
      var zlib_inflate = require_inflate();
      var utils = require_common();
      var strings = require_strings();
      var c2 = require_constants();
      var msg = require_messages();
      var ZStream = require_zstream();
      var GZheader = require_gzheader();
      var toString = Object.prototype.toString;
      function Inflate(options) {
        if (!(this instanceof Inflate))
          return new Inflate(options);
        this.options = utils.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_inflate.inflateInit2(
          this.strm,
          opt.windowBits
        );
        if (status !== c2.Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
          if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
          }
          if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== c2.Z_OK) {
              throw new Error(msg[status]);
            }
          }
        }
      }
      Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var dictionary = this.options.dictionary;
        var status, _mode;
        var next_out_utf8, tail, utf8str;
        var allowBufError = false;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? c2.Z_FINISH : c2.Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.binstring2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, c2.Z_NO_FLUSH);
          if (status === c2.Z_NEED_DICT && dictionary) {
            status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
          }
          if (status === c2.Z_BUF_ERROR && allowBufError === true) {
            status = c2.Z_OK;
            allowBufError = false;
          }
          if (status !== c2.Z_STREAM_END && status !== c2.Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === c2.Z_STREAM_END || strm.avail_in === 0 && (_mode === c2.Z_FINISH || _mode === c2.Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                tail = strm.next_out - next_out_utf8;
                utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail) {
                  utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                }
                this.onData(utf8str);
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          }
          if (strm.avail_in === 0 && strm.avail_out === 0) {
            allowBufError = true;
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c2.Z_STREAM_END);
        if (status === c2.Z_STREAM_END) {
          _mode = c2.Z_FINISH;
        }
        if (_mode === c2.Z_FINISH) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === c2.Z_OK;
        }
        if (_mode === c2.Z_SYNC_FLUSH) {
          this.onEnd(c2.Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === c2.Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function inflate(input, options) {
        var inflator = new Inflate(options);
        inflator.push(input, true);
        if (inflator.err) {
          throw inflator.msg || msg[inflator.err];
        }
        return inflator.result;
      }
      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      exports.Inflate = Inflate;
      exports.inflate = inflate;
      exports.inflateRaw = inflateRaw;
      exports.ungzip = inflate;
    }
  });

  // node_modules/pako/index.js
  var require_pako = __commonJS({
    "node_modules/pako/index.js"(exports, module) {
      "use strict";
      init_inject();
      var assign = require_common().assign;
      var deflate = require_deflate2();
      var inflate = require_inflate2();
      var constants = require_constants();
      var pako = {};
      assign(pako, deflate, inflate, constants);
      module.exports = pako;
    }
  });

  // node_modules/get-signed-32-bit-int/index.js
  var require_get_signed_32_bit_int = __commonJS({
    "node_modules/get-signed-32-bit-int/index.js"(exports) {
      "use strict";
      init_inject();
      exports.__esModule = true;
      var getSigned32BitInt = function(val) {
        return val | 0;
      };
      exports["default"] = getSigned32BitInt;
    }
  });

  // node_modules/isaac-crypto/src/memory/initialise-temp-memory.js
  var require_initialise_temp_memory = __commonJS({
    "node_modules/isaac-crypto/src/memory/initialise-temp-memory.js"(exports) {
      "use strict";
      init_inject();
      exports.__esModule = true;
      exports["default"] = function(value) {
        var memory = [];
        for (var i = 0; i < 8; i++) {
          memory[i] = value;
        }
        return memory;
      };
    }
  });

  // node_modules/isaac-crypto/src/memory/scramble-memory.js
  var require_scramble_memory = __commonJS({
    "node_modules/isaac-crypto/src/memory/scramble-memory.js"(exports) {
      "use strict";
      init_inject();
      exports.__esModule = true;
      exports["default"] = function(memory) {
        memory[0] ^= memory[1] << 11;
        memory[3] += memory[0];
        memory[1] += memory[2];
        memory[1] ^= memory[2] >>> 2;
        memory[4] += memory[1];
        memory[2] += memory[3];
        memory[2] ^= memory[3] << 8;
        memory[5] += memory[2];
        memory[3] += memory[4];
        memory[3] ^= memory[4] >>> 16;
        memory[6] += memory[3];
        memory[4] += memory[5];
        memory[4] ^= memory[5] << 10;
        memory[7] += memory[4];
        memory[5] += memory[6];
        memory[5] ^= memory[6] >>> 4;
        memory[0] += memory[5];
        memory[6] += memory[7];
        memory[6] ^= memory[7] << 8;
        memory[1] += memory[6];
        memory[7] += memory[0];
        memory[7] ^= memory[0] >>> 9;
        memory[2] += memory[7];
        memory[0] += memory[1];
      };
    }
  });

  // node_modules/isaac-crypto/src/memory/increment-memory.js
  var require_increment_memory = __commonJS({
    "node_modules/isaac-crypto/src/memory/increment-memory.js"(exports) {
      "use strict";
      init_inject();
      exports.__esModule = true;
      exports["default"] = function(memory, startIndex, valueFunction) {
        for (var i = 0; i < 8; i++) {
          memory[i] += valueFunction(startIndex + i);
        }
      };
    }
  });

  // node_modules/isaac-crypto/src/memory/move-memory.js
  var require_move_memory = __commonJS({
    "node_modules/isaac-crypto/src/memory/move-memory.js"(exports) {
      "use strict";
      init_inject();
      exports.__esModule = true;
      exports["default"] = function(target, source, index) {
        for (var i = 0; i < 8; i++) {
          target[index + i] = source[i];
        }
      };
    }
  });

  // node_modules/isaac-crypto/src/memory/initialization-pass.js
  var require_initialization_pass = __commonJS({
    "node_modules/isaac-crypto/src/memory/initialization-pass.js"(exports) {
      "use strict";
      init_inject();
      exports.__esModule = true;
      var scramble_memory_1 = require_scramble_memory();
      var increment_memory_1 = require_increment_memory();
      var move_memory_1 = require_move_memory();
      exports["default"] = function(size, memory, temp, valueFunction) {
        for (var i = 0; i < size; i += 8) {
          increment_memory_1["default"](temp, i, valueFunction);
          scramble_memory_1["default"](temp);
          move_memory_1["default"](memory, temp, i);
        }
      };
    }
  });

  // node_modules/isaac-crypto/src/index.js
  var require_src = __commonJS({
    "node_modules/isaac-crypto/src/index.js"(exports) {
      "use strict";
      init_inject();
      exports.__esModule = true;
      var get_signed_32_bit_int_1 = require_get_signed_32_bit_int();
      var initialise_temp_memory_1 = require_initialise_temp_memory();
      var scramble_memory_1 = require_scramble_memory();
      var initialization_pass_1 = require_initialization_pass();
      var ISAACGenerator2 = function() {
        function ISAACGenerator3(seed) {
          this.lastResult = 0;
          this.counter = 0;
          this.accumulator = 0;
          this.count = 0;
          this.results = Array(ISAACGenerator3.SIZE);
          this.memory = Array(ISAACGenerator3.SIZE);
          this.initializeMemory(seed);
        }
        ISAACGenerator3.prototype.getNextResult = function() {
          if (this.count-- == 0) {
            this.generateResults();
            this.count = ISAACGenerator3.SIZE - 1;
          }
          return this.getSafeResult(this.count);
        };
        ;
        ISAACGenerator3.prototype.generateResults = function() {
          this.counter += 1;
          this.lastResult += this.counter;
          for (var i = 0; i < ISAACGenerator3.SIZE; i++) {
            switch (i & 3) {
              case 0:
                this.accumulator ^= this.accumulator << 13;
                break;
              case 1:
                this.accumulator ^= this.accumulator >>> 6;
                break;
              case 2:
                this.accumulator ^= this.accumulator << 2;
                break;
              case 3:
                this.accumulator ^= this.accumulator >>> 16;
                break;
            }
            this.accumulator += this.memory[i + 128 & 255];
            var x2 = this.memory[i];
            this.memory[i] = this.memory[x2 >>> 2 & 255] + this.accumulator + this.lastResult;
            var y = this.memory[i];
            this.results[i] = this.memory[y >>> 10 & 255] + x2;
            this.lastResult = this.results[i];
          }
        };
        ISAACGenerator3.prototype.getSafeResult = function(index) {
          var result = this.results[index];
          if (result === void 0) {
            return 0;
          }
          return get_signed_32_bit_int_1["default"](result);
        };
        ISAACGenerator3.prototype.initializeMemory = function(seed) {
          var _this = this;
          var temp = initialise_temp_memory_1["default"](ISAACGenerator3.MAGIC_NUMBER);
          for (var i = 0; i < 4; i++) {
            scramble_memory_1["default"](temp);
          }
          initialization_pass_1["default"](ISAACGenerator3.SIZE, this.memory, temp, function(index) {
            return seed[index] || 0;
          });
          initialization_pass_1["default"](ISAACGenerator3.SIZE, this.memory, temp, function(index) {
            return _this.memory[index];
          });
          this.generateResults();
          this.count = ISAACGenerator3.SIZE;
        };
        return ISAACGenerator3;
      }();
      ISAACGenerator2.SIZE = 256;
      ISAACGenerator2.MAGIC_NUMBER = get_signed_32_bit_int_1["default"](2654435769);
      exports.ISAACGenerator = ISAACGenerator2;
    }
  });

  // osrs/GamePlayground.ts
  init_inject();

  // osrs/Game.ts
  init_inject();

  // plugin-glob-imports:./../client_cache/*.dat
  init_inject();

  // client_cache/main_file_cache.dat
  var main_file_cache_default = "./main_file_cache-4KFHH3W4.dat";

  // plugin-glob-imports:./../client_cache/*.dat
  var __default = { "client_cache": { "main_file_cache.dat": main_file_cache_default } };

  // plugin-glob-imports:./../client_cache/*.idx*
  init_inject();

  // client_cache/main_file_cache.idx0
  var main_file_cache_default2 = "./main_file_cache-RRRNXG7R.idx0";

  // client_cache/main_file_cache.idx1
  var main_file_cache_default3 = "./main_file_cache-EEGHQU65.idx1";

  // client_cache/main_file_cache.idx2
  var main_file_cache_default4 = "./main_file_cache-B6H5XJJC.idx2";

  // client_cache/main_file_cache.idx3
  var main_file_cache_default5 = "./main_file_cache-BGWSZLQC.idx3";

  // client_cache/main_file_cache.idx4
  var main_file_cache_default6 = "./main_file_cache-FVIM3PES.idx4";

  // plugin-glob-imports:./../client_cache/*.idx*
  var __default2 = { "client_cache": { "main_file_cache.idx0": main_file_cache_default2, "main_file_cache.idx1": main_file_cache_default3, "main_file_cache.idx2": main_file_cache_default4, "main_file_cache.idx3": main_file_cache_default5, "main_file_cache.idx4": main_file_cache_default6 } };

  // osrs/cache/Index.ts
  init_inject();
  var _Index = class {
    constructor(_type, _maxSize, dataFile, indexFile) {
      if (this.dataFile === void 0) {
        this.dataFile = null;
      }
      if (this.indexFile === void 0) {
        this.indexFile = null;
      }
      if (this.type === void 0) {
        this.type = 0;
      }
      if (this.maxSize === void 0) {
        this.maxSize = 0;
      }
      this.type = _type;
      this.dataFile = dataFile;
      this.indexFile = indexFile;
      this.maxSize = _maxSize;
    }
    readIn(inBuffer, inOffset, inSize, fromBuffer, fromOffset) {
      const fromSlice = new Int8Array(fromBuffer.slice(fromOffset, fromOffset + inSize));
      const readSize = Math.min(inSize, fromSlice.byteLength);
      for (let i = 0; i < readSize; i++) {
        inBuffer[inOffset + i] = fromSlice[i];
      }
      return readSize;
    }
    get(index) {
      try {
        let fileSize;
        for (let indexPart = 0; indexPart < 6; indexPart += fileSize) {
          fileSize = this.readIn(_Index.buffer, indexPart, 6 - indexPart, this.indexFile, index * 6);
          if (fileSize === -1) {
            return null;
          }
        }
        fileSize = ((_Index.buffer[0] & 255) << 16) + ((_Index.buffer[1] & 255) << 8) + (_Index.buffer[2] & 255);
        let fileBlock = ((_Index.buffer[3] & 255) << 16) + ((_Index.buffer[4] & 255) << 8) + (_Index.buffer[5] & 255);
        if (fileSize < 0 || fileSize > this.maxSize) {
          return null;
        }
        if (fileBlock <= 0 || fileBlock > ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(
          this.dataFile.byteLength / 520
        )) {
          return null;
        }
        const fileBuffer = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(fileSize);
        let read2 = 0;
        for (let cycle = 0; read2 < fileSize; cycle++) {
          {
            if (fileBlock === 0) {
              return null;
            }
            let size = 0;
            let remaining = fileSize - read2;
            if (remaining > 512) {
              remaining = 512;
            }
            let nextFileId;
            for (; size < remaining + 8; size += nextFileId) {
              {
                nextFileId = this.readIn(
                  _Index.buffer,
                  size,
                  remaining + 8 - size,
                  this.dataFile,
                  fileBlock * 520
                );
                if (nextFileId === -1) {
                  return null;
                }
              }
            }
            nextFileId = ((_Index.buffer[0] & 255) << 8) + (_Index.buffer[1] & 255);
            const currentPartId = ((_Index.buffer[2] & 255) << 8) + (_Index.buffer[3] & 255);
            const nextBlockId = ((_Index.buffer[4] & 255) << 16) + ((_Index.buffer[5] & 255) << 8) + (_Index.buffer[6] & 255);
            const nextStoreId = _Index.buffer[7] & 255;
            if (nextFileId !== index || currentPartId !== cycle || nextStoreId !== this.type) {
              return null;
            }
            if (nextBlockId < 0 || nextBlockId > ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(
              this.dataFile.byteLength / 520
            )) {
              return null;
            }
            for (let offset = 0; offset < remaining; offset++) {
              fileBuffer[read2++] = _Index.buffer[offset + 8];
            }
            fileBlock = nextBlockId;
          }
        }
        return fileBuffer;
      } catch (_ex) {
        return null;
      }
    }
    put$int$byte_A$int(len, buf, id) {
      throw Error("Unimplemented method put$int$byte_A$int");
      return true;
    }
  };
  var Index = _Index;
  Index.buffer = new Array(520).map(() => 0);

  // osrs/cache/Archive.ts
  init_inject();

  // osrs/net/Buffer.ts
  init_inject();

  // osrs/collection/CacheableNode.ts
  init_inject();

  // osrs/collection/Node.ts
  init_inject();
  var Node = class {
    constructor() {
      this.id = 0;
      this.next = null;
      this.previous = null;
    }
    remove() {
      if (this.previous != null) {
        this.previous.next = this.next;
        this.next.previous = this.previous;
        this.next = null;
        this.previous = null;
      }
    }
  };

  // osrs/collection/CacheableNode.ts
  var CacheableNode = class extends Node {
    constructor() {
      super();
      this.cacheNext = null;
      this.cachePrevious = null;
      if (this.cacheNext === void 0) {
        this.cacheNext = null;
      }
      if (this.cachePrevious === void 0) {
        this.cachePrevious = null;
      }
    }
    clear() {
      if (this.cachePrevious == null) {
        return;
      } else {
        this.cachePrevious.next = this.next;
        this.cacheNext.cachePrevious = this.cachePrevious;
        this.cacheNext = null;
        this.cachePrevious = null;
        return;
      }
    }
  };

  // osrs/util/LinkedList.ts
  init_inject();
  var LinkedList = class {
    constructor() {
      this.head = new Node();
      if (this.current === void 0) {
        this.current = null;
      }
      this.head.next = this.head;
      this.head.previous = this.head;
    }
    insertBack(node) {
      if (node.previous != null) {
        node.remove();
      }
      node.previous = this.head.previous;
      node.next = this.head;
      node.previous.next = node;
      node.next.previous = node;
    }
    addFirst(node) {
      if (node.previous != null) {
        node.remove();
      }
      node.previous = this.head;
      node.next = this.head.next;
      node.previous.next = node;
      node.next.previous = node;
    }
    removeFirst() {
      const node = this.head.next;
      if (node === this.head) {
        return null;
      } else {
        node.remove();
        return node;
      }
    }
    first() {
      const node = this.head.next;
      if (node === this.head) {
        this.current = null;
        return null;
      } else {
        this.current = node.next;
        return node;
      }
    }
    last() {
      const node = this.head.previous;
      if (node === this.head) {
        this.current = null;
        return null;
      } else {
        this.current = node.previous;
        return node;
      }
    }
    next() {
      const node = this.current;
      if (node === this.head) {
        this.current = null;
        return null;
      }
      this.current = node.next;
      return node;
    }
    previous() {
      const node = this.current;
      if (node === this.head) {
        this.current = null;
        return null;
      } else {
        this.current = node.previous;
        return node;
      }
    }
    getNodeCount() {
      if (this.head.next === this.head) {
        return;
      }
      do {
        {
          const node = this.head.next;
          if (node === this.head) {
            return;
          }
          node.remove();
        }
      } while (true);
    }
  };

  // osrs/Hash.ts
  init_inject();
  var import_jsbn = __toESM(require_jsbn(), 1);
  function rs_hash_string(s) {
    let hash = 0 | 0;
    for (let c2 of s) {
      hash = hash * 61 + c2.charCodeAt(0) - 32 | 0;
    }
    return hash;
  }
  function rs_encrypt_bytes(bytes, modulus, pubKey) {
    const result = new import_jsbn.default.BigInteger(bytes);
    const eB = new import_jsbn.default.BigInteger(pubKey);
    const mB = new import_jsbn.default.BigInteger(modulus);
    const ret = new Uint8Array(result.modPow(eB, mB).toByteArray());
    return ret;
  }
  function noise(x2, y) {
    let xw = x2;
    let yw = y;
    let n = xw + yw * 57 | 0;
    n ^= n << 13;
    return ((n * (n * n * 15731 | 0 + 789221 | 0) + 1376312589 | 0) & 2147483647 | 0) >> 19 & 255 | 0;
  }

  // osrs/net/Buffer.ts
  var import_long = __toESM(require_long(), 1);
  function createCRC32Table() {
    let pos = 0;
    let table = Array(256);
    while (pos < 256) {
      {
        let value = pos;
        for (let pass = 0; pass < 8; pass++) {
          if ((value & 1) === 1) {
            value = value >>> 1 ^ -306674912;
          } else {
            value >>>= 1;
          }
        }
        table[pos] = value;
        pos++;
      }
    }
    return table;
  }
  var _Buffer2 = class extends CacheableNode {
    constructor(buffer) {
      var __super = (...args) => {
        super(...args);
      };
      if (buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || typeof buffer[0] === "number") || buffer === null) {
        const __args = arguments;
        __super();
        if (this.buffer === void 0) {
          this.buffer = null;
        }
        if (this.currentPosition === void 0) {
          this.currentPosition = 0;
        }
        if (this.bitPosition === void 0) {
          this.bitPosition = 0;
        }
        if (this.random === void 0) {
          this.random = null;
        }
        if (this.buffer === void 0) {
          this.buffer = null;
        }
        if (this.currentPosition === void 0) {
          this.currentPosition = 0;
        }
        if (this.bitPosition === void 0) {
          this.bitPosition = 0;
        }
        if (this.random === void 0) {
          this.random = null;
        }
        (() => {
          this.buffer = buffer;
          this.currentPosition = 0;
        })();
      } else if (buffer === void 0) {
        const __args = arguments;
        __super();
        if (this.buffer === void 0) {
          this.buffer = null;
        }
        if (this.currentPosition === void 0) {
          this.currentPosition = 0;
        }
        if (this.bitPosition === void 0) {
          this.bitPosition = 0;
        }
        if (this.random === void 0) {
          this.random = null;
        }
        if (this.buffer === void 0) {
          this.buffer = null;
        }
        if (this.currentPosition === void 0) {
          this.currentPosition = 0;
        }
        if (this.bitPosition === void 0) {
          this.bitPosition = 0;
        }
        if (this.random === void 0) {
          this.random = null;
        }
      } else {
        throw new Error("invalid overload");
      }
    }
    static allocate(sizeMode) {
      {
        let buffer2 = null;
        if (sizeMode === 0 && _Buffer2.smallBufferCount > 0) {
          _Buffer2.smallBufferCount;
          _Buffer2.smallBufferCount--;
          buffer2 = _Buffer2.smallBuffers.removeFirst();
        } else if (sizeMode === 1 && _Buffer2.mediumBufferCount > 0) {
          _Buffer2.mediumBufferCount;
          _Buffer2.mediumBufferCount--;
          buffer2 = _Buffer2.mediumBuffers.removeFirst();
        } else if (sizeMode === 2 && _Buffer2.largeBufferCount > 0) {
          _Buffer2.largeBufferCount;
          _Buffer2.largeBufferCount--;
          buffer2 = _Buffer2.largeBuffers.removeFirst();
        }
        if (buffer2 != null) {
          buffer2.currentPosition = 0;
          return buffer2;
        }
      }
      const buffer = new _Buffer2();
      buffer.currentPosition = 0;
      if (sizeMode === 0) {
        buffer.buffer = new Int8Array(100);
      } else if (sizeMode === 1) {
        buffer.buffer = new Int8Array(5e3);
      } else {
        buffer.buffer = new Int8Array(3e4);
      }
      return buffer;
    }
    putOpcode(opcode) {
      this.buffer[this.currentPosition++] = opcode + (this.random.nextInt() | 0) | 0;
    }
    putByte(value) {
      this.buffer[this.currentPosition++] = value | 0;
    }
    putShort(value) {
      this.buffer[this.currentPosition++] = value >> 8 | 0;
      this.buffer[this.currentPosition++] = value | 0;
    }
    putLEShort(value) {
      this.buffer[this.currentPosition++] = value | 0;
      this.buffer[this.currentPosition++] = value >> 8 | 0;
    }
    putTriByte(value) {
      this.buffer[this.currentPosition++] = value >> 16 | 0;
      this.buffer[this.currentPosition++] = value >> 8 | 0;
      this.buffer[this.currentPosition++] = value | 0;
    }
    putInt(value) {
      this.buffer[this.currentPosition++] = value >> 24 | 0;
      this.buffer[this.currentPosition++] = value >> 16 | 0;
      this.buffer[this.currentPosition++] = value >> 8 | 0;
      this.buffer[this.currentPosition++] = value | 0;
    }
    putLEInt(value) {
      this.buffer[this.currentPosition++] = value | 0;
      this.buffer[this.currentPosition++] = value >> 8 | 0;
      this.buffer[this.currentPosition++] = value >> 16 | 0;
      this.buffer[this.currentPosition++] = value >> 24 | 0;
    }
    putLong(value) {
      this.putInt(value.high);
      this.putInt(value.low);
    }
    putString(str) {
      for (let c2 of str) {
        this.buffer[this.currentPosition++] = c2.charCodeAt(0);
      }
      this.buffer[this.currentPosition++] = 10;
    }
    putBytes(bytes, start, length) {
      for (let pos = start; pos < start + length; pos++) {
        this.buffer[this.currentPosition++] = bytes[pos];
      }
    }
    putLength(length) {
      this.buffer[this.currentPosition - length - 1] = length | 0;
    }
    getUnsignedByte() {
      return this.buffer[this.currentPosition++] & 255;
    }
    getSignedByte() {
      return this.buffer[this.currentPosition++];
    }
    getUnsignedLEShort() {
      this.currentPosition += 2;
      return ((this.buffer[this.currentPosition - 2] & 255) << 8) + (this.buffer[this.currentPosition - 1] & 255);
    }
    getSignedShort() {
      this.currentPosition += 2;
      let i = ((this.buffer[this.currentPosition - 2] & 255) << 8) + (this.buffer[this.currentPosition - 1] & 255);
      if (i > 32767) {
        i -= 65536;
      }
      return i;
    }
    get24BitInt() {
      this.currentPosition += 3;
      return ((this.buffer[this.currentPosition - 3] & 255) << 16) + ((this.buffer[this.currentPosition - 2] & 255) << 8) + (this.buffer[this.currentPosition - 1] & 255);
    }
    getInt() {
      this.currentPosition += 4;
      return ((this.buffer[this.currentPosition - 4] & 255) << 24) + ((this.buffer[this.currentPosition - 3] & 255) << 16) + ((this.buffer[this.currentPosition - 2] & 255) << 8) + (this.buffer[this.currentPosition - 1] & 255) | 0;
    }
    getLong() {
      const l = this.getInt() & 4294967295;
      const l1 = this.getInt() & 4294967295;
      return new import_long.default(l1, l);
    }
    getString() {
      const start = this.currentPosition;
      while (this.buffer[this.currentPosition++] !== 10) {
      }
      return String.fromCharCode.apply(null, this.buffer.slice(start, this.currentPosition));
    }
    getStringBytes() {
      const start = this.currentPosition;
      while (this.buffer[this.currentPosition++] !== 10) {
      }
      return Array.from(this.buffer.slice(start, this.currentPosition));
    }
    getBytes(bytes, start, len) {
      for (let pos = start; pos < start + len; pos++) {
        bytes[pos] = this.buffer[this.currentPosition++];
      }
    }
    initBitAccess() {
      this.bitPosition = this.currentPosition * 8;
    }
    getBits(numBits) {
      let k = this.bitPosition >> 3;
      let l = 8 - (this.bitPosition & 7);
      let value = 0;
      this.bitPosition += numBits;
      for (; numBits > l; l = 8) {
        {
          value += (this.buffer[k++] & _Buffer2.BIT_MASKS[l]) << numBits - l;
          numBits -= l;
        }
      }
      if (numBits === l) {
        value += this.buffer[k] & _Buffer2.BIT_MASKS[l];
      } else {
        value += this.buffer[k] >> l - numBits & _Buffer2.BIT_MASKS[numBits];
      }
      return value;
    }
    finishBitAccess() {
      this.currentPosition = (this.bitPosition + 7) / 8 | 0;
    }
    getSignedSmart() {
      const peek = this.buffer[this.currentPosition] & 255;
      if (peek < 128) {
        return this.getUnsignedByte() - 64;
      } else {
        return this.getUnsignedLEShort() - 49152;
      }
    }
    getSmart() {
      const peek = this.buffer[this.currentPosition] & 255;
      if (peek < 128) {
        return this.getUnsignedByte();
      } else {
        return this.getUnsignedLEShort() - 32768;
      }
    }
    encrypt(modulus, key) {
      const length = this.currentPosition;
      this.currentPosition = 0;
      let bytes = Array(length).fill(0);
      this.getBytes(bytes, 0, length);
      const rawEnc = rs_encrypt_bytes(new Int8Array(bytes), modulus, key);
      const encrypted = new Int8Array(rawEnc);
      this.currentPosition = 0;
      this.putByte(encrypted.length);
      this.putBytes(encrypted, 0, encrypted.length);
    }
    putByteAdded(value) {
      this.buffer[this.currentPosition++] = value + 128 | 0;
    }
    putByteNegated(value) {
      this.buffer[this.currentPosition++] = -value | 0;
    }
    putByteSubtracted(value) {
      this.buffer[this.currentPosition++] = 128 - value | 0;
    }
    getByteAdded() {
      return this.buffer[this.currentPosition++] - 128 & 255;
    }
    getByteNegated() {
      return -this.buffer[this.currentPosition++] & 255;
    }
    getByteSubtracted() {
      return 128 - this.buffer[this.currentPosition++] & 255;
    }
    getSignedByteAdded() {
      return this.buffer[this.currentPosition++] - 128 | 0;
    }
    getSignedByteNegated() {
      return -this.buffer[this.currentPosition++] | 0;
    }
    getSignedByteSubtracted() {
      return 128 - this.buffer[this.currentPosition++] | 0;
    }
    putLEShortDup(value) {
      this.buffer[this.currentPosition++] = value | 0;
      this.buffer[this.currentPosition++] = value >> 8 | 0;
    }
    putShortAdded(value) {
      this.buffer[this.currentPosition++] = value >> 8 | 0;
      this.buffer[this.currentPosition++] = value + 128 | 0;
    }
    putLEShortAdded(value) {
      this.buffer[this.currentPosition++] = value + 128 | 0;
      this.buffer[this.currentPosition++] = value >> 8 | 0;
    }
    method549() {
      this.currentPosition += 2;
      return ((this.buffer[this.currentPosition - 1] & 255) << 8) + (this.buffer[this.currentPosition - 2] & 255);
    }
    method550() {
      this.currentPosition += 2;
      return ((this.buffer[this.currentPosition - 2] & 255) << 8) + (this.buffer[this.currentPosition - 1] - 128 & 255);
    }
    getLittleShortA() {
      this.currentPosition += 2;
      return ((this.buffer[this.currentPosition - 1] & 255) << 8) + (this.buffer[this.currentPosition - 2] - 128 & 255);
    }
    method552() {
      this.currentPosition += 2;
      let j = ((this.buffer[this.currentPosition - 1] & 255) << 8) + (this.buffer[this.currentPosition - 2] & 255);
      if (j > 32767) {
        j -= 65536;
      }
      return j;
    }
    method553() {
      this.currentPosition += 2;
      let i = ((this.buffer[this.currentPosition - 2] & 255) << 8) + (this.buffer[this.currentPosition - 1] - 128 & 255);
      if (i > 32767) {
        i -= 65536;
      }
      return i;
    }
    method554() {
      this.currentPosition += 3;
      return ((this.buffer[this.currentPosition - 2] & 255) << 16) + ((this.buffer[this.currentPosition - 3] & 255) << 8) + (this.buffer[this.currentPosition - 1] & 255);
    }
    method555() {
      this.currentPosition += 4;
      return ((this.buffer[this.currentPosition - 1] & 255) << 24) + ((this.buffer[this.currentPosition - 2] & 255) << 16) + ((this.buffer[this.currentPosition - 3] & 255) << 8) + (this.buffer[this.currentPosition - 4] & 255);
    }
    method556() {
      this.currentPosition += 4;
      return ((this.buffer[this.currentPosition - 2] & 255) << 24) + ((this.buffer[this.currentPosition - 1] & 255) << 16) + ((this.buffer[this.currentPosition - 4] & 255) << 8) + (this.buffer[this.currentPosition - 3] & 255);
    }
    method557() {
      this.currentPosition += 4;
      return ((this.buffer[this.currentPosition - 3] & 255) << 24) + ((this.buffer[this.currentPosition - 4] & 255) << 16) + ((this.buffer[this.currentPosition - 1] & 255) << 8) + (this.buffer[this.currentPosition - 2] & 255);
    }
    getBytesReverse(bytes, start, len) {
      for (let pos = start + len - 1; pos >= start; pos--) {
        bytes[pos] = this.buffer[this.currentPosition++];
      }
    }
    getBytesAdded(bytes, start, len) {
      for (let pos = start; pos < start + len; pos++) {
        bytes[pos] = this.buffer[this.currentPosition++] - 128 | 0;
      }
    }
  };
  var Buffer3 = _Buffer2;
  Buffer3.__static_initialized = false;
  Buffer3.CRC32_TABLE = createCRC32Table();
  Buffer3.BIT_MASKS = [
    0,
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255,
    511,
    1023,
    2047,
    4095,
    8191,
    16383,
    32767,
    65535,
    131071,
    262143,
    524287,
    1048575,
    2097151,
    4194303,
    8388607,
    16777215,
    33554431,
    67108863,
    134217727,
    268435455,
    536870911,
    1073741823,
    2147483647,
    -1
  ];
  Buffer3.smallBufferCount = 0;
  Buffer3.mediumBufferCount = 0;
  Buffer3.largeBufferCount = 0;
  Buffer3.smallBuffers = new LinkedList();
  Buffer3.mediumBuffers = new LinkedList();
  Buffer3.largeBuffers = new LinkedList();

  // osrs/cache/bzip/BZip2Decompressor.ts
  init_inject();

  // osrs/cache/bzip/Bzip2Context.ts
  init_inject();
  var Bzip2Context = class {
    constructor() {
      this.anIntArray67 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(256);
      this.anIntArray69 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(257);
      this.aBooleanArray73 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(false);
        }
        return a;
      })(256);
      this.aBooleanArray74 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(false);
        }
        return a;
      })(16);
      this.aByteArray75 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(256);
      this.aByteArray76 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(4096);
      this.anIntArray77 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(16);
      this.aByteArray78 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(18002);
      this.aByteArray79 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(18002);
      this.aByteArrayArray80 = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([6, 258]);
      this.anIntArrayArray81 = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([6, 258]);
      this.anIntArrayArray82 = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([6, 258]);
      this.anIntArrayArray83 = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([6, 258]);
      this.anIntArray84 = [0, 0, 0, 0, 0, 0];
      if (this.compressed === void 0) {
        this.compressed = null;
      }
      if (this.nextIn === void 0) {
        this.nextIn = 0;
      }
      if (this.decompressedLength === void 0) {
        this.decompressedLength = 0;
      }
      if (this.totalInLo32 === void 0) {
        this.totalInLo32 = 0;
      }
      if (this.totalInHi32 === void 0) {
        this.totalInHi32 = 0;
      }
      if (this.decompressed === void 0) {
        this.decompressed = null;
      }
      if (this.nextOut === void 0) {
        this.nextOut = 0;
      }
      if (this.lenght === void 0) {
        this.lenght = 0;
      }
      if (this.totalOutLo32 === void 0) {
        this.totalOutLo32 = 0;
      }
      if (this.totalOutHigh32 === void 0) {
        this.totalOutHigh32 = 0;
      }
      if (this.aByte57 === void 0) {
        this.aByte57 = 0;
      }
      if (this.anInt58 === void 0) {
        this.anInt58 = 0;
      }
      if (this.aBoolean59 === void 0) {
        this.aBoolean59 = false;
      }
      if (this.bsBuff === void 0) {
        this.bsBuff = 0;
      }
      if (this.bsLive === void 0) {
        this.bsLive = 0;
      }
      if (this.anInt62 === void 0) {
        this.anInt62 = 0;
      }
      if (this.currentBlock === void 0) {
        this.currentBlock = 0;
      }
      if (this.anInt64 === void 0) {
        this.anInt64 = 0;
      }
      if (this.anInt65 === void 0) {
        this.anInt65 = 0;
      }
      if (this.anInt66 === void 0) {
        this.anInt66 = 0;
      }
      if (this.anInt68 === void 0) {
        this.anInt68 = 0;
      }
      if (this.anInt72 === void 0) {
        this.anInt72 = 0;
      }
      if (this.anInt85 === void 0) {
        this.anInt85 = 0;
      }
    }
  };
  Bzip2Context.anIntArray71 = null;

  // osrs/cache/bzip/BZip2Decompressor.ts
  var BZip2Decompressor = class {
    static state_$LI$() {
      if (BZip2Decompressor.state == null) {
        BZip2Decompressor.state = new Bzip2Context();
      }
      return BZip2Decompressor.state;
    }
    static decompress$byte_A$int$byte_A$int$int(output, lenght, compressed, decompressedLength, minLen) {
      BZip2Decompressor.state_$LI$().compressed = compressed;
      BZip2Decompressor.state_$LI$().nextIn = minLen;
      BZip2Decompressor.state_$LI$().decompressed = output;
      BZip2Decompressor.state_$LI$().nextOut = 0;
      BZip2Decompressor.state_$LI$().decompressedLength = decompressedLength;
      BZip2Decompressor.state_$LI$().lenght = lenght;
      BZip2Decompressor.state_$LI$().bsLive = 0;
      BZip2Decompressor.state_$LI$().bsBuff = 0;
      BZip2Decompressor.state_$LI$().totalInLo32 = 0;
      BZip2Decompressor.state_$LI$().totalInHi32 = 0;
      BZip2Decompressor.state_$LI$().totalOutLo32 = 0;
      BZip2Decompressor.state_$LI$().totalOutHigh32 = 0;
      BZip2Decompressor.state_$LI$().currentBlock = 0;
      BZip2Decompressor.decompress$com_jagex_runescape_cache_bzip_Bzip2Context(BZip2Decompressor.state_$LI$());
      lenght -= BZip2Decompressor.state_$LI$().lenght;
      return lenght;
    }
    static decompress(output, lenght, compressed, decompressedLength, minLen) {
      if ((output != null && output instanceof Array && (output.length == 0 || output[0] == null || typeof output[0] === "number") || output === null) && (typeof lenght === "number" || lenght === null) && (compressed != null && compressed instanceof Array && (compressed.length == 0 || compressed[0] == null || typeof compressed[0] === "number") || compressed === null) && (typeof decompressedLength === "number" || decompressedLength === null) && (typeof minLen === "number" || minLen === null)) {
        return BZip2Decompressor.decompress$byte_A$int$byte_A$int$int(output, lenght, compressed, decompressedLength, minLen);
      } else if ((output != null && output instanceof Bzip2Context || output === null) && lenght === void 0 && compressed === void 0 && decompressedLength === void 0 && minLen === void 0) {
        return BZip2Decompressor.decompress$com_jagex_runescape_cache_bzip_Bzip2Context(output);
      } else {
        throw new Error("invalid overload");
      }
    }
    static method313(bzip2Context) {
      let byte4 = bzip2Context.aByte57;
      let i = bzip2Context.anInt58;
      let j = bzip2Context.anInt68;
      let k = bzip2Context.anInt66;
      const ai = Bzip2Context.anIntArray71;
      let l = bzip2Context.anInt65;
      const abyte0 = bzip2Context.decompressed;
      let i1 = bzip2Context.nextOut;
      let j1 = bzip2Context.lenght;
      const k1 = j1;
      const l1 = bzip2Context.anInt85 + 1;
      label0:
        do {
          {
            if (i > 0) {
              do {
                {
                  if (j1 === 0) {
                    break label0;
                  }
                  if (i === 1) {
                    break;
                  }
                  abyte0[i1] = byte4;
                  i--;
                  i1++;
                  j1--;
                }
              } while (true);
              if (j1 === 0) {
                i = 1;
                break;
              }
              abyte0[i1] = byte4;
              i1++;
              j1--;
            }
            let flag = true;
            while (flag) {
              {
                flag = false;
                if (j === l1) {
                  i = 0;
                  break label0;
                }
                byte4 = k | 0;
                l = ai[l];
                const byte0 = l & 255 | 0;
                l >>= 8;
                j++;
                if (byte0 !== k) {
                  k = byte0;
                  if (j1 === 0) {
                    i = 1;
                  } else {
                    abyte0[i1] = byte4;
                    i1++;
                    j1--;
                    flag = true;
                    continue;
                  }
                  break label0;
                }
                if (j !== l1) {
                  continue;
                }
                if (j1 === 0) {
                  i = 1;
                  break label0;
                }
                abyte0[i1] = byte4;
                i1++;
                j1--;
                flag = true;
              }
            }
            i = 2;
            l = ai[l];
            const byte1 = l & 255 | 0;
            l >>= 8;
            if (++j !== l1) {
              if (byte1 !== k) {
                k = byte1;
              } else {
                i = 3;
                l = ai[l];
                const byte2 = l & 255 | 0;
                l >>= 8;
                if (++j !== l1) {
                  if (byte2 !== k) {
                    k = byte2;
                  } else {
                    l = ai[l];
                    const byte3 = l & 255 | 0;
                    l >>= 8;
                    j++;
                    i = (byte3 & 255) + 4;
                    l = ai[l];
                    k = l & 255 | 0;
                    l >>= 8;
                    j++;
                  }
                }
              }
            }
          }
        } while (true);
      const i2 = bzip2Context.totalOutLo32;
      bzip2Context.totalOutLo32 += k1 - j1;
      if (bzip2Context.totalOutLo32 < i2) {
        bzip2Context.totalOutHigh32++;
      }
      bzip2Context.aByte57 = byte4;
      bzip2Context.anInt58 = i;
      bzip2Context.anInt68 = j;
      bzip2Context.anInt66 = k;
      Bzip2Context.anIntArray71 = ai;
      bzip2Context.anInt65 = l;
      bzip2Context.decompressed = abyte0;
      bzip2Context.nextOut = i1;
      bzip2Context.lenght = j1;
    }
    static decompress$com_jagex_runescape_cache_bzip_Bzip2Context(bzip2Context) {
      let k8 = 0;
      let ai = null;
      let ai1 = null;
      let ai2 = null;
      bzip2Context.anInt62 = 1;
      if (Bzip2Context.anIntArray71 == null) {
        Bzip2Context.anIntArray71 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(bzip2Context.anInt62 * 1e5);
      }
      let flag19 = true;
      while (flag19) {
        {
          let b = BZip2Decompressor.method315(bzip2Context);
          if (b === 23) {
            return;
          }
          b = BZip2Decompressor.method315(bzip2Context);
          b = BZip2Decompressor.method315(bzip2Context);
          b = BZip2Decompressor.method315(bzip2Context);
          b = BZip2Decompressor.method315(bzip2Context);
          b = BZip2Decompressor.method315(bzip2Context);
          bzip2Context.currentBlock++;
          b = BZip2Decompressor.method315(bzip2Context);
          b = BZip2Decompressor.method315(bzip2Context);
          b = BZip2Decompressor.method315(bzip2Context);
          b = BZip2Decompressor.method315(bzip2Context);
          b = BZip2Decompressor.method316(bzip2Context);
          if (b !== 0) {
            bzip2Context.aBoolean59 = true;
          } else {
            bzip2Context.aBoolean59 = false;
          }
          if (bzip2Context.aBoolean59) {
            console.info("PANIC! RANDOMISED BLOCK!");
          }
          bzip2Context.anInt64 = 0;
          b = BZip2Decompressor.method315(bzip2Context);
          bzip2Context.anInt64 = bzip2Context.anInt64 << 8 | b & 255;
          b = BZip2Decompressor.method315(bzip2Context);
          bzip2Context.anInt64 = bzip2Context.anInt64 << 8 | b & 255;
          b = BZip2Decompressor.method315(bzip2Context);
          bzip2Context.anInt64 = bzip2Context.anInt64 << 8 | b & 255;
          for (let j = 0; j < 16; j++) {
            {
              const byte1 = BZip2Decompressor.method316(bzip2Context);
              if (byte1 === 1) {
                bzip2Context.aBooleanArray74[j] = true;
              } else {
                bzip2Context.aBooleanArray74[j] = false;
              }
            }
          }
          for (let k = 0; k < 256; k++) {
            bzip2Context.aBooleanArray73[k] = false;
          }
          for (let l = 0; l < 16; l++) {
            if (bzip2Context.aBooleanArray74[l]) {
              for (let i3 = 0; i3 < 16; i3++) {
                {
                  const byte2 = BZip2Decompressor.method316(bzip2Context);
                  if (byte2 === 1) {
                    bzip2Context.aBooleanArray73[l * 16 + i3] = true;
                  }
                }
              }
            }
          }
          BZip2Decompressor.method318(bzip2Context);
          const i4 = bzip2Context.anInt72 + 2;
          const j4 = BZip2Decompressor.method317(3, bzip2Context);
          const k4 = BZip2Decompressor.method317(15, bzip2Context);
          for (let i1 = 0; i1 < k4; i1++) {
            {
              let j3 = 0;
              do {
                {
                  const byte3 = BZip2Decompressor.method316(bzip2Context);
                  if (byte3 === 0) {
                    break;
                  }
                  j3++;
                }
              } while (true);
              bzip2Context.aByteArray79[i1] = j3 | 0;
            }
          }
          const abyte0 = [0, 0, 0, 0, 0, 0];
          for (let byte16 = 0; byte16 < j4; byte16++) {
            abyte0[byte16] = byte16;
          }
          for (let j1 = 0; j1 < k4; j1++) {
            {
              let byte17 = bzip2Context.aByteArray79[j1];
              const byte15 = abyte0[byte17];
              for (; byte17 > 0; byte17--) {
                abyte0[byte17] = abyte0[byte17 - 1];
              }
              abyte0[0] = byte15;
              bzip2Context.aByteArray78[j1] = byte15;
            }
          }
          for (let k3 = 0; k3 < j4; k3++) {
            {
              let l6 = BZip2Decompressor.method317(5, bzip2Context);
              for (let k1 = 0; k1 < i4; k1++) {
                {
                  do {
                    {
                      let byte4 = BZip2Decompressor.method316(bzip2Context);
                      if (byte4 === 0) {
                        break;
                      }
                      byte4 = BZip2Decompressor.method316(bzip2Context);
                      if (byte4 === 0) {
                        l6++;
                      } else {
                        l6--;
                      }
                    }
                  } while (true);
                  bzip2Context.aByteArrayArray80[k3][k1] = l6 | 0;
                }
              }
            }
          }
          for (let l3 = 0; l3 < j4; l3++) {
            {
              let byte8 = 32;
              let i = 0;
              for (let l1 = 0; l1 < i4; l1++) {
                {
                  if (bzip2Context.aByteArrayArray80[l3][l1] > i) {
                    i = bzip2Context.aByteArrayArray80[l3][l1];
                  }
                  if (bzip2Context.aByteArrayArray80[l3][l1] < byte8) {
                    byte8 = bzip2Context.aByteArrayArray80[l3][l1];
                  }
                }
              }
              BZip2Decompressor.method319(
                bzip2Context.anIntArrayArray81[l3],
                bzip2Context.anIntArrayArray82[l3],
                bzip2Context.anIntArrayArray83[l3],
                bzip2Context.aByteArrayArray80[l3],
                byte8,
                i,
                i4
              );
              bzip2Context.anIntArray84[l3] = byte8;
            }
          }
          const l4 = bzip2Context.anInt72 + 1;
          let i5 = -1;
          let j5 = 0;
          for (let i2 = 0; i2 <= 255; i2++) {
            bzip2Context.anIntArray67[i2] = 0;
          }
          let j9 = 4095;
          for (let l8 = 15; l8 >= 0; l8--) {
            {
              for (let i9 = 15; i9 >= 0; i9--) {
                {
                  bzip2Context.aByteArray76[j9] = l8 * 16 + i9 | 0;
                  j9--;
                }
              }
              bzip2Context.anIntArray77[l8] = j9 + 1;
            }
          }
          let i6 = 0;
          if (j5 === 0) {
            i5++;
            j5 = 50;
            const byte12 = bzip2Context.aByteArray78[i5];
            k8 = bzip2Context.anIntArray84[byte12];
            ai = bzip2Context.anIntArrayArray81[byte12];
            ai2 = bzip2Context.anIntArrayArray83[byte12];
            ai1 = bzip2Context.anIntArrayArray82[byte12];
          }
          j5--;
          let i7 = k8;
          let l7;
          let byte9;
          for (l7 = BZip2Decompressor.method317(i7, bzip2Context); l7 > ai[i7]; l7 = l7 << 1 | byte9) {
            {
              i7++;
              byte9 = BZip2Decompressor.method316(bzip2Context);
            }
          }
          for (let k5 = ai2[l7 - ai1[i7]]; k5 !== l4; ) {
            if (k5 === 0 || k5 === 1) {
              let j6 = -1;
              let k6 = 1;
              do {
                {
                  if (k5 === 0) {
                    j6 += k6;
                  } else if (k5 === 1) {
                    j6 += 2 * k6;
                  }
                  k6 *= 2;
                  if (j5 === 0) {
                    i5++;
                    j5 = 50;
                    const byte13 = bzip2Context.aByteArray78[i5];
                    k8 = bzip2Context.anIntArray84[byte13];
                    ai = bzip2Context.anIntArrayArray81[byte13];
                    ai2 = bzip2Context.anIntArrayArray83[byte13];
                    ai1 = bzip2Context.anIntArrayArray82[byte13];
                  }
                  j5--;
                  let j7 = k8;
                  let i8;
                  let byte10;
                  for (i8 = BZip2Decompressor.method317(j7, bzip2Context); i8 > ai[j7]; i8 = i8 << 1 | byte10) {
                    {
                      j7++;
                      byte10 = BZip2Decompressor.method316(bzip2Context);
                    }
                  }
                  k5 = ai2[i8 - ai1[j7]];
                }
              } while (k5 === 0 || k5 === 1);
              j6++;
              const byte5 = bzip2Context.aByteArray75[bzip2Context.aByteArray76[bzip2Context.anIntArray77[0]] & 255];
              bzip2Context.anIntArray67[byte5 & 255] += j6;
              for (; j6 > 0; j6--) {
                {
                  Bzip2Context.anIntArray71[i6] = byte5 & 255;
                  i6++;
                }
              }
            } else {
              let j11 = k5 - 1;
              let byte6;
              if (j11 < 16) {
                const j10 = bzip2Context.anIntArray77[0];
                byte6 = bzip2Context.aByteArray76[j10 + j11];
                for (; j11 > 3; j11 -= 4) {
                  {
                    const k11 = j10 + j11;
                    bzip2Context.aByteArray76[k11] = bzip2Context.aByteArray76[k11 - 1];
                    bzip2Context.aByteArray76[k11 - 1] = bzip2Context.aByteArray76[k11 - 2];
                    bzip2Context.aByteArray76[k11 - 2] = bzip2Context.aByteArray76[k11 - 3];
                    bzip2Context.aByteArray76[k11 - 3] = bzip2Context.aByteArray76[k11 - 4];
                  }
                }
                for (; j11 > 0; j11--) {
                  bzip2Context.aByteArray76[j10 + j11] = bzip2Context.aByteArray76[j10 + j11 - 1];
                }
                bzip2Context.aByteArray76[j10] = byte6;
              } else {
                let l10 = j11 / 16 | 0;
                const i11 = j11 % 16;
                let k10 = bzip2Context.anIntArray77[l10] + i11;
                byte6 = bzip2Context.aByteArray76[k10];
                for (; k10 > bzip2Context.anIntArray77[l10]; k10--) {
                  bzip2Context.aByteArray76[k10] = bzip2Context.aByteArray76[k10 - 1];
                }
                bzip2Context.anIntArray77[l10]++;
                for (; l10 > 0; l10--) {
                  {
                    bzip2Context.anIntArray77[l10]--;
                    bzip2Context.aByteArray76[bzip2Context.anIntArray77[l10]] = bzip2Context.aByteArray76[bzip2Context.anIntArray77[l10 - 1] + 16 - 1];
                  }
                }
                bzip2Context.anIntArray77[0]--;
                bzip2Context.aByteArray76[bzip2Context.anIntArray77[0]] = byte6;
                if (bzip2Context.anIntArray77[0] === 0) {
                  let i10 = 4095;
                  for (let k9 = 15; k9 >= 0; k9--) {
                    {
                      for (let l9 = 15; l9 >= 0; l9--) {
                        {
                          bzip2Context.aByteArray76[i10] = bzip2Context.aByteArray76[bzip2Context.anIntArray77[k9] + l9];
                          i10--;
                        }
                      }
                      bzip2Context.anIntArray77[k9] = i10 + 1;
                    }
                  }
                }
              }
              bzip2Context.anIntArray67[bzip2Context.aByteArray75[byte6 & 255] & 255]++;
              Bzip2Context.anIntArray71[i6] = bzip2Context.aByteArray75[byte6 & 255] & 255;
              i6++;
              if (j5 === 0) {
                i5++;
                j5 = 50;
                const byte14 = bzip2Context.aByteArray78[i5];
                k8 = bzip2Context.anIntArray84[byte14];
                ai = bzip2Context.anIntArrayArray81[byte14];
                ai2 = bzip2Context.anIntArrayArray83[byte14];
                ai1 = bzip2Context.anIntArrayArray82[byte14];
              }
              j5--;
              let k7 = k8;
              let j8;
              let byte11;
              for (j8 = BZip2Decompressor.method317(k7, bzip2Context); j8 > ai[k7]; j8 = j8 << 1 | byte11) {
                {
                  k7++;
                  byte11 = BZip2Decompressor.method316(bzip2Context);
                }
              }
              k5 = ai2[j8 - ai1[k7]];
            }
          }
          bzip2Context.anInt58 = 0;
          bzip2Context.aByte57 = 0;
          bzip2Context.anIntArray69[0] = 0;
          for (let j2 = 1; j2 <= 256; j2++) {
            bzip2Context.anIntArray69[j2] = bzip2Context.anIntArray67[j2 - 1];
          }
          for (let k2 = 1; k2 <= 256; k2++) {
            bzip2Context.anIntArray69[k2] += bzip2Context.anIntArray69[k2 - 1];
          }
          for (let l2 = 0; l2 < i6; l2++) {
            {
              const byte7 = Bzip2Context.anIntArray71[l2] & 255 | 0;
              Bzip2Context.anIntArray71[bzip2Context.anIntArray69[byte7 & 255]] |= l2 << 8;
              bzip2Context.anIntArray69[byte7 & 255]++;
            }
          }
          bzip2Context.anInt65 = Bzip2Context.anIntArray71[bzip2Context.anInt64] >> 8;
          bzip2Context.anInt68 = 0;
          bzip2Context.anInt65 = Bzip2Context.anIntArray71[bzip2Context.anInt65];
          bzip2Context.anInt66 = bzip2Context.anInt65 & 255 | 0;
          bzip2Context.anInt65 >>= 8;
          bzip2Context.anInt68++;
          bzip2Context.anInt85 = i6;
          BZip2Decompressor.method313(bzip2Context);
          if (bzip2Context.anInt68 === bzip2Context.anInt85 + 1 && bzip2Context.anInt58 === 0) {
            flag19 = true;
          } else {
            flag19 = false;
          }
        }
      }
    }
    static method315(class1) {
      return BZip2Decompressor.method317(8, class1) | 0;
    }
    static method316(class1) {
      return BZip2Decompressor.method317(1, class1) | 0;
    }
    static method317(i, class1) {
      let j;
      do {
        {
          if (class1.bsLive >= i) {
            const k = class1.bsBuff >> class1.bsLive - i & (1 << i) - 1;
            class1.bsLive -= i;
            j = k;
            break;
          }
          class1.bsBuff = class1.bsBuff << 8 | class1.compressed[class1.nextIn] & 255;
          class1.bsLive += 8;
          class1.nextIn++;
          class1.decompressedLength--;
          class1.totalInLo32++;
          if (class1.totalInLo32 === 0) {
            class1.totalInHi32++;
          }
        }
      } while (true);
      return j;
    }
    static method318(class1) {
      class1.anInt72 = 0;
      for (let i = 0; i < 256; i++) {
        if (class1.aBooleanArray73[i]) {
          class1.aByteArray75[class1.anInt72] = i | 0;
          class1.anInt72++;
        }
      }
    }
    static method319(ai, ai1, ai2, abyte0, i, j, k) {
      let l = 0;
      for (let i1 = i; i1 <= j; i1++) {
        {
          for (let l2 = 0; l2 < k; l2++) {
            if (abyte0[l2] === i1) {
              ai2[l] = l2;
              l++;
            }
          }
        }
      }
      for (let j1 = 0; j1 < 23; j1++) {
        ai1[j1] = 0;
      }
      for (let k1 = 0; k1 < k; k1++) {
        ai1[abyte0[k1] + 1]++;
      }
      for (let l1 = 1; l1 < 23; l1++) {
        ai1[l1] += ai1[l1 - 1];
      }
      for (let i2 = 0; i2 < 23; i2++) {
        ai[i2] = 0;
      }
      let i3 = 0;
      for (let j2 = i; j2 <= j; j2++) {
        {
          i3 += ai1[j2 + 1] - ai1[j2];
          ai[j2] = i3 - 1;
          i3 <<= 1;
        }
      }
      for (let k2 = i + 1; k2 <= j; k2++) {
        ai1[k2] = (ai[k2 - 1] + 1 << 1) - ai1[k2];
      }
    }
  };
  BZip2Decompressor.state_$LI$();

  // osrs/cache/Archive.ts
  var Archive = class {
    constructor(dataBuffer) {
      if (this.archiveBuffer === void 0) {
        this.archiveBuffer = null;
      }
      if (this.dataSize === void 0) {
        this.dataSize = 0;
      }
      if (this.nameHashes === void 0) {
        this.nameHashes = null;
      }
      if (this.uncompressedSizes === void 0) {
        this.uncompressedSizes = null;
      }
      if (this.compressedSizes === void 0) {
        this.compressedSizes = null;
      }
      if (this.startOffsets === void 0) {
        this.startOffsets = null;
      }
      if (this.compressed === void 0) {
        this.compressed = false;
      }
      let buffer = new Buffer3(dataBuffer);
      const uncompressed = buffer.get24BitInt();
      const compressed = buffer.get24BitInt();
      if (compressed !== uncompressed) {
        const data = Array(uncompressed).fill(0);
        BZip2Decompressor.decompress$byte_A$int$byte_A$int$int(
          data,
          uncompressed,
          dataBuffer,
          compressed,
          6
        );
        this.archiveBuffer = data;
        buffer = new Buffer3(this.archiveBuffer);
        this.compressed = true;
      } else {
        this.archiveBuffer = dataBuffer;
        this.compressed = false;
      }
      this.dataSize = buffer.getUnsignedLEShort();
      this.nameHashes = Array(this.dataSize).fill(0);
      this.uncompressedSizes = Array(this.dataSize).fill(0);
      this.compressedSizes = Array(this.dataSize).fill(0);
      this.startOffsets = Array(this.dataSize).fill(0);
      let offset = buffer.currentPosition + this.dataSize * 10;
      for (let index = 0; index < this.dataSize; index++) {
        {
          this.nameHashes[index] = buffer.getInt();
          this.uncompressedSizes[index] = buffer.get24BitInt();
          this.compressedSizes[index] = buffer.get24BitInt();
          this.startOffsets[index] = offset;
          offset += this.compressedSizes[index];
        }
      }
    }
    getFile(file) {
      let dataBuffer = null;
      file = file.toUpperCase();
      const hash = rs_hash_string(file);
      for (let index = 0; index < this.dataSize; index++) {
        {
          if (this.nameHashes[index] === hash) {
            if (dataBuffer == null) {
              dataBuffer = Array(this.uncompressedSizes[index]).fill(0);
            }
            if (!this.compressed) {
              BZip2Decompressor.decompress$byte_A$int$byte_A$int$int(
                dataBuffer,
                this.uncompressedSizes[index],
                this.archiveBuffer,
                this.compressedSizes[index],
                this.startOffsets[index]
              );
            } else {
              for (let pos = 0; pos < this.uncompressedSizes[index]; pos++) {
                dataBuffer[pos] = this.archiveBuffer[this.startOffsets[index] + pos];
              }
            }
            return dataBuffer;
          }
        }
      }
      return null;
    }
  };

  // osrs/cache/media/TypeFace.ts
  init_inject();

  // osrs/media/Rasterizer.ts
  init_inject();
  var _Rasterizer = class extends CacheableNode {
    static createRasterizer(pixels, width, height) {
      _Rasterizer.pixels = pixels;
      _Rasterizer.width = width;
      _Rasterizer.height = height;
      _Rasterizer.setCoordinates(0, 0, height, width);
    }
    static resetCoordinates() {
      _Rasterizer.topX = 0;
      _Rasterizer.topY = 0;
      _Rasterizer.bottomX = _Rasterizer.width;
      _Rasterizer.bottomY = _Rasterizer.height;
      _Rasterizer.virtualBottomX = _Rasterizer.bottomX - 1;
      _Rasterizer.centerX = _Rasterizer.bottomX / 2 | 0;
    }
    static setCoordinates(y, x2, height, width) {
      if (x2 < 0) {
        x2 = 0;
      }
      if (y < 0) {
        y = 0;
      }
      if (width > _Rasterizer.width) {
        width = _Rasterizer.width;
      }
      if (height > _Rasterizer.height) {
        height = _Rasterizer.height;
      }
      _Rasterizer.topX = x2;
      _Rasterizer.topY = y;
      _Rasterizer.bottomX = width;
      _Rasterizer.bottomY = height;
      _Rasterizer.virtualBottomX = _Rasterizer.bottomX - 1;
      _Rasterizer.centerX = _Rasterizer.bottomX / 2 | 0;
      _Rasterizer.centerY = _Rasterizer.bottomY / 2 | 0;
    }
    static resetPixels() {
      const pixelCount = _Rasterizer.width * _Rasterizer.height;
      for (let pixel = 0; pixel < pixelCount; pixel++) {
        _Rasterizer.pixels[pixel] = 0;
      }
    }
    static drawFilledRectangleAlhpa(x2, y, width, height, colour, alpha) {
      if (x2 < _Rasterizer.topX) {
        width -= _Rasterizer.topX - x2;
        x2 = _Rasterizer.topX;
      }
      if (y < _Rasterizer.topY) {
        height -= _Rasterizer.topY - y;
        y = _Rasterizer.topY;
      }
      if (x2 + width > _Rasterizer.bottomX) {
        width = _Rasterizer.bottomX - x2;
      }
      if (y + height > _Rasterizer.bottomY) {
        height = _Rasterizer.bottomY - y;
      }
      const a = 256 - alpha;
      const r2 = (colour >> 16 & 255) * alpha;
      const g = (colour >> 8 & 255) * alpha;
      const b = (colour & 255) * alpha;
      const widthOffset = _Rasterizer.width - width;
      let pixel = x2 + y * _Rasterizer.width;
      for (let heightCounter = 0; heightCounter < height; heightCounter++) {
        {
          for (let widthCounter = -width; widthCounter < 0; widthCounter++) {
            {
              const red = (_Rasterizer.pixels[pixel] >> 16 & 255) * a;
              const green = (_Rasterizer.pixels[pixel] >> 8 & 255) * a;
              const blue = (_Rasterizer.pixels[pixel] & 255) * a;
              const rgba = (r2 + red >> 8 << 16) + (g + green >> 8 << 8) + (b + blue >> 8);
              _Rasterizer.pixels[pixel++] = rgba;
            }
          }
          pixel += widthOffset;
        }
      }
    }
    static drawFilledRectangle(x2, y, width, height, colour) {
      if (x2 < _Rasterizer.topX) {
        width -= _Rasterizer.topX - x2;
        x2 = _Rasterizer.topX;
      }
      if (y < _Rasterizer.topY) {
        height -= _Rasterizer.topY - y;
        y = _Rasterizer.topY;
      }
      if (x2 + width > _Rasterizer.bottomX) {
        width = _Rasterizer.bottomX - x2;
      }
      if (y + height > _Rasterizer.bottomY) {
        height = _Rasterizer.bottomY - y;
      }
      const pixelOffset = _Rasterizer.width - width;
      let pixel = x2 + y * _Rasterizer.width;
      for (let heightCounter = -height; heightCounter < 0; heightCounter++) {
        {
          for (let widthCounter = -width; widthCounter < 0; widthCounter++) {
            _Rasterizer.pixels[pixel++] = colour;
          }
          pixel += pixelOffset;
        }
      }
    }
    static drawUnfilledRectangle(x2, y, width, height, color) {
      _Rasterizer.drawHorizontalLine(x2, y, width, color);
      _Rasterizer.drawHorizontalLine(x2, y + height - 1, width, color);
      _Rasterizer.drawVerticalLine(x2, y, height, color);
      _Rasterizer.drawVerticalLine(x2 + width - 1, y, height, color);
    }
    static drawUnfilledRectangleAlpha(x2, y, width, height, colour, alpha) {
      _Rasterizer.drawHorizontalLineAlpha(x2, y, width, colour, alpha);
      _Rasterizer.drawHorizontalLineAlpha(x2, y + height - 1, width, colour, alpha);
      if (height >= 3) {
        _Rasterizer.drawVerticalLineAlpha(x2, y + 1, height - 2, colour, alpha);
        _Rasterizer.drawVerticalLineAlpha(x2 + width - 1, y + 1, height - 2, colour, alpha);
      }
    }
    static drawHorizontalLine(x2, y, lenght, colour) {
      if (y < _Rasterizer.topY || y >= _Rasterizer.bottomY) {
        return;
      }
      if (x2 < _Rasterizer.topX) {
        lenght -= _Rasterizer.topX - x2;
        x2 = _Rasterizer.topX;
      }
      if (x2 + lenght > _Rasterizer.bottomX) {
        lenght = _Rasterizer.bottomX - x2;
      }
      const pixelOffset = x2 + y * _Rasterizer.width;
      for (let pixel = 0; pixel < lenght; pixel++) {
        _Rasterizer.pixels[pixelOffset + pixel] = colour;
      }
    }
    static drawHorizontalLineAlpha(x2, y, length, colour, alpha) {
      if (y < _Rasterizer.topY || y >= _Rasterizer.bottomY) {
        return;
      }
      if (x2 < _Rasterizer.topX) {
        length -= _Rasterizer.topX - x2;
        x2 = _Rasterizer.topX;
      }
      if (x2 + length > _Rasterizer.bottomX) {
        length = _Rasterizer.bottomX - x2;
      }
      const a = 256 - alpha;
      const r2 = (colour >> 16 & 255) * alpha;
      const g = (colour >> 8 & 255) * alpha;
      const b = (colour & 255) * alpha;
      let pixelOffset = x2 + y * _Rasterizer.width;
      for (let lengthCounter = 0; lengthCounter < length; lengthCounter++) {
        {
          const red = (_Rasterizer.pixels[pixelOffset] >> 16 & 255) * a;
          const green = (_Rasterizer.pixels[pixelOffset] >> 8 & 255) * a;
          const blue = (_Rasterizer.pixels[pixelOffset] & 255) * a;
          const rgba = (r2 + red >> 8 << 16) + (g + green >> 8 << 8) + (b + blue >> 8);
          _Rasterizer.pixels[pixelOffset++] = rgba;
        }
      }
    }
    static drawVerticalLine(x2, y, lenght, colour) {
      if (x2 < _Rasterizer.topX || x2 >= _Rasterizer.bottomX) {
        return;
      }
      if (y < _Rasterizer.topY) {
        lenght -= _Rasterizer.topY - y;
        y = _Rasterizer.topY;
      }
      if (y + lenght > _Rasterizer.bottomY) {
        lenght = _Rasterizer.bottomY - y;
      }
      const pixelOffset = x2 + y * _Rasterizer.width;
      for (let pixel = 0; pixel < lenght; pixel++) {
        _Rasterizer.pixels[pixelOffset + pixel * _Rasterizer.width] = colour;
      }
    }
    static drawVerticalLineAlpha(x2, y, lenght, colour, alpha) {
      if (x2 < _Rasterizer.topX || x2 >= _Rasterizer.bottomX) {
        return;
      }
      if (y < _Rasterizer.topY) {
        lenght -= _Rasterizer.topY - y;
        y = _Rasterizer.topY;
      }
      if (y + lenght > _Rasterizer.bottomY) {
        lenght = _Rasterizer.bottomY - y;
      }
      const a = 256 - alpha;
      const r2 = (colour >> 16 & 255) * alpha;
      const g = (colour >> 8 & 255) * alpha;
      const b = (colour & 255) * alpha;
      let pixel = x2 + y * _Rasterizer.width;
      for (let lengthCounter = 0; lengthCounter < lenght; lengthCounter++) {
        {
          const red = (_Rasterizer.pixels[pixel] >> 16 & 255) * a;
          const blue = (_Rasterizer.pixels[pixel] >> 8 & 255) * a;
          const green = (_Rasterizer.pixels[pixel] & 255) * a;
          const rgba = (r2 + red >> 8 << 16) + (g + blue >> 8 << 8) + (b + green >> 8);
          _Rasterizer.pixels[pixel] = rgba;
          pixel += _Rasterizer.width;
        }
      }
    }
    constructor() {
      super();
    }
  };
  var Rasterizer = _Rasterizer;
  Rasterizer.pixels = null;
  Rasterizer.width = 0;
  Rasterizer.height = 0;
  Rasterizer.topY = 0;
  Rasterizer.bottomY = 0;
  Rasterizer.topX = 0;
  Rasterizer.bottomX = 0;
  Rasterizer.virtualBottomX = 0;
  Rasterizer.centerX = 0;
  Rasterizer.centerY = 0;

  // osrs/cache/media/TypeFace.ts
  var TypeFace = class extends Rasterizer {
    constructor(large, archive, archiveName) {
      super();
      this.characterPixels = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(256);
      this.characterWidths = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(256);
      this.characterHeights = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(256);
      this.characterXOffsets = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(256);
      this.characterYOffsets = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(256);
      this.characterScreenWidths = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(256);
      this.strikethrough = false;
      if (this.characterDefaultHeight === void 0) {
        this.characterDefaultHeight = 0;
      }
      const dataBuffer = new Buffer3(archive.getFile(archiveName + ".dat"));
      const indexBuffer = new Buffer3(archive.getFile("index.dat"));
      indexBuffer.currentPosition = dataBuffer.getUnsignedLEShort() + 4;
      const k = indexBuffer.getUnsignedByte();
      if (k > 0) {
        indexBuffer.currentPosition += 3 * (k - 1);
      }
      for (let character = 0; character < 256; character++) {
        {
          this.characterXOffsets[character] = indexBuffer.getUnsignedByte();
          this.characterYOffsets[character] = indexBuffer.getUnsignedByte();
          const characterWidth = this.characterWidths[character] = indexBuffer.getUnsignedLEShort();
          const characterHeight = this.characterHeights[character] = indexBuffer.getUnsignedLEShort();
          const characterType = indexBuffer.getUnsignedByte();
          const characterSize = characterWidth * characterHeight;
          this.characterPixels[character] = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(characterSize);
          if (characterType === 0) {
            for (let pixel = 0; pixel < characterSize; pixel++) {
              this.characterPixels[character][pixel] = dataBuffer.getSignedByte();
            }
          } else if (characterType === 1) {
            for (let characterX = 0; characterX < characterWidth; characterX++) {
              {
                for (let characterY = 0; characterY < characterHeight; characterY++) {
                  this.characterPixels[character][characterX + characterY * characterWidth] = dataBuffer.getSignedByte();
                }
              }
            }
          }
          if (characterHeight > this.characterDefaultHeight && character < 128) {
            this.characterDefaultHeight = characterHeight;
          }
          this.characterXOffsets[character] = 1;
          this.characterScreenWidths[character] = characterWidth + 2;
          let pixelCount = 0;
          for (let characterY = characterHeight / 7 | 0; characterY < characterHeight; characterY++) {
            pixelCount += this.characterPixels[character][characterY * characterWidth];
          }
          if (pixelCount <= (characterHeight / 7 | 0)) {
            this.characterScreenWidths[character]--;
            this.characterXOffsets[character] = 0;
          }
          pixelCount = 0;
          for (let characterY = characterHeight / 7 | 0; characterY < characterHeight; characterY++) {
            pixelCount += this.characterPixels[character][characterWidth - 1 + characterY * characterWidth];
          }
          if (pixelCount <= (characterHeight / 7 | 0)) {
            this.characterScreenWidths[character]--;
          }
        }
      }
      if (large) {
        this.characterScreenWidths[32] = this.characterScreenWidths[73];
      } else {
        this.characterScreenWidths[32] = this.characterScreenWidths[105];
      }
    }
    drawStringRight(string, x2, y, colour) {
      this.drawString(string, x2 - this.getStringWidth(string), y, colour);
    }
    drawStringLeft(string, x2, y, colour) {
      this.drawString(string, x2 - (this.getStringWidth(string) / 2 | 0), y, colour);
    }
    drawStringCenter(string, x2, y, colour, shadowed) {
      this.drawShadowedString(string, x2 - (this.getStringEffectWidth(string) / 2 | 0), y, shadowed, colour);
    }
    getStringEffectWidth(string) {
      if (string == null) {
        return 0;
      }
      let width = 0;
      for (let character = 0; character < string.length; character++) {
        if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(string.charAt(character)) == "@".charCodeAt(0) && character + 4 < string.length && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(string.charAt(character + 4)) == "@".charCodeAt(0)) {
          character += 4;
        } else {
          width += this.characterScreenWidths[string.charAt(character).charCodeAt(0)];
        }
      }
      return width;
    }
    getStringWidth(string) {
      if (string == null) {
        return 0;
      }
      let width = 0;
      for (let character = 0; character < string.length; character++) {
        width += this.characterScreenWidths[string.charAt(character).charCodeAt(0)];
      }
      return width;
    }
    drawString(string, x2, y, colour) {
      if (string == null) {
        return;
      }
      y -= this.characterDefaultHeight;
      for (let index = 0; index < string.length; index++) {
        {
          const character = string.charAt(index);
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) != " ".charCodeAt(0)) {
            this.drawCharacter(this.characterPixels[character.charCodeAt(0)], x2 + this.characterXOffsets[character.charCodeAt(0)], y + this.characterYOffsets[character.charCodeAt(0)], this.characterWidths[character.charCodeAt(0)], this.characterHeights[character.charCodeAt(0)], colour);
          }
          x2 += this.characterScreenWidths[character.charCodeAt(0)];
        }
      }
    }
    drawCenteredStringWaveY(string, x2, y, wave, colour) {
      if (string == null) {
        return;
      }
      x2 -= this.getStringWidth(string) / 2 | 0;
      y -= this.characterDefaultHeight;
      for (let index = 0; index < string.length; index++) {
        {
          const character = string.charAt(index);
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) != " ".charCodeAt(0)) {
            this.drawCharacter(this.characterPixels[character.charCodeAt(0)], x2 + this.characterXOffsets[character.charCodeAt(0)], y + this.characterYOffsets[character.charCodeAt(0)] + (Math.sin(index / 2 + wave / 5) * 5 | 0), this.characterWidths[character.charCodeAt(0)], this.characterHeights[character.charCodeAt(0)], colour);
          }
          x2 += this.characterScreenWidths[character.charCodeAt(0)];
        }
      }
    }
    drawCeneteredStringWaveXY(string, x2, y, wave, colour) {
      if (string == null) {
        return;
      }
      x2 -= this.getStringWidth(string) / 2 | 0;
      y -= this.characterDefaultHeight;
      for (let index = 0; index < string.length; index++) {
        {
          const character = string.charAt(index);
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) != " ".charCodeAt(0)) {
            this.drawCharacter(this.characterPixels[character.charCodeAt(0)], x2 + this.characterXOffsets[character.charCodeAt(0)] + (Math.sin(index / 5 + wave / 5) * 5 | 0), y + this.characterYOffsets[character.charCodeAt(0)] + (Math.sin(index / 3 + wave / 5) * 5 | 0), this.characterWidths[character.charCodeAt(0)], this.characterHeights[character.charCodeAt(0)], colour);
          }
          x2 += this.characterScreenWidths[character.charCodeAt(0)];
        }
      }
    }
    drawCenteredStringWaveXYMove(string, x2, y, waveAmount, waveSpeed, colour) {
      if (string == null) {
        return;
      }
      let speed = 7 - waveSpeed / 8;
      if (speed < 0) {
        speed = 0;
      }
      x2 -= this.getStringWidth(string) / 2 | 0;
      y -= this.characterDefaultHeight;
      for (let index = 0; index < string.length; index++) {
        {
          const character = string.charAt(index);
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) != " ".charCodeAt(0)) {
            this.drawCharacter(this.characterPixels[character.charCodeAt(0)], x2 + this.characterXOffsets[character.charCodeAt(0)], y + this.characterYOffsets[character.charCodeAt(0)] + (Math.sin(index / 1.5 + waveAmount) * speed | 0), this.characterWidths[character.charCodeAt(0)], this.characterHeights[character.charCodeAt(0)], colour);
          }
          x2 += this.characterScreenWidths[character.charCodeAt(0)];
        }
      }
    }
    drawShadowedString(string, x2, y, shadow, colour) {
      this.strikethrough = false;
      const originalX = x2;
      if (string == null) {
        return;
      }
      y -= this.characterDefaultHeight;
      for (let character = 0; character < string.length; character++) {
        if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(string.charAt(character)) == "@".charCodeAt(0) && character + 4 < string.length && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(string.charAt(character + 4)) == "@".charCodeAt(0)) {
          const stringColour = this.getColour(string.substring(character + 1, character + 4));
          if (stringColour !== -1) {
            colour = stringColour;
          }
          character += 4;
        } else {
          const c2 = string.charAt(character);
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) != " ".charCodeAt(0)) {
            if (shadow) {
              this.drawCharacter(this.characterPixels[c2.charCodeAt(0)], x2 + this.characterXOffsets[c2.charCodeAt(0)] + 1, y + this.characterYOffsets[c2.charCodeAt(0)] + 1, this.characterWidths[c2.charCodeAt(0)], this.characterHeights[c2.charCodeAt(0)], 0);
            }
            this.drawCharacter(this.characterPixels[c2.charCodeAt(0)], x2 + this.characterXOffsets[c2.charCodeAt(0)], y + this.characterYOffsets[c2.charCodeAt(0)], this.characterWidths[c2.charCodeAt(0)], this.characterHeights[c2.charCodeAt(0)], colour);
          }
          x2 += this.characterScreenWidths[c2.charCodeAt(0)];
        }
      }
      if (this.strikethrough) {
        Rasterizer.drawHorizontalLine(originalX, y + (this.characterDefaultHeight * 0.7 | 0), x2 - originalX, 8388608);
      }
    }
    drawShadowedSeededAlphaString(string, x2, y, colour, seed) {
      if (string == null) {
        return;
      }
      const alpha = 255;
      y -= this.characterDefaultHeight;
      for (let index = 0; index < string.length; index++) {
        if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(string.charAt(index)) == "@".charCodeAt(0) && index + 4 < string.length && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(string.charAt(index + 4)) == "@".charCodeAt(0)) {
          const stringColour = this.getColour(string.substring(index + 1, index + 4));
          if (stringColour !== -1) {
            colour = stringColour;
          }
          index += 4;
        } else {
          const c2 = string.charAt(index);
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) != " ".charCodeAt(0)) {
            this.drawAlphaCharacter(x2 + this.characterXOffsets[c2.charCodeAt(0)] + 1, true, 0, this.characterPixels[c2.charCodeAt(0)], y + this.characterYOffsets[c2.charCodeAt(0)] + 1, this.characterHeights[c2.charCodeAt(0)], this.characterWidths[c2.charCodeAt(0)], 192);
            this.drawAlphaCharacter(x2 + this.characterXOffsets[c2.charCodeAt(0)], true, colour, this.characterPixels[c2.charCodeAt(0)], y + this.characterYOffsets[c2.charCodeAt(0)], this.characterHeights[c2.charCodeAt(0)], this.characterWidths[c2.charCodeAt(0)], alpha);
          }
          x2 += this.characterScreenWidths[c2.charCodeAt(0)];
        }
      }
    }
    getColour(code) {
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "red")) {
        return 16711680;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "gre")) {
        return 65280;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "blu")) {
        return 255;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "yel")) {
        return 16776960;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "cya")) {
        return 65535;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "mag")) {
        return 16711935;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "whi")) {
        return 16777215;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "bla")) {
        return 0;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "lre")) {
        return 16748608;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "dre")) {
        return 8388608;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "dbl")) {
        return 128;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "or1")) {
        return 16756736;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "or2")) {
        return 16740352;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "or3")) {
        return 16723968;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "gr1")) {
        return 12648192;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "gr2")) {
        return 8453888;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "gr3")) {
        return 4259584;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "str")) {
        this.strikethrough = true;
      }
      if (((o1, o2) => {
        if (o1 && o1.equals) {
          return o1.equals(o2);
        } else {
          return o1 === o2;
        }
      })(code, "end")) {
        this.strikethrough = false;
      }
      return -1;
    }
    drawCharacter(pixels, x2, y, width, height, colour) {
      let rasterizerPixel = x2 + y * Rasterizer.width;
      let remainingWidth = Rasterizer.width - width;
      let characterPixelOffset = 0;
      let characterPixel = 0;
      if (y < Rasterizer.topY) {
        const offsetY = Rasterizer.topY - y;
        height -= offsetY;
        y = Rasterizer.topY;
        characterPixel += offsetY * width;
        rasterizerPixel += offsetY * Rasterizer.width;
      }
      if (y + height >= Rasterizer.bottomY) {
        height -= y + height - Rasterizer.bottomY + 1;
      }
      if (x2 < Rasterizer.topX) {
        const offsetX = Rasterizer.topX - x2;
        width -= offsetX;
        x2 = Rasterizer.topX;
        characterPixel += offsetX;
        rasterizerPixel += offsetX;
        characterPixelOffset += offsetX;
        remainingWidth += offsetX;
      }
      if (x2 + width >= Rasterizer.bottomX) {
        const endOffsetX = x2 + width - Rasterizer.bottomX + 1;
        width -= endOffsetX;
        characterPixelOffset += endOffsetX;
        remainingWidth += endOffsetX;
      }
      if (width > 0 && height > 0) {
        this.drawCharacterPixels(pixels, Rasterizer.pixels, characterPixel, rasterizerPixel, characterPixelOffset, remainingWidth, width, height, colour);
      }
    }
    drawCharacterPixels(characterPixels, rasterizerPixels, characterPixel, rasterizerPixel, characterPixelOffset, rasterizerPixelOffset, width, height, colour) {
      const negativeQuaterWidth = -(width >> 2);
      width = -(width & 3);
      for (let heightCounter = -height; heightCounter < 0; heightCounter++) {
        {
          for (let widthCounter = negativeQuaterWidth; widthCounter < 0; widthCounter++) {
            {
              if (characterPixels[characterPixel++] !== 0) {
                rasterizerPixels[rasterizerPixel++] = colour;
              } else {
                rasterizerPixel++;
              }
              if (characterPixels[characterPixel++] !== 0) {
                rasterizerPixels[rasterizerPixel++] = colour;
              } else {
                rasterizerPixel++;
              }
              if (characterPixels[characterPixel++] !== 0) {
                rasterizerPixels[rasterizerPixel++] = colour;
              } else {
                rasterizerPixel++;
              }
              if (characterPixels[characterPixel++] !== 0) {
                rasterizerPixels[rasterizerPixel++] = colour;
              } else {
                rasterizerPixel++;
              }
            }
          }
          for (let widthCounter = width; widthCounter < 0; widthCounter++) {
            if (characterPixels[characterPixel++] !== 0) {
              rasterizerPixels[rasterizerPixel++] = colour;
            } else {
              rasterizerPixel++;
            }
          }
          rasterizerPixel += rasterizerPixelOffset;
          characterPixel += characterPixelOffset;
        }
      }
    }
    drawAlphaCharacter(x2, flag, j, abyte0, y, height, width, j1) {
      let rasterizerPixel = x2 + y * Rasterizer.width;
      let rasterizerPixelOffset = Rasterizer.width - width;
      let characterPixelOffset = 0;
      let characterPixel = 0;
      if (y < Rasterizer.topY) {
        const yOffset = Rasterizer.topY - y;
        height -= yOffset;
        y = Rasterizer.topY;
        characterPixel += yOffset * width;
        rasterizerPixel += yOffset * Rasterizer.width;
      }
      if (y + height >= Rasterizer.bottomY) {
        height -= y + height - Rasterizer.bottomY + 1;
      }
      if (x2 < Rasterizer.topX) {
        const xOffset = Rasterizer.topX - x2;
        width -= xOffset;
        x2 = Rasterizer.topX;
        characterPixel += xOffset;
        rasterizerPixel += xOffset;
        characterPixelOffset += xOffset;
        rasterizerPixelOffset += xOffset;
      }
      if (x2 + width >= Rasterizer.bottomX) {
        const widthoffset = x2 + width - Rasterizer.bottomX + 1;
        width -= widthoffset;
        characterPixelOffset += widthoffset;
        rasterizerPixelOffset += widthoffset;
      }
      if (width > 0 && height > 0) {
        this.drawCharacterPixelsAlpha(characterPixel, rasterizerPixelOffset, characterPixelOffset, rasterizerPixel, j1, Rasterizer.pixels, j, 2, height, width, abyte0);
      }
    }
    drawCharacterPixelsAlpha(characterPixel, rasterizerPixelOffset, characterPixelOffset, rasterizerPixel, alpha, rasterizerPixels, colour, k1, height, width, characterPixels) {
      colour = ((colour & 16711935) * alpha & -16711936) + ((colour & 65280) * alpha & 16711680) >> 8;
      alpha = 256 - alpha;
      for (let heightCounter = -height; heightCounter < 0; heightCounter++) {
        {
          for (let widthCounter = -width; widthCounter < 0; widthCounter++) {
            if (characterPixels[characterPixel++] !== 0) {
              const rasterizerPixelColor = rasterizerPixels[rasterizerPixel];
              rasterizerPixels[rasterizerPixel++] = (((rasterizerPixelColor & 16711935) * alpha & -16711936) + ((rasterizerPixelColor & 65280) * alpha & 16711680) >> 8) + colour;
            } else {
              rasterizerPixel++;
            }
          }
          rasterizerPixel += rasterizerPixelOffset;
          characterPixel += characterPixelOffset;
        }
      }
    }
    getRandomInt(max) {
      return Math.floor(Math.random() * Math.floor(max));
    }
  };

  // osrs/GameShell.ts
  init_inject();

  // osrs/media/ProducingGraphicsBuffer.ts
  init_inject();
  var ProducingGraphicsBuffer = class {
    constructor(width, height) {
      if (this.pixels === void 0) {
        this.pixels = null;
      }
      if (this.width === void 0) {
        this.width = 0;
      }
      if (this.height === void 0) {
        this.height = 0;
      }
      this.width = width;
      this.height = height;
      this.pixels = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(width * height);
      this.createRasterizer();
    }
    createRasterizer() {
      Rasterizer.createRasterizer(this.pixels, this.width, this.height);
    }
    drawGraphics(x2, y, graphics) {
      graphics.drawImage(
        new ImageData(
          new Uint8ClampedArray(
            new Int32Array(
              this.pixels.map((p) => this.fixPixel(p))
            ).buffer
          ),
          this.width,
          this.height
        ),
        x2,
        y
      );
    }
    fixPixel(pixel) {
      let c2 = pixel >> 24 & 255;
      let r2 = pixel >> 16 & 255;
      let g = pixel >> 8 & 255;
      let b = pixel & 255;
      if (c2 != 0) {
        return pixel;
      }
      let a = 255;
      const black = 255 << 24;
      return pixel == 0 ? black : (a << 24) + (b << 16) + (g << 8) + r2;
    }
  };

  // osrs/graphics/Graphics.ts
  init_inject();
  var Graphics = class {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext("2d");
    }
    setColor(color) {
      this.ctx.fillStyle = color.toCanvasStyle();
      this.ctx.strokeStyle = color.toCanvasStyle();
    }
    fillRect(x2, y, width, height) {
      this.ctx.fillRect(x2, y, width, height);
    }
    drawRect(x2, y, width, height) {
      this.ctx.strokeRect(x2, y, width, height);
    }
    setFont(font) {
      this.ctx.font = font.toCanvasFont();
    }
    drawString(s, x2, y) {
      this.ctx.fillText(s, x2, y);
    }
    measureTextWidth(s) {
      return this.ctx.measureText(s).width;
    }
    drawImage(image, x2, y) {
      this.ctx.putImageData(image, x2, y);
    }
    getImage(width, height) {
      return this.ctx.getImageData(0, 0, width, height);
    }
  };

  // osrs/graphics/Font.ts
  init_inject();
  var Font = class {
    constructor(name, type, size) {
      this.name = name;
      this.type = type;
      this.size = size;
    }
    toCanvasFont() {
      return `${this.getType()} ${this.size}px ${this.name}`;
    }
    getType() {
      if (this.type == 1) {
        return "bold";
      } else if (this.type == 2) {
        return "italic";
      }
      return "normal";
    }
  };

  // osrs/graphics/Color.ts
  init_inject();
  var _Color = class {
    constructor(r2, g, b, a = 255) {
      this.r = r2;
      this.g = g;
      this.b = b;
      this.a = a;
    }
    toCanvasStyle() {
      return `rgba(${this.r},${this.g}, ${this.b}, ${this.a})`;
    }
  };
  var Color = _Color;
  Color.white = new _Color(255, 255, 255);
  Color.WHITE = _Color.white;
  Color.lightGray = new _Color(192, 192, 192);
  Color.LIGHT_GRAY = _Color.lightGray;
  Color.gray = new _Color(128, 128, 128);
  Color.GRAY = _Color.gray;
  Color.darkGray = new _Color(64, 64, 64);
  Color.DARK_GRAY = _Color.darkGray;
  Color.black = new _Color(0, 0, 0);
  Color.BLACK = _Color.black;
  Color.red = new _Color(255, 0, 0);
  Color.RED = _Color.red;
  Color.pink = new _Color(255, 175, 175);
  Color.PINK = _Color.pink;
  Color.orange = new _Color(255, 200, 0);
  Color.ORANGE = _Color.orange;
  Color.yellow = new _Color(255, 255, 0);
  Color.YELLOW = _Color.yellow;
  Color.green = new _Color(0, 255, 0);
  Color.GREEN = _Color.green;
  Color.magenta = new _Color(255, 0, 255);
  Color.MAGENTA = _Color.magenta;
  Color.cyan = new _Color(0, 255, 255);
  Color.CYAN = _Color.cyan;
  Color.blue = new _Color(0, 0, 255);
  Color.BLUE = _Color.blue;

  // osrs/ParallelExecutor.ts
  init_inject();
  var Executed = class {
    constructor(func, instance) {
      this.func = null;
      this.instance = null;
      this.funcBound = null;
      this.timeout = null;
      this.executeFunc = null;
      this.stopped = true;
      this.func = func;
      this.instance = instance;
      this.initExecuteFunc();
    }
    execute() {
      this.stopped = false;
      this.executeFunc();
    }
    stop() {
      this.stopped = true;
      if (this.timeout != null) {
        clearTimeout(this.timeout);
      }
    }
    restart() {
      this.stop();
      this.initExecuteFunc();
      this.execute();
    }
    initExecuteFunc() {
      this.funcBound = this.func.bind(this.instance);
      this.executeFunc = (async () => {
        const run = await this.funcBound();
        if (run && !this.stopped) {
          this.timeout = setTimeout(this.executeFunc, 1);
        } else {
          this.timeout = null;
        }
      }).bind(this);
    }
  };
  async function sleep(milliseconds) {
    return new Promise((resolve) => setTimeout(resolve, milliseconds));
  }
  var ParallelExecutor = class {
    constructor() {
      this.executeds = [];
    }
    start(runnable) {
      this.startRaw(runnable.run, runnable);
    }
    startRaw(func, instance) {
      const executed = new Executed(func, instance);
      executed.execute();
      this.executeds.push(executed);
    }
    restartAll() {
      this.executeds.forEach((ex) => {
        ex.restart();
      });
    }
    stopAll() {
      this.executeds.forEach((ex) => {
        ex.stop();
      });
    }
  };

  // osrs/GameShell.ts
  var GameShell = class {
    constructor(canvas) {
      this.gameState = 0;
      this.deltime = 20;
      this.mindel = 1;
      this.optims = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.fps = 0;
      this.dumpRequested = false;
      this.width = 0;
      this.height = 0;
      this.aClass50_Sub1_Sub1_Sub1Array16 = [null, null, null, null, null, null];
      this.clearScreen = true;
      this.awtFocus = true;
      this.idleTime = 0;
      this.mouseX = 0;
      this.mouseY = 0;
      this.eventMouseButtonPressed = 0;
      this.eventClickX = 0;
      this.eventClickY = 0;
      this.lastClick = 0;
      this.clickType = 0;
      this.clickX = 0;
      this.clickY = 0;
      this.clickTime = 0;
      this.keyStatus = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(128);
      this.inputBuffer = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(128);
      this.readIndex = 0;
      this.writeIndex = 0;
      this.mouseWheelDown = false;
      this.mouseWheelX = 0;
      this.mouseWheelY = 0;
      this.loopData = {
        opos: 0,
        ratio: 256,
        del: 1,
        count: 0,
        intex: 0
      };
      this.runInitialized = false;
      this.canvas = canvas;
      this.gameGraphics = new Graphics(canvas);
    }
    async initializeApplication(_width, _height) {
      this.width = _width;
      this.height = _height;
      this.gameGraphics = new Graphics(this.canvas);
      this.imageProducer = new ProducingGraphicsBuffer(this.width, this.height);
      await this.run();
    }
    async run() {
      if (!this.runInitialized) {
        this.runInitialized = true;
        this.canvas.addEventListener("mousedown", this.mousePressed.bind(this));
        this.canvas.addEventListener("mouseup", this.mouseReleased.bind(this));
        this.canvas.addEventListener("dragstart", this.mouseDragged.bind(this));
        this.canvas.addEventListener("mouseleave", this.mouseExited.bind(this));
        this.canvas.addEventListener("mousemove", this.mouseMoved.bind(this));
        this.canvas.addEventListener("keydown", this.keyPressed.bind(this));
        this.canvas.addEventListener("keyup", this.keyReleased.bind(this));
        this.canvas.addEventListener("contextmenu", (event) => {
          event.preventDefault();
        }, true);
        await this.drawLoadingText(0, "Loading...");
        await this.startUp();
        for (let optim = 0; optim < 10; optim++) {
          this.optims[optim] = new Date().getTime();
        }
      }
      Game.parallelExecutor.startRaw(this.mainLoop, this);
    }
    async mainLoop() {
      const ld = this.loopData;
      if (this.gameState > 0) {
        this.gameState--;
        if (this.gameState === 0) {
          this.exit();
          return;
        }
      }
      ld.ratio = 300;
      ld.del = 1;
      const currentTime = new Date().getTime();
      if (currentTime > this.optims[ld.opos]) {
        ld.ratio = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(2560 * this.deltime / (currentTime - this.optims[ld.opos])) | 0;
      }
      if (ld.ratio < 25) {
        ld.ratio = 25;
      }
      if (ld.ratio > 256) {
        ld.ratio = 256;
        ld.del = this.deltime - ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))((currentTime - this.optims[ld.opos]) / 10) | 0;
      }
      if (ld.del > this.deltime) {
        ld.del = this.deltime;
      }
      this.optims[ld.opos] = currentTime;
      ld.opos = (ld.opos + 1) % 10;
      if (ld.del > 1) {
        for (let optim = 0; optim < 10; optim++) {
          if (this.optims[optim] !== 0) {
            this.optims[optim] += ld.del;
          }
        }
      }
      if (ld.del < this.mindel) {
        ld.del = this.mindel;
      }
      await sleep(ld.del);
      for (; ld.count < 256; ld.count += ld.ratio) {
        {
          this.clickType = this.eventMouseButtonPressed;
          this.clickX = this.eventClickX;
          this.clickY = this.eventClickY;
          this.clickTime = this.lastClick;
          this.eventMouseButtonPressed = 0;
          await this.doLogic();
          this.readIndex = this.writeIndex;
        }
      }
      ld.count &= 255;
      if (this.deltime > 0) {
        this.fps = 1e3 * ld.ratio / (this.deltime * 256) | 0;
      }
      await this.repaintGame();
      if (this.dumpRequested) {
        console.info("ntime:" + currentTime);
        for (let i = 0; i < 10; i++) {
          {
            const optim = (ld.opos - i - 1 + 20) % 10;
            console.info("otim" + optim + ":" + this.optims[optim]);
          }
        }
        console.info("fps:" + this.fps + " ratio:" + ld.ratio + " count:" + ld.count);
        console.info("del:" + ld.del + " deltime:" + this.deltime + " mindel:" + this.mindel);
        console.info("intex:" + ld.intex + " opos:" + ld.opos);
        this.dumpRequested = false;
        ld.intex = 0;
      }
      if (this.gameState === -1) {
        this.exit();
        return false;
      } else if (this.gameState >= 0) {
        return true;
      }
    }
    exit() {
      this.gameState = -2;
      this.shutdown();
    }
    setFrameRate(i) {
      this.deltime = 1e3 / i | 0;
    }
    start() {
      if (this.gameState >= 0) {
        this.gameState = 0;
      }
    }
    stop() {
      if (this.gameState >= 0) {
        this.gameState = 4e3 / this.deltime | 0;
      }
    }
    destroy() {
      this.gameState = -1;
      this.exit();
    }
    update(graphics) {
      if (this.gameGraphics == null) {
        this.gameGraphics = graphics;
      }
      this.clearScreen = true;
      this.redraw();
    }
    paint(graphics) {
      if (this.gameGraphics == null) {
        this.gameGraphics = graphics;
      }
      this.clearScreen = true;
      this.redraw();
    }
    mousePressed(mouseevent) {
      let mouseX = mouseevent.offsetX;
      let mouseY = mouseevent.offsetY;
      this.idleTime = 0;
      this.eventClickX = mouseX;
      this.eventClickY = mouseY;
      this.lastClick = new Date().getTime();
      if (mouseevent.button === 1) {
        this.mouseWheelDown = true;
        this.mouseWheelX = mouseX;
        this.mouseWheelY = mouseY;
        return;
      }
      if (mouseevent.metaKey || mouseevent.button === 2) {
        this.eventMouseButtonPressed = 2;
        this.mouseButtonPressed = 2;
      } else {
        this.eventMouseButtonPressed = 1;
        this.mouseButtonPressed = 1;
      }
    }
    mouseReleased(mouseevent) {
      this.idleTime = 0;
      this.mouseButtonPressed = 0;
      this.mouseWheelDown = false;
    }
    mouseExited(mouseevent) {
      this.idleTime = 0;
      this.mouseX = -1;
      this.mouseY = -1;
    }
    mouseDragged(mouseevent) {
      let mouseX = mouseevent.offsetX;
      let mouseY = mouseevent.offsetY;
      if (this.mouseWheelDown) {
        mouseY = this.mouseWheelX - mouseevent.x;
        const k = this.mouseWheelY - mouseevent.y;
        this.mouseWheelDragged(mouseY, -k);
        this.mouseWheelX = mouseevent.x;
        this.mouseWheelY = mouseevent.y;
        return;
      }
      this.idleTime = 0;
      this.mouseX = mouseX;
      this.mouseY = mouseY;
    }
    mouseWheelDragged(param1, param2) {
    }
    mouseMoved(mouseevent) {
      let mouseX = mouseevent.offsetX;
      let mouseY = mouseevent.offsetY;
      this.idleTime = 0;
      this.mouseX = mouseX;
      this.mouseY = mouseY;
    }
    keyPressed(event) {
      this.idleTime = 0;
      const keyCode = event.keyCode;
      let keyChar = event.key.length == 1 ? event.key.charCodeAt(0) : keyCode;
      if (keyChar < 30) {
        keyChar = 0;
      }
      if (keyCode === 37) {
        keyChar = 1;
      }
      if (keyCode === 13) {
        keyChar = 13;
      }
      if (keyCode === 39) {
        keyChar = 2;
      }
      if (keyCode === 38) {
        keyChar = 3;
      }
      if (keyCode === 40) {
        keyChar = 4;
      }
      if (keyCode === 17) {
        keyChar = 5;
      }
      if (keyCode === 8) {
        keyChar = 8;
      }
      if (keyCode === 127) {
        keyChar = 8;
      }
      if (keyCode === 9) {
        keyChar = 9;
      }
      if (keyCode === 10) {
        keyChar = 10;
      }
      if (keyCode >= 112 && keyCode <= 123) {
        keyChar = 1008 + keyCode - 112;
      }
      if (keyCode === 36) {
        keyChar = 1e3;
      }
      if (keyCode === 35) {
        keyChar = 1001;
      }
      if (keyCode === 33) {
        keyChar = 1002;
      }
      if (keyCode === 34) {
        keyChar = 1003;
      }
      if (keyChar > 0 && keyChar < 128) {
        this.keyStatus[keyChar] = 1;
      }
      if (keyChar > 4) {
        this.inputBuffer[this.writeIndex] = keyChar;
        this.writeIndex = this.writeIndex + 1 & 127;
      }
    }
    keyReleased(event) {
      this.idleTime = 0;
      const keyCode = event.keyCode;
      let keyChar = event.key.length == 1 ? event.key.charCodeAt(0) : keyCode;
      if (keyChar < 36) {
        keyChar = 0;
      }
      if (keyCode === 37) {
        keyChar = 1;
      }
      if (keyCode === 39) {
        keyChar = 2;
      }
      if (keyCode === 38) {
        keyChar = 3;
      }
      if (keyCode === 40) {
        keyChar = 4;
      }
      if (keyCode === 17) {
        keyChar = 5;
      }
      if (keyCode === 8) {
        keyChar = 8;
      }
      if (keyCode === 127) {
        keyChar = 8;
      }
      if (keyCode === 9) {
        keyChar = 9;
      }
      if (keyCode === 10) {
        keyChar = 10;
      }
      if (keyChar > 0 && keyChar < 128) {
        this.keyStatus[keyChar] = 0;
      }
    }
    keyTyped(KeyboardEvent) {
    }
    readCharacter() {
      let character = -1;
      if (this.writeIndex !== this.readIndex) {
        character = this.inputBuffer[this.readIndex];
        this.readIndex = this.readIndex + 1 & 127;
      }
      return character;
    }
    focusGained(focusevent) {
      this.awtFocus = true;
      this.clearScreen = true;
      this.redraw();
    }
    focusLost(focusevent) {
      this.awtFocus = false;
      for (let key = 0; key < 128; key++) {
        this.keyStatus[key] = 0;
      }
    }
    async startUp() {
    }
    async doLogic() {
    }
    shutdown() {
    }
    async repaintGame() {
    }
    redraw() {
    }
    getParentComponent() {
    }
    async drawLoadingText(percent, desc) {
      const helveticaBold = new Font("Helvetica", 1, 13);
      if (this.clearScreen) {
        this.gameGraphics.setColor(Color.black);
        this.gameGraphics.fillRect(0, 0, this.width, this.height);
        this.clearScreen = false;
      }
      const color = new Color(140, 17, 17);
      const centerHeight = (this.height / 2 | 0) - 18;
      this.gameGraphics.setColor(color);
      this.gameGraphics.drawRect((this.width / 2 | 0) - 152, centerHeight, 304, 34);
      this.gameGraphics.fillRect((this.width / 2 | 0) - 150, centerHeight + 2, percent * 3, 30);
      this.gameGraphics.setColor(Color.black);
      this.gameGraphics.fillRect((this.width / 2 | 0) - 150 + percent * 3, centerHeight + 2, 300 - percent * 3, 30);
      this.gameGraphics.setFont(helveticaBold);
      this.gameGraphics.setColor(Color.white);
      this.gameGraphics.drawString(desc, (this.width - this.gameGraphics.measureTextWidth(desc)) / 2 | 0, centerHeight + 22);
    }
  };

  // osrs/cache/media/ImageRGB.ts
  init_inject();
  var import_jpeg_js = __toESM(require_jpeg_js(), 1);
  var ImageRGB = class extends Rasterizer {
    static from(width, height) {
      let image = new ImageRGB();
      image.pixels = Array(width * height).fill(0);
      image.width = image.maxWidth = width;
      image.height = image.maxHeight = height;
      image.offsetX = image.offsetY = 0;
      return image;
    }
    static async fromJpg(bytes) {
      const jpgData = (0, import_jpeg_js.decode)(bytes);
      let image = new ImageRGB();
      image.pixels = Array.from(new Int32Array(jpgData.data.buffer));
      image.width = image.maxWidth = jpgData.width;
      image.height = image.maxHeight = jpgData.height;
      image.offsetX = image.offsetY = 0;
      return image;
    }
    static fromArchive(archive, archiveName, archiveIndex) {
      let image = new ImageRGB();
      const imageBytes = archive.getFile(archiveName + ".dat");
      const dataBuffer = new Buffer3(imageBytes);
      const indexBuffer = new Buffer3(archive.getFile("index.dat"));
      indexBuffer.currentPosition = dataBuffer.getUnsignedLEShort();
      image.maxWidth = indexBuffer.getUnsignedLEShort();
      image.maxHeight = indexBuffer.getUnsignedLEShort();
      const length = indexBuffer.getUnsignedByte();
      const pixels = Array(length).fill(0);
      for (let pixel = 0; pixel < length - 1; pixel++) {
        {
          pixels[pixel + 1] = indexBuffer.get24BitInt();
          if (pixels[pixel + 1] === 0) {
            pixels[pixel + 1] = 1;
          }
        }
      }
      for (let index = 0; index < archiveIndex; index++) {
        {
          indexBuffer.currentPosition += 2;
          dataBuffer.currentPosition += indexBuffer.getUnsignedLEShort() * indexBuffer.getUnsignedLEShort();
          indexBuffer.currentPosition++;
        }
      }
      image.offsetX = indexBuffer.getUnsignedByte();
      image.offsetY = indexBuffer.getUnsignedByte();
      image.width = indexBuffer.getUnsignedLEShort();
      image.height = indexBuffer.getUnsignedLEShort();
      const type = indexBuffer.getUnsignedByte();
      const pixelCount = image.width * image.height;
      image.pixels = Array(pixelCount).fill(0);
      if (type === 0) {
        for (let pixel = 0; pixel < pixelCount; pixel++) {
          const newPixel = pixels[dataBuffer.getUnsignedByte()];
          image.pixels[pixel] = newPixel;
        }
        return image;
      }
      if (type === 1) {
        for (let x2 = 0; x2 < image.width; x2++) {
          {
            for (let y = 0; y < image.height; y++) {
              const newPixel = pixels[dataBuffer.getUnsignedByte()];
              image.pixels[x2 + y * image.width] = newPixel;
            }
          }
        }
      }
      return image;
    }
    createRasterizer() {
      Rasterizer.createRasterizer(this.pixels, this.width, this.height);
    }
    adjustRGB(redOffset, greenOffset, blueOffset) {
      for (let pixel = 0; pixel < this.pixels.length; pixel++) {
        {
          const originalColor = this.pixels[pixel];
          if (originalColor !== 0) {
            let red = originalColor >> 16 & 255;
            red += redOffset;
            if (red < 1) {
              red = 1;
            } else if (red > 255) {
              red = 255;
            }
            let green = originalColor >> 8 & 255;
            green += greenOffset;
            if (green < 1) {
              green = 1;
            } else if (green > 255) {
              green = 255;
            }
            let blue = originalColor & 255;
            blue += blueOffset;
            if (blue < 1) {
              blue = 1;
            } else if (blue > 255) {
              blue = 255;
            }
            this.pixels[pixel] = (red << 16) + (green << 8) + blue;
          }
        }
      }
    }
    trim() {
      const newPixels = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.maxWidth * this.maxHeight);
      for (let y = 0; y < this.height; y++) {
        {
          for (let x2 = 0; x2 < this.width; x2++) {
            newPixels[(y + this.offsetY) * this.maxWidth + (x2 + this.offsetX)] = this.pixels[y * this.width + x2];
          }
        }
      }
      this.pixels = newPixels;
      this.width = this.maxWidth;
      this.height = this.maxHeight;
      this.offsetX = 0;
      this.offsetY = 0;
    }
    drawInverse(x2, y) {
      x2 += this.offsetX;
      y += this.offsetY;
      let rasterizerPixel = x2 + y * Rasterizer.width;
      let pixel = 0;
      let newHeight = this.height;
      let newWidth = this.width;
      let rasterizerPixelOffset = Rasterizer.width - newWidth;
      let pixelOffset = 0;
      if (y < Rasterizer.topY) {
        const yOffset = Rasterizer.topY - y;
        newHeight -= yOffset;
        y = Rasterizer.topY;
        pixel += yOffset * newWidth;
        rasterizerPixel += yOffset * Rasterizer.width;
      }
      if (y + newHeight > Rasterizer.bottomY) {
        newHeight -= y + newHeight - Rasterizer.bottomY;
      }
      if (x2 < Rasterizer.topX) {
        const xOffset = Rasterizer.topX - x2;
        newWidth -= xOffset;
        x2 = Rasterizer.topX;
        pixel += xOffset;
        rasterizerPixel += xOffset;
        pixelOffset += xOffset;
        rasterizerPixelOffset += xOffset;
      }
      if (x2 + newWidth > Rasterizer.bottomX) {
        const widthOffset = x2 + newWidth - Rasterizer.bottomX;
        newWidth -= widthOffset;
        pixelOffset += widthOffset;
        rasterizerPixelOffset += widthOffset;
      }
      if (newWidth <= 0 || newHeight <= 0) {
        return;
      }
      this.copyPixels(this.pixels, Rasterizer.pixels, pixel, rasterizerPixel, pixelOffset, rasterizerPixelOffset, newWidth, newHeight);
    }
    copyPixels(pixels, rasterizerPixels, pixel, rasterizerPixel, pixelOffset, rasterizerPixelOffset, width, height) {
      const shiftedWidth = -(width >> 2);
      width = -(width & 3);
      for (let heightCounter = -height; heightCounter < 0; heightCounter++) {
        {
          for (let widthCounter = shiftedWidth; widthCounter < 0; widthCounter++) {
            {
              rasterizerPixels[rasterizerPixel++] = pixels[pixel++];
              rasterizerPixels[rasterizerPixel++] = pixels[pixel++];
              rasterizerPixels[rasterizerPixel++] = pixels[pixel++];
              rasterizerPixels[rasterizerPixel++] = pixels[pixel++];
            }
          }
          for (let widthCounter = width; widthCounter < 0; widthCounter++) {
            rasterizerPixels[rasterizerPixel++] = pixels[pixel++];
          }
          rasterizerPixel += rasterizerPixelOffset;
          pixel += pixelOffset;
        }
      }
    }
    drawImage(y, x2) {
      x2 += this.offsetX;
      y += this.offsetY;
      let rasterizerOffset = x2 + y * Rasterizer.width;
      let pixelOffset = 0;
      let imageHeight = this.height;
      let imageWidth = this.width;
      let deviation = Rasterizer.width - imageWidth;
      let originalDeviation = 0;
      if (y < Rasterizer.topY) {
        const yOffset = Rasterizer.topY - y;
        imageHeight -= yOffset;
        y = Rasterizer.topY;
        pixelOffset += yOffset * imageWidth;
        rasterizerOffset += yOffset * Rasterizer.width;
      }
      if (y + imageHeight > Rasterizer.bottomY) {
        imageHeight -= y + imageHeight - Rasterizer.bottomY;
      }
      if (x2 < Rasterizer.topX) {
        const xOffset = Rasterizer.topX - x2;
        imageWidth -= xOffset;
        x2 = Rasterizer.topX;
        pixelOffset += xOffset;
        rasterizerOffset += xOffset;
        originalDeviation += xOffset;
        deviation += xOffset;
      }
      if (x2 + imageWidth > Rasterizer.bottomX) {
        const xOffset = x2 + imageWidth - Rasterizer.bottomX;
        imageWidth -= xOffset;
        originalDeviation += xOffset;
        deviation += xOffset;
      }
      if (imageWidth <= 0 || imageHeight <= 0) {
        return;
      } else {
        this.shapeImageToPixels$int_A$int_A$int$int$int$int$int$int$int(
          this.pixels,
          Rasterizer.pixels,
          pixelOffset,
          rasterizerOffset,
          imageWidth,
          imageHeight,
          originalDeviation,
          deviation,
          0
        );
        return;
      }
    }
    shapeImageToPixels$int_A$int_A$int$int$int$int$int$int$int(pixels, rasterizerPixels, pixel, rasterizerPixel, width, height, pixelOffset, rasterizerPixelOffset, pixelColor) {
      const shiftedWidth = -(width >> 2);
      width = -(width & 3);
      for (let heightCounter = -height; heightCounter < 0; heightCounter++) {
        {
          for (let widthCounter = shiftedWidth; widthCounter < 0; widthCounter++) {
            {
              pixelColor = pixels[pixel++];
              if (pixelColor !== 0) {
                rasterizerPixels[rasterizerPixel++] = pixelColor;
              } else {
                rasterizerPixel++;
              }
              pixelColor = pixels[pixel++];
              if (pixelColor !== 0) {
                rasterizerPixels[rasterizerPixel++] = pixelColor;
              } else {
                rasterizerPixel++;
              }
              pixelColor = pixels[pixel++];
              if (pixelColor !== 0) {
                rasterizerPixels[rasterizerPixel++] = pixelColor;
              } else {
                rasterizerPixel++;
              }
              pixelColor = pixels[pixel++];
              if (pixelColor !== 0) {
                rasterizerPixels[rasterizerPixel++] = pixelColor;
              } else {
                rasterizerPixel++;
              }
            }
          }
          for (let widthCounter = width; widthCounter < 0; widthCounter++) {
            {
              pixelColor = pixels[pixel++];
              if (pixelColor !== 0) {
                rasterizerPixels[rasterizerPixel++] = pixelColor;
              } else {
                rasterizerPixel++;
              }
            }
          }
          rasterizerPixel += rasterizerPixelOffset;
          pixel += pixelOffset;
        }
      }
    }
    drawImageAlpha(x2, y, alpha) {
      x2 += this.offsetX;
      y += this.offsetY;
      let rasterizerPixel = x2 + y * Rasterizer.width;
      let pixel = 0;
      let newHeight = this.height;
      let newWidth = this.width;
      let rasterizerPixelOffset = Rasterizer.width - newWidth;
      let pixelOffset = 0;
      if (y < Rasterizer.topY) {
        const yOffset = Rasterizer.topY - y;
        newHeight -= yOffset;
        y = Rasterizer.topY;
        pixel += yOffset * newWidth;
        rasterizerPixel += yOffset * Rasterizer.width;
      }
      if (y + newHeight > Rasterizer.bottomY) {
        newHeight -= y + newHeight - Rasterizer.bottomY;
      }
      if (x2 < Rasterizer.topX) {
        const xOffset = Rasterizer.topX - x2;
        newWidth -= xOffset;
        x2 = Rasterizer.topX;
        pixel += xOffset;
        rasterizerPixel += xOffset;
        pixelOffset += xOffset;
        rasterizerPixelOffset += xOffset;
      }
      if (x2 + newWidth > Rasterizer.bottomX) {
        const xOffset = x2 + newWidth - Rasterizer.bottomX;
        newWidth -= xOffset;
        pixelOffset += xOffset;
        rasterizerPixelOffset += xOffset;
      }
      if (newWidth > 0 && newHeight > 0) {
        this.copyPixelsAlpha(
          this.pixels,
          Rasterizer.pixels,
          pixel,
          rasterizerPixel,
          pixelOffset,
          rasterizerPixelOffset,
          newWidth,
          newHeight,
          0,
          alpha
        );
      }
    }
    copyPixelsAlpha(pixels, rasterizerPixels, pixel, rasterizerPixel, pixelOffset, rasterizerPixelOffset, width, height, color, alpha) {
      const alphaValue = 256 - alpha;
      for (let heightCounter = -height; heightCounter < 0; heightCounter++) {
        {
          for (let widthCounter = -width; widthCounter < 0; widthCounter++) {
            {
              color = pixels[pixel++];
              if (color !== 0) {
                const rasterizerPixelColor = rasterizerPixels[rasterizerPixel];
                rasterizerPixels[rasterizerPixel++] = ((color & 16711935) * alpha + (rasterizerPixelColor & 16711935) * alphaValue & -16711936) + ((color & 65280) * alpha + (rasterizerPixelColor & 65280) * alphaValue & 16711680) >> 8;
              } else {
                rasterizerPixel++;
              }
            }
          }
          rasterizerPixel += rasterizerPixelOffset;
          pixel += pixelOffset;
        }
      }
    }
    shapeImageToPixels$int$int$int$int$int_A$int$int$int$int_A$int(i, k, l, i1, ai, j1, k1, l1, ai1, i2) {
      try {
        const j2 = -i1 / 2 | 0;
        const k2 = -k / 2 | 0;
        let l2 = Math.sin(k1 / 326.11) * 65536 | 0;
        let i3 = Math.cos(k1 / 326.11) * 65536 | 0;
        l2 = l2 * l1 >> 8;
        i3 = i3 * l1 >> 8;
        let j3 = (l << 16) + (k2 * l2 + j2 * i3);
        let k3 = (i2 << 16) + (k2 * i3 - j2 * l2);
        let l3 = j1 + i * Rasterizer.width;
        for (i = 0; i < k; i++) {
          {
            const i4 = ai1[i];
            let j4 = l3 + i4;
            let k4 = j3 + i3 * i4;
            let l4 = k3 - l2 * i4;
            for (j1 = -ai[i]; j1 < 0; j1++) {
              {
                Rasterizer.pixels[j4++] = this.pixels[(k4 >> 16) + (l4 >> 16) * this.width];
                k4 += i3;
                l4 -= l2;
              }
            }
            j3 += l2;
            k3 += i3;
            l3 += Rasterizer.width;
          }
        }
        return;
      } catch (_ex) {
        return;
      }
    }
    shapeImageToPixels(i, k, l, i1, ai, j1, k1, l1, ai1, i2) {
      if ((typeof i === "number" || i === null) && (typeof k === "number" || k === null) && (typeof l === "number" || l === null) && (typeof i1 === "number" || i1 === null) && (ai != null && ai instanceof Array && (ai.length == 0 || ai[0] == null || typeof ai[0] === "number") || ai === null) && (typeof j1 === "number" || j1 === null) && (typeof k1 === "number" || k1 === null) && (typeof l1 === "number" || l1 === null) && (ai1 != null && ai1 instanceof Array && (ai1.length == 0 || ai1[0] == null || typeof ai1[0] === "number") || ai1 === null) && (typeof i2 === "number" || i2 === null)) {
        return this.shapeImageToPixels$int$int$int$int$int_A$int$int$int$int_A$int(i, k, l, i1, ai, j1, k1, l1, ai1, i2);
      } else if ((i != null && i instanceof Array && (i.length == 0 || i[0] == null || typeof i[0] === "number") || i === null) && (k != null && k instanceof Array && (k.length == 0 || k[0] == null || typeof k[0] === "number") || k === null) && (typeof l === "number" || l === null) && (typeof i1 === "number" || i1 === null) && (typeof ai === "number" || ai === null) && (typeof j1 === "number" || j1 === null) && (typeof k1 === "number" || k1 === null) && (typeof l1 === "number" || l1 === null) && (typeof ai1 === "number" || ai1 === null) && i2 === void 0) {
        return this.shapeImageToPixels$int_A$int_A$int$int$int$int$int$int$int(i, k, l, i1, ai, j1, k1, l1, ai1);
      } else {
        throw new Error("invalid overload");
      }
    }
    method466(i, j, k, l, i1, j1, k1, d, l1) {
      if (j1 !== -30658) {
        return;
      }
      try {
        const i2 = -k1 / 2 | 0;
        const j2 = -i1 / 2 | 0;
        let k2 = Math.sin(d) * 65536 | 0;
        let l2 = Math.cos(d) * 65536 | 0;
        k2 = k2 * i >> 8;
        l2 = l2 * i >> 8;
        let i3 = (j << 16) + (j2 * k2 + i2 * l2);
        let j3 = (l << 16) + (j2 * l2 - i2 * k2);
        let k3 = k + l1 * Rasterizer.width;
        for (l1 = 0; l1 < i1; l1++) {
          {
            let l3 = k3;
            let i4 = i3;
            let j4 = j3;
            for (k = -k1; k < 0; k++) {
              {
                const k4 = this.pixels[(i4 >> 16) + (j4 >> 16) * this.width];
                if (k4 !== 0) {
                  Rasterizer.pixels[l3++] = k4;
                } else {
                  l3++;
                }
                i4 += l2;
                j4 -= k2;
              }
            }
            i3 += k2;
            j3 += l2;
            k3 += Rasterizer.width;
          }
        }
        return;
      } catch (_ex) {
        return;
      }
    }
    method467(class50_sub1_sub1_sub3, i, j, k) {
      if (j !== -49993) {
        return;
      }
      k += this.offsetX;
      i += this.offsetY;
      let l = k + i * Rasterizer.width;
      let i1 = 0;
      let j1 = this.height;
      let k1 = this.width;
      let l1 = Rasterizer.width - k1;
      let i2 = 0;
      if (i < Rasterizer.topY) {
        const j2 = Rasterizer.topY - i;
        j1 -= j2;
        i = Rasterizer.topY;
        i1 += j2 * k1;
        l += j2 * Rasterizer.width;
      }
      if (i + j1 > Rasterizer.bottomY) {
        j1 -= i + j1 - Rasterizer.bottomY;
      }
      if (k < Rasterizer.topX) {
        const k2 = Rasterizer.topX - k;
        k1 -= k2;
        k = Rasterizer.topX;
        i1 += k2;
        l += k2;
        i2 += k2;
        l1 += k2;
      }
      if (k + k1 > Rasterizer.bottomX) {
        const l2 = k + k1 - Rasterizer.bottomX;
        k1 -= l2;
        i2 += l2;
        l1 += l2;
      }
      if (k1 <= 0 || j1 <= 0) {
        return;
      } else {
        this.method468(l, l1, this.pixels, k1, Rasterizer.pixels, class50_sub1_sub1_sub3.pixels, 40303, j1, i1, 0, i2);
        return;
      }
    }
    method468(i, j, ai, k, ai1, abyte0, l, i1, j1, k1, l1) {
      const i2 = -(k >> 2);
      k = -(k & 3);
      for (let j2 = -i1; j2 < 0; j2++) {
        {
          for (let k2 = i2; k2 < 0; k2++) {
            {
              k1 = ai[j1++];
              if (k1 !== 0 && abyte0[i] === 0) {
                ai1[i++] = k1;
              } else {
                i++;
              }
              k1 = ai[j1++];
              if (k1 !== 0 && abyte0[i] === 0) {
                ai1[i++] = k1;
              } else {
                i++;
              }
              k1 = ai[j1++];
              if (k1 !== 0 && abyte0[i] === 0) {
                ai1[i++] = k1;
              } else {
                i++;
              }
              k1 = ai[j1++];
              if (k1 !== 0 && abyte0[i] === 0) {
                ai1[i++] = k1;
              } else {
                i++;
              }
            }
          }
          for (let l2 = k; l2 < 0; l2++) {
            {
              k1 = ai[j1++];
              if (k1 !== 0 && abyte0[i] === 0) {
                ai1[i++] = k1;
              } else {
                i++;
              }
            }
          }
          i += j;
          j1 += l1;
        }
      }
    }
  };

  // osrs/cache/media/IndexedImage.ts
  init_inject();
  var IndexedImage = class extends Rasterizer {
    constructor(archive, archiveName, offset) {
      super();
      if (this.pixels === void 0) {
        this.pixels = null;
      }
      if (this.palette === void 0) {
        this.palette = null;
      }
      if (this.width === void 0) {
        this.width = 0;
      }
      if (this.height === void 0) {
        this.height = 0;
      }
      if (this.xDrawOffset === void 0) {
        this.xDrawOffset = 0;
      }
      if (this.yDrawOffset === void 0) {
        this.yDrawOffset = 0;
      }
      if (this.maxWidth === void 0) {
        this.maxWidth = 0;
      }
      if (this.maxHeight === void 0) {
        this.maxHeight = 0;
      }
      const dataBuffer = new Buffer3(archive.getFile(archiveName + ".dat"));
      const indexBuffer = new Buffer3(archive.getFile("index.dat"));
      indexBuffer.currentPosition = dataBuffer.getUnsignedLEShort();
      this.maxWidth = indexBuffer.getUnsignedLEShort();
      this.maxHeight = indexBuffer.getUnsignedLEShort();
      const palleteLength = indexBuffer.getUnsignedByte();
      this.palette = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(palleteLength);
      for (let index = 0; index < palleteLength - 1; index++) {
        this.palette[index + 1] = indexBuffer.get24BitInt();
      }
      for (let counter = 0; counter < offset; counter++) {
        {
          indexBuffer.currentPosition += 2;
          dataBuffer.currentPosition += indexBuffer.getUnsignedLEShort() * indexBuffer.getUnsignedLEShort();
          indexBuffer.currentPosition++;
        }
      }
      this.xDrawOffset = indexBuffer.getUnsignedByte();
      this.yDrawOffset = indexBuffer.getUnsignedByte();
      this.width = indexBuffer.getUnsignedLEShort();
      this.height = indexBuffer.getUnsignedLEShort();
      const type = indexBuffer.getUnsignedByte();
      const pixelLength = this.width * this.height;
      this.pixels = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(pixelLength);
      if (type === 0) {
        for (let pixel = 0; pixel < pixelLength; pixel++) {
          this.pixels[pixel] = dataBuffer.getSignedByte();
        }
        return;
      }
      if (type === 1) {
        for (let x2 = 0; x2 < this.width; x2++) {
          {
            for (let y = 0; y < this.height; y++) {
              this.pixels[x2 + y * this.width] = dataBuffer.getSignedByte();
            }
          }
        }
      }
    }
    resizeToHalfMax() {
      this.maxWidth = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.maxWidth / 2);
      this.maxHeight = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.maxHeight / 2);
      const resizedPixels = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.maxWidth * this.maxHeight);
      let pixelCount = 0;
      for (let y = 0; y < this.height; y++) {
        {
          for (let x2 = 0; x2 < this.width; x2++) {
            resizedPixels[(x2 + this.xDrawOffset >> 1) + (y + this.yDrawOffset >> 1) * this.maxWidth] = this.pixels[pixelCount++];
          }
        }
      }
      this.pixels = resizedPixels;
      this.width = this.maxWidth;
      this.height = this.maxHeight;
      this.xDrawOffset = 0;
      this.yDrawOffset = 0;
    }
    resizeToMax() {
      if (this.width !== this.maxWidth || this.height !== this.maxHeight) {
        const resizedPixels = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(this.maxWidth * this.maxHeight);
        let pixelCount = 0;
        for (let y = 0; y < this.height; y++) {
          {
            for (let x2 = 0; x2 < this.width; x2++) {
              resizedPixels[x2 + this.xDrawOffset + (y + this.yDrawOffset) * this.maxWidth] = this.pixels[pixelCount++];
            }
          }
        }
        this.pixels = resizedPixels;
        this.width = this.maxWidth;
        this.height = this.maxHeight;
        this.xDrawOffset = 0;
        this.yDrawOffset = 0;
      }
    }
    flipHorizontal() {
      const flipedPixels = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.width * this.height);
      let pixelCount = 0;
      for (let y = 0; y < this.height; y++) {
        {
          for (let x2 = this.width - 1; x2 >= 0; x2--) {
            flipedPixels[pixelCount++] = this.pixels[x2 + y * this.width];
          }
        }
      }
      this.pixels = flipedPixels;
      this.xDrawOffset = this.maxWidth - this.width - this.xDrawOffset;
    }
    flipVertical() {
      const flipedPixels = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.width * this.height);
      let pixelCount = 0;
      for (let y = this.height - 1; y >= 0; y--) {
        {
          for (let x2 = 0; x2 < this.width; x2++) {
            flipedPixels[pixelCount++] = this.pixels[x2 + y * this.width];
          }
        }
      }
      this.pixels = flipedPixels;
      this.yDrawOffset = this.maxHeight - this.height - this.yDrawOffset;
    }
    mixPalette(red, green, blue) {
      for (let index = 0; index < this.palette.length; index++) {
        {
          let r2 = this.palette[index] >> 16 & 255;
          r2 += red;
          if (r2 < 0) {
            r2 = 0;
          } else if (r2 > 255) {
            r2 = 255;
          }
          let g = this.palette[index] >> 8 & 255;
          g += green;
          if (g < 0) {
            g = 0;
          } else if (g > 255) {
            g = 255;
          }
          let b = this.palette[index] & 255;
          b += blue;
          if (b < 0) {
            b = 0;
          } else if (b > 255) {
            b = 255;
          }
          this.palette[index] = (r2 << 16) + (g << 8) + b;
        }
      }
    }
    drawImage(x2, y) {
      x2 += this.xDrawOffset;
      y += this.yDrawOffset;
      let offset = x2 + y * Rasterizer.width;
      let originalOffset = 0;
      let imageHeight = this.height;
      let imageWidth = this.width;
      let deviation = Rasterizer.width - imageWidth;
      let originalDeviation = 0;
      if (y < Rasterizer.topY) {
        const yOffset = Rasterizer.topY - y;
        imageHeight -= yOffset;
        y = Rasterizer.topY;
        originalOffset += yOffset * imageWidth;
        offset += yOffset * Rasterizer.width;
      }
      if (y + imageHeight > Rasterizer.bottomY) {
        imageHeight -= y + imageHeight - Rasterizer.bottomY;
      }
      if (x2 < Rasterizer.topX) {
        const xOffset = Rasterizer.topX - x2;
        imageWidth -= xOffset;
        x2 = Rasterizer.topX;
        originalOffset += xOffset;
        offset += xOffset;
        originalDeviation += xOffset;
        deviation += xOffset;
      }
      if (x2 + imageWidth > Rasterizer.bottomX) {
        const xOffset = x2 + imageWidth - Rasterizer.bottomX;
        imageWidth -= xOffset;
        originalDeviation += xOffset;
        deviation += xOffset;
      }
      if (imageWidth > 0 && imageHeight > 0) {
        this.copyPixels(this.pixels, Rasterizer.pixels, imageWidth, imageHeight, offset, originalOffset, deviation, originalDeviation, this.palette);
      }
    }
    copyPixels(pixels, rasterizerPixels, width, height, offset, originalOffset, deviation, originalDeviation, pallete) {
      const shiftedWidth = -(width >> 2);
      width = -(width & 3);
      for (let heightCounter = -height; heightCounter < 0; heightCounter++) {
        {
          for (let shiftedWidthCounter = shiftedWidth; shiftedWidthCounter < 0; shiftedWidthCounter++) {
            {
              let pixel = pixels[originalOffset++];
              if (pixel !== 0) {
                rasterizerPixels[offset++] = pallete[pixel & 255];
              } else {
                offset++;
              }
              pixel = pixels[originalOffset++];
              if (pixel !== 0) {
                rasterizerPixels[offset++] = pallete[pixel & 255];
              } else {
                offset++;
              }
              pixel = pixels[originalOffset++];
              if (pixel !== 0) {
                rasterizerPixels[offset++] = pallete[pixel & 255];
              } else {
                offset++;
              }
              pixel = pixels[originalOffset++];
              if (pixel !== 0) {
                rasterizerPixels[offset++] = pallete[pixel & 255];
              } else {
                offset++;
              }
            }
          }
          for (let widthCounter = width; widthCounter < 0; widthCounter++) {
            {
              const pixel = pixels[originalOffset++];
              if (pixel !== 0) {
                rasterizerPixels[offset++] = pallete[pixel & 255];
              } else {
                offset++;
              }
            }
          }
          offset += deviation;
          originalOffset += originalDeviation;
        }
      }
    }
  };

  // osrs/scene/Scene.ts
  init_inject();

  // osrs/media/Rasterizer3D.ts
  init_inject();
  function staticInitialize() {
    for (let i = 1; i < 512; i++) {
      Rasterizer3D.anIntArray1534[i] = 32768 / i | 0;
    }
    for (let j = 1; j < 2048; j++) {
      Rasterizer3D.anIntArray1535[j] = 65536 / j | 0;
    }
    for (let k = 0; k < 2048; k++) {
      Rasterizer3D.SINE[k] = 65536 * Math.sin(k * 0.0030679615) | 0;
      Rasterizer3D.COSINE[k] = 65536 * Math.cos(k * 0.0030679615) | 0;
    }
  }
  var _Rasterizer3D = class extends Rasterizer {
    static reset() {
      _Rasterizer3D.anIntArray1534 = null;
      _Rasterizer3D.anIntArray1534 = null;
      _Rasterizer3D.SINE = null;
      _Rasterizer3D.COSINE = null;
      _Rasterizer3D.lineOffsets = null;
      _Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540 = null;
      _Rasterizer3D.aBooleanArray1541 = null;
      _Rasterizer3D.anIntArray1542 = null;
      _Rasterizer3D.anIntArrayArray1544 = null;
      _Rasterizer3D.anIntArrayArray1545 = null;
      _Rasterizer3D.anIntArray1546 = null;
      _Rasterizer3D.getRgbLookupTableId = null;
      _Rasterizer3D.anIntArrayArray1549 = null;
    }
    static setDefaultBoundaries() {
      _Rasterizer3D.lineOffsets = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(Rasterizer.height);
      for (let lineOffset = 0; lineOffset < Rasterizer.height; lineOffset++) {
        _Rasterizer3D.lineOffsets[lineOffset] = Rasterizer.width * lineOffset;
      }
      _Rasterizer3D.centerX = Rasterizer.width / 2 | 0;
      _Rasterizer3D.centerY = Rasterizer.height / 2 | 0;
    }
    static method494(width, height) {
      _Rasterizer3D.lineOffsets = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(height);
      for (let lineOffset = 0; lineOffset < height; lineOffset++) {
        _Rasterizer3D.lineOffsets[lineOffset] = width * lineOffset;
      }
      _Rasterizer3D.centerX = width / 2 | 0;
      _Rasterizer3D.centerY = height / 2 | 0;
    }
    static method495(byte0) {
      if (byte0 !== 71) {
        return;
      }
      _Rasterizer3D.anIntArrayArray1544 = null;
      for (let i = 0; i < 50; i++) {
        _Rasterizer3D.anIntArrayArray1545[i] = null;
      }
    }
    static method496(i) {
      if (_Rasterizer3D.anIntArrayArray1544 == null) {
        _Rasterizer3D.anInt1543 = i;
        if (_Rasterizer3D.lowMemory) {
          _Rasterizer3D.anIntArrayArray1544 = function(dims) {
            const allocate = function(dims2) {
              if (dims2.length == 0) {
                return 0;
              } else {
                const array = [];
                for (let i2 = 0; i2 < dims2[0]; i2++) {
                  array.push(allocate(dims2.slice(1)));
                }
                return array;
              }
            };
            return allocate(dims);
          }([_Rasterizer3D.anInt1543, 16384]);
        } else {
          _Rasterizer3D.anIntArrayArray1544 = function(dims) {
            const allocate = function(dims2) {
              if (dims2.length == 0) {
                return 0;
              } else {
                const array = [];
                for (let i2 = 0; i2 < dims2[0]; i2++) {
                  array.push(allocate(dims2.slice(1)));
                }
                return array;
              }
            };
            return allocate(dims);
          }([_Rasterizer3D.anInt1543, 65536]);
        }
        for (let k = 0; k < 50; k++) {
          _Rasterizer3D.anIntArrayArray1545[k] = null;
        }
      }
    }
    static loadIndexedImages(class2) {
      _Rasterizer3D.anInt1539 = 0;
      for (let k = 0; k < 50; k++) {
        try {
          _Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540[k] = new IndexedImage(class2, new String(k).toString(), 0);
          if (_Rasterizer3D.lowMemory && _Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540[k].maxWidth === 128) {
            _Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540[k].resizeToHalfMax();
          } else {
            _Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540[k].resizeToMax();
          }
          _Rasterizer3D.anInt1539;
          _Rasterizer3D.anInt1539++;
        } catch (_ex) {
        }
      }
    }
    static getAverageRgbColorForTexture(i, j) {
      if (_Rasterizer3D.anIntArray1542[i] !== 0) {
        return _Rasterizer3D.anIntArray1542[i];
      }
      let k = 0;
      let l = 0;
      let i1 = 0;
      const j1 = _Rasterizer3D.anIntArrayArray1549[i].length;
      for (let k1 = 0; k1 < j1; k1++) {
        {
          k += _Rasterizer3D.anIntArrayArray1549[i][k1] >> 16 & 255;
          l += _Rasterizer3D.anIntArrayArray1549[i][k1] >> 8 & 255;
          i1 += _Rasterizer3D.anIntArrayArray1549[i][k1] & 255;
        }
      }
      if (j !== 0) {
        return _Rasterizer3D.anInt1525;
      }
      let l1 = ((k / j1 | 0) << 16) + ((l / j1 | 0) << 8) + (i1 / j1 | 0);
      l1 = _Rasterizer3D.method502(l1, 1.4);
      if (l1 === 0) {
        l1 = 1;
      }
      _Rasterizer3D.anIntArray1542[i] = l1;
      return l1;
    }
    static method499(i, j) {
      if (j !== 9) {
        _Rasterizer3D.anInt1524 = -48;
      }
      if (_Rasterizer3D.anIntArrayArray1545[i] == null) {
        return;
      } else {
        _Rasterizer3D.anInt1543;
        _Rasterizer3D.anIntArrayArray1544[_Rasterizer3D.anInt1543++] = _Rasterizer3D.anIntArrayArray1545[i];
        _Rasterizer3D.anIntArrayArray1545[i] = null;
        return;
      }
    }
    static method500(i) {
      _Rasterizer3D.anInt1547;
      _Rasterizer3D.anIntArray1546[i] = _Rasterizer3D.anInt1547++;
      if (_Rasterizer3D.anIntArrayArray1545[i] != null) {
        return _Rasterizer3D.anIntArrayArray1545[i];
      }
      let ai;
      if (_Rasterizer3D.anInt1543 > 0) {
        _Rasterizer3D.anInt1543;
        ai = _Rasterizer3D.anIntArrayArray1544[--_Rasterizer3D.anInt1543];
        _Rasterizer3D.anIntArrayArray1544[_Rasterizer3D.anInt1543] = null;
      } else {
        let j = 0;
        let k = -1;
        for (let l = 0; l < _Rasterizer3D.anInt1539; l++) {
          if (_Rasterizer3D.anIntArrayArray1545[l] != null && (_Rasterizer3D.anIntArray1546[l] < j || k === -1)) {
            j = _Rasterizer3D.anIntArray1546[l];
            k = l;
          }
        }
        ai = _Rasterizer3D.anIntArrayArray1545[k];
        _Rasterizer3D.anIntArrayArray1545[k] = null;
      }
      _Rasterizer3D.anIntArrayArray1545[i] = ai;
      const class50_sub1_sub1_sub3 = _Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540[i];
      const ai1 = _Rasterizer3D.anIntArrayArray1549[i];
      if (_Rasterizer3D.lowMemory) {
        _Rasterizer3D.aBooleanArray1541[i] = false;
        for (let i1 = 0; i1 < 4096; i1++) {
          {
            const i2 = ai[i1] = ai1[class50_sub1_sub1_sub3.pixels[i1]] & 16316671;
            if (i2 === 0) {
              _Rasterizer3D.aBooleanArray1541[i] = true;
            }
            ai[4096 + i1] = i2 - (i2 >>> 3) & 16316671;
            ai[8192 + i1] = i2 - (i2 >>> 2) & 16316671;
            ai[12288 + i1] = i2 - (i2 >>> 2) - (i2 >>> 3) & 16316671;
          }
        }
      } else {
        if (class50_sub1_sub1_sub3.width === 64) {
          for (let j1 = 0; j1 < 128; j1++) {
            {
              for (let j2 = 0; j2 < 128; j2++) {
                ai[j2 + (j1 << 7)] = ai1[class50_sub1_sub1_sub3.pixels[(j2 >> 1) + (j1 >> 1 << 6)]];
              }
            }
          }
        } else {
          for (let k1 = 0; k1 < 16384; k1++) {
            ai[k1] = ai1[class50_sub1_sub1_sub3.pixels[k1]];
          }
        }
        _Rasterizer3D.aBooleanArray1541[i] = false;
        for (let l1 = 0; l1 < 16384; l1++) {
          {
            ai[l1] &= 16316671;
            const k2 = ai[l1];
            if (k2 === 0) {
              _Rasterizer3D.aBooleanArray1541[i] = true;
            }
            ai[16384 + l1] = k2 - (k2 >>> 3) & 16316671;
            ai[32768 + l1] = k2 - (k2 >>> 2) & 16316671;
            ai[49152 + l1] = k2 - (k2 >>> 2) - (k2 >>> 3) & 16316671;
          }
        }
      }
      return ai;
    }
    static method501(d) {
      d += Math.random() * 0.03 - 0.015;
      let i = 0;
      for (let j = 0; j < 512; j++) {
        {
          const d1 = (j / 8 | 0) / 64 + 78125e-7;
          const d2 = (j & 7) / 8 + 0.0625;
          for (let j1 = 0; j1 < 128; j1++) {
            {
              const d3 = j1 / 128;
              let d4 = d3;
              let d5 = d3;
              let d6 = d3;
              if (d2 !== 0) {
                let d7;
                if (d3 < 0.5) {
                  d7 = d3 * (1 + d2);
                } else {
                  d7 = d3 + d2 - d3 * d2;
                }
                const d8 = 2 * d3 - d7;
                let d9 = d1 + 0.3333333333333333;
                if (d9 > 1) {
                  d9--;
                }
                const d10 = d1;
                let d11 = d1 - 0.3333333333333333;
                if (d11 < 0) {
                  d11++;
                }
                if (6 * d9 < 1) {
                  d4 = d8 + (d7 - d8) * 6 * d9;
                } else if (2 * d9 < 1) {
                  d4 = d7;
                } else if (3 * d9 < 2) {
                  d4 = d8 + (d7 - d8) * (0.6666666666666666 - d9) * 6;
                } else {
                  d4 = d8;
                }
                if (6 * d10 < 1) {
                  d5 = d8 + (d7 - d8) * 6 * d10;
                } else if (2 * d10 < 1) {
                  d5 = d7;
                } else if (3 * d10 < 2) {
                  d5 = d8 + (d7 - d8) * (0.6666666666666666 - d10) * 6;
                } else {
                  d5 = d8;
                }
                if (6 * d11 < 1) {
                  d6 = d8 + (d7 - d8) * 6 * d11;
                } else if (2 * d11 < 1) {
                  d6 = d7;
                } else if (3 * d11 < 2) {
                  d6 = d8 + (d7 - d8) * (0.6666666666666666 - d11) * 6;
                } else {
                  d6 = d8;
                }
              }
              const k1 = d4 * 256 | 0;
              const l1 = d5 * 256 | 0;
              const i2 = d6 * 256 | 0;
              let j2 = (k1 << 16) + (l1 << 8) + i2;
              j2 = _Rasterizer3D.method502(j2, d);
              if (j2 === 0) {
                j2 = 1;
              }
              _Rasterizer3D.getRgbLookupTableId[i++] = j2;
            }
          }
        }
      }
      for (let k = 0; k < 50; k++) {
        if (_Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540[k] != null) {
          const ai = _Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540[k].palette;
          _Rasterizer3D.anIntArrayArray1549[k] = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(ai.length);
          for (let i1 = 0; i1 < ai.length; i1++) {
            {
              _Rasterizer3D.anIntArrayArray1549[k][i1] = _Rasterizer3D.method502(ai[i1], d);
              if ((_Rasterizer3D.anIntArrayArray1549[k][i1] & 16316671) === 0 && i1 !== 0) {
                _Rasterizer3D.anIntArrayArray1549[k][i1] = 1;
              }
            }
          }
        }
      }
      for (let l = 0; l < 50; l++) {
        _Rasterizer3D.method499(l, 9);
      }
    }
    static method502(i, d) {
      let d1 = (i >> 16) / 256;
      let d2 = (i >> 8 & 255) / 256;
      let d3 = (i & 255) / 256;
      d1 = Math.pow(d1, d);
      d2 = Math.pow(d2, d);
      d3 = Math.pow(d3, d);
      const j = d1 * 256 | 0;
      const k = d2 * 256 | 0;
      const l = d3 * 256 | 0;
      return (j << 16) + (k << 8) + l;
    }
    static method503(i, j, k, l, i1, j1, k1, l1, i2) {
      let j2 = 0;
      let k2 = 0;
      if (j !== i) {
        j2 = (i1 - l << 16) / (j - i) | 0;
        k2 = (l1 - k1 << 15) / (j - i) | 0;
      }
      let l2 = 0;
      let i3 = 0;
      if (k !== j) {
        l2 = (j1 - i1 << 16) / (k - j) | 0;
        i3 = (i2 - l1 << 15) / (k - j) | 0;
      }
      let j3 = 0;
      let k3 = 0;
      if (k !== i) {
        j3 = (l - j1 << 16) / (i - k) | 0;
        k3 = (k1 - i2 << 15) / (i - k) | 0;
      }
      if (i <= j && i <= k) {
        if (i >= Rasterizer.bottomY) {
          return;
        }
        if (j > Rasterizer.bottomY) {
          j = Rasterizer.bottomY;
        }
        if (k > Rasterizer.bottomY) {
          k = Rasterizer.bottomY;
        }
        if (j < k) {
          j1 = l <<= 16;
          i2 = k1 <<= 15;
          if (i < 0) {
            j1 -= j3 * i;
            l -= j2 * i;
            i2 -= k3 * i;
            k1 -= k2 * i;
            i = 0;
          }
          i1 <<= 16;
          l1 <<= 15;
          if (j < 0) {
            i1 -= l2 * j;
            l1 -= i3 * j;
            j = 0;
          }
          if (i !== j && j3 < j2 || i === j && j3 > l2) {
            k -= j;
            j -= i;
            for (i = _Rasterizer3D.lineOffsets[i]; --j >= 0; i += Rasterizer.width) {
              {
                _Rasterizer3D.method504(Rasterizer.pixels, i, 0, 0, j1 >> 16, l >> 16, i2 >> 7, k1 >> 7);
                j1 += j3;
                l += j2;
                i2 += k3;
                k1 += k2;
              }
            }
            while (--k >= 0) {
              {
                _Rasterizer3D.method504(Rasterizer.pixels, i, 0, 0, j1 >> 16, i1 >> 16, i2 >> 7, l1 >> 7);
                j1 += j3;
                i1 += l2;
                i2 += k3;
                l1 += i3;
                i += Rasterizer.width;
              }
            }
            return;
          }
          k -= j;
          j -= i;
          for (i = _Rasterizer3D.lineOffsets[i]; --j >= 0; i += Rasterizer.width) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, i, 0, 0, l >> 16, j1 >> 16, k1 >> 7, i2 >> 7);
              j1 += j3;
              l += j2;
              i2 += k3;
              k1 += k2;
            }
          }
          while (--k >= 0) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, i, 0, 0, i1 >> 16, j1 >> 16, l1 >> 7, i2 >> 7);
              j1 += j3;
              i1 += l2;
              i2 += k3;
              l1 += i3;
              i += Rasterizer.width;
            }
          }
          return;
        }
        i1 = l <<= 16;
        l1 = k1 <<= 15;
        if (i < 0) {
          i1 -= j3 * i;
          l -= j2 * i;
          l1 -= k3 * i;
          k1 -= k2 * i;
          i = 0;
        }
        j1 <<= 16;
        i2 <<= 15;
        if (k < 0) {
          j1 -= l2 * k;
          i2 -= i3 * k;
          k = 0;
        }
        if (i !== k && j3 < j2 || i === k && l2 > j2) {
          j -= k;
          k -= i;
          for (i = _Rasterizer3D.lineOffsets[i]; --k >= 0; i += Rasterizer.width) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, i, 0, 0, i1 >> 16, l >> 16, l1 >> 7, k1 >> 7);
              i1 += j3;
              l += j2;
              l1 += k3;
              k1 += k2;
            }
          }
          while (--j >= 0) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, i, 0, 0, j1 >> 16, l >> 16, i2 >> 7, k1 >> 7);
              j1 += l2;
              l += j2;
              i2 += i3;
              k1 += k2;
              i += Rasterizer.width;
            }
          }
          return;
        }
        j -= k;
        k -= i;
        for (i = _Rasterizer3D.lineOffsets[i]; --k >= 0; i += Rasterizer.width) {
          {
            _Rasterizer3D.method504(Rasterizer.pixels, i, 0, 0, l >> 16, i1 >> 16, k1 >> 7, l1 >> 7);
            i1 += j3;
            l += j2;
            l1 += k3;
            k1 += k2;
          }
        }
        while (--j >= 0) {
          {
            _Rasterizer3D.method504(Rasterizer.pixels, i, 0, 0, l >> 16, j1 >> 16, k1 >> 7, i2 >> 7);
            j1 += l2;
            l += j2;
            i2 += i3;
            k1 += k2;
            i += Rasterizer.width;
          }
        }
        return;
      }
      if (j <= k) {
        if (j >= Rasterizer.bottomY) {
          return;
        }
        if (k > Rasterizer.bottomY) {
          k = Rasterizer.bottomY;
        }
        if (i > Rasterizer.bottomY) {
          i = Rasterizer.bottomY;
        }
        if (k < i) {
          l = i1 <<= 16;
          k1 = l1 <<= 15;
          if (j < 0) {
            l -= j2 * j;
            i1 -= l2 * j;
            k1 -= k2 * j;
            l1 -= i3 * j;
            j = 0;
          }
          j1 <<= 16;
          i2 <<= 15;
          if (k < 0) {
            j1 -= j3 * k;
            i2 -= k3 * k;
            k = 0;
          }
          if (j !== k && j2 < l2 || j === k && j2 > j3) {
            i -= k;
            k -= j;
            for (j = _Rasterizer3D.lineOffsets[j]; --k >= 0; j += Rasterizer.width) {
              {
                _Rasterizer3D.method504(Rasterizer.pixels, j, 0, 0, l >> 16, i1 >> 16, k1 >> 7, l1 >> 7);
                l += j2;
                i1 += l2;
                k1 += k2;
                l1 += i3;
              }
            }
            while (--i >= 0) {
              {
                _Rasterizer3D.method504(Rasterizer.pixels, j, 0, 0, l >> 16, j1 >> 16, k1 >> 7, i2 >> 7);
                l += j2;
                j1 += j3;
                k1 += k2;
                i2 += k3;
                j += Rasterizer.width;
              }
            }
            return;
          }
          i -= k;
          k -= j;
          for (j = _Rasterizer3D.lineOffsets[j]; --k >= 0; j += Rasterizer.width) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, j, 0, 0, i1 >> 16, l >> 16, l1 >> 7, k1 >> 7);
              l += j2;
              i1 += l2;
              k1 += k2;
              l1 += i3;
            }
          }
          while (--i >= 0) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, j, 0, 0, j1 >> 16, l >> 16, i2 >> 7, k1 >> 7);
              l += j2;
              j1 += j3;
              k1 += k2;
              i2 += k3;
              j += Rasterizer.width;
            }
          }
          return;
        }
        j1 = i1 <<= 16;
        i2 = l1 <<= 15;
        if (j < 0) {
          j1 -= j2 * j;
          i1 -= l2 * j;
          i2 -= k2 * j;
          l1 -= i3 * j;
          j = 0;
        }
        l <<= 16;
        k1 <<= 15;
        if (i < 0) {
          l -= j3 * i;
          k1 -= k3 * i;
          i = 0;
        }
        if (j2 < l2) {
          k -= i;
          i -= j;
          for (j = _Rasterizer3D.lineOffsets[j]; --i >= 0; j += Rasterizer.width) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, j, 0, 0, j1 >> 16, i1 >> 16, i2 >> 7, l1 >> 7);
              j1 += j2;
              i1 += l2;
              i2 += k2;
              l1 += i3;
            }
          }
          while (--k >= 0) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, j, 0, 0, l >> 16, i1 >> 16, k1 >> 7, l1 >> 7);
              l += j3;
              i1 += l2;
              k1 += k3;
              l1 += i3;
              j += Rasterizer.width;
            }
          }
          return;
        }
        k -= i;
        i -= j;
        for (j = _Rasterizer3D.lineOffsets[j]; --i >= 0; j += Rasterizer.width) {
          {
            _Rasterizer3D.method504(Rasterizer.pixels, j, 0, 0, i1 >> 16, j1 >> 16, l1 >> 7, i2 >> 7);
            j1 += j2;
            i1 += l2;
            i2 += k2;
            l1 += i3;
          }
        }
        while (--k >= 0) {
          {
            _Rasterizer3D.method504(Rasterizer.pixels, j, 0, 0, i1 >> 16, l >> 16, l1 >> 7, k1 >> 7);
            l += j3;
            i1 += l2;
            k1 += k3;
            l1 += i3;
            j += Rasterizer.width;
          }
        }
        return;
      }
      if (k >= Rasterizer.bottomY) {
        return;
      }
      if (i > Rasterizer.bottomY) {
        i = Rasterizer.bottomY;
      }
      if (j > Rasterizer.bottomY) {
        j = Rasterizer.bottomY;
      }
      if (i < j) {
        i1 = j1 <<= 16;
        l1 = i2 <<= 15;
        if (k < 0) {
          i1 -= l2 * k;
          j1 -= j3 * k;
          l1 -= i3 * k;
          i2 -= k3 * k;
          k = 0;
        }
        l <<= 16;
        k1 <<= 15;
        if (i < 0) {
          l -= j2 * i;
          k1 -= k2 * i;
          i = 0;
        }
        if (l2 < j3) {
          j -= i;
          i -= k;
          for (k = _Rasterizer3D.lineOffsets[k]; --i >= 0; k += Rasterizer.width) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, k, 0, 0, i1 >> 16, j1 >> 16, l1 >> 7, i2 >> 7);
              i1 += l2;
              j1 += j3;
              l1 += i3;
              i2 += k3;
            }
          }
          while (--j >= 0) {
            {
              _Rasterizer3D.method504(Rasterizer.pixels, k, 0, 0, i1 >> 16, l >> 16, l1 >> 7, k1 >> 7);
              i1 += l2;
              l += j2;
              l1 += i3;
              k1 += k2;
              k += Rasterizer.width;
            }
          }
          return;
        }
        j -= i;
        i -= k;
        for (k = _Rasterizer3D.lineOffsets[k]; --i >= 0; k += Rasterizer.width) {
          {
            _Rasterizer3D.method504(Rasterizer.pixels, k, 0, 0, j1 >> 16, i1 >> 16, i2 >> 7, l1 >> 7);
            i1 += l2;
            j1 += j3;
            l1 += i3;
            i2 += k3;
          }
        }
        while (--j >= 0) {
          {
            _Rasterizer3D.method504(Rasterizer.pixels, k, 0, 0, l >> 16, i1 >> 16, k1 >> 7, l1 >> 7);
            i1 += l2;
            l += j2;
            l1 += i3;
            k1 += k2;
            k += Rasterizer.width;
          }
        }
        return;
      }
      l = j1 <<= 16;
      k1 = i2 <<= 15;
      if (k < 0) {
        l -= l2 * k;
        j1 -= j3 * k;
        k1 -= i3 * k;
        i2 -= k3 * k;
        k = 0;
      }
      i1 <<= 16;
      l1 <<= 15;
      if (j < 0) {
        i1 -= j2 * j;
        l1 -= k2 * j;
        j = 0;
      }
      if (l2 < j3) {
        i -= j;
        j -= k;
        for (k = _Rasterizer3D.lineOffsets[k]; --j >= 0; k += Rasterizer.width) {
          {
            _Rasterizer3D.method504(Rasterizer.pixels, k, 0, 0, l >> 16, j1 >> 16, k1 >> 7, i2 >> 7);
            l += l2;
            j1 += j3;
            k1 += i3;
            i2 += k3;
          }
        }
        while (--i >= 0) {
          {
            _Rasterizer3D.method504(Rasterizer.pixels, k, 0, 0, i1 >> 16, j1 >> 16, l1 >> 7, i2 >> 7);
            i1 += j2;
            j1 += j3;
            l1 += k2;
            i2 += k3;
            k += Rasterizer.width;
          }
        }
        return;
      }
      i -= j;
      j -= k;
      for (k = _Rasterizer3D.lineOffsets[k]; --j >= 0; k += Rasterizer.width) {
        {
          _Rasterizer3D.method504(Rasterizer.pixels, k, 0, 0, j1 >> 16, l >> 16, i2 >> 7, k1 >> 7);
          l += l2;
          j1 += j3;
          k1 += i3;
          i2 += k3;
        }
      }
      while (--i >= 0) {
        {
          _Rasterizer3D.method504(Rasterizer.pixels, k, 0, 0, j1 >> 16, i1 >> 16, i2 >> 7, l1 >> 7);
          i1 += j2;
          j1 += j3;
          l1 += k2;
          i2 += k3;
          k += Rasterizer.width;
        }
      }
    }
    static method504(pixels, i, j, k, l, i1, j1, k1) {
      if (_Rasterizer3D.approximateAlphaBlending) {
        let l1;
        if (_Rasterizer3D.aBoolean1528) {
          if (i1 - l > 3) {
            l1 = (k1 - j1) / (i1 - l) | 0;
          } else {
            l1 = 0;
          }
          if (i1 > Rasterizer.virtualBottomX) {
            i1 = Rasterizer.virtualBottomX;
          }
          if (l < 0) {
            j1 -= l * l1;
            l = 0;
          }
          if (l >= i1) {
            return;
          }
          i += l;
          k = i1 - l >> 2;
          l1 <<= 2;
        } else {
          if (l >= i1) {
            return;
          }
          i += l;
          k = i1 - l >> 2;
          if (k > 0) {
            l1 = (k1 - j1) * _Rasterizer3D.anIntArray1534[k] >> 15;
          } else {
            l1 = 0;
          }
        }
        if (_Rasterizer3D.anInt1531 === 0) {
          while (--k >= 0) {
            {
              j = _Rasterizer3D.getRgbLookupTableId[j1 >> 8];
              j1 += l1;
              pixels[i++] = j;
              pixels[i++] = j;
              pixels[i++] = j;
              pixels[i++] = j;
            }
          }
          k = i1 - l & 3;
          if (k > 0) {
            j = _Rasterizer3D.getRgbLookupTableId[j1 >> 8];
            do {
              pixels[i++] = j;
            } while (--k > 0);
            return;
          }
        } else {
          const j2 = _Rasterizer3D.anInt1531;
          const l2 = 256 - _Rasterizer3D.anInt1531;
          while (--k >= 0) {
            {
              j = _Rasterizer3D.getRgbLookupTableId[j1 >> 8];
              j1 += l1;
              j = ((j & 16711935) * l2 >> 8 & 16711935) + ((j & 65280) * l2 >> 8 & 65280);
              pixels[i++] = j + ((pixels[i] & 16711935) * j2 >> 8 & 16711935) + ((pixels[i] & 65280) * j2 >> 8 & 65280);
              pixels[i++] = j + ((pixels[i] & 16711935) * j2 >> 8 & 16711935) + ((pixels[i] & 65280) * j2 >> 8 & 65280);
              pixels[i++] = j + ((pixels[i] & 16711935) * j2 >> 8 & 16711935) + ((pixels[i] & 65280) * j2 >> 8 & 65280);
              pixels[i++] = j + ((pixels[i] & 16711935) * j2 >> 8 & 16711935) + ((pixels[i] & 65280) * j2 >> 8 & 65280);
            }
          }
          k = i1 - l & 3;
          if (k > 0) {
            j = _Rasterizer3D.getRgbLookupTableId[j1 >> 8];
            j = ((j & 16711935) * l2 >> 8 & 16711935) + ((j & 65280) * l2 >> 8 & 65280);
            do {
              pixels[i++] = j + ((pixels[i] & 16711935) * j2 >> 8 & 16711935) + ((pixels[i] & 65280) * j2 >> 8 & 65280);
            } while (--k > 0);
          }
        }
        return;
      }
      if (l >= i1) {
        return;
      }
      const i2 = (k1 - j1) / (i1 - l) | 0;
      if (_Rasterizer3D.aBoolean1528) {
        if (i1 > Rasterizer.virtualBottomX) {
          i1 = Rasterizer.virtualBottomX;
        }
        if (l < 0) {
          j1 -= l * i2;
          l = 0;
        }
        if (l >= i1) {
          return;
        }
      }
      i += l;
      k = i1 - l;
      if (_Rasterizer3D.anInt1531 === 0) {
        do {
          {
            pixels[i++] = _Rasterizer3D.getRgbLookupTableId[j1 >> 8];
            j1 += i2;
          }
        } while (--k > 0);
        return;
      }
      const k2 = _Rasterizer3D.anInt1531;
      const i3 = 256 - _Rasterizer3D.anInt1531;
      do {
        {
          j = _Rasterizer3D.getRgbLookupTableId[j1 >> 8];
          j1 += i2;
          j = ((j & 16711935) * i3 >> 8 & 16711935) + ((j & 65280) * i3 >> 8 & 65280);
          pixels[i++] = j + ((pixels[i] & 16711935) * k2 >> 8 & 16711935) + ((pixels[i] & 65280) * k2 >> 8 & 65280);
        }
      } while (--k > 0);
    }
    static method505(i, j, k, l, i1, j1, k1) {
      let l1 = 0;
      if (j !== i) {
        l1 = (i1 - l << 16) / (j - i) | 0;
      }
      let i2 = 0;
      if (k !== j) {
        i2 = (j1 - i1 << 16) / (k - j) | 0;
      }
      let j2 = 0;
      if (k !== i) {
        j2 = (l - j1 << 16) / (i - k) | 0;
      }
      if (i <= j && i <= k) {
        if (i >= Rasterizer.bottomY) {
          return;
        }
        if (j > Rasterizer.bottomY) {
          j = Rasterizer.bottomY;
        }
        if (k > Rasterizer.bottomY) {
          k = Rasterizer.bottomY;
        }
        if (j < k) {
          j1 = l <<= 16;
          if (i < 0) {
            j1 -= j2 * i;
            l -= l1 * i;
            i = 0;
          }
          i1 <<= 16;
          if (j < 0) {
            i1 -= i2 * j;
            j = 0;
          }
          if (i !== j && j2 < l1 || i === j && j2 > i2) {
            k -= j;
            j -= i;
            for (i = _Rasterizer3D.lineOffsets[i]; --j >= 0; i += Rasterizer.width) {
              {
                _Rasterizer3D.method506(Rasterizer.pixels, i, k1, 0, j1 >> 16, l >> 16);
                j1 += j2;
                l += l1;
              }
            }
            while (--k >= 0) {
              {
                _Rasterizer3D.method506(Rasterizer.pixels, i, k1, 0, j1 >> 16, i1 >> 16);
                j1 += j2;
                i1 += i2;
                i += Rasterizer.width;
              }
            }
            return;
          }
          k -= j;
          j -= i;
          for (i = _Rasterizer3D.lineOffsets[i]; --j >= 0; i += Rasterizer.width) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, i, k1, 0, l >> 16, j1 >> 16);
              j1 += j2;
              l += l1;
            }
          }
          while (--k >= 0) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, i, k1, 0, i1 >> 16, j1 >> 16);
              j1 += j2;
              i1 += i2;
              i += Rasterizer.width;
            }
          }
          return;
        }
        i1 = l <<= 16;
        if (i < 0) {
          i1 -= j2 * i;
          l -= l1 * i;
          i = 0;
        }
        j1 <<= 16;
        if (k < 0) {
          j1 -= i2 * k;
          k = 0;
        }
        if (i !== k && j2 < l1 || i === k && i2 > l1) {
          j -= k;
          k -= i;
          for (i = _Rasterizer3D.lineOffsets[i]; --k >= 0; i += Rasterizer.width) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, i, k1, 0, i1 >> 16, l >> 16);
              i1 += j2;
              l += l1;
            }
          }
          while (--j >= 0) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, i, k1, 0, j1 >> 16, l >> 16);
              j1 += i2;
              l += l1;
              i += Rasterizer.width;
            }
          }
          return;
        }
        j -= k;
        k -= i;
        for (i = _Rasterizer3D.lineOffsets[i]; --k >= 0; i += Rasterizer.width) {
          {
            _Rasterizer3D.method506(Rasterizer.pixels, i, k1, 0, l >> 16, i1 >> 16);
            i1 += j2;
            l += l1;
          }
        }
        while (--j >= 0) {
          {
            _Rasterizer3D.method506(Rasterizer.pixels, i, k1, 0, l >> 16, j1 >> 16);
            j1 += i2;
            l += l1;
            i += Rasterizer.width;
          }
        }
        return;
      }
      if (j <= k) {
        if (j >= Rasterizer.bottomY) {
          return;
        }
        if (k > Rasterizer.bottomY) {
          k = Rasterizer.bottomY;
        }
        if (i > Rasterizer.bottomY) {
          i = Rasterizer.bottomY;
        }
        if (k < i) {
          l = i1 <<= 16;
          if (j < 0) {
            l -= l1 * j;
            i1 -= i2 * j;
            j = 0;
          }
          j1 <<= 16;
          if (k < 0) {
            j1 -= j2 * k;
            k = 0;
          }
          if (j !== k && l1 < i2 || j === k && l1 > j2) {
            i -= k;
            k -= j;
            for (j = _Rasterizer3D.lineOffsets[j]; --k >= 0; j += Rasterizer.width) {
              {
                _Rasterizer3D.method506(Rasterizer.pixels, j, k1, 0, l >> 16, i1 >> 16);
                l += l1;
                i1 += i2;
              }
            }
            while (--i >= 0) {
              {
                _Rasterizer3D.method506(Rasterizer.pixels, j, k1, 0, l >> 16, j1 >> 16);
                l += l1;
                j1 += j2;
                j += Rasterizer.width;
              }
            }
            return;
          }
          i -= k;
          k -= j;
          for (j = _Rasterizer3D.lineOffsets[j]; --k >= 0; j += Rasterizer.width) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, j, k1, 0, i1 >> 16, l >> 16);
              l += l1;
              i1 += i2;
            }
          }
          while (--i >= 0) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, j, k1, 0, j1 >> 16, l >> 16);
              l += l1;
              j1 += j2;
              j += Rasterizer.width;
            }
          }
          return;
        }
        j1 = i1 <<= 16;
        if (j < 0) {
          j1 -= l1 * j;
          i1 -= i2 * j;
          j = 0;
        }
        l <<= 16;
        if (i < 0) {
          l -= j2 * i;
          i = 0;
        }
        if (l1 < i2) {
          k -= i;
          i -= j;
          for (j = _Rasterizer3D.lineOffsets[j]; --i >= 0; j += Rasterizer.width) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, j, k1, 0, j1 >> 16, i1 >> 16);
              j1 += l1;
              i1 += i2;
            }
          }
          while (--k >= 0) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, j, k1, 0, l >> 16, i1 >> 16);
              l += j2;
              i1 += i2;
              j += Rasterizer.width;
            }
          }
          return;
        }
        k -= i;
        i -= j;
        for (j = _Rasterizer3D.lineOffsets[j]; --i >= 0; j += Rasterizer.width) {
          {
            _Rasterizer3D.method506(Rasterizer.pixels, j, k1, 0, i1 >> 16, j1 >> 16);
            j1 += l1;
            i1 += i2;
          }
        }
        while (--k >= 0) {
          {
            _Rasterizer3D.method506(Rasterizer.pixels, j, k1, 0, i1 >> 16, l >> 16);
            l += j2;
            i1 += i2;
            j += Rasterizer.width;
          }
        }
        return;
      }
      if (k >= Rasterizer.bottomY) {
        return;
      }
      if (i > Rasterizer.bottomY) {
        i = Rasterizer.bottomY;
      }
      if (j > Rasterizer.bottomY) {
        j = Rasterizer.bottomY;
      }
      if (i < j) {
        i1 = j1 <<= 16;
        if (k < 0) {
          i1 -= i2 * k;
          j1 -= j2 * k;
          k = 0;
        }
        l <<= 16;
        if (i < 0) {
          l -= l1 * i;
          i = 0;
        }
        if (i2 < j2) {
          j -= i;
          i -= k;
          for (k = _Rasterizer3D.lineOffsets[k]; --i >= 0; k += Rasterizer.width) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, k, k1, 0, i1 >> 16, j1 >> 16);
              i1 += i2;
              j1 += j2;
            }
          }
          while (--j >= 0) {
            {
              _Rasterizer3D.method506(Rasterizer.pixels, k, k1, 0, i1 >> 16, l >> 16);
              i1 += i2;
              l += l1;
              k += Rasterizer.width;
            }
          }
          return;
        }
        j -= i;
        i -= k;
        for (k = _Rasterizer3D.lineOffsets[k]; --i >= 0; k += Rasterizer.width) {
          {
            _Rasterizer3D.method506(Rasterizer.pixels, k, k1, 0, j1 >> 16, i1 >> 16);
            i1 += i2;
            j1 += j2;
          }
        }
        while (--j >= 0) {
          {
            _Rasterizer3D.method506(Rasterizer.pixels, k, k1, 0, l >> 16, i1 >> 16);
            i1 += i2;
            l += l1;
            k += Rasterizer.width;
          }
        }
        return;
      }
      l = j1 <<= 16;
      if (k < 0) {
        l -= i2 * k;
        j1 -= j2 * k;
        k = 0;
      }
      i1 <<= 16;
      if (j < 0) {
        i1 -= l1 * j;
        j = 0;
      }
      if (i2 < j2) {
        i -= j;
        j -= k;
        for (k = _Rasterizer3D.lineOffsets[k]; --j >= 0; k += Rasterizer.width) {
          {
            _Rasterizer3D.method506(Rasterizer.pixels, k, k1, 0, l >> 16, j1 >> 16);
            l += i2;
            j1 += j2;
          }
        }
        while (--i >= 0) {
          {
            _Rasterizer3D.method506(Rasterizer.pixels, k, k1, 0, i1 >> 16, j1 >> 16);
            i1 += l1;
            j1 += j2;
            k += Rasterizer.width;
          }
        }
        return;
      }
      i -= j;
      j -= k;
      for (k = _Rasterizer3D.lineOffsets[k]; --j >= 0; k += Rasterizer.width) {
        {
          _Rasterizer3D.method506(Rasterizer.pixels, k, k1, 0, j1 >> 16, l >> 16);
          l += i2;
          j1 += j2;
        }
      }
      while (--i >= 0) {
        {
          _Rasterizer3D.method506(Rasterizer.pixels, k, k1, 0, j1 >> 16, i1 >> 16);
          i1 += l1;
          j1 += j2;
          k += Rasterizer.width;
        }
      }
    }
    static method506(ai, i, j, k, l, i1) {
      if (_Rasterizer3D.aBoolean1528) {
        if (i1 > Rasterizer.virtualBottomX) {
          i1 = Rasterizer.virtualBottomX;
        }
        if (l < 0) {
          l = 0;
        }
      }
      if (l >= i1) {
        return;
      }
      i += l;
      k = i1 - l >> 2;
      if (_Rasterizer3D.anInt1531 === 0) {
        while (--k >= 0) {
          {
            ai[i++] = j;
            ai[i++] = j;
            ai[i++] = j;
            ai[i++] = j;
          }
        }
        for (k = i1 - l & 3; --k >= 0; ) {
          ai[i++] = j;
        }
        return;
      }
      const j1 = _Rasterizer3D.anInt1531;
      const k1 = 256 - _Rasterizer3D.anInt1531;
      j = ((j & 16711935) * k1 >> 8 & 16711935) + ((j & 65280) * k1 >> 8 & 65280);
      while (--k >= 0) {
        {
          ai[i++] = j + ((ai[i] & 16711935) * j1 >> 8 & 16711935) + ((ai[i] & 65280) * j1 >> 8 & 65280);
          ai[i++] = j + ((ai[i] & 16711935) * j1 >> 8 & 16711935) + ((ai[i] & 65280) * j1 >> 8 & 65280);
          ai[i++] = j + ((ai[i] & 16711935) * j1 >> 8 & 16711935) + ((ai[i] & 65280) * j1 >> 8 & 65280);
          ai[i++] = j + ((ai[i] & 16711935) * j1 >> 8 & 16711935) + ((ai[i] & 65280) * j1 >> 8 & 65280);
        }
      }
      for (k = i1 - l & 3; --k >= 0; ) {
        ai[i++] = j + ((ai[i] & 16711935) * j1 >> 8 & 16711935) + ((ai[i] & 65280) * j1 >> 8 & 65280);
      }
    }
    static method507(i, j, k, l, i1, j1, k1, l1, i2, j2, k2, l2, i3, j3, k3, l3, i4, j4, k4) {
      const ai = _Rasterizer3D.method500(k4);
      _Rasterizer3D.aBoolean1529 = !_Rasterizer3D.aBooleanArray1541[k4];
      k2 = j2 - k2;
      j3 = i3 - j3;
      i4 = l3 - i4;
      l2 -= j2;
      k3 -= i3;
      j4 -= l3;
      let l4 = l2 * i3 - k3 * j2 << 14;
      const i5 = k3 * l3 - j4 * i3 << 8;
      const j5 = j4 * j2 - l2 * l3 << 5;
      let k5 = k2 * i3 - j3 * j2 << 14;
      const l5 = j3 * l3 - i4 * i3 << 8;
      const i6 = i4 * j2 - k2 * l3 << 5;
      let j6 = j3 * l2 - k2 * k3 << 14;
      const k6 = i4 * k3 - j3 * j4 << 8;
      const l6 = k2 * j4 - i4 * l2 << 5;
      let i7 = 0;
      let j7 = 0;
      if (j !== i) {
        i7 = (i1 - l << 16) / (j - i) | 0;
        j7 = (l1 - k1 << 16) / (j - i) | 0;
      }
      let k7 = 0;
      let l7 = 0;
      if (k !== j) {
        k7 = (j1 - i1 << 16) / (k - j) | 0;
        l7 = (i2 - l1 << 16) / (k - j) | 0;
      }
      let i8 = 0;
      let j8 = 0;
      if (k !== i) {
        i8 = (l - j1 << 16) / (i - k) | 0;
        j8 = (k1 - i2 << 16) / (i - k) | 0;
      }
      if (i <= j && i <= k) {
        if (i >= Rasterizer.bottomY) {
          return;
        }
        if (j > Rasterizer.bottomY) {
          j = Rasterizer.bottomY;
        }
        if (k > Rasterizer.bottomY) {
          k = Rasterizer.bottomY;
        }
        if (j < k) {
          j1 = l <<= 16;
          i2 = k1 <<= 16;
          if (i < 0) {
            j1 -= i8 * i;
            l -= i7 * i;
            i2 -= j8 * i;
            k1 -= j7 * i;
            i = 0;
          }
          i1 <<= 16;
          l1 <<= 16;
          if (j < 0) {
            i1 -= k7 * j;
            l1 -= l7 * j;
            j = 0;
          }
          const k8 = i - _Rasterizer3D.centerY;
          l4 += j5 * k8;
          k5 += i6 * k8;
          j6 += l6 * k8;
          if (i !== j && i8 < i7 || i === j && i8 > k7) {
            k -= j;
            j -= i;
            i = _Rasterizer3D.lineOffsets[i];
            while (--j >= 0) {
              {
                _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, i, j1 >> 16, l >> 16, i2 >> 8, k1 >> 8, l4, k5, j6, i5, l5, k6);
                j1 += i8;
                l += i7;
                i2 += j8;
                k1 += j7;
                i += Rasterizer.width;
                l4 += j5;
                k5 += i6;
                j6 += l6;
              }
            }
            while (--k >= 0) {
              {
                _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, i, j1 >> 16, i1 >> 16, i2 >> 8, l1 >> 8, l4, k5, j6, i5, l5, k6);
                j1 += i8;
                i1 += k7;
                i2 += j8;
                l1 += l7;
                i += Rasterizer.width;
                l4 += j5;
                k5 += i6;
                j6 += l6;
              }
            }
            return;
          }
          k -= j;
          j -= i;
          i = _Rasterizer3D.lineOffsets[i];
          while (--j >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, i, l >> 16, j1 >> 16, k1 >> 8, i2 >> 8, l4, k5, j6, i5, l5, k6);
              j1 += i8;
              l += i7;
              i2 += j8;
              k1 += j7;
              i += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          while (--k >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, i, i1 >> 16, j1 >> 16, l1 >> 8, i2 >> 8, l4, k5, j6, i5, l5, k6);
              j1 += i8;
              i1 += k7;
              i2 += j8;
              l1 += l7;
              i += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          return;
        }
        i1 = l <<= 16;
        l1 = k1 <<= 16;
        if (i < 0) {
          i1 -= i8 * i;
          l -= i7 * i;
          l1 -= j8 * i;
          k1 -= j7 * i;
          i = 0;
        }
        j1 <<= 16;
        i2 <<= 16;
        if (k < 0) {
          j1 -= k7 * k;
          i2 -= l7 * k;
          k = 0;
        }
        const l8 = i - _Rasterizer3D.centerY;
        l4 += j5 * l8;
        k5 += i6 * l8;
        j6 += l6 * l8;
        if (i !== k && i8 < i7 || i === k && k7 > i7) {
          j -= k;
          k -= i;
          i = _Rasterizer3D.lineOffsets[i];
          while (--k >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, i, i1 >> 16, l >> 16, l1 >> 8, k1 >> 8, l4, k5, j6, i5, l5, k6);
              i1 += i8;
              l += i7;
              l1 += j8;
              k1 += j7;
              i += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          while (--j >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, i, j1 >> 16, l >> 16, i2 >> 8, k1 >> 8, l4, k5, j6, i5, l5, k6);
              j1 += k7;
              l += i7;
              i2 += l7;
              k1 += j7;
              i += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          return;
        }
        j -= k;
        k -= i;
        i = _Rasterizer3D.lineOffsets[i];
        while (--k >= 0) {
          {
            _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, i, l >> 16, i1 >> 16, k1 >> 8, l1 >> 8, l4, k5, j6, i5, l5, k6);
            i1 += i8;
            l += i7;
            l1 += j8;
            k1 += j7;
            i += Rasterizer.width;
            l4 += j5;
            k5 += i6;
            j6 += l6;
          }
        }
        while (--j >= 0) {
          {
            _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, i, l >> 16, j1 >> 16, k1 >> 8, i2 >> 8, l4, k5, j6, i5, l5, k6);
            j1 += k7;
            l += i7;
            i2 += l7;
            k1 += j7;
            i += Rasterizer.width;
            l4 += j5;
            k5 += i6;
            j6 += l6;
          }
        }
        return;
      }
      if (j <= k) {
        if (j >= Rasterizer.bottomY) {
          return;
        }
        if (k > Rasterizer.bottomY) {
          k = Rasterizer.bottomY;
        }
        if (i > Rasterizer.bottomY) {
          i = Rasterizer.bottomY;
        }
        if (k < i) {
          l = i1 <<= 16;
          k1 = l1 <<= 16;
          if (j < 0) {
            l -= i7 * j;
            i1 -= k7 * j;
            k1 -= j7 * j;
            l1 -= l7 * j;
            j = 0;
          }
          j1 <<= 16;
          i2 <<= 16;
          if (k < 0) {
            j1 -= i8 * k;
            i2 -= j8 * k;
            k = 0;
          }
          const i9 = j - _Rasterizer3D.centerY;
          l4 += j5 * i9;
          k5 += i6 * i9;
          j6 += l6 * i9;
          if (j !== k && i7 < k7 || j === k && i7 > i8) {
            i -= k;
            k -= j;
            j = _Rasterizer3D.lineOffsets[j];
            while (--k >= 0) {
              {
                _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, j, l >> 16, i1 >> 16, k1 >> 8, l1 >> 8, l4, k5, j6, i5, l5, k6);
                l += i7;
                i1 += k7;
                k1 += j7;
                l1 += l7;
                j += Rasterizer.width;
                l4 += j5;
                k5 += i6;
                j6 += l6;
              }
            }
            while (--i >= 0) {
              {
                _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, j, l >> 16, j1 >> 16, k1 >> 8, i2 >> 8, l4, k5, j6, i5, l5, k6);
                l += i7;
                j1 += i8;
                k1 += j7;
                i2 += j8;
                j += Rasterizer.width;
                l4 += j5;
                k5 += i6;
                j6 += l6;
              }
            }
            return;
          }
          i -= k;
          k -= j;
          j = _Rasterizer3D.lineOffsets[j];
          while (--k >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, j, i1 >> 16, l >> 16, l1 >> 8, k1 >> 8, l4, k5, j6, i5, l5, k6);
              l += i7;
              i1 += k7;
              k1 += j7;
              l1 += l7;
              j += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          while (--i >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, j, j1 >> 16, l >> 16, i2 >> 8, k1 >> 8, l4, k5, j6, i5, l5, k6);
              l += i7;
              j1 += i8;
              k1 += j7;
              i2 += j8;
              j += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          return;
        }
        j1 = i1 <<= 16;
        i2 = l1 <<= 16;
        if (j < 0) {
          j1 -= i7 * j;
          i1 -= k7 * j;
          i2 -= j7 * j;
          l1 -= l7 * j;
          j = 0;
        }
        l <<= 16;
        k1 <<= 16;
        if (i < 0) {
          l -= i8 * i;
          k1 -= j8 * i;
          i = 0;
        }
        const j9 = j - _Rasterizer3D.centerY;
        l4 += j5 * j9;
        k5 += i6 * j9;
        j6 += l6 * j9;
        if (i7 < k7) {
          k -= i;
          i -= j;
          j = _Rasterizer3D.lineOffsets[j];
          while (--i >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, j, j1 >> 16, i1 >> 16, i2 >> 8, l1 >> 8, l4, k5, j6, i5, l5, k6);
              j1 += i7;
              i1 += k7;
              i2 += j7;
              l1 += l7;
              j += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          while (--k >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, j, l >> 16, i1 >> 16, k1 >> 8, l1 >> 8, l4, k5, j6, i5, l5, k6);
              l += i8;
              i1 += k7;
              k1 += j8;
              l1 += l7;
              j += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          return;
        }
        k -= i;
        i -= j;
        j = _Rasterizer3D.lineOffsets[j];
        while (--i >= 0) {
          {
            _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, j, i1 >> 16, j1 >> 16, l1 >> 8, i2 >> 8, l4, k5, j6, i5, l5, k6);
            j1 += i7;
            i1 += k7;
            i2 += j7;
            l1 += l7;
            j += Rasterizer.width;
            l4 += j5;
            k5 += i6;
            j6 += l6;
          }
        }
        while (--k >= 0) {
          {
            _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, j, i1 >> 16, l >> 16, l1 >> 8, k1 >> 8, l4, k5, j6, i5, l5, k6);
            l += i8;
            i1 += k7;
            k1 += j8;
            l1 += l7;
            j += Rasterizer.width;
            l4 += j5;
            k5 += i6;
            j6 += l6;
          }
        }
        return;
      }
      if (k >= Rasterizer.bottomY) {
        return;
      }
      if (i > Rasterizer.bottomY) {
        i = Rasterizer.bottomY;
      }
      if (j > Rasterizer.bottomY) {
        j = Rasterizer.bottomY;
      }
      if (i < j) {
        i1 = j1 <<= 16;
        l1 = i2 <<= 16;
        if (k < 0) {
          i1 -= k7 * k;
          j1 -= i8 * k;
          l1 -= l7 * k;
          i2 -= j8 * k;
          k = 0;
        }
        l <<= 16;
        k1 <<= 16;
        if (i < 0) {
          l -= i7 * i;
          k1 -= j7 * i;
          i = 0;
        }
        const k9 = k - _Rasterizer3D.centerY;
        l4 += j5 * k9;
        k5 += i6 * k9;
        j6 += l6 * k9;
        if (k7 < i8) {
          j -= i;
          i -= k;
          k = _Rasterizer3D.lineOffsets[k];
          while (--i >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, k, i1 >> 16, j1 >> 16, l1 >> 8, i2 >> 8, l4, k5, j6, i5, l5, k6);
              i1 += k7;
              j1 += i8;
              l1 += l7;
              i2 += j8;
              k += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          while (--j >= 0) {
            {
              _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, k, i1 >> 16, l >> 16, l1 >> 8, k1 >> 8, l4, k5, j6, i5, l5, k6);
              i1 += k7;
              l += i7;
              l1 += l7;
              k1 += j7;
              k += Rasterizer.width;
              l4 += j5;
              k5 += i6;
              j6 += l6;
            }
          }
          return;
        }
        j -= i;
        i -= k;
        k = _Rasterizer3D.lineOffsets[k];
        while (--i >= 0) {
          {
            _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, k, j1 >> 16, i1 >> 16, i2 >> 8, l1 >> 8, l4, k5, j6, i5, l5, k6);
            i1 += k7;
            j1 += i8;
            l1 += l7;
            i2 += j8;
            k += Rasterizer.width;
            l4 += j5;
            k5 += i6;
            j6 += l6;
          }
        }
        while (--j >= 0) {
          {
            _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, k, l >> 16, i1 >> 16, k1 >> 8, l1 >> 8, l4, k5, j6, i5, l5, k6);
            i1 += k7;
            l += i7;
            l1 += l7;
            k1 += j7;
            k += Rasterizer.width;
            l4 += j5;
            k5 += i6;
            j6 += l6;
          }
        }
        return;
      }
      l = j1 <<= 16;
      k1 = i2 <<= 16;
      if (k < 0) {
        l -= k7 * k;
        j1 -= i8 * k;
        k1 -= l7 * k;
        i2 -= j8 * k;
        k = 0;
      }
      i1 <<= 16;
      l1 <<= 16;
      if (j < 0) {
        i1 -= i7 * j;
        l1 -= j7 * j;
        j = 0;
      }
      const l9 = k - _Rasterizer3D.centerY;
      l4 += j5 * l9;
      k5 += i6 * l9;
      j6 += l6 * l9;
      if (k7 < i8) {
        i -= j;
        j -= k;
        k = _Rasterizer3D.lineOffsets[k];
        while (--j >= 0) {
          {
            _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, k, l >> 16, j1 >> 16, k1 >> 8, i2 >> 8, l4, k5, j6, i5, l5, k6);
            l += k7;
            j1 += i8;
            k1 += l7;
            i2 += j8;
            k += Rasterizer.width;
            l4 += j5;
            k5 += i6;
            j6 += l6;
          }
        }
        while (--i >= 0) {
          {
            _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, k, i1 >> 16, j1 >> 16, l1 >> 8, i2 >> 8, l4, k5, j6, i5, l5, k6);
            i1 += i7;
            j1 += i8;
            l1 += j7;
            i2 += j8;
            k += Rasterizer.width;
            l4 += j5;
            k5 += i6;
            j6 += l6;
          }
        }
        return;
      }
      i -= j;
      j -= k;
      k = _Rasterizer3D.lineOffsets[k];
      while (--j >= 0) {
        {
          _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, k, j1 >> 16, l >> 16, i2 >> 8, k1 >> 8, l4, k5, j6, i5, l5, k6);
          l += k7;
          j1 += i8;
          k1 += l7;
          i2 += j8;
          k += Rasterizer.width;
          l4 += j5;
          k5 += i6;
          j6 += l6;
        }
      }
      while (--i >= 0) {
        {
          _Rasterizer3D.fillPixels(Rasterizer.pixels, ai, 0, 0, k, j1 >> 16, i1 >> 16, i2 >> 8, l1 >> 8, l4, k5, j6, i5, l5, k6);
          i1 += i7;
          j1 += i8;
          l1 += j7;
          i2 += j8;
          k += Rasterizer.width;
          l4 += j5;
          k5 += i6;
          j6 += l6;
        }
      }
    }
    static fillPixels(pixels, ai1, i, j, k, l, i1, j1, k1, l1, i2, j2, k2, l2, i3) {
      if (l >= i1) {
        return;
      }
      let j3;
      let k3;
      if (_Rasterizer3D.aBoolean1528) {
        j3 = (k1 - j1) / (i1 - l) | 0;
        if (i1 > Rasterizer.virtualBottomX) {
          i1 = Rasterizer.virtualBottomX;
        }
        if (l < 0) {
          j1 -= l * j3;
          l = 0;
        }
        if (l >= i1) {
          return;
        }
        k3 = i1 - l >> 3;
        j3 <<= 12;
        j1 <<= 9;
      } else {
        if (i1 - l > 7) {
          k3 = i1 - l >> 3;
          j3 = (k1 - j1) * _Rasterizer3D.anIntArray1534[k3] >> 6;
        } else {
          k3 = 0;
          j3 = 0;
        }
        j1 <<= 9;
      }
      k += l;
      if (_Rasterizer3D.lowMemory) {
        let i4 = 0;
        let k4 = 0;
        const k6 = l - _Rasterizer3D.centerX;
        l1 += (k2 >> 3) * k6;
        i2 += (l2 >> 3) * k6;
        j2 += (i3 >> 3) * k6;
        let i5 = j2 >> 12;
        if (i5 !== 0) {
          i = l1 / i5 | 0;
          j = i2 / i5 | 0;
          if (i < 0) {
            i = 0;
          } else if (i > 4032) {
            i = 4032;
          }
        }
        l1 += k2;
        i2 += l2;
        j2 += i3;
        i5 = j2 >> 12;
        if (i5 !== 0) {
          i4 = l1 / i5 | 0;
          k4 = i2 / i5 | 0;
          if (i4 < 7) {
            i4 = 7;
          } else if (i4 > 4032) {
            i4 = 4032;
          }
        }
        let i7 = i4 - i >> 3;
        let k7 = k4 - j >> 3;
        i += (j1 & 6291456) >> 3;
        let i8 = j1 >> 23;
        if (_Rasterizer3D.aBoolean1529) {
          while (k3-- > 0) {
            {
              pixels[k++] = ai1[(j & 4032) + (i >> 6)] >>> i8;
              i += i7;
              j += k7;
              pixels[k++] = ai1[(j & 4032) + (i >> 6)] >>> i8;
              i += i7;
              j += k7;
              pixels[k++] = ai1[(j & 4032) + (i >> 6)] >>> i8;
              i += i7;
              j += k7;
              pixels[k++] = ai1[(j & 4032) + (i >> 6)] >>> i8;
              i += i7;
              j += k7;
              pixels[k++] = ai1[(j & 4032) + (i >> 6)] >>> i8;
              i += i7;
              j += k7;
              pixels[k++] = ai1[(j & 4032) + (i >> 6)] >>> i8;
              i += i7;
              j += k7;
              pixels[k++] = ai1[(j & 4032) + (i >> 6)] >>> i8;
              i += i7;
              j += k7;
              pixels[k++] = ai1[(j & 4032) + (i >> 6)] >>> i8;
              i = i4;
              j = k4;
              l1 += k2;
              i2 += l2;
              j2 += i3;
              const j5 = j2 >> 12;
              if (j5 !== 0) {
                i4 = l1 / j5 | 0;
                k4 = i2 / j5 | 0;
                if (i4 < 7) {
                  i4 = 7;
                } else if (i4 > 4032) {
                  i4 = 4032;
                }
              }
              i7 = i4 - i >> 3;
              k7 = k4 - j >> 3;
              j1 += j3;
              i += (j1 & 6291456) >> 3;
              i8 = j1 >> 23;
            }
          }
          for (k3 = i1 - l & 7; k3-- > 0; ) {
            {
              pixels[k++] = ai1[(j & 4032) + (i >> 6)] >>> i8;
              i += i7;
              j += k7;
            }
          }
          return;
        }
        while (k3-- > 0) {
          {
            let k8;
            if ((k8 = ai1[(j & 4032) + (i >> 6)] >>> i8) !== 0) {
              pixels[k] = k8;
            }
            k++;
            i += i7;
            j += k7;
            if ((k8 = ai1[(j & 4032) + (i >> 6)] >>> i8) !== 0) {
              pixels[k] = k8;
            }
            k++;
            i += i7;
            j += k7;
            if ((k8 = ai1[(j & 4032) + (i >> 6)] >>> i8) !== 0) {
              pixels[k] = k8;
            }
            k++;
            i += i7;
            j += k7;
            if ((k8 = ai1[(j & 4032) + (i >> 6)] >>> i8) !== 0) {
              pixels[k] = k8;
            }
            k++;
            i += i7;
            j += k7;
            if ((k8 = ai1[(j & 4032) + (i >> 6)] >>> i8) !== 0) {
              pixels[k] = k8;
            }
            k++;
            i += i7;
            j += k7;
            if ((k8 = ai1[(j & 4032) + (i >> 6)] >>> i8) !== 0) {
              pixels[k] = k8;
            }
            k++;
            i += i7;
            j += k7;
            if ((k8 = ai1[(j & 4032) + (i >> 6)] >>> i8) !== 0) {
              pixels[k] = k8;
            }
            k++;
            i += i7;
            j += k7;
            if ((k8 = ai1[(j & 4032) + (i >> 6)] >>> i8) !== 0) {
              pixels[k] = k8;
            }
            k++;
            i = i4;
            j = k4;
            l1 += k2;
            i2 += l2;
            j2 += i3;
            const k5 = j2 >> 12;
            if (k5 !== 0) {
              i4 = l1 / k5 | 0;
              k4 = i2 / k5 | 0;
              if (i4 < 7) {
                i4 = 7;
              } else if (i4 > 4032) {
                i4 = 4032;
              }
            }
            i7 = i4 - i >> 3;
            k7 = k4 - j >> 3;
            j1 += j3;
            i += (j1 & 6291456) >> 3;
            i8 = j1 >> 23;
          }
        }
        for (k3 = i1 - l & 7; k3-- > 0; ) {
          {
            let l8;
            if ((l8 = ai1[(j & 4032) + (i >> 6)] >>> i8) !== 0) {
              pixels[k] = l8;
            }
            k++;
            i += i7;
            j += k7;
          }
        }
        return;
      }
      let j4 = 0;
      let l4 = 0;
      const l6 = l - _Rasterizer3D.centerX;
      l1 += (k2 >> 3) * l6;
      i2 += (l2 >> 3) * l6;
      j2 += (i3 >> 3) * l6;
      let l5 = j2 >> 14;
      if (l5 !== 0) {
        i = l1 / l5 | 0;
        j = i2 / l5 | 0;
        if (i < 0) {
          i = 0;
        } else if (i > 16256) {
          i = 16256;
        }
      }
      l1 += k2;
      i2 += l2;
      j2 += i3;
      l5 = j2 >> 14;
      if (l5 !== 0) {
        j4 = l1 / l5 | 0;
        l4 = i2 / l5 | 0;
        if (j4 < 7) {
          j4 = 7;
        } else if (j4 > 16256) {
          j4 = 16256;
        }
      }
      let j7 = j4 - i >> 3;
      let l7 = l4 - j >> 3;
      i += j1 & 6291456;
      let j8 = j1 >> 23;
      if (_Rasterizer3D.aBoolean1529) {
        while (k3-- > 0) {
          {
            pixels[k++] = ai1[(j & 16256) + (i >> 7)] >>> j8;
            i += j7;
            j += l7;
            pixels[k++] = ai1[(j & 16256) + (i >> 7)] >>> j8;
            i += j7;
            j += l7;
            pixels[k++] = ai1[(j & 16256) + (i >> 7)] >>> j8;
            i += j7;
            j += l7;
            pixels[k++] = ai1[(j & 16256) + (i >> 7)] >>> j8;
            i += j7;
            j += l7;
            pixels[k++] = ai1[(j & 16256) + (i >> 7)] >>> j8;
            i += j7;
            j += l7;
            pixels[k++] = ai1[(j & 16256) + (i >> 7)] >>> j8;
            i += j7;
            j += l7;
            pixels[k++] = ai1[(j & 16256) + (i >> 7)] >>> j8;
            i += j7;
            j += l7;
            pixels[k++] = ai1[(j & 16256) + (i >> 7)] >>> j8;
            i = j4;
            j = l4;
            l1 += k2;
            i2 += l2;
            j2 += i3;
            const i6 = j2 >> 14;
            if (i6 !== 0) {
              j4 = l1 / i6 | 0;
              l4 = i2 / i6 | 0;
              if (j4 < 7) {
                j4 = 7;
              } else if (j4 > 16256) {
                j4 = 16256;
              }
            }
            j7 = j4 - i >> 3;
            l7 = l4 - j >> 3;
            j1 += j3;
            i += j1 & 6291456;
            j8 = j1 >> 23;
          }
        }
        for (k3 = i1 - l & 7; k3-- > 0; ) {
          {
            pixels[k++] = ai1[(j & 16256) + (i >> 7)] >>> j8;
            i += j7;
            j += l7;
          }
        }
        return;
      }
      while (k3-- > 0) {
        {
          let i9;
          if ((i9 = ai1[(j & 16256) + (i >> 7)] >>> j8) !== 0) {
            pixels[k] = i9;
          }
          k++;
          i += j7;
          j += l7;
          if ((i9 = ai1[(j & 16256) + (i >> 7)] >>> j8) !== 0) {
            pixels[k] = i9;
          }
          k++;
          i += j7;
          j += l7;
          if ((i9 = ai1[(j & 16256) + (i >> 7)] >>> j8) !== 0) {
            pixels[k] = i9;
          }
          k++;
          i += j7;
          j += l7;
          if ((i9 = ai1[(j & 16256) + (i >> 7)] >>> j8) !== 0) {
            pixels[k] = i9;
          }
          k++;
          i += j7;
          j += l7;
          if ((i9 = ai1[(j & 16256) + (i >> 7)] >>> j8) !== 0) {
            pixels[k] = i9;
          }
          k++;
          i += j7;
          j += l7;
          if ((i9 = ai1[(j & 16256) + (i >> 7)] >>> j8) !== 0) {
            pixels[k] = i9;
          }
          k++;
          i += j7;
          j += l7;
          if ((i9 = ai1[(j & 16256) + (i >> 7)] >>> j8) !== 0) {
            pixels[k] = i9;
          }
          k++;
          i += j7;
          j += l7;
          if ((i9 = ai1[(j & 16256) + (i >> 7)] >>> j8) !== 0) {
            pixels[k] = i9;
          }
          k++;
          i = j4;
          j = l4;
          l1 += k2;
          i2 += l2;
          j2 += i3;
          const j6 = j2 >> 14;
          if (j6 !== 0) {
            j4 = l1 / j6 | 0;
            l4 = i2 / j6 | 0;
            if (j4 < 7) {
              j4 = 7;
            } else if (j4 > 16256) {
              j4 = 16256;
            }
          }
          j7 = j4 - i >> 3;
          l7 = l4 - j >> 3;
          j1 += j3;
          i += j1 & 6291456;
          j8 = j1 >> 23;
        }
      }
      for (let l3 = i1 - l & 7; l3-- > 0; ) {
        {
          let j9;
          if ((j9 = ai1[(j & 16256) + (i >> 7)] >>> j8) !== 0) {
            pixels[k] = j9;
          }
          k++;
          i += j7;
          j += l7;
        }
      }
    }
  };
  var Rasterizer3D = _Rasterizer3D;
  Rasterizer3D.anInt1524 = -20714;
  Rasterizer3D.anInt1525 = 0;
  Rasterizer3D.aBoolean1526 = false;
  Rasterizer3D.lowMemory = false;
  Rasterizer3D.aBoolean1528 = false;
  Rasterizer3D.aBoolean1529 = false;
  Rasterizer3D.approximateAlphaBlending = true;
  Rasterizer3D.anInt1531 = 0;
  Rasterizer3D.centerX = 0;
  Rasterizer3D.centerY = 0;
  Rasterizer3D.anIntArray1534 = Array(512).fill(0);
  Rasterizer3D.anIntArray1535 = Array(2048).fill(0);
  Rasterizer3D.SINE = Array(2048).fill(0);
  Rasterizer3D.COSINE = Array(2048).fill(0);
  Rasterizer3D.lineOffsets = null;
  Rasterizer3D.anInt1539 = 0;
  Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540 = Array(50).fill(null);
  Rasterizer3D.aBooleanArray1541 = Array(50).fill(false);
  Rasterizer3D.anIntArray1542 = Array(50).fill(0);
  Rasterizer3D.anInt1543 = 0;
  Rasterizer3D.anIntArrayArray1544 = null;
  Rasterizer3D.anIntArrayArray1545 = Array(50);
  Rasterizer3D.anIntArray1546 = Array(50).fill(0);
  Rasterizer3D.anInt1547 = 0;
  Rasterizer3D.getRgbLookupTableId = Array(65536).fill(0);
  Rasterizer3D.anIntArrayArray1549 = Array(50);
  staticInitialize();

  // osrs/media/renderable/Model.ts
  init_inject();

  // osrs/media/Animation.ts
  init_inject();

  // osrs/media/Skins.ts
  init_inject();
  var Skins = class {
    constructor(buffer) {
      if (this.count === void 0) {
        this.count = 0;
      }
      if (this.opcodes === void 0) {
        this.opcodes = null;
      }
      if (this.skinList === void 0) {
        this.skinList = null;
      }
      this.count = buffer.getUnsignedByte();
      this.opcodes = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.count);
      this.skinList = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(this.count);
      for (let opcode = 0; opcode < this.count; opcode++) {
        this.opcodes[opcode] = buffer.getUnsignedByte();
      }
      for (let skin = 0; skin < this.count; skin++) {
        {
          const subSkinAmount = buffer.getUnsignedByte();
          this.skinList[skin] = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(subSkinAmount);
          for (let subSkin = 0; subSkin < subSkinAmount; subSkin++) {
            this.skinList[skin][subSkin] = buffer.getUnsignedByte();
          }
        }
      }
    }
  };

  // osrs/media/Animation.ts
  var _Animation = class {
    static method235(i) {
      _Animation.cache = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(i + 1);
      _Animation.aBooleanArray438 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(false);
        }
        return a;
      })(i + 1);
      for (let j = 0; j < i + 1; j++) {
        _Animation.aBooleanArray438[j] = true;
      }
    }
    static method236(bs) {
      const buffer = new Buffer3(bs);
      buffer.currentPosition = bs.length - 8;
      const i = buffer.getUnsignedLEShort();
      const j = buffer.getUnsignedLEShort();
      const k = buffer.getUnsignedLEShort();
      const l = buffer.getUnsignedLEShort();
      let i1 = 0;
      const buffer_5_ = new Buffer3(bs);
      buffer_5_.currentPosition = i1;
      i1 += i + 2;
      const class50_sub1_sub2_2 = new Buffer3(bs);
      class50_sub1_sub2_2.currentPosition = i1;
      i1 += j;
      const class50_sub1_sub2_3 = new Buffer3(bs);
      class50_sub1_sub2_3.currentPosition = i1;
      i1 += k;
      const class50_sub1_sub2_4 = new Buffer3(bs);
      class50_sub1_sub2_4.currentPosition = i1;
      i1 += l;
      const buffer_9_ = new Buffer3(bs);
      buffer_9_.currentPosition = i1;
      const skins = new Skins(buffer_9_);
      const animationAmount = buffer_5_.getUnsignedLEShort();
      const ai = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(500);
      const ai1 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(500);
      const ai2 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(500);
      const ai3 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(500);
      for (let k1 = 0; k1 < animationAmount; k1++) {
        {
          const l1 = buffer_5_.getUnsignedLEShort();
          const animation = _Animation.cache[l1] = new _Animation();
          animation.anInt431 = class50_sub1_sub2_4.getUnsignedByte();
          animation.animationSkins = skins;
          const i2 = buffer_5_.getUnsignedByte();
          let j2 = -1;
          let k2 = 0;
          for (let l2 = 0; l2 < i2; l2++) {
            {
              const i3 = class50_sub1_sub2_2.getUnsignedByte();
              if (i3 > 0) {
                if (skins.opcodes[l2] !== 0) {
                  for (let k3 = l2 - 1; k3 > j2; k3--) {
                    {
                      if (skins.opcodes[k3] !== 0) {
                        continue;
                      }
                      ai[k2] = k3;
                      ai1[k2] = 0;
                      ai2[k2] = 0;
                      ai3[k2] = 0;
                      k2++;
                      break;
                    }
                  }
                }
                ai[k2] = l2;
                let c2 = "\0";
                if (skins.opcodes[l2] === 3) {
                  c2 = "\x80";
                }
                if ((i3 & 1) !== 0) {
                  ai1[k2] = class50_sub1_sub2_3.getSignedSmart();
                } else {
                  ai1[k2] = c2.charCodeAt(0);
                }
                if ((i3 & 2) !== 0) {
                  ai2[k2] = class50_sub1_sub2_3.getSignedSmart();
                } else {
                  ai2[k2] = c2.charCodeAt(0);
                }
                if ((i3 & 4) !== 0) {
                  ai3[k2] = class50_sub1_sub2_3.getSignedSmart();
                } else {
                  ai3[k2] = c2.charCodeAt(0);
                }
                j2 = l2;
                k2++;
                if (skins.opcodes[l2] === 5) {
                  _Animation.aBooleanArray438[l1] = false;
                }
              }
            }
          }
          animation.anInt433 = k2;
          animation.opcodeTable = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(k2);
          animation.modifier1 = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(k2);
          animation.modifier2 = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(k2);
          animation.modifier3 = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(k2);
          for (let j3 = 0; j3 < k2; j3++) {
            {
              animation.opcodeTable[j3] = ai[j3];
              animation.modifier1[j3] = ai1[j3];
              animation.modifier2[j3] = ai2[j3];
              animation.modifier3[j3] = ai3[j3];
            }
          }
        }
      }
    }
    static reset() {
      _Animation.cache = null;
    }
    static getAnimation(animationId) {
      if (_Animation.cache == null) {
        return null;
      } else {
        return _Animation.cache[animationId];
      }
    }
    static exists(i) {
      return i === -1;
    }
    constructor() {
      if (this.anInt431 === void 0) {
        this.anInt431 = 0;
      }
      if (this.animationSkins === void 0) {
        this.animationSkins = null;
      }
      if (this.anInt433 === void 0) {
        this.anInt433 = 0;
      }
      if (this.opcodeTable === void 0) {
        this.opcodeTable = null;
      }
      if (this.modifier1 === void 0) {
        this.modifier1 = null;
      }
      if (this.modifier2 === void 0) {
        this.modifier2 = null;
      }
      if (this.modifier3 === void 0) {
        this.modifier3 = null;
      }
    }
  };
  var Animation = _Animation;
  Animation.cache = null;
  Animation.aBooleanArray438 = null;

  // osrs/media/VertexNormal.ts
  init_inject();
  var VertexNormal = class {
    constructor() {
      if (this.x === void 0) {
        this.x = 0;
      }
      if (this.y === void 0) {
        this.y = 0;
      }
      if (this.z === void 0) {
        this.z = 0;
      }
      if (this.magnitude === void 0) {
        this.magnitude = 0;
      }
    }
  };

  // osrs/media/renderable/ModelHeader.ts
  init_inject();
  var ModelHeader = class {
    constructor() {
      if (this.modelData === void 0) {
        this.modelData = null;
      }
      if (this.vertexCount === void 0) {
        this.vertexCount = 0;
      }
      if (this.triangleCount === void 0) {
        this.triangleCount = 0;
      }
      if (this.texturedTriangleCount === void 0) {
        this.texturedTriangleCount = 0;
      }
      if (this.vertexDirectionOffset === void 0) {
        this.vertexDirectionOffset = 0;
      }
      if (this.xDataOffset === void 0) {
        this.xDataOffset = 0;
      }
      if (this.yDataOffset === void 0) {
        this.yDataOffset = 0;
      }
      if (this.zDataOffset === void 0) {
        this.zDataOffset = 0;
      }
      if (this.vertexSkinOffset === void 0) {
        this.vertexSkinOffset = 0;
      }
      if (this.triangleDataOffset === void 0) {
        this.triangleDataOffset = 0;
      }
      if (this.triangleTypeOffset === void 0) {
        this.triangleTypeOffset = 0;
      }
      if (this.colorDataOffset === void 0) {
        this.colorDataOffset = 0;
      }
      if (this.texturePointerOffset === void 0) {
        this.texturePointerOffset = 0;
      }
      if (this.trianglePriorityOffset === void 0) {
        this.trianglePriorityOffset = 0;
      }
      if (this.triangleAlphaOffset === void 0) {
        this.triangleAlphaOffset = 0;
      }
      if (this.triangleSkinOffset === void 0) {
        this.triangleSkinOffset = 0;
      }
      if (this.uvMapTriangleOffset === void 0) {
        this.uvMapTriangleOffset = 0;
      }
    }
  };

  // osrs/media/renderable/Renderable.ts
  init_inject();
  var Renderable = class extends CacheableNode {
    constructor() {
      super();
      this.modelHeight = 1e3;
      if (this.verticesNormal === void 0) {
        this.verticesNormal = null;
      }
    }
    renderAtPoint(i, j, k, l, i1, j1, k1, l1, i2) {
      const model = this.getRotatedModel();
      if (model != null) {
        this.modelHeight = model.modelHeight;
        model.renderAtPoint(i, j, k, l, i1, j1, k1, l1, i2);
      }
    }
    getRotatedModel() {
      return null;
    }
  };

  // osrs/Arrays.ts
  init_inject();
  function array3d(x2, y, z, init) {
    return Array.from(Array(x2), (_) => Array.from(Array(y), (_2) => Array(z).fill(init)));
  }
  function array2d(x2, y, init) {
    return Array.from(Array(x2), (_) => Array(y).fill(init));
  }

  // osrs/media/renderable/Model.ts
  var _Model = class extends Renderable {
    constructor(flag, flag1, i, class50_sub1_sub4_sub4) {
      var __super = (...args) => {
        super(...args);
      };
      if ((typeof flag === "boolean" || flag === null) && (typeof flag1 === "boolean" || flag1 === null) && (typeof i === "number" || i === null) && (class50_sub1_sub4_sub4 != null && class50_sub1_sub4_sub4 instanceof _Model || class50_sub1_sub4_sub4 === null)) {
        const __args = arguments;
        __super();
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        this.anInt1636 = 932;
        this.anInt1637 = 426;
        this.aBoolean1638 = false;
        this.aBoolean1639 = true;
        this.anInt1640 = -252;
        this.aBoolean1641 = false;
        this.oneSquareModel = false;
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        (() => {
          this.aBoolean1638 = false;
          this.aBoolean1639 = true;
          this.anInt1640 = -252;
          _Model.anInt1642;
          _Model.anInt1642++;
          this.vertexCount = class50_sub1_sub4_sub4.vertexCount;
          this.triangleCount = class50_sub1_sub4_sub4.triangleCount;
          this.texturedTriangleCount = class50_sub1_sub4_sub4.texturedTriangleCount;
          if (flag) {
            this.verticesY = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.vertexCount);
            for (let j = 0; j < this.vertexCount; j++) {
              this.verticesY[j] = class50_sub1_sub4_sub4.verticesY[j];
            }
          } else {
            this.verticesY = class50_sub1_sub4_sub4.verticesY;
          }
          if (flag1) {
            this.anIntArray1656 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
            this.anIntArray1657 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
            this.anIntArray1658 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
            for (let k = 0; k < this.triangleCount; k++) {
              {
                this.anIntArray1656[k] = class50_sub1_sub4_sub4.anIntArray1656[k];
                this.anIntArray1657[k] = class50_sub1_sub4_sub4.anIntArray1657[k];
                this.anIntArray1658[k] = class50_sub1_sub4_sub4.anIntArray1658[k];
              }
            }
            this.texturePoints = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
            if (class50_sub1_sub4_sub4.texturePoints == null) {
              for (let l = 0; l < this.triangleCount; l++) {
                this.texturePoints[l] = 0;
              }
            } else {
              for (let i1 = 0; i1 < this.triangleCount; i1++) {
                this.texturePoints[i1] = class50_sub1_sub4_sub4.texturePoints[i1];
              }
            }
            this.verticesNormal = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(null);
              }
              return a;
            })(this.vertexCount);
            for (let j1 = 0; j1 < this.vertexCount; j1++) {
              {
                const class40 = this.verticesNormal[j1] = new VertexNormal();
                const class40_1 = class50_sub1_sub4_sub4.verticesNormal[j1];
                class40.x = class40_1.x;
                class40.y = class40_1.y;
                class40.z = class40_1.z;
                class40.magnitude = class40_1.magnitude;
              }
            }
            this.aClass40Array1681 = class50_sub1_sub4_sub4.aClass40Array1681;
          } else {
            this.anIntArray1656 = class50_sub1_sub4_sub4.anIntArray1656;
            this.anIntArray1657 = class50_sub1_sub4_sub4.anIntArray1657;
            this.anIntArray1658 = class50_sub1_sub4_sub4.anIntArray1658;
            this.texturePoints = class50_sub1_sub4_sub4.texturePoints;
          }
          this.verticesX = class50_sub1_sub4_sub4.verticesX;
          this.verticesZ = class50_sub1_sub4_sub4.verticesZ;
          if (i !== 0) {
            this.aBoolean1638 = !this.aBoolean1638;
          }
          this.triangleColorValues = class50_sub1_sub4_sub4.triangleColorValues;
          this.triangleAlphaValues = class50_sub1_sub4_sub4.triangleAlphaValues;
          this.trianglePriorities = class50_sub1_sub4_sub4.trianglePriorities;
          this.anInt1663 = class50_sub1_sub4_sub4.anInt1663;
          this.trianglePointsX = class50_sub1_sub4_sub4.trianglePointsX;
          this.trianglePointsY = class50_sub1_sub4_sub4.trianglePointsY;
          this.trianglePointsZ = class50_sub1_sub4_sub4.trianglePointsZ;
          this.texturedTrianglePointsX = class50_sub1_sub4_sub4.texturedTrianglePointsX;
          this.texturedTrianglePointsY = class50_sub1_sub4_sub4.texturedTrianglePointsY;
          this.texturedTrianglePointsZ = class50_sub1_sub4_sub4.texturedTrianglePointsZ;
          this.modelHeight = class50_sub1_sub4_sub4.modelHeight;
          this.maxY = class50_sub1_sub4_sub4.maxY;
          this.shadowIntensity = class50_sub1_sub4_sub4.shadowIntensity;
          this.anInt1674 = class50_sub1_sub4_sub4.anInt1674;
          this.anInt1673 = class50_sub1_sub4_sub4.anInt1673;
          this.anInt1669 = class50_sub1_sub4_sub4.anInt1669;
          this.anInt1670 = class50_sub1_sub4_sub4.anInt1670;
          this.anInt1668 = class50_sub1_sub4_sub4.anInt1668;
        })();
      } else if ((typeof flag === "boolean" || flag === null) && (flag1 != null && flag1 instanceof _Model || flag1 === null) && (typeof i === "boolean" || i === null) && class50_sub1_sub4_sub4 === void 0) {
        const __args = arguments;
        const flag2 = __args[0];
        const model = __args[1];
        const flag3 = __args[2];
        __super();
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        this.anInt1636 = 932;
        this.anInt1637 = 426;
        this.aBoolean1638 = false;
        this.aBoolean1639 = true;
        this.anInt1640 = -252;
        this.aBoolean1641 = false;
        this.oneSquareModel = false;
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        (() => {
          this.aBoolean1638 = false;
          this.aBoolean1639 = true;
          this.anInt1640 = -252;
          _Model.anInt1642;
          _Model.anInt1642++;
          this.vertexCount = model.vertexCount;
          this.triangleCount = model.triangleCount;
          this.texturedTriangleCount = model.texturedTriangleCount;
          this.verticesX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.verticesY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.verticesZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          for (let i2 = 0; i2 < this.vertexCount; i2++) {
            {
              this.verticesX[i2] = model.verticesX[i2];
              this.verticesY[i2] = model.verticesY[i2];
              this.verticesZ[i2] = model.verticesZ[i2];
            }
          }
          if (flag2) {
            this.triangleColorValues = model.triangleColorValues;
          } else {
            this.triangleColorValues = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
            for (let j = 0; j < this.triangleCount; j++) {
              this.triangleColorValues[j] = model.triangleColorValues[j];
            }
          }
          if (flag3) {
            this.triangleAlphaValues = model.triangleAlphaValues;
          } else {
            this.triangleAlphaValues = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
            if (model.triangleAlphaValues == null) {
              for (let k = 0; k < this.triangleCount; k++) {
                this.triangleAlphaValues[k] = 0;
              }
            } else {
              for (let l = 0; l < this.triangleCount; l++) {
                this.triangleAlphaValues[l] = model.triangleAlphaValues[l];
              }
            }
          }
          this.vertexSkins = model.vertexSkins;
          this.triangleSkinValues = model.triangleSkinValues;
          this.texturePoints = model.texturePoints;
          this.trianglePointsX = model.trianglePointsX;
          this.trianglePointsY = model.trianglePointsY;
          this.trianglePointsZ = model.trianglePointsZ;
          this.trianglePriorities = model.trianglePriorities;
          this.anInt1663 = model.anInt1663;
          this.texturedTrianglePointsX = model.texturedTrianglePointsX;
          this.texturedTrianglePointsY = model.texturedTrianglePointsY;
          this.texturedTrianglePointsZ = model.texturedTrianglePointsZ;
        })();
      } else if ((typeof flag === "number" || flag === null) && (typeof flag1 === "number" || flag1 === null) && (i != null && i instanceof Array && (i.length == 0 || i[0] == null || i[0] != null && i[0] instanceof _Model) || i === null) && class50_sub1_sub4_sub4 === void 0) {
        const __args = arguments;
        const i2 = __args[0];
        const j = __args[1];
        const models = __args[2];
        __super();
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        this.anInt1636 = 932;
        this.anInt1637 = 426;
        this.aBoolean1638 = false;
        this.aBoolean1639 = true;
        this.anInt1640 = -252;
        this.aBoolean1641 = false;
        this.oneSquareModel = false;
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        (() => {
          this.aBoolean1638 = false;
          this.aBoolean1639 = true;
          this.anInt1640 = -252;
          _Model.anInt1642;
          _Model.anInt1642++;
          let flag12 = false;
          let flag2 = false;
          let flag3 = false;
          let flag4 = false;
          this.vertexCount = 0;
          this.triangleCount = 0;
          this.texturedTriangleCount = 0;
          this.anInt1663 = -1;
          for (let k = 0; k < i2; k++) {
            {
              const class50_sub1_sub4_sub42 = models[k];
              if (class50_sub1_sub4_sub42 != null) {
                this.vertexCount += class50_sub1_sub4_sub42.vertexCount;
                this.triangleCount += class50_sub1_sub4_sub42.triangleCount;
                this.texturedTriangleCount += class50_sub1_sub4_sub42.texturedTriangleCount;
                flag12 = class50_sub1_sub4_sub42.texturePoints != null || flag12;
                if (class50_sub1_sub4_sub42.trianglePriorities != null) {
                  flag2 = true;
                } else {
                  if (this.anInt1663 === -1) {
                    this.anInt1663 = class50_sub1_sub4_sub42.anInt1663;
                  }
                  if (this.anInt1663 !== class50_sub1_sub4_sub42.anInt1663) {
                    flag2 = true;
                  }
                }
                flag3 = class50_sub1_sub4_sub42.triangleAlphaValues != null || flag3;
                flag4 = class50_sub1_sub4_sub42.triangleColorValues != null || flag4;
              }
            }
          }
          this.verticesX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.verticesY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.verticesZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.trianglePointsX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.trianglePointsY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.trianglePointsZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.anIntArray1656 = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.anIntArray1657 = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.anIntArray1658 = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.texturedTrianglePointsX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.texturedTriangleCount);
          this.texturedTrianglePointsY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.texturedTriangleCount);
          this.texturedTrianglePointsZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.texturedTriangleCount);
          if (flag12) {
            this.texturePoints = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          if (flag2) {
            this.trianglePriorities = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          if (flag3) {
            this.triangleAlphaValues = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          if (flag4) {
            this.triangleColorValues = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          this.vertexCount = 0;
          if (j !== 0) {
            throw Error("NullPointerException");
          }
          this.triangleCount = 0;
          this.texturedTriangleCount = 0;
          let l = 0;
          for (let i1 = 0; i1 < i2; i1++) {
            {
              const class50_sub1_sub4_sub4_1 = models[i1];
              if (class50_sub1_sub4_sub4_1 != null) {
                const j1 = this.vertexCount;
                for (let k1 = 0; k1 < class50_sub1_sub4_sub4_1.vertexCount; k1++) {
                  {
                    this.verticesX[this.vertexCount] = class50_sub1_sub4_sub4_1.verticesX[k1];
                    this.verticesY[this.vertexCount] = class50_sub1_sub4_sub4_1.verticesY[k1];
                    this.verticesZ[this.vertexCount] = class50_sub1_sub4_sub4_1.verticesZ[k1];
                    this.vertexCount++;
                  }
                }
                for (let l1 = 0; l1 < class50_sub1_sub4_sub4_1.triangleCount; l1++) {
                  {
                    this.trianglePointsX[this.triangleCount] = class50_sub1_sub4_sub4_1.trianglePointsX[l1] + j1;
                    this.trianglePointsY[this.triangleCount] = class50_sub1_sub4_sub4_1.trianglePointsY[l1] + j1;
                    this.trianglePointsZ[this.triangleCount] = class50_sub1_sub4_sub4_1.trianglePointsZ[l1] + j1;
                    this.anIntArray1656[this.triangleCount] = class50_sub1_sub4_sub4_1.anIntArray1656[l1];
                    this.anIntArray1657[this.triangleCount] = class50_sub1_sub4_sub4_1.anIntArray1657[l1];
                    this.anIntArray1658[this.triangleCount] = class50_sub1_sub4_sub4_1.anIntArray1658[l1];
                    if (flag12) {
                      if (class50_sub1_sub4_sub4_1.texturePoints == null) {
                        this.texturePoints[this.triangleCount] = 0;
                      } else {
                        let i22 = class50_sub1_sub4_sub4_1.texturePoints[l1];
                        if ((i22 & 2) === 2) {
                          i22 += l << 2;
                        }
                        this.texturePoints[this.triangleCount] = i22;
                      }
                    }
                    if (flag2) {
                      if (class50_sub1_sub4_sub4_1.trianglePriorities == null) {
                        this.trianglePriorities[this.triangleCount] = class50_sub1_sub4_sub4_1.anInt1663;
                      } else {
                        this.trianglePriorities[this.triangleCount] = class50_sub1_sub4_sub4_1.trianglePriorities[l1];
                      }
                    }
                    if (flag3) {
                      if (class50_sub1_sub4_sub4_1.triangleAlphaValues == null) {
                        this.triangleAlphaValues[this.triangleCount] = 0;
                      } else {
                        this.triangleAlphaValues[this.triangleCount] = class50_sub1_sub4_sub4_1.triangleAlphaValues[l1];
                      }
                    }
                    if (flag4 && class50_sub1_sub4_sub4_1.triangleColorValues != null) {
                      this.triangleColorValues[this.triangleCount] = class50_sub1_sub4_sub4_1.triangleColorValues[l1];
                    }
                    this.triangleCount++;
                  }
                }
                for (let j2 = 0; j2 < class50_sub1_sub4_sub4_1.texturedTriangleCount; j2++) {
                  {
                    this.texturedTrianglePointsX[this.texturedTriangleCount] = class50_sub1_sub4_sub4_1.texturedTrianglePointsX[j2] + j1;
                    this.texturedTrianglePointsY[this.texturedTriangleCount] = class50_sub1_sub4_sub4_1.texturedTrianglePointsY[j2] + j1;
                    this.texturedTrianglePointsZ[this.texturedTriangleCount] = class50_sub1_sub4_sub4_1.texturedTrianglePointsZ[j2] + j1;
                    this.texturedTriangleCount++;
                  }
                }
                l += class50_sub1_sub4_sub4_1.texturedTriangleCount;
              }
            }
          }
          this.calculateDiagonals();
        })();
      } else if ((typeof flag === "number" || flag === null) && (flag1 != null && flag1 instanceof Array && (flag1.length == 0 || flag1[0] == null || flag1[0] != null && flag1[0] instanceof _Model) || flag1 === null) && i === void 0 && class50_sub1_sub4_sub4 === void 0) {
        const __args = arguments;
        const i2 = __args[0];
        const subModels = __args[1];
        __super();
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        this.anInt1636 = 932;
        this.anInt1637 = 426;
        this.aBoolean1638 = false;
        this.aBoolean1639 = true;
        this.anInt1640 = -252;
        this.aBoolean1641 = false;
        this.oneSquareModel = false;
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        (() => {
          this.aBoolean1638 = false;
          this.aBoolean1639 = true;
          this.anInt1640 = -252;
          _Model.anInt1642;
          _Model.anInt1642++;
          let flag2 = false;
          let flag12 = false;
          let flag22 = false;
          let flag3 = false;
          this.vertexCount = 0;
          this.triangleCount = 0;
          this.texturedTriangleCount = 0;
          this.anInt1663 = -1;
          for (let j = 0; j < i2; j++) {
            {
              const class50_sub1_sub4_sub42 = subModels[j];
              if (class50_sub1_sub4_sub42 != null) {
                this.vertexCount += class50_sub1_sub4_sub42.vertexCount;
                this.triangleCount += class50_sub1_sub4_sub42.triangleCount;
                this.texturedTriangleCount += class50_sub1_sub4_sub42.texturedTriangleCount;
                flag2 = class50_sub1_sub4_sub42.texturePoints != null || flag2;
                if (class50_sub1_sub4_sub42.trianglePriorities != null) {
                  flag12 = true;
                } else {
                  if (this.anInt1663 === -1) {
                    this.anInt1663 = class50_sub1_sub4_sub42.anInt1663;
                  }
                  if (this.anInt1663 !== class50_sub1_sub4_sub42.anInt1663) {
                    flag12 = true;
                  }
                }
                flag22 = class50_sub1_sub4_sub42.triangleAlphaValues != null || flag22;
                flag3 = class50_sub1_sub4_sub42.triangleSkinValues != null || flag3;
              }
            }
          }
          this.verticesX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.verticesY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.verticesZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.vertexSkins = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.trianglePointsX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.trianglePointsY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.trianglePointsZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.texturedTrianglePointsX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.texturedTriangleCount);
          this.texturedTrianglePointsY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.texturedTriangleCount);
          this.texturedTrianglePointsZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.texturedTriangleCount);
          if (flag2) {
            this.texturePoints = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          if (flag12) {
            this.trianglePriorities = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          if (flag22) {
            this.triangleAlphaValues = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          if (flag3) {
            this.triangleSkinValues = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          this.triangleColorValues = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.vertexCount = 0;
          this.triangleCount = 0;
          this.texturedTriangleCount = 0;
          let k = 0;
          for (let l = 0; l < i2; l++) {
            {
              const model_44_ = subModels[l];
              if (model_44_ != null) {
                for (let i1 = 0; i1 < model_44_.triangleCount; i1++) {
                  {
                    if (flag2) {
                      if (model_44_.texturePoints == null) {
                        this.texturePoints[this.triangleCount] = 0;
                      } else {
                        let j1 = model_44_.texturePoints[i1];
                        if ((j1 & 2) === 2) {
                          j1 += k << 2;
                        }
                        this.texturePoints[this.triangleCount] = j1;
                      }
                    }
                    if (flag12) {
                      if (model_44_.trianglePriorities == null) {
                        this.trianglePriorities[this.triangleCount] = model_44_.anInt1663;
                      } else {
                        this.trianglePriorities[this.triangleCount] = model_44_.trianglePriorities[i1];
                      }
                    }
                    if (flag22) {
                      if (model_44_.triangleAlphaValues == null) {
                        this.triangleAlphaValues[this.triangleCount] = 0;
                      } else {
                        this.triangleAlphaValues[this.triangleCount] = model_44_.triangleAlphaValues[i1];
                      }
                    }
                    if (flag3 && model_44_.triangleSkinValues != null) {
                      this.triangleSkinValues[this.triangleCount] = model_44_.triangleSkinValues[i1];
                    }
                    this.triangleColorValues[this.triangleCount] = model_44_.triangleColorValues[i1];
                    this.trianglePointsX[this.triangleCount] = this.getFirstIdenticalVertexIndex(
                      model_44_,
                      model_44_.trianglePointsX[i1]
                    );
                    this.trianglePointsY[this.triangleCount] = this.getFirstIdenticalVertexIndex(
                      model_44_,
                      model_44_.trianglePointsY[i1]
                    );
                    this.trianglePointsZ[this.triangleCount] = this.getFirstIdenticalVertexIndex(
                      model_44_,
                      model_44_.trianglePointsZ[i1]
                    );
                    this.triangleCount++;
                  }
                }
                for (let k1 = 0; k1 < model_44_.texturedTriangleCount; k1++) {
                  {
                    this.texturedTrianglePointsX[this.texturedTriangleCount] = this.getFirstIdenticalVertexIndex(
                      model_44_,
                      model_44_.texturedTrianglePointsX[k1]
                    );
                    this.texturedTrianglePointsY[this.texturedTriangleCount] = this.getFirstIdenticalVertexIndex(
                      model_44_,
                      model_44_.texturedTrianglePointsY[k1]
                    );
                    this.texturedTrianglePointsZ[this.texturedTriangleCount] = this.getFirstIdenticalVertexIndex(
                      model_44_,
                      model_44_.texturedTrianglePointsZ[k1]
                    );
                    this.texturedTriangleCount++;
                  }
                }
                k += model_44_.texturedTriangleCount;
              }
            }
          }
        })();
      } else if ((typeof flag === "number" || flag === null) && flag1 === void 0 && i === void 0 && class50_sub1_sub4_sub4 === void 0) {
        const __args = arguments;
        const modelId = __args[0];
        __super();
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        this.anInt1636 = 932;
        this.anInt1637 = 426;
        this.aBoolean1638 = false;
        this.aBoolean1639 = true;
        this.anInt1640 = -252;
        this.aBoolean1641 = false;
        this.oneSquareModel = false;
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        (() => {
          this.aBoolean1638 = false;
          this.aBoolean1639 = true;
          this.anInt1640 = -252;
          _Model.anInt1642;
          _Model.anInt1642++;
          const modelHeader = _Model.modelHeaders[modelId];
          this.vertexCount = modelHeader.vertexCount;
          this.triangleCount = modelHeader.triangleCount;
          this.texturedTriangleCount = modelHeader.texturedTriangleCount;
          this.verticesX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.verticesY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.verticesZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.vertexCount);
          this.trianglePointsX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.trianglePointsY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.trianglePointsZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          this.texturedTrianglePointsX = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.texturedTriangleCount);
          this.texturedTrianglePointsY = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.texturedTriangleCount);
          this.texturedTrianglePointsZ = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.texturedTriangleCount);
          if (modelHeader.vertexSkinOffset >= 0) {
            this.vertexSkins = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.vertexCount);
          }
          if (modelHeader.texturePointerOffset >= 0) {
            this.texturePoints = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          if (modelHeader.trianglePriorityOffset >= 0) {
            this.trianglePriorities = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          } else {
            this.anInt1663 = -modelHeader.trianglePriorityOffset - 1;
          }
          if (modelHeader.triangleAlphaOffset >= 0) {
            this.triangleAlphaValues = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          if (modelHeader.triangleSkinOffset >= 0) {
            this.triangleSkinValues = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(this.triangleCount);
          }
          this.triangleColorValues = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount);
          const vertexDirectionOffsetBuffer = new Buffer3(modelHeader.modelData);
          vertexDirectionOffsetBuffer.currentPosition = modelHeader.vertexDirectionOffset;
          const xDataOffsetBuffer = new Buffer3(modelHeader.modelData);
          xDataOffsetBuffer.currentPosition = modelHeader.xDataOffset;
          const yDataOffsetBuffer = new Buffer3(modelHeader.modelData);
          yDataOffsetBuffer.currentPosition = modelHeader.yDataOffset;
          const zDataOffsetBuffer = new Buffer3(modelHeader.modelData);
          zDataOffsetBuffer.currentPosition = modelHeader.zDataOffset;
          const vertexSkinOffsetBuffer = new Buffer3(modelHeader.modelData);
          vertexSkinOffsetBuffer.currentPosition = modelHeader.vertexSkinOffset;
          let baseOffsetX = 0;
          let baseOffsetY = 0;
          let baseOffsetz = 0;
          for (let vertex = 0; vertex < this.vertexCount; vertex++) {
            {
              const flag2 = vertexDirectionOffsetBuffer.getUnsignedByte();
              let currentOffsetX = 0;
              if ((flag2 & 1) !== 0) {
                currentOffsetX = xDataOffsetBuffer.getSignedSmart();
              }
              let currentOffsetY = 0;
              if ((flag2 & 2) !== 0) {
                currentOffsetY = yDataOffsetBuffer.getSignedSmart();
              }
              let currentOffsetZ = 0;
              if ((flag2 & 4) !== 0) {
                currentOffsetZ = zDataOffsetBuffer.getSignedSmart();
              }
              this.verticesX[vertex] = baseOffsetX + currentOffsetX;
              this.verticesY[vertex] = baseOffsetY + currentOffsetY;
              this.verticesZ[vertex] = baseOffsetz + currentOffsetZ;
              baseOffsetX = this.verticesX[vertex];
              baseOffsetY = this.verticesY[vertex];
              baseOffsetz = this.verticesZ[vertex];
              if (this.vertexSkins != null) {
                this.vertexSkins[vertex] = vertexSkinOffsetBuffer.getUnsignedByte();
              }
            }
          }
          vertexDirectionOffsetBuffer.currentPosition = modelHeader.colorDataOffset;
          xDataOffsetBuffer.currentPosition = modelHeader.texturePointerOffset;
          yDataOffsetBuffer.currentPosition = modelHeader.trianglePriorityOffset;
          zDataOffsetBuffer.currentPosition = modelHeader.triangleAlphaOffset;
          vertexSkinOffsetBuffer.currentPosition = modelHeader.triangleSkinOffset;
          for (let l1 = 0; l1 < this.triangleCount; l1++) {
            {
              this.triangleColorValues[l1] = vertexDirectionOffsetBuffer.getUnsignedLEShort();
              if (this.texturePoints != null) {
                this.texturePoints[l1] = xDataOffsetBuffer.getUnsignedByte();
              }
              if (this.trianglePriorities != null) {
                this.trianglePriorities[l1] = yDataOffsetBuffer.getUnsignedByte();
              }
              if (this.triangleAlphaValues != null) {
                this.triangleAlphaValues[l1] = zDataOffsetBuffer.getUnsignedByte();
              }
              if (this.triangleSkinValues != null) {
                this.triangleSkinValues[l1] = vertexSkinOffsetBuffer.getUnsignedByte();
              }
            }
          }
          vertexDirectionOffsetBuffer.currentPosition = modelHeader.triangleDataOffset;
          xDataOffsetBuffer.currentPosition = modelHeader.triangleTypeOffset;
          let trianglePointOffsetX = 0;
          let trianglePointOffsetY = 0;
          let trianglePointOffsetZ = 0;
          let offset = 0;
          for (let triangle = 0; triangle < this.triangleCount; triangle++) {
            {
              const type = xDataOffsetBuffer.getUnsignedByte();
              if (type === 1) {
                trianglePointOffsetX = vertexDirectionOffsetBuffer.getSignedSmart() + offset;
                offset = trianglePointOffsetX;
                trianglePointOffsetY = vertexDirectionOffsetBuffer.getSignedSmart() + offset;
                offset = trianglePointOffsetY;
                trianglePointOffsetZ = vertexDirectionOffsetBuffer.getSignedSmart() + offset;
                offset = trianglePointOffsetZ;
                this.trianglePointsX[triangle] = trianglePointOffsetX;
                this.trianglePointsY[triangle] = trianglePointOffsetY;
                this.trianglePointsZ[triangle] = trianglePointOffsetZ;
              }
              if (type === 2) {
                trianglePointOffsetY = trianglePointOffsetZ;
                trianglePointOffsetZ = vertexDirectionOffsetBuffer.getSignedSmart() + offset;
                offset = trianglePointOffsetZ;
                this.trianglePointsX[triangle] = trianglePointOffsetX;
                this.trianglePointsY[triangle] = trianglePointOffsetY;
                this.trianglePointsZ[triangle] = trianglePointOffsetZ;
              }
              if (type === 3) {
                trianglePointOffsetX = trianglePointOffsetZ;
                trianglePointOffsetZ = vertexDirectionOffsetBuffer.getSignedSmart() + offset;
                offset = trianglePointOffsetZ;
                this.trianglePointsX[triangle] = trianglePointOffsetX;
                this.trianglePointsY[triangle] = trianglePointOffsetY;
                this.trianglePointsZ[triangle] = trianglePointOffsetZ;
              }
              if (type === 4) {
                const oldTrianglePointOffsetX = trianglePointOffsetX;
                trianglePointOffsetX = trianglePointOffsetY;
                trianglePointOffsetY = oldTrianglePointOffsetX;
                trianglePointOffsetZ = vertexDirectionOffsetBuffer.getSignedSmart() + offset;
                offset = trianglePointOffsetZ;
                this.trianglePointsX[triangle] = trianglePointOffsetX;
                this.trianglePointsY[triangle] = trianglePointOffsetY;
                this.trianglePointsZ[triangle] = trianglePointOffsetZ;
              }
            }
          }
          vertexDirectionOffsetBuffer.currentPosition = modelHeader.uvMapTriangleOffset;
          for (let triangle = 0; triangle < this.texturedTriangleCount; triangle++) {
            {
              this.texturedTrianglePointsX[triangle] = vertexDirectionOffsetBuffer.getUnsignedLEShort();
              this.texturedTrianglePointsY[triangle] = vertexDirectionOffsetBuffer.getUnsignedLEShort();
              this.texturedTrianglePointsZ[triangle] = vertexDirectionOffsetBuffer.getUnsignedLEShort();
            }
          }
        })();
      } else if (flag === void 0 && flag1 === void 0 && i === void 0 && class50_sub1_sub4_sub4 === void 0) {
        const __args = arguments;
        __super();
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
        this.anInt1636 = 932;
        this.anInt1637 = 426;
        this.aBoolean1638 = false;
        this.aBoolean1639 = true;
        this.anInt1640 = -252;
        this.aBoolean1641 = false;
        this.oneSquareModel = false;
        if (this.vertexCount === void 0) {
          this.vertexCount = 0;
        }
        if (this.verticesX === void 0) {
          this.verticesX = null;
        }
        if (this.verticesY === void 0) {
          this.verticesY = null;
        }
        if (this.verticesZ === void 0) {
          this.verticesZ = null;
        }
        if (this.triangleCount === void 0) {
          this.triangleCount = 0;
        }
        if (this.trianglePointsX === void 0) {
          this.trianglePointsX = null;
        }
        if (this.trianglePointsY === void 0) {
          this.trianglePointsY = null;
        }
        if (this.trianglePointsZ === void 0) {
          this.trianglePointsZ = null;
        }
        if (this.anIntArray1656 === void 0) {
          this.anIntArray1656 = null;
        }
        if (this.anIntArray1657 === void 0) {
          this.anIntArray1657 = null;
        }
        if (this.anIntArray1658 === void 0) {
          this.anIntArray1658 = null;
        }
        if (this.texturePoints === void 0) {
          this.texturePoints = null;
        }
        if (this.trianglePriorities === void 0) {
          this.trianglePriorities = null;
        }
        if (this.triangleAlphaValues === void 0) {
          this.triangleAlphaValues = null;
        }
        if (this.triangleColorValues === void 0) {
          this.triangleColorValues = null;
        }
        if (this.anInt1663 === void 0) {
          this.anInt1663 = 0;
        }
        if (this.texturedTriangleCount === void 0) {
          this.texturedTriangleCount = 0;
        }
        if (this.texturedTrianglePointsX === void 0) {
          this.texturedTrianglePointsX = null;
        }
        if (this.texturedTrianglePointsY === void 0) {
          this.texturedTrianglePointsY = null;
        }
        if (this.texturedTrianglePointsZ === void 0) {
          this.texturedTrianglePointsZ = null;
        }
        if (this.anInt1668 === void 0) {
          this.anInt1668 = 0;
        }
        if (this.anInt1669 === void 0) {
          this.anInt1669 = 0;
        }
        if (this.anInt1670 === void 0) {
          this.anInt1670 = 0;
        }
        if (this.shadowIntensity === void 0) {
          this.shadowIntensity = 0;
        }
        if (this.maxY === void 0) {
          this.maxY = 0;
        }
        if (this.anInt1673 === void 0) {
          this.anInt1673 = 0;
        }
        if (this.anInt1674 === void 0) {
          this.anInt1674 = 0;
        }
        if (this.anInt1675 === void 0) {
          this.anInt1675 = 0;
        }
        if (this.vertexSkins === void 0) {
          this.vertexSkins = null;
        }
        if (this.triangleSkinValues === void 0) {
          this.triangleSkinValues = null;
        }
        if (this.vectorSkin === void 0) {
          this.vectorSkin = null;
        }
        if (this.triangleSkin === void 0) {
          this.triangleSkin = null;
        }
        if (this.aClass40Array1681 === void 0) {
          this.aClass40Array1681 = null;
        }
      } else {
        throw new Error("invalid overload");
      }
    }
    static reset() {
      _Model.modelHeaders = null;
      _Model.aBooleanArray1684 = null;
      _Model.aBooleanArray1685 = null;
      _Model.anIntArray1686 = null;
      _Model.anIntArray1687 = null;
      _Model.anIntArray1688 = null;
      _Model.anIntArray1689 = null;
      _Model.anIntArray1690 = null;
      _Model.anIntArray1691 = null;
      _Model.anIntArray1692 = null;
      _Model.anIntArrayArray1693 = null;
      _Model.anIntArray1694 = null;
      _Model.anIntArrayArray1695 = null;
      _Model.anIntArray1696 = null;
      _Model.anIntArray1697 = null;
      _Model.anIntArray1698 = null;
      _Model.SINE = null;
      _Model.COSINE = null;
      _Model.anIntArray1712 = null;
      _Model.anIntArray1713 = null;
    }
    static init(modelCount, requester) {
      _Model.modelHeaders = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(modelCount);
      _Model.requester = requester;
    }
    static loadModelHeader(modelData, modelId) {
      if (modelData == null) {
        const modelHeader2 = _Model.modelHeaders[modelId] = new ModelHeader();
        modelHeader2.vertexCount = 0;
        modelHeader2.triangleCount = 0;
        modelHeader2.texturedTriangleCount = 0;
        return;
      }
      const buffer = new Buffer3(modelData);
      buffer.currentPosition = modelData.length - 18;
      const modelHeader = _Model.modelHeaders[modelId] = new ModelHeader();
      modelHeader.modelData = modelData;
      modelHeader.vertexCount = buffer.getUnsignedLEShort();
      modelHeader.triangleCount = buffer.getUnsignedLEShort();
      modelHeader.texturedTriangleCount = buffer.getUnsignedByte();
      const useTextures = buffer.getUnsignedByte();
      const useTrianglePriority = buffer.getUnsignedByte();
      const useTransparency = buffer.getUnsignedByte();
      const useTriangleSkinning = buffer.getUnsignedByte();
      const useVertexSkinning = buffer.getUnsignedByte();
      const xDataLength = buffer.getUnsignedLEShort();
      const yDataLength = buffer.getUnsignedLEShort();
      const zDataLength = buffer.getUnsignedLEShort();
      const triangleDataLength = buffer.getUnsignedLEShort();
      let offset = 0;
      modelHeader.vertexDirectionOffset = offset;
      offset += modelHeader.vertexCount;
      modelHeader.triangleTypeOffset = offset;
      offset += modelHeader.triangleCount;
      modelHeader.trianglePriorityOffset = offset;
      if (useTrianglePriority === 255) {
        offset += modelHeader.triangleCount;
      } else {
        modelHeader.trianglePriorityOffset = -useTrianglePriority - 1;
      }
      modelHeader.triangleSkinOffset = offset;
      if (useTriangleSkinning === 1) {
        offset += modelHeader.triangleCount;
      } else {
        modelHeader.triangleSkinOffset = -1;
      }
      modelHeader.texturePointerOffset = offset;
      if (useTextures === 1) {
        offset += modelHeader.triangleCount;
      } else {
        modelHeader.texturePointerOffset = -1;
      }
      modelHeader.vertexSkinOffset = offset;
      if (useVertexSkinning === 1) {
        offset += modelHeader.vertexCount;
      } else {
        modelHeader.vertexSkinOffset = -1;
      }
      modelHeader.triangleAlphaOffset = offset;
      if (useTransparency === 1) {
        offset += modelHeader.triangleCount;
      } else {
        modelHeader.triangleAlphaOffset = -1;
      }
      modelHeader.triangleDataOffset = offset;
      offset += triangleDataLength;
      modelHeader.colorDataOffset = offset;
      offset += modelHeader.triangleCount * 2;
      modelHeader.uvMapTriangleOffset = offset;
      offset += modelHeader.texturedTriangleCount * 6;
      modelHeader.xDataOffset = offset;
      offset += xDataLength;
      modelHeader.yDataOffset = offset;
      offset += yDataLength;
      modelHeader.zDataOffset = offset;
      offset += zDataLength;
    }
    static resetModel(model) {
      _Model.modelHeaders[model] = null;
    }
    static getModel(model) {
      if (_Model.modelHeaders == null) {
        return null;
      }
      const modelHeader = _Model.modelHeaders[model];
      if (modelHeader == null) {
        _Model.requester.requestModel(model);
        return null;
      } else {
        return new _Model(model);
      }
    }
    static loaded(id) {
      if (_Model.modelHeaders == null) {
        return false;
      }
      const modelHeader = _Model.modelHeaders[id];
      if (modelHeader == null) {
        _Model.requester.requestModel(id);
        return false;
      } else {
        return true;
      }
    }
    static method597(i, j, k) {
      if ((k & 2) === 2) {
        if (j < 0) {
          j = 0;
        } else if (j > 127) {
          j = 127;
        }
        j = 127 - j;
        return j;
      }
      j = j * (i & 127) >> 7;
      if (j < 2) {
        j = 2;
      } else if (j > 126) {
        j = 126;
      }
      return (i & 65408) + j;
    }
    replaceWithModel(model, replaceAlphaValues) {
      this.vertexCount = model.vertexCount;
      this.triangleCount = model.triangleCount;
      this.texturedTriangleCount = model.texturedTriangleCount;
      if (_Model.anIntArray1644.length < this.vertexCount) {
        _Model.anIntArray1644 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(this.vertexCount + 100);
        _Model.anIntArray1645 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(this.vertexCount + 100);
        _Model.anIntArray1646 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(this.vertexCount + 100);
      }
      this.verticesX = _Model.anIntArray1644;
      this.verticesY = _Model.anIntArray1645;
      this.verticesZ = _Model.anIntArray1646;
      for (let vertex = 0; vertex < this.vertexCount; vertex++) {
        {
          this.verticesX[vertex] = model.verticesX[vertex];
          this.verticesY[vertex] = model.verticesY[vertex];
          this.verticesZ[vertex] = model.verticesZ[vertex];
        }
      }
      if (replaceAlphaValues) {
        this.triangleAlphaValues = model.triangleAlphaValues;
      } else {
        if (_Model.anIntArray1647.length < this.triangleCount) {
          _Model.anIntArray1647 = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(this.triangleCount + 100);
        }
        this.triangleAlphaValues = _Model.anIntArray1647;
        if (model.triangleAlphaValues == null) {
          for (let triangle = 0; triangle < this.triangleCount; triangle++) {
            this.triangleAlphaValues[triangle] = 0;
          }
        } else {
          for (let triangle = 0; triangle < this.triangleCount; triangle++) {
            this.triangleAlphaValues[triangle] = model.triangleAlphaValues[triangle];
          }
        }
      }
      this.texturePoints = model.texturePoints;
      this.triangleColorValues = model.triangleColorValues;
      this.trianglePriorities = model.trianglePriorities;
      this.anInt1663 = model.anInt1663;
      this.triangleSkin = model.triangleSkin;
      this.vectorSkin = model.vectorSkin;
      this.trianglePointsX = model.trianglePointsX;
      this.trianglePointsY = model.trianglePointsY;
      this.trianglePointsZ = model.trianglePointsZ;
      this.anIntArray1656 = model.anIntArray1656;
      this.anIntArray1657 = model.anIntArray1657;
      this.anIntArray1658 = model.anIntArray1658;
      this.texturedTrianglePointsX = model.texturedTrianglePointsX;
      this.texturedTrianglePointsY = model.texturedTrianglePointsY;
      this.texturedTrianglePointsZ = model.texturedTrianglePointsZ;
    }
    getFirstIdenticalVertexIndex(model, vertex) {
      let identicalVertexIndex = -1;
      const vertexX = model.verticesX[vertex];
      const vertexY = model.verticesY[vertex];
      const vertexZ = model.verticesZ[vertex];
      for (let index = 0; index < this.vertexCount; index++) {
        {
          if (vertexX !== this.verticesX[index] || vertexY !== this.verticesY[index] || vertexZ !== this.verticesZ[index]) {
            continue;
          }
          identicalVertexIndex = index;
          break;
        }
      }
      if (identicalVertexIndex === -1) {
        this.verticesX[this.vertexCount] = vertexX;
        this.verticesY[this.vertexCount] = vertexY;
        this.verticesZ[this.vertexCount] = vertexZ;
        if (model.vertexSkins != null) {
          this.vertexSkins[this.vertexCount] = model.vertexSkins[vertex];
        }
        identicalVertexIndex = this.vertexCount++;
      }
      return identicalVertexIndex;
    }
    calculateDiagonals() {
      this.modelHeight = 0;
      this.shadowIntensity = 0;
      this.maxY = 0;
      for (let vertex = 0; vertex < this.vertexCount; vertex++) {
        {
          const vertexX = this.verticesX[vertex];
          const vertexY = this.verticesY[vertex];
          const vertexZ = this.verticesZ[vertex];
          if (-vertexY > this.modelHeight) {
            this.modelHeight = -vertexY;
          }
          if (vertexY > this.maxY) {
            this.maxY = vertexY;
          }
          const j1 = vertexX * vertexX + vertexZ * vertexZ;
          if (j1 > this.shadowIntensity) {
            this.shadowIntensity = j1;
          }
        }
      }
      this.shadowIntensity = Math.sqrt(this.shadowIntensity) + 0.99 | 0;
      this.anInt1674 = Math.sqrt(this.shadowIntensity * this.shadowIntensity + this.modelHeight * this.modelHeight) + 0.99 | 0;
      this.anInt1673 = this.anInt1674 + (Math.sqrt(this.shadowIntensity * this.shadowIntensity + this.maxY * this.maxY) + 0.99 | 0);
    }
    normalise() {
      this.modelHeight = 0;
      this.maxY = 0;
      for (let j = 0; j < this.vertexCount; j++) {
        {
          const k = this.verticesY[j];
          if (-k > this.modelHeight) {
            this.modelHeight = -k;
          }
          if (k > this.maxY) {
            this.maxY = k;
          }
        }
      }
      this.anInt1674 = Math.sqrt(this.shadowIntensity * this.shadowIntensity + this.modelHeight * this.modelHeight) + 0.99 | 0;
      this.anInt1673 = this.anInt1674 + (Math.sqrt(this.shadowIntensity * this.shadowIntensity + this.maxY * this.maxY) + 0.99 | 0);
    }
    method583(i) {
      this.modelHeight = 0;
      this.shadowIntensity = 0;
      this.maxY = 0;
      let j = 32767;
      let k = -32767;
      let l = -32767;
      let i1 = 32767;
      for (let j1 = 0; j1 < this.vertexCount; j1++) {
        {
          const k1 = this.verticesX[j1];
          const l1 = this.verticesY[j1];
          const i2 = this.verticesZ[j1];
          if (k1 < j) {
            j = k1;
          }
          if (k1 > k) {
            k = k1;
          }
          if (i2 < i1) {
            i1 = i2;
          }
          if (i2 > l) {
            l = i2;
          }
          if (-l1 > this.modelHeight) {
            this.modelHeight = -l1;
          }
          if (l1 > this.maxY) {
            this.maxY = l1;
          }
          const j2 = k1 * k1 + i2 * i2;
          if (j2 > this.shadowIntensity) {
            this.shadowIntensity = j2;
          }
        }
      }
      this.shadowIntensity = Math.sqrt(this.shadowIntensity) | 0;
      this.anInt1674 = Math.sqrt(this.shadowIntensity * this.shadowIntensity + this.modelHeight * this.modelHeight) | 0;
      this.anInt1673 = this.anInt1674 + (Math.sqrt(this.shadowIntensity * this.shadowIntensity + this.maxY * this.maxY) | 0);
      this.anInt1669 = (j << 16) + (k & 65535);
      if (i <= 0) {
        this.anInt1637 = 50;
      }
      this.anInt1670 = (l << 16) + (i1 & 65535);
    }
    createBones() {
      if (this.vertexSkins != null) {
        const ai = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(256);
        let j = 0;
        for (let l = 0; l < this.vertexCount; l++) {
          {
            const j1 = this.vertexSkins[l];
            ai[j1]++;
            if (j1 > j) {
              j = j1;
            }
          }
        }
        this.vectorSkin = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(j + 1);
        for (let k1 = 0; k1 <= j; k1++) {
          {
            this.vectorSkin[k1] = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(ai[k1]);
            ai[k1] = 0;
          }
        }
        for (let j2 = 0; j2 < this.vertexCount; j2++) {
          {
            const l2 = this.vertexSkins[j2];
            this.vectorSkin[l2][ai[l2]++] = j2;
          }
        }
        this.vertexSkins = null;
      }
      if (this.triangleSkinValues != null) {
        const ai1 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(256);
        let k = 0;
        for (let i1 = 0; i1 < this.triangleCount; i1++) {
          {
            const l1 = this.triangleSkinValues[i1];
            ai1[l1]++;
            if (l1 > k) {
              k = l1;
            }
          }
        }
        this.triangleSkin = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(k + 1);
        for (let i2 = 0; i2 <= k; i2++) {
          {
            this.triangleSkin[i2] = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(ai1[i2]);
            ai1[i2] = 0;
          }
        }
        for (let k2 = 0; k2 < this.triangleCount; k2++) {
          {
            const i3 = this.triangleSkinValues[k2];
            this.triangleSkin[i3][ai1[i3]++] = k2;
          }
        }
        this.triangleSkinValues = null;
      }
    }
    applyTransform(frameId) {
      if (this.vectorSkin == null) {
        return;
      }
      if (frameId === -1) {
        return;
      }
      const animation = Animation.getAnimation(frameId);
      if (animation == null) {
        return;
      }
      const skins = animation.animationSkins;
      _Model.vertexXModifier = 0;
      _Model.vertexYModifier = 0;
      _Model.vertexZModifier = 0;
      for (let stepId = 0; stepId < animation.anInt433; stepId++) {
        {
          const opcode = animation.opcodeTable[stepId];
          this.transformStep(
            skins.opcodes[opcode],
            skins.skinList[opcode],
            animation.modifier1[stepId],
            animation.modifier2[stepId],
            animation.modifier3[stepId]
          );
        }
      }
    }
    mixAnimationFrames(i, j, k, ai) {
      if (k === -1) {
        return;
      }
      if (ai == null || i === -1) {
        this.applyTransform(k);
        return;
      }
      const animation = Animation.getAnimation(k);
      if (animation == null) {
        return;
      }
      const animation_1 = Animation.getAnimation(i);
      if (animation_1 == null) {
        this.applyTransform(k);
        return;
      }
      const skins = animation.animationSkins;
      _Model.vertexXModifier = 0;
      if (j !== 0) {
        this.aBoolean1641 = !this.aBoolean1641;
      }
      _Model.vertexYModifier = 0;
      _Model.vertexZModifier = 0;
      let l = 0;
      let i1 = ai[l++];
      for (let j1 = 0; j1 < animation.anInt433; j1++) {
        {
          let k1;
          for (k1 = animation.opcodeTable[j1]; k1 > i1; i1 = ai[l++]) {
          }
          if (k1 !== i1 || skins.opcodes[k1] === 0) {
            this.transformStep(
              skins.opcodes[k1],
              skins.skinList[k1],
              animation.modifier1[j1],
              animation.modifier2[j1],
              animation.modifier3[j1]
            );
          }
        }
      }
      _Model.vertexXModifier = 0;
      _Model.vertexYModifier = 0;
      _Model.vertexZModifier = 0;
      l = 0;
      i1 = ai[l++];
      for (let l1 = 0; l1 < animation_1.anInt433; l1++) {
        {
          let i2;
          for (i2 = animation_1.opcodeTable[l1]; i2 > i1; i1 = ai[l++]) {
          }
          if (i2 === i1 || skins.opcodes[i2] === 0) {
            this.transformStep(
              skins.opcodes[i2],
              skins.skinList[i2],
              animation_1.modifier1[l1],
              animation_1.modifier2[l1],
              animation_1.modifier3[l1]
            );
          }
        }
      }
    }
    transformStep(i, ai, j, k, l) {
      const i1 = ai.length;
      if (i === 0) {
        let j1 = 0;
        _Model.vertexXModifier = 0;
        _Model.vertexYModifier = 0;
        _Model.vertexZModifier = 0;
        for (let k2 = 0; k2 < i1; k2++) {
          {
            const l3 = ai[k2];
            if (l3 < this.vectorSkin.length) {
              const ai5 = this.vectorSkin[l3];
              for (let i5 = 0; i5 < ai5.length; i5++) {
                {
                  const j6 = ai5[i5];
                  _Model.vertexXModifier = _Model.vertexXModifier + this.verticesX[j6];
                  _Model.vertexYModifier = _Model.vertexYModifier + this.verticesY[j6];
                  _Model.vertexZModifier = _Model.vertexZModifier + this.verticesZ[j6];
                  j1++;
                }
              }
            }
          }
        }
        if (j1 > 0) {
          _Model.vertexXModifier = (_Model.vertexXModifier / j1 | 0) + j;
          _Model.vertexYModifier = (_Model.vertexYModifier / j1 | 0) + k;
          _Model.vertexZModifier = (_Model.vertexZModifier / j1 | 0) + l;
          return;
        } else {
          _Model.vertexXModifier = j;
          _Model.vertexYModifier = k;
          _Model.vertexZModifier = l;
          return;
        }
      }
      if (i === 1) {
        for (let k1 = 0; k1 < i1; k1++) {
          {
            const l2 = ai[k1];
            if (l2 < this.vectorSkin.length) {
              const ai1 = this.vectorSkin[l2];
              for (let i4 = 0; i4 < ai1.length; i4++) {
                {
                  const j5 = ai1[i4];
                  this.verticesX[j5] += j;
                  this.verticesY[j5] += k;
                  this.verticesZ[j5] += l;
                }
              }
            }
          }
        }
        return;
      }
      if (i === 2) {
        for (let l1 = 0; l1 < i1; l1++) {
          {
            const i3 = ai[l1];
            if (i3 < this.vectorSkin.length) {
              const ai2 = this.vectorSkin[i3];
              for (let j4 = 0; j4 < ai2.length; j4++) {
                {
                  const k5 = ai2[j4];
                  this.verticesX[k5] -= _Model.vertexXModifier;
                  this.verticesY[k5] -= _Model.vertexYModifier;
                  this.verticesZ[k5] -= _Model.vertexZModifier;
                  const k6 = (j & 255) * 8;
                  const l6 = (k & 255) * 8;
                  const i7 = (l & 255) * 8;
                  if (i7 !== 0) {
                    const j7 = _Model.SINE[i7];
                    const i8 = _Model.COSINE[i7];
                    const l8 = this.verticesY[k5] * j7 + this.verticesX[k5] * i8 >> 16;
                    this.verticesY[k5] = this.verticesY[k5] * i8 - this.verticesX[k5] * j7 >> 16;
                    this.verticesX[k5] = l8;
                  }
                  if (k6 !== 0) {
                    const k7 = _Model.SINE[k6];
                    const j8 = _Model.COSINE[k6];
                    const i9 = this.verticesY[k5] * j8 - this.verticesZ[k5] * k7 >> 16;
                    this.verticesZ[k5] = this.verticesY[k5] * k7 + this.verticesZ[k5] * j8 >> 16;
                    this.verticesY[k5] = i9;
                  }
                  if (l6 !== 0) {
                    const l7 = _Model.SINE[l6];
                    const k8 = _Model.COSINE[l6];
                    const j9 = this.verticesZ[k5] * l7 + this.verticesX[k5] * k8 >> 16;
                    this.verticesZ[k5] = this.verticesZ[k5] * k8 - this.verticesX[k5] * l7 >> 16;
                    this.verticesX[k5] = j9;
                  }
                  this.verticesX[k5] += _Model.vertexXModifier;
                  this.verticesY[k5] += _Model.vertexYModifier;
                  this.verticesZ[k5] += _Model.vertexZModifier;
                }
              }
            }
          }
        }
        return;
      }
      if (i === 3) {
        for (let i2 = 0; i2 < i1; i2++) {
          {
            const j3 = ai[i2];
            if (j3 < this.vectorSkin.length) {
              const ai3 = this.vectorSkin[j3];
              for (let k4 = 0; k4 < ai3.length; k4++) {
                {
                  const l5 = ai3[k4];
                  this.verticesX[l5] -= _Model.vertexXModifier;
                  this.verticesY[l5] -= _Model.vertexYModifier;
                  this.verticesZ[l5] -= _Model.vertexZModifier;
                  this.verticesX[l5] = this.verticesX[l5] * j / 128 | 0;
                  this.verticesY[l5] = this.verticesY[l5] * k / 128 | 0;
                  this.verticesZ[l5] = this.verticesZ[l5] * l / 128 | 0;
                  this.verticesX[l5] += _Model.vertexXModifier;
                  this.verticesY[l5] += _Model.vertexYModifier;
                  this.verticesZ[l5] += _Model.vertexZModifier;
                }
              }
            }
          }
        }
        return;
      }
      if (i === 5 && this.triangleSkin != null && this.triangleAlphaValues != null) {
        for (let j2 = 0; j2 < i1; j2++) {
          {
            const k3 = ai[j2];
            if (k3 < this.triangleSkin.length) {
              const ai4 = this.triangleSkin[k3];
              for (let l4 = 0; l4 < ai4.length; l4++) {
                {
                  const i6 = ai4[l4];
                  this.triangleAlphaValues[i6] += j * 8;
                  if (this.triangleAlphaValues[i6] < 0) {
                    this.triangleAlphaValues[i6] = 0;
                  }
                  if (this.triangleAlphaValues[i6] > 255) {
                    this.triangleAlphaValues[i6] = 255;
                  }
                }
              }
            }
          }
        }
      }
    }
    rotate90Degrees() {
      for (let i = 0; i < this.vertexCount; i++) {
        {
          const j = this.verticesX[i];
          this.verticesX[i] = this.verticesZ[i];
          this.verticesZ[i] = -j;
        }
      }
    }
    rotateX(i) {
      const k = _Model.SINE[i];
      const l = _Model.COSINE[i];
      for (let i1 = 0; i1 < this.vertexCount; i1++) {
        {
          const j1 = this.verticesY[i1] * l - this.verticesZ[i1] * k >> 16;
          this.verticesZ[i1] = this.verticesY[i1] * k + this.verticesZ[i1] * l >> 16;
          this.verticesY[i1] = j1;
        }
      }
    }
    translate(i, j, k) {
      for (let l = 0; l < this.vertexCount; l++) {
        {
          this.verticesX[l] += i;
          this.verticesY[l] += k;
          this.verticesZ[l] += j;
        }
      }
    }
    replaceColor(oldColor, newColor) {
      for (let i = 0; i < this.triangleCount; i++) {
        if (this.triangleColorValues[i] === oldColor) {
          this.triangleColorValues[i] = newColor;
        }
      }
    }
    mirror(i) {
      if (i !== 0) {
        for (let j = 1; j > 0; j++) {
        }
      }
      for (let k = 0; k < this.vertexCount; k++) {
        this.verticesZ[k] = -this.verticesZ[k];
      }
      for (let l = 0; l < this.triangleCount; l++) {
        {
          const i1 = this.trianglePointsX[l];
          this.trianglePointsX[l] = this.trianglePointsZ[l];
          this.trianglePointsZ[l] = i1;
        }
      }
    }
    scaleT(i, j, k, l) {
      for (let i1 = 0; i1 < this.vertexCount; i1++) {
        {
          this.verticesX[i1] = this.verticesX[i1] * l / 128 | 0;
          this.verticesY[i1] = this.verticesY[i1] * i / 128 | 0;
          this.verticesZ[i1] = this.verticesZ[i1] * j / 128 | 0;
        }
      }
      if (k !== 9) {
        this.anInt1636 = 322;
      }
    }
    applyLighting(i, j, k, l, i1, flag) {
      const j1 = Math.sqrt(k * k + l * l + i1 * i1) | 0;
      const k1 = j * j1 >> 8;
      if (this.anIntArray1656 == null) {
        this.anIntArray1656 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(this.triangleCount);
        this.anIntArray1657 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(this.triangleCount);
        this.anIntArray1658 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(this.triangleCount);
      }
      if (this.verticesNormal == null) {
        this.verticesNormal = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(this.vertexCount);
        for (let l1 = 0; l1 < this.vertexCount; l1++) {
          this.verticesNormal[l1] = new VertexNormal();
        }
      }
      for (let i2 = 0; i2 < this.triangleCount; i2++) {
        {
          const j2 = this.trianglePointsX[i2];
          const l2 = this.trianglePointsY[i2];
          const i3 = this.trianglePointsZ[i2];
          const j3 = this.verticesX[l2] - this.verticesX[j2];
          const k3 = this.verticesY[l2] - this.verticesY[j2];
          const l3 = this.verticesZ[l2] - this.verticesZ[j2];
          const i4 = this.verticesX[i3] - this.verticesX[j2];
          const j4 = this.verticesY[i3] - this.verticesY[j2];
          const k4 = this.verticesZ[i3] - this.verticesZ[j2];
          let l4 = k3 * k4 - j4 * l3;
          let i5 = l3 * i4 - k4 * j3;
          let j5;
          for (j5 = j3 * j4 - i4 * k3; l4 > 8192 || i5 > 8192 || j5 > 8192 || l4 < -8192 || i5 < -8192 || j5 < -8192; j5 >>= 1) {
            {
              l4 >>= 1;
              i5 >>= 1;
            }
          }
          let k5 = Math.sqrt(l4 * l4 + i5 * i5 + j5 * j5) | 0;
          if (k5 <= 0) {
            k5 = 1;
          }
          l4 = l4 * 256 / k5 | 0;
          i5 = i5 * 256 / k5 | 0;
          j5 = j5 * 256 / k5 | 0;
          if (this.texturePoints == null || (this.texturePoints[i2] & 1) === 0) {
            let class40_2 = this.verticesNormal[j2];
            class40_2.x += l4;
            class40_2.y += i5;
            class40_2.z += j5;
            class40_2.magnitude++;
            class40_2 = this.verticesNormal[l2];
            class40_2.x += l4;
            class40_2.y += i5;
            class40_2.z += j5;
            class40_2.magnitude++;
            class40_2 = this.verticesNormal[i3];
            class40_2.x += l4;
            class40_2.y += i5;
            class40_2.z += j5;
            class40_2.magnitude++;
          } else {
            const l5 = i + ((k * l4 + l * i5 + i1 * j5) / (k1 + (k1 / 2 | 0)) | 0);
            this.anIntArray1656[i2] = _Model.method597(this.triangleColorValues[i2], l5, this.texturePoints[i2]);
          }
        }
      }
      if (flag) {
        this.method596(i, k1, k, l, i1);
      } else {
        this.aClass40Array1681 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(this.vertexCount);
        for (let k2 = 0; k2 < this.vertexCount; k2++) {
          {
            const class40 = this.verticesNormal[k2];
            const class40_1 = this.aClass40Array1681[k2] = new VertexNormal();
            class40_1.x = class40.x;
            class40_1.y = class40.y;
            class40_1.z = class40.z;
            class40_1.magnitude = class40.magnitude;
          }
        }
        this.anInt1668 = (i << 16) + (k1 & 65535);
      }
      if (flag) {
        this.calculateDiagonals();
        return;
      } else {
        this.method583(426);
        return;
      }
    }
    method595(i, j, k, l) {
      const i1 = this.anInt1668 >> 16;
      const j1 = this.anInt1668 << 16 >> 16;
      if (k !== 0) {
        for (let k1 = 1; k1 > 0; k1++) {
        }
      }
      this.method596(i1, j1, l, i, j);
    }
    method596(i, j, k, l, i1) {
      for (let j1 = 0; j1 < this.triangleCount; j1++) {
        {
          const k1 = this.trianglePointsX[j1];
          const i2 = this.trianglePointsY[j1];
          const j2 = this.trianglePointsZ[j1];
          if (this.texturePoints == null) {
            const i3 = this.triangleColorValues[j1];
            let class40 = this.verticesNormal[k1];
            let k2 = i + ((k * class40.x + l * class40.y + i1 * class40.z) / (j * class40.magnitude) | 0);
            this.anIntArray1656[j1] = _Model.method597(i3, k2, 0);
            class40 = this.verticesNormal[i2];
            k2 = i + ((k * class40.x + l * class40.y + i1 * class40.z) / (j * class40.magnitude) | 0);
            this.anIntArray1657[j1] = _Model.method597(i3, k2, 0);
            class40 = this.verticesNormal[j2];
            k2 = i + ((k * class40.x + l * class40.y + i1 * class40.z) / (j * class40.magnitude) | 0);
            this.anIntArray1658[j1] = _Model.method597(i3, k2, 0);
          } else if ((this.texturePoints[j1] & 1) === 0) {
            const j3 = this.triangleColorValues[j1];
            const k3 = this.texturePoints[j1];
            let class40_1 = this.verticesNormal[k1];
            let l2 = i + ((k * class40_1.x + l * class40_1.y + i1 * class40_1.z) / (j * class40_1.magnitude) | 0);
            this.anIntArray1656[j1] = _Model.method597(j3, l2, k3);
            class40_1 = this.verticesNormal[i2];
            l2 = i + ((k * class40_1.x + l * class40_1.y + i1 * class40_1.z) / (j * class40_1.magnitude) | 0);
            this.anIntArray1657[j1] = _Model.method597(j3, l2, k3);
            class40_1 = this.verticesNormal[j2];
            l2 = i + ((k * class40_1.x + l * class40_1.y + i1 * class40_1.z) / (j * class40_1.magnitude) | 0);
            this.anIntArray1658[j1] = _Model.method597(j3, l2, k3);
          }
        }
      }
      this.verticesNormal = null;
      this.aClass40Array1681 = null;
      this.vertexSkins = null;
      this.triangleSkinValues = null;
      if (this.texturePoints != null) {
        for (let l1 = 0; l1 < this.triangleCount; l1++) {
          if ((this.texturePoints[l1] & 2) === 2) {
            return;
          }
        }
      }
      this.triangleColorValues = null;
    }
    render(i, j, k, l, i1, j1, k1) {
      const l1 = Rasterizer3D.centerX;
      const i2 = Rasterizer3D.centerY;
      const j2 = _Model.SINE[i];
      const k2 = _Model.COSINE[i];
      const l2 = _Model.SINE[j];
      const i3 = _Model.COSINE[j];
      const j3 = _Model.SINE[k];
      const k3 = _Model.COSINE[k];
      const l3 = _Model.SINE[l];
      const i4 = _Model.COSINE[l];
      const j4 = j1 * l3 + k1 * i4 >> 16;
      for (let k4 = 0; k4 < this.vertexCount; k4++) {
        {
          let l4 = this.verticesX[k4];
          let i5 = this.verticesY[k4];
          let j5 = this.verticesZ[k4];
          if (k !== 0) {
            const k5 = i5 * j3 + l4 * k3 >> 16;
            i5 = i5 * k3 - l4 * j3 >> 16;
            l4 = k5;
          }
          if (i !== 0) {
            const l5 = i5 * k2 - j5 * j2 >> 16;
            j5 = i5 * j2 + j5 * k2 >> 16;
            i5 = l5;
          }
          if (j !== 0) {
            const i6 = j5 * l2 + l4 * i3 >> 16;
            j5 = j5 * i3 - l4 * l2 >> 16;
            l4 = i6;
          }
          l4 += i1;
          i5 += j1;
          j5 += k1;
          const j6 = i5 * i4 - j5 * l3 >> 16;
          j5 = i5 * l3 + j5 * i4 >> 16;
          i5 = j6;
          _Model.anIntArray1688[k4] = j5 - j4;
          _Model.anIntArray1686[k4] = l1 + ((l4 << 9) / j5 | 0);
          _Model.anIntArray1687[k4] = i2 + ((i5 << 9) / j5 | 0);
          if (this.texturedTriangleCount > 0) {
            _Model.anIntArray1689[k4] = l4;
            _Model.anIntArray1690[k4] = i5;
            _Model.anIntArray1691[k4] = j5;
          }
        }
      }
      try {
        this.method599(false, false, 0);
        return;
      } catch (_ex) {
        return;
      }
    }
    renderAtPoint(i, j, k, l, i1, j1, k1, l1, i2) {
      const j2 = l1 * i1 - j1 * l >> 16;
      const k2 = k1 * j + j2 * k >> 16;
      const l2 = this.shadowIntensity * k >> 16;
      const i3 = k2 + l2;
      if (i3 <= 50 || k2 >= 3500) {
        return;
      }
      const j3 = l1 * l + j1 * i1 >> 16;
      let k3 = j3 - this.shadowIntensity << 9;
      if ((k3 / i3 | 0) >= Rasterizer.centerX) {
        return;
      }
      let l3 = j3 + this.shadowIntensity << 9;
      if ((l3 / i3 | 0) <= -Rasterizer.centerX) {
        return;
      }
      const i4 = k1 * k - j2 * j >> 16;
      const j4 = this.shadowIntensity * j >> 16;
      let k4 = i4 + j4 << 9;
      if ((k4 / i3 | 0) <= -Rasterizer.centerY) {
        return;
      }
      const l4 = j4 + (this.modelHeight * k >> 16);
      let i5 = i4 - l4 << 9;
      if ((i5 / i3 | 0) >= Rasterizer.centerY) {
        return;
      }
      const j5 = l2 + (this.modelHeight * j >> 16);
      let flag = false;
      if (k2 - j5 <= 50) {
        flag = true;
      }
      let flag1 = false;
      if (i2 > 0 && _Model.aBoolean1705) {
        let k5 = k2 - l2;
        if (k5 <= 50) {
          k5 = 50;
        }
        if (j3 > 0) {
          k3 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(k3 / i3);
          l3 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(l3 / k5);
        } else {
          l3 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(l3 / i3);
          k3 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(k3 / k5);
        }
        if (i4 > 0) {
          i5 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(i5 / i3);
          k4 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(k4 / k5);
        } else {
          k4 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(k4 / i3);
          i5 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(i5 / k5);
        }
        const i6 = _Model.anInt1706 - Rasterizer3D.centerX;
        const k6 = _Model.anInt1707 - Rasterizer3D.centerY;
        if (i6 > k3 && i6 < l3 && k6 > i5 && k6 < k4) {
          if (this.oneSquareModel) {
            _Model.anInt1708;
            _Model.anIntArray1709[_Model.anInt1708++] = i2;
          } else {
            flag1 = true;
          }
        }
      }
      const l5 = Rasterizer3D.centerX;
      const j6 = Rasterizer3D.centerY;
      let l6 = 0;
      let i7 = 0;
      if (i !== 0) {
        l6 = _Model.SINE[i];
        i7 = _Model.COSINE[i];
      }
      for (let j7 = 0; j7 < this.vertexCount; j7++) {
        {
          let k7 = this.verticesX[j7];
          let l7 = this.verticesY[j7];
          let i8 = this.verticesZ[j7];
          if (i !== 0) {
            const j8 = i8 * l6 + k7 * i7 >> 16;
            i8 = i8 * i7 - k7 * l6 >> 16;
            k7 = j8;
          }
          k7 += j1;
          l7 += k1;
          i8 += l1;
          let k8 = i8 * l + k7 * i1 >> 16;
          i8 = i8 * i1 - k7 * l >> 16;
          k7 = k8;
          k8 = l7 * k - i8 * j >> 16;
          i8 = l7 * j + i8 * k >> 16;
          l7 = k8;
          _Model.anIntArray1688[j7] = i8 - k2;
          if (i8 >= 50) {
            _Model.anIntArray1686[j7] = l5 + ((k7 << 9) / i8 | 0);
            _Model.anIntArray1687[j7] = j6 + ((l7 << 9) / i8 | 0);
          } else {
            _Model.anIntArray1686[j7] = -5e3;
            flag = true;
          }
          if (flag || this.texturedTriangleCount > 0) {
            _Model.anIntArray1689[j7] = k7;
            _Model.anIntArray1690[j7] = l7;
            _Model.anIntArray1691[j7] = i8;
          }
        }
      }
      try {
        this.method599(flag, flag1, i2);
        return;
      } catch (_ex) {
        return;
      }
    }
    method599(flag, flag1, i) {
      for (let j = 0; j < this.anInt1673; j++) {
        _Model.anIntArray1692[j] = 0;
      }
      for (let k = 0; k < this.triangleCount; k++) {
        if (this.texturePoints == null || this.texturePoints[k] !== -1) {
          const l = this.trianglePointsX[k];
          const k1 = this.trianglePointsY[k];
          const j2 = this.trianglePointsZ[k];
          const i3 = _Model.anIntArray1686[l];
          const l3 = _Model.anIntArray1686[k1];
          const k4 = _Model.anIntArray1686[j2];
          if (flag && (i3 === -5e3 || l3 === -5e3 || k4 === -5e3)) {
            _Model.aBooleanArray1685[k] = true;
            const j5 = ((_Model.anIntArray1688[l] + _Model.anIntArray1688[k1] + _Model.anIntArray1688[j2]) / 3 | 0) + this.anInt1674;
            _Model.anIntArrayArray1693[j5][_Model.anIntArray1692[j5]++] = k;
          } else {
            if (flag1 && this.method602(
              _Model.anInt1706,
              _Model.anInt1707,
              _Model.anIntArray1687[l],
              _Model.anIntArray1687[k1],
              _Model.anIntArray1687[j2],
              i3,
              l3,
              k4
            )) {
              _Model.anInt1708;
              _Model.anIntArray1709[_Model.anInt1708++] = i;
              flag1 = false;
            }
            if ((i3 - l3) * (_Model.anIntArray1687[j2] - _Model.anIntArray1687[k1]) - (_Model.anIntArray1687[l] - _Model.anIntArray1687[k1]) * (k4 - l3) > 0) {
              _Model.aBooleanArray1685[k] = false;
              if (i3 < 0 || l3 < 0 || k4 < 0 || i3 > Rasterizer.virtualBottomX || l3 > Rasterizer.virtualBottomX || k4 > Rasterizer.virtualBottomX) {
                _Model.aBooleanArray1684[k] = true;
              } else {
                _Model.aBooleanArray1684[k] = false;
              }
              const k5 = ((_Model.anIntArray1688[l] + _Model.anIntArray1688[k1] + _Model.anIntArray1688[j2]) / 3 | 0) + this.anInt1674;
              _Model.anIntArrayArray1693[k5][_Model.anIntArray1692[k5]++] = k;
            }
          }
        }
      }
      if (this.trianglePriorities == null) {
        for (let i1 = this.anInt1673 - 1; i1 >= 0; i1--) {
          {
            const l1 = _Model.anIntArray1692[i1];
            if (l1 > 0) {
              const ai = _Model.anIntArrayArray1693[i1];
              for (let j3 = 0; j3 < l1; j3++) {
                this.method600(ai[j3]);
              }
            }
          }
        }
        return;
      }
      for (let j1 = 0; j1 < 12; j1++) {
        {
          _Model.anIntArray1694[j1] = 0;
          _Model.anIntArray1698[j1] = 0;
        }
      }
      for (let i2 = this.anInt1673 - 1; i2 >= 0; i2--) {
        {
          const k2 = _Model.anIntArray1692[i2];
          if (k2 > 0) {
            const ai1 = _Model.anIntArrayArray1693[i2];
            for (let i4 = 0; i4 < k2; i4++) {
              {
                const l4 = ai1[i4];
                const l5 = this.trianglePriorities[l4];
                const j6 = _Model.anIntArray1694[l5]++;
                _Model.anIntArrayArray1695[l5][j6] = l4;
                if (l5 < 10) {
                  _Model.anIntArray1698[l5] += i2;
                } else if (l5 === 10) {
                  _Model.anIntArray1696[j6] = i2;
                } else {
                  _Model.anIntArray1697[j6] = i2;
                }
              }
            }
          }
        }
      }
      let l2 = 0;
      if (_Model.anIntArray1694[1] > 0 || _Model.anIntArray1694[2] > 0) {
        l2 = (_Model.anIntArray1698[1] + _Model.anIntArray1698[2]) / (_Model.anIntArray1694[1] + _Model.anIntArray1694[2]) | 0;
      }
      let k3 = 0;
      if (_Model.anIntArray1694[3] > 0 || _Model.anIntArray1694[4] > 0) {
        k3 = (_Model.anIntArray1698[3] + _Model.anIntArray1698[4]) / (_Model.anIntArray1694[3] + _Model.anIntArray1694[4]) | 0;
      }
      let j4 = 0;
      if (_Model.anIntArray1694[6] > 0 || _Model.anIntArray1694[8] > 0) {
        j4 = (_Model.anIntArray1698[6] + _Model.anIntArray1698[8]) / (_Model.anIntArray1694[6] + _Model.anIntArray1694[8]) | 0;
      }
      let i6 = 0;
      let k6 = _Model.anIntArray1694[10];
      let ai2 = _Model.anIntArrayArray1695[10];
      let ai3 = _Model.anIntArray1696;
      if (i6 === k6) {
        i6 = 0;
        k6 = _Model.anIntArray1694[11];
        ai2 = _Model.anIntArrayArray1695[11];
        ai3 = _Model.anIntArray1697;
      }
      let i5;
      if (i6 < k6) {
        i5 = ai3[i6];
      } else {
        i5 = -1e3;
      }
      for (let l6 = 0; l6 < 10; l6++) {
        {
          while (l6 === 0 && i5 > l2) {
            {
              this.method600(ai2[i6++]);
              if (i6 === k6 && ai2 !== _Model.anIntArrayArray1695[11]) {
                i6 = 0;
                k6 = _Model.anIntArray1694[11];
                ai2 = _Model.anIntArrayArray1695[11];
                ai3 = _Model.anIntArray1697;
              }
              if (i6 < k6) {
                i5 = ai3[i6];
              } else {
                i5 = -1e3;
              }
            }
          }
          while (l6 === 3 && i5 > k3) {
            {
              this.method600(ai2[i6++]);
              if (i6 === k6 && ai2 !== _Model.anIntArrayArray1695[11]) {
                i6 = 0;
                k6 = _Model.anIntArray1694[11];
                ai2 = _Model.anIntArrayArray1695[11];
                ai3 = _Model.anIntArray1697;
              }
              if (i6 < k6) {
                i5 = ai3[i6];
              } else {
                i5 = -1e3;
              }
            }
          }
          while (l6 === 5 && i5 > j4) {
            {
              this.method600(ai2[i6++]);
              if (i6 === k6 && ai2 !== _Model.anIntArrayArray1695[11]) {
                i6 = 0;
                k6 = _Model.anIntArray1694[11];
                ai2 = _Model.anIntArrayArray1695[11];
                ai3 = _Model.anIntArray1697;
              }
              if (i6 < k6) {
                i5 = ai3[i6];
              } else {
                i5 = -1e3;
              }
            }
          }
          const i7 = _Model.anIntArray1694[l6];
          const ai4 = _Model.anIntArrayArray1695[l6];
          for (let j7 = 0; j7 < i7; j7++) {
            this.method600(ai4[j7]);
          }
        }
      }
      while (i5 !== -1e3) {
        {
          this.method600(ai2[i6++]);
          if (i6 === k6 && ai2 !== _Model.anIntArrayArray1695[11]) {
            i6 = 0;
            ai2 = _Model.anIntArrayArray1695[11];
            k6 = _Model.anIntArray1694[11];
            ai3 = _Model.anIntArray1697;
          }
          if (i6 < k6) {
            i5 = ai3[i6];
          } else {
            i5 = -1e3;
          }
        }
      }
    }
    method600(i) {
      if (_Model.aBooleanArray1685[i]) {
        this.method601(i);
        return;
      }
      const j = this.trianglePointsX[i];
      const k = this.trianglePointsY[i];
      const l = this.trianglePointsZ[i];
      Rasterizer3D.aBoolean1528 = _Model.aBooleanArray1684[i];
      if (this.triangleAlphaValues == null) {
        Rasterizer3D.anInt1531 = 0;
      } else {
        Rasterizer3D.anInt1531 = this.triangleAlphaValues[i];
      }
      let i1;
      if (this.texturePoints == null) {
        i1 = 0;
      } else {
        i1 = this.texturePoints[i] & 3;
      }
      if (i1 === 0) {
        Rasterizer3D.method503(
          _Model.anIntArray1687[j],
          _Model.anIntArray1687[k],
          _Model.anIntArray1687[l],
          _Model.anIntArray1686[j],
          _Model.anIntArray1686[k],
          _Model.anIntArray1686[l],
          this.anIntArray1656[i],
          this.anIntArray1657[i],
          this.anIntArray1658[i]
        );
        return;
      }
      if (i1 === 1) {
        Rasterizer3D.method505(
          _Model.anIntArray1687[j],
          _Model.anIntArray1687[k],
          _Model.anIntArray1687[l],
          _Model.anIntArray1686[j],
          _Model.anIntArray1686[k],
          _Model.anIntArray1686[l],
          _Model.anIntArray1712[this.anIntArray1656[i]]
        );
        return;
      }
      if (i1 === 2) {
        const j1 = this.texturePoints[i] >> 2;
        const l1 = this.texturedTrianglePointsX[j1];
        const j2 = this.texturedTrianglePointsY[j1];
        const l2 = this.texturedTrianglePointsZ[j1];
        Rasterizer3D.method507(
          _Model.anIntArray1687[j],
          _Model.anIntArray1687[k],
          _Model.anIntArray1687[l],
          _Model.anIntArray1686[j],
          _Model.anIntArray1686[k],
          _Model.anIntArray1686[l],
          this.anIntArray1656[i],
          this.anIntArray1657[i],
          this.anIntArray1658[i],
          _Model.anIntArray1689[l1],
          _Model.anIntArray1689[j2],
          _Model.anIntArray1689[l2],
          _Model.anIntArray1690[l1],
          _Model.anIntArray1690[j2],
          _Model.anIntArray1690[l2],
          _Model.anIntArray1691[l1],
          _Model.anIntArray1691[j2],
          _Model.anIntArray1691[l2],
          this.triangleColorValues[i]
        );
        return;
      }
      if (i1 === 3) {
        const k1 = this.texturePoints[i] >> 2;
        const i2 = this.texturedTrianglePointsX[k1];
        const k2 = this.texturedTrianglePointsY[k1];
        const i3 = this.texturedTrianglePointsZ[k1];
        Rasterizer3D.method507(
          _Model.anIntArray1687[j],
          _Model.anIntArray1687[k],
          _Model.anIntArray1687[l],
          _Model.anIntArray1686[j],
          _Model.anIntArray1686[k],
          _Model.anIntArray1686[l],
          this.anIntArray1656[i],
          this.anIntArray1656[i],
          this.anIntArray1656[i],
          _Model.anIntArray1689[i2],
          _Model.anIntArray1689[k2],
          _Model.anIntArray1689[i3],
          _Model.anIntArray1690[i2],
          _Model.anIntArray1690[k2],
          _Model.anIntArray1690[i3],
          _Model.anIntArray1691[i2],
          _Model.anIntArray1691[k2],
          _Model.anIntArray1691[i3],
          this.triangleColorValues[i]
        );
      }
    }
    method601(i) {
      const j = Rasterizer3D.centerX;
      const k = Rasterizer3D.centerY;
      let l = 0;
      const i1 = this.trianglePointsX[i];
      const j1 = this.trianglePointsY[i];
      const k1 = this.trianglePointsZ[i];
      const l1 = _Model.anIntArray1691[i1];
      const i2 = _Model.anIntArray1691[j1];
      const j2 = _Model.anIntArray1691[k1];
      if (l1 >= 50) {
        _Model.anIntArray1699[l] = _Model.anIntArray1686[i1];
        _Model.anIntArray1700[l] = _Model.anIntArray1687[i1];
        _Model.anIntArray1701[l++] = this.anIntArray1656[i];
      } else {
        const k2 = _Model.anIntArray1689[i1];
        const k3 = _Model.anIntArray1690[i1];
        const k4 = this.anIntArray1656[i];
        if (j2 >= 50) {
          const k5 = (50 - l1) * _Model.anIntArray1713[j2 - l1];
          _Model.anIntArray1699[l] = j + ((k2 + ((_Model.anIntArray1689[k1] - k2) * k5 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1700[l] = k + ((k3 + ((_Model.anIntArray1690[k1] - k3) * k5 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1701[l++] = k4 + ((this.anIntArray1658[i] - k4) * k5 >> 16);
        }
        if (i2 >= 50) {
          const l5 = (50 - l1) * _Model.anIntArray1713[i2 - l1];
          _Model.anIntArray1699[l] = j + ((k2 + ((_Model.anIntArray1689[j1] - k2) * l5 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1700[l] = k + ((k3 + ((_Model.anIntArray1690[j1] - k3) * l5 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1701[l++] = k4 + ((this.anIntArray1657[i] - k4) * l5 >> 16);
        }
      }
      if (i2 >= 50) {
        _Model.anIntArray1699[l] = _Model.anIntArray1686[j1];
        _Model.anIntArray1700[l] = _Model.anIntArray1687[j1];
        _Model.anIntArray1701[l++] = this.anIntArray1657[i];
      } else {
        const l2 = _Model.anIntArray1689[j1];
        const l3 = _Model.anIntArray1690[j1];
        const l4 = this.anIntArray1657[i];
        if (l1 >= 50) {
          const i6 = (50 - i2) * _Model.anIntArray1713[l1 - i2];
          _Model.anIntArray1699[l] = j + ((l2 + ((_Model.anIntArray1689[i1] - l2) * i6 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1700[l] = k + ((l3 + ((_Model.anIntArray1690[i1] - l3) * i6 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1701[l++] = l4 + ((this.anIntArray1656[i] - l4) * i6 >> 16);
        }
        if (j2 >= 50) {
          const j6 = (50 - i2) * _Model.anIntArray1713[j2 - i2];
          _Model.anIntArray1699[l] = j + ((l2 + ((_Model.anIntArray1689[k1] - l2) * j6 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1700[l] = k + ((l3 + ((_Model.anIntArray1690[k1] - l3) * j6 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1701[l++] = l4 + ((this.anIntArray1658[i] - l4) * j6 >> 16);
        }
      }
      if (j2 >= 50) {
        _Model.anIntArray1699[l] = _Model.anIntArray1686[k1];
        _Model.anIntArray1700[l] = _Model.anIntArray1687[k1];
        _Model.anIntArray1701[l++] = this.anIntArray1658[i];
      } else {
        const i3 = _Model.anIntArray1689[k1];
        const i4 = _Model.anIntArray1690[k1];
        const i5 = this.anIntArray1658[i];
        if (i2 >= 50) {
          const k6 = (50 - j2) * _Model.anIntArray1713[i2 - j2];
          _Model.anIntArray1699[l] = j + ((i3 + ((_Model.anIntArray1689[j1] - i3) * k6 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1700[l] = k + ((i4 + ((_Model.anIntArray1690[j1] - i4) * k6 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1701[l++] = i5 + ((this.anIntArray1657[i] - i5) * k6 >> 16);
        }
        if (l1 >= 50) {
          const l6 = (50 - j2) * _Model.anIntArray1713[l1 - j2];
          _Model.anIntArray1699[l] = j + ((i3 + ((_Model.anIntArray1689[i1] - i3) * l6 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1700[l] = k + ((i4 + ((_Model.anIntArray1690[i1] - i4) * l6 >> 16) << 9) / 50 | 0);
          _Model.anIntArray1701[l++] = i5 + ((this.anIntArray1656[i] - i5) * l6 >> 16);
        }
      }
      const j3 = _Model.anIntArray1699[0];
      const j4 = _Model.anIntArray1699[1];
      const j5 = _Model.anIntArray1699[2];
      const i7 = _Model.anIntArray1700[0];
      const j7 = _Model.anIntArray1700[1];
      const k7 = _Model.anIntArray1700[2];
      if ((j3 - j4) * (k7 - j7) - (i7 - j7) * (j5 - j4) > 0) {
        Rasterizer3D.aBoolean1528 = false;
        if (l === 3) {
          if (j3 < 0 || j4 < 0 || j5 < 0 || j3 > Rasterizer.virtualBottomX || j4 > Rasterizer.virtualBottomX || j5 > Rasterizer.virtualBottomX) {
            Rasterizer3D.aBoolean1528 = true;
          }
          let l7;
          if (this.texturePoints == null) {
            l7 = 0;
          } else {
            l7 = this.texturePoints[i] & 3;
          }
          if (l7 === 0) {
            Rasterizer3D.method503(
              i7,
              j7,
              k7,
              j3,
              j4,
              j5,
              _Model.anIntArray1701[0],
              _Model.anIntArray1701[1],
              _Model.anIntArray1701[2]
            );
          } else if (l7 === 1) {
            Rasterizer3D.method505(i7, j7, k7, j3, j4, j5, _Model.anIntArray1712[this.anIntArray1656[i]]);
          } else if (l7 === 2) {
            const j8 = this.texturePoints[i] >> 2;
            const k9 = this.texturedTrianglePointsX[j8];
            const k10 = this.texturedTrianglePointsY[j8];
            const k11 = this.texturedTrianglePointsZ[j8];
            Rasterizer3D.method507(
              i7,
              j7,
              k7,
              j3,
              j4,
              j5,
              _Model.anIntArray1701[0],
              _Model.anIntArray1701[1],
              _Model.anIntArray1701[2],
              _Model.anIntArray1689[k9],
              _Model.anIntArray1689[k10],
              _Model.anIntArray1689[k11],
              _Model.anIntArray1690[k9],
              _Model.anIntArray1690[k10],
              _Model.anIntArray1690[k11],
              _Model.anIntArray1691[k9],
              _Model.anIntArray1691[k10],
              _Model.anIntArray1691[k11],
              this.triangleColorValues[i]
            );
          } else if (l7 === 3) {
            const k8 = this.texturePoints[i] >> 2;
            const l9 = this.texturedTrianglePointsX[k8];
            const l10 = this.texturedTrianglePointsY[k8];
            const l11 = this.texturedTrianglePointsZ[k8];
            Rasterizer3D.method507(
              i7,
              j7,
              k7,
              j3,
              j4,
              j5,
              this.anIntArray1656[i],
              this.anIntArray1656[i],
              this.anIntArray1656[i],
              _Model.anIntArray1689[l9],
              _Model.anIntArray1689[l10],
              _Model.anIntArray1689[l11],
              _Model.anIntArray1690[l9],
              _Model.anIntArray1690[l10],
              _Model.anIntArray1690[l11],
              _Model.anIntArray1691[l9],
              _Model.anIntArray1691[l10],
              _Model.anIntArray1691[l11],
              this.triangleColorValues[i]
            );
          }
        }
        if (l === 4) {
          if (j3 < 0 || j4 < 0 || j5 < 0 || j3 > Rasterizer.virtualBottomX || j4 > Rasterizer.virtualBottomX || j5 > Rasterizer.virtualBottomX || _Model.anIntArray1699[3] < 0 || _Model.anIntArray1699[3] > Rasterizer.virtualBottomX) {
            Rasterizer3D.aBoolean1528 = true;
          }
          let i8;
          if (this.texturePoints == null) {
            i8 = 0;
          } else {
            i8 = this.texturePoints[i] & 3;
          }
          if (i8 === 0) {
            Rasterizer3D.method503(
              i7,
              j7,
              k7,
              j3,
              j4,
              j5,
              _Model.anIntArray1701[0],
              _Model.anIntArray1701[1],
              _Model.anIntArray1701[2]
            );
            Rasterizer3D.method503(
              i7,
              k7,
              _Model.anIntArray1700[3],
              j3,
              j5,
              _Model.anIntArray1699[3],
              _Model.anIntArray1701[0],
              _Model.anIntArray1701[2],
              _Model.anIntArray1701[3]
            );
            return;
          }
          if (i8 === 1) {
            const l8 = _Model.anIntArray1712[this.anIntArray1656[i]];
            Rasterizer3D.method505(i7, j7, k7, j3, j4, j5, l8);
            Rasterizer3D.method505(i7, k7, _Model.anIntArray1700[3], j3, j5, _Model.anIntArray1699[3], l8);
            return;
          }
          if (i8 === 2) {
            const i9 = this.texturePoints[i] >> 2;
            const i10 = this.texturedTrianglePointsX[i9];
            const i11 = this.texturedTrianglePointsY[i9];
            const i12 = this.texturedTrianglePointsZ[i9];
            Rasterizer3D.method507(
              i7,
              j7,
              k7,
              j3,
              j4,
              j5,
              _Model.anIntArray1701[0],
              _Model.anIntArray1701[1],
              _Model.anIntArray1701[2],
              _Model.anIntArray1689[i10],
              _Model.anIntArray1689[i11],
              _Model.anIntArray1689[i12],
              _Model.anIntArray1690[i10],
              _Model.anIntArray1690[i11],
              _Model.anIntArray1690[i12],
              _Model.anIntArray1691[i10],
              _Model.anIntArray1691[i11],
              _Model.anIntArray1691[i12],
              this.triangleColorValues[i]
            );
            Rasterizer3D.method507(
              i7,
              k7,
              _Model.anIntArray1700[3],
              j3,
              j5,
              _Model.anIntArray1699[3],
              _Model.anIntArray1701[0],
              _Model.anIntArray1701[2],
              _Model.anIntArray1701[3],
              _Model.anIntArray1689[i10],
              _Model.anIntArray1689[i11],
              _Model.anIntArray1689[i12],
              _Model.anIntArray1690[i10],
              _Model.anIntArray1690[i11],
              _Model.anIntArray1690[i12],
              _Model.anIntArray1691[i10],
              _Model.anIntArray1691[i11],
              _Model.anIntArray1691[i12],
              this.triangleColorValues[i]
            );
            return;
          }
          if (i8 === 3) {
            const j9 = this.texturePoints[i] >> 2;
            const j10 = this.texturedTrianglePointsX[j9];
            const j11 = this.texturedTrianglePointsY[j9];
            const j12 = this.texturedTrianglePointsZ[j9];
            Rasterizer3D.method507(
              i7,
              j7,
              k7,
              j3,
              j4,
              j5,
              this.anIntArray1656[i],
              this.anIntArray1656[i],
              this.anIntArray1656[i],
              _Model.anIntArray1689[j10],
              _Model.anIntArray1689[j11],
              _Model.anIntArray1689[j12],
              _Model.anIntArray1690[j10],
              _Model.anIntArray1690[j11],
              _Model.anIntArray1690[j12],
              _Model.anIntArray1691[j10],
              _Model.anIntArray1691[j11],
              _Model.anIntArray1691[j12],
              this.triangleColorValues[i]
            );
            Rasterizer3D.method507(
              i7,
              k7,
              _Model.anIntArray1700[3],
              j3,
              j5,
              _Model.anIntArray1699[3],
              this.anIntArray1656[i],
              this.anIntArray1656[i],
              this.anIntArray1656[i],
              _Model.anIntArray1689[j10],
              _Model.anIntArray1689[j11],
              _Model.anIntArray1689[j12],
              _Model.anIntArray1690[j10],
              _Model.anIntArray1690[j11],
              _Model.anIntArray1690[j12],
              _Model.anIntArray1691[j10],
              _Model.anIntArray1691[j11],
              _Model.anIntArray1691[j12],
              this.triangleColorValues[i]
            );
          }
        }
      }
    }
    method602(i, j, k, l, i1, j1, k1, l1) {
      if (j < k && j < l && j < i1) {
        return false;
      }
      if (j > k && j > l && j > i1) {
        return false;
      }
      if (i < j1 && i < k1 && i < l1) {
        return false;
      }
      return i <= j1 || i <= k1 || i <= l1;
    }
  };
  var Model = _Model;
  Model.__static_initialized = false;
  Model.anInt1642 = 0;
  Model.EMPTY_MODEL = new _Model();
  Model.anIntArray1644 = Array(2e3).fill(0);
  Model.anIntArray1645 = Array(2e3).fill(0);
  Model.anIntArray1646 = Array(2e3).fill(0);
  Model.anIntArray1647 = Array(2e3).fill(0);
  Model.modelHeaders = null;
  Model.requester = null;
  Model.aBooleanArray1684 = Array(4096).fill(false);
  Model.aBooleanArray1685 = Array(4096).fill(false);
  Model.anIntArray1686 = Array(4096).fill(0);
  Model.anIntArray1687 = Array(4096).fill(0);
  Model.anIntArray1688 = Array(4096).fill(0);
  Model.anIntArray1689 = Array(4096).fill(0);
  Model.anIntArray1690 = Array(4096).fill(0);
  Model.anIntArray1691 = Array(4096).fill(0);
  Model.anIntArray1692 = Array(4096).fill(0);
  Model.anIntArrayArray1693 = array2d(1500, 512, 0);
  Model.anIntArray1694 = Array(12).fill(0);
  Model.anIntArrayArray1695 = array2d(12, 2e3, 0);
  Model.anIntArray1696 = Array(2e3).fill(0);
  Model.anIntArray1697 = Array(2e3).fill(0);
  Model.anIntArray1698 = Array(12).fill(0);
  Model.anIntArray1699 = Array(10).fill(0);
  Model.anIntArray1700 = Array(10).fill(0);
  Model.anIntArray1701 = Array(10).fill(0);
  Model.vertexXModifier = 0;
  Model.vertexYModifier = 0;
  Model.vertexZModifier = 0;
  Model.aBoolean1705 = false;
  Model.anInt1706 = 0;
  Model.anInt1707 = 0;
  Model.anInt1708 = 0;
  Model.anIntArray1709 = Array(1e3).fill(0);
  Model.SINE = Rasterizer3D.SINE;
  Model.COSINE = Rasterizer3D.COSINE;
  Model.anIntArray1712 = Rasterizer3D.getRgbLookupTableId;
  Model.anIntArray1713 = Rasterizer3D.anIntArray1535;

  // osrs/scene/CameraAngle.ts
  init_inject();
  var CameraAngle = class {
    constructor() {
      if (this.x === void 0) {
        this.x = 0;
      }
      if (this.y === void 0) {
        this.y = 0;
      }
      if (this.z === void 0) {
        this.z = 0;
      }
      if (this.aRenderable150 === void 0) {
        this.aRenderable150 = null;
      }
      if (this.aRenderable151 === void 0) {
        this.aRenderable151 = null;
      }
      if (this.aRenderable152 === void 0) {
        this.aRenderable152 = null;
      }
      if (this.anInt179 === void 0) {
        this.anInt179 = 0;
      }
      if (this.anInt180 === void 0) {
        this.anInt180 = 0;
      }
    }
  };

  // osrs/scene/SceneCluster.ts
  init_inject();
  var SceneCluster = class {
    constructor() {
      if (this.anInt675 === void 0) {
        this.anInt675 = 0;
      }
      if (this.anInt676 === void 0) {
        this.anInt676 = 0;
      }
      if (this.anInt677 === void 0) {
        this.anInt677 = 0;
      }
      if (this.anInt678 === void 0) {
        this.anInt678 = 0;
      }
      if (this.anInt679 === void 0) {
        this.anInt679 = 0;
      }
      if (this.anInt680 === void 0) {
        this.anInt680 = 0;
      }
      if (this.anInt681 === void 0) {
        this.anInt681 = 0;
      }
      if (this.anInt682 === void 0) {
        this.anInt682 = 0;
      }
      if (this.anInt683 === void 0) {
        this.anInt683 = 0;
      }
      if (this.anInt684 === void 0) {
        this.anInt684 = 0;
      }
      if (this.anInt685 === void 0) {
        this.anInt685 = 0;
      }
      if (this.anInt686 === void 0) {
        this.anInt686 = 0;
      }
      if (this.anInt687 === void 0) {
        this.anInt687 = 0;
      }
      if (this.anInt688 === void 0) {
        this.anInt688 = 0;
      }
      if (this.anInt689 === void 0) {
        this.anInt689 = 0;
      }
      if (this.anInt690 === void 0) {
        this.anInt690 = 0;
      }
      if (this.anInt691 === void 0) {
        this.anInt691 = 0;
      }
      if (this.anInt692 === void 0) {
        this.anInt692 = 0;
      }
    }
  };

  // osrs/scene/SceneSpawnRequest.ts
  init_inject();
  var SceneSpawnRequest = class {
    constructor() {
      if (this.anInt113 === void 0) {
        this.anInt113 = 0;
      }
      if (this.tileHeight === void 0) {
        this.tileHeight = 0;
      }
      if (this.relativeX === void 0) {
        this.relativeX = 0;
      }
      if (this.y === void 0) {
        this.y = 0;
      }
      if (this.renderable === void 0) {
        this.renderable = null;
      }
      if (this.anInt118 === void 0) {
        this.anInt118 = 0;
      }
      if (this.relativeX === void 0) {
        this.relativeX = 0;
      }
      if (this.offsetX === void 0) {
        this.offsetX = 0;
      }
      if (this.relativeY === void 0) {
        this.relativeY = 0;
      }
      if (this.offsetY === void 0) {
        this.offsetY = 0;
      }
      if (this.anInt123 === void 0) {
        this.anInt123 = 0;
      }
      if (this.cycle === void 0) {
        this.cycle = 0;
      }
      if (this.hash === void 0) {
        this.hash = 0;
      }
      if (this.config === void 0) {
        this.config = 0;
      }
    }
  };

  // osrs/scene/tile/ComplexTile.ts
  init_inject();
  var _ComplexTile = class {
    constructor(i, j, k, l, i1, j1, k1, l1, i2, j2, k2, l2, i3, j3, k3, l3, i4, j4, k4, l4) {
      if (this.anIntArray403 === void 0) {
        this.anIntArray403 = null;
      }
      if (this.anIntArray404 === void 0) {
        this.anIntArray404 = null;
      }
      if (this.anIntArray405 === void 0) {
        this.anIntArray405 = null;
      }
      if (this.anIntArray406 === void 0) {
        this.anIntArray406 = null;
      }
      if (this.anIntArray407 === void 0) {
        this.anIntArray407 = null;
      }
      if (this.anIntArray408 === void 0) {
        this.anIntArray408 = null;
      }
      if (this.anIntArray409 === void 0) {
        this.anIntArray409 = null;
      }
      if (this.anIntArray410 === void 0) {
        this.anIntArray410 = null;
      }
      if (this.anIntArray411 === void 0) {
        this.anIntArray411 = null;
      }
      if (this.anIntArray412 === void 0) {
        this.anIntArray412 = null;
      }
      if (this.aBoolean413 === void 0) {
        this.aBoolean413 = false;
      }
      if (this.anInt414 === void 0) {
        this.anInt414 = 0;
      }
      if (this.anInt415 === void 0) {
        this.anInt415 = 0;
      }
      if (this.anInt416 === void 0) {
        this.anInt416 = 0;
      }
      if (this.anInt417 === void 0) {
        this.anInt417 = 0;
      }
      this.aBoolean413 = true;
      if (l !== j3 || l !== k || l !== i) {
        this.aBoolean413 = false;
      }
      this.anInt414 = i3;
      this.anInt415 = l4;
      this.anInt416 = i4;
      this.anInt417 = l1;
      const c2 = "\x80";
      const i5 = ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0;
      const j5 = ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 4 | 0;
      const k5 = ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) * 3 / 4 | 0;
      const ai = _ComplexTile.anIntArrayArray426[i3];
      const l5 = ai.length;
      this.anIntArray403 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(l5);
      this.anIntArray404 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(l5);
      this.anIntArray405 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(l5);
      const ai1 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(l5);
      const ai2 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(l5);
      const i6 = i1 * ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
      const j6 = k4 * ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
      for (let k6 = 0; k6 < l5; k6++) {
        {
          let l6 = ai[k6];
          if ((l6 & 1) === 0 && l6 <= 8) {
            l6 = (l6 - l4 - l4 - 1 & 7) + 1;
          }
          if (l6 > 8 && l6 <= 12) {
            l6 = (l6 - 9 - l4 & 3) + 9;
          }
          if (l6 > 12 && l6 <= 16) {
            l6 = (l6 - 13 - l4 & 3) + 13;
          }
          let i7;
          let k7;
          let i8;
          let k8;
          let j9;
          if (l6 === 1) {
            i7 = i6;
            k7 = j6;
            i8 = l;
            k8 = l2;
            j9 = j;
          } else if (l6 === 2) {
            i7 = i6 + i5;
            k7 = j6;
            i8 = l + j3 >> 1;
            k8 = l2 + i2 >> 1;
            j9 = j + j4 >> 1;
          } else if (l6 === 3) {
            i7 = i6 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            k7 = j6;
            i8 = j3;
            k8 = i2;
            j9 = j4;
          } else if (l6 === 4) {
            i7 = i6 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            k7 = j6 + i5;
            i8 = j3 + k >> 1;
            k8 = i2 + j1 >> 1;
            j9 = j4 + j2 >> 1;
          } else if (l6 === 5) {
            i7 = i6 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            k7 = j6 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            i8 = k;
            k8 = j1;
            j9 = j2;
          } else if (l6 === 6) {
            i7 = i6 + i5;
            k7 = j6 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            i8 = k + i >> 1;
            k8 = j1 + k1 >> 1;
            j9 = j2 + k3 >> 1;
          } else if (l6 === 7) {
            i7 = i6;
            k7 = j6 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            i8 = i;
            k8 = k1;
            j9 = k3;
          } else if (l6 === 8) {
            i7 = i6;
            k7 = j6 + i5;
            i8 = i + l >> 1;
            k8 = k1 + l2 >> 1;
            j9 = k3 + j >> 1;
          } else if (l6 === 9) {
            i7 = i6 + i5;
            k7 = j6 + j5;
            i8 = l + j3 >> 1;
            k8 = l2 + i2 >> 1;
            j9 = j + j4 >> 1;
          } else if (l6 === 10) {
            i7 = i6 + k5;
            k7 = j6 + i5;
            i8 = j3 + k >> 1;
            k8 = i2 + j1 >> 1;
            j9 = j4 + j2 >> 1;
          } else if (l6 === 11) {
            i7 = i6 + i5;
            k7 = j6 + k5;
            i8 = k + i >> 1;
            k8 = j1 + k1 >> 1;
            j9 = j2 + k3 >> 1;
          } else if (l6 === 12) {
            i7 = i6 + j5;
            k7 = j6 + i5;
            i8 = i + l >> 1;
            k8 = k1 + l2 >> 1;
            j9 = k3 + j >> 1;
          } else if (l6 === 13) {
            i7 = i6 + j5;
            k7 = j6 + j5;
            i8 = l;
            k8 = l2;
            j9 = j;
          } else if (l6 === 14) {
            i7 = i6 + k5;
            k7 = j6 + j5;
            i8 = j3;
            k8 = i2;
            j9 = j4;
          } else if (l6 === 15) {
            i7 = i6 + k5;
            k7 = j6 + k5;
            i8 = k;
            k8 = j1;
            j9 = j2;
          } else {
            i7 = i6 + j5;
            k7 = j6 + k5;
            i8 = i;
            k8 = k1;
            j9 = k3;
          }
          this.anIntArray403[k6] = i7;
          this.anIntArray404[k6] = i8;
          this.anIntArray405[k6] = k7;
          ai1[k6] = k8;
          ai2[k6] = j9;
        }
      }
      const ai3 = _ComplexTile.anIntArrayArray427[i3];
      const j7 = ai3.length / 4 | 0;
      this.anIntArray409 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(j7);
      this.anIntArray410 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(j7);
      this.anIntArray411 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(j7);
      this.anIntArray406 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(j7);
      this.anIntArray407 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(j7);
      this.anIntArray408 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(j7);
      if (l3 !== -1) {
        this.anIntArray412 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(j7);
      }
      let l7 = 0;
      for (let j8 = 0; j8 < j7; j8++) {
        {
          const l8 = ai3[l7];
          let k9 = ai3[l7 + 1];
          let i10 = ai3[l7 + 2];
          let j10 = ai3[l7 + 3];
          l7 += 4;
          if (k9 < 4) {
            k9 = k9 - l4 & 3;
          }
          if (i10 < 4) {
            i10 = i10 - l4 & 3;
          }
          if (j10 < 4) {
            j10 = j10 - l4 & 3;
          }
          this.anIntArray409[j8] = k9;
          this.anIntArray410[j8] = i10;
          this.anIntArray411[j8] = j10;
          if (l8 === 0) {
            this.anIntArray406[j8] = ai1[k9];
            this.anIntArray407[j8] = ai1[i10];
            this.anIntArray408[j8] = ai1[j10];
            if (this.anIntArray412 != null) {
              this.anIntArray412[j8] = -1;
            }
          } else {
            this.anIntArray406[j8] = ai2[k9];
            this.anIntArray407[j8] = ai2[i10];
            this.anIntArray408[j8] = ai2[j10];
            if (this.anIntArray412 != null) {
              this.anIntArray412[j8] = l3;
            }
          }
        }
      }
      let i9 = l;
      let l9 = j3;
      if (j3 < i9) {
        i9 = j3;
      }
      if (j3 > l9) {
        l9 = j3;
      }
      if (k < i9) {
        i9 = k;
      }
      if (k > l9) {
        l9 = k;
      }
      if (i < i9) {
        i9 = i;
      }
      if (i > l9) {
        l9 = i;
      }
    }
  };
  var ComplexTile = _ComplexTile;
  ComplexTile.anIntArray418 = Array(6).fill(0);
  ComplexTile.anIntArray419 = Array(6).fill(0);
  ComplexTile.anIntArray420 = Array(6).fill(0);
  ComplexTile.anIntArray421 = Array(6).fill(0);
  ComplexTile.anIntArray422 = Array(6).fill(0);
  ComplexTile.anIntArrayArray426 = [
    [1, 3, 5, 7],
    [1, 3, 5, 7],
    [1, 3, 5, 7],
    [1, 3, 5, 7, 6],
    [1, 3, 5, 7, 6],
    [1, 3, 5, 7, 6],
    [1, 3, 5, 7, 6],
    [1, 3, 5, 7, 2, 6],
    [1, 3, 5, 7, 2, 8],
    [1, 3, 5, 7, 2, 8],
    [1, 3, 5, 7, 11, 12],
    [1, 3, 5, 7, 11, 12],
    [1, 3, 5, 7, 13, 14]
  ];
  ComplexTile.anIntArrayArray427 = [
    [0, 1, 2, 3, 0, 0, 1, 3],
    [1, 1, 2, 3, 1, 0, 1, 3],
    [0, 1, 2, 3, 1, 0, 1, 3],
    [0, 0, 1, 2, 0, 0, 2, 4, 1, 0, 4, 3],
    [0, 0, 1, 4, 0, 0, 4, 3, 1, 1, 2, 4],
    [0, 0, 4, 3, 1, 0, 1, 2, 1, 0, 2, 4],
    [0, 1, 2, 4, 1, 0, 1, 4, 1, 0, 4, 3],
    [0, 4, 1, 2, 0, 4, 2, 5, 1, 0, 4, 5, 1, 0, 5, 3],
    [0, 4, 1, 2, 0, 4, 2, 3, 0, 4, 3, 5, 1, 0, 4, 5],
    [0, 0, 4, 5, 1, 4, 1, 2, 1, 4, 2, 3, 1, 4, 3, 5],
    [0, 0, 1, 5, 0, 1, 4, 5, 0, 1, 2, 4, 1, 0, 5, 3, 1, 5, 4, 3, 1, 4, 2, 3],
    [1, 0, 1, 5, 1, 1, 4, 5, 1, 1, 2, 4, 0, 0, 5, 3, 0, 5, 4, 3, 0, 4, 2, 3],
    [1, 0, 5, 4, 1, 0, 1, 5, 0, 0, 4, 3, 0, 4, 5, 3, 0, 5, 2, 3, 0, 1, 2, 5]
  ];

  // osrs/scene/tile/FloorDecoration.ts
  init_inject();
  var FloorDecoration = class {
    constructor() {
      if (this.x === void 0) {
        this.x = 0;
      }
      if (this.y === void 0) {
        this.y = 0;
      }
      if (this.z === void 0) {
        this.z = 0;
      }
      if (this.renderable === void 0) {
        this.renderable = null;
      }
      if (this.hash === void 0) {
        this.hash = 0;
      }
      if (this.config === void 0) {
        this.config = 0;
      }
    }
  };

  // osrs/scene/tile/GenericTile.ts
  init_inject();
  var GenericTile = class {
    constructor(i, j, k, l, texture, rgbColor, flat) {
      if (this.anInt95 === void 0) {
        this.anInt95 = 0;
      }
      if (this.anInt96 === void 0) {
        this.anInt96 = 0;
      }
      if (this.anInt97 === void 0) {
        this.anInt97 = 0;
      }
      if (this.anInt98 === void 0) {
        this.anInt98 = 0;
      }
      if (this.texture === void 0) {
        this.texture = 0;
      }
      if (this.flat === void 0) {
        this.flat = false;
      }
      if (this.rgbColor === void 0) {
        this.rgbColor = 0;
      }
      this.anInt95 = i;
      this.anInt96 = j;
      this.anInt97 = k;
      this.anInt98 = l;
      this.texture = texture;
      this.rgbColor = rgbColor;
      this.flat = flat;
    }
  };

  // osrs/scene/tile/SceneTile.ts
  init_inject();
  var SceneTile = class extends Node {
    constructor(i, j, k) {
      super();
      this.sceneSpawnRequests = [null, null, null, null, null];
      this.anIntArray1409 = [0, 0, 0, 0, 0];
      if (this.plane === void 0) {
        this.plane = 0;
      }
      if (this.x === void 0) {
        this.x = 0;
      }
      if (this.y === void 0) {
        this.y = 0;
      }
      if (this.renderLevel === void 0) {
        this.renderLevel = 0;
      }
      if (this.paint === void 0) {
        this.paint = null;
      }
      if (this.complexTile === void 0) {
        this.complexTile = null;
      }
      if (this.wall === void 0) {
        this.wall = null;
      }
      if (this.wallDecoration === void 0) {
        this.wallDecoration = null;
      }
      if (this.floorDecoration === void 0) {
        this.floorDecoration = null;
      }
      if (this.cameraAngle === void 0) {
        this.cameraAngle = null;
      }
      if (this.sceneSpawnRequestCount === void 0) {
        this.sceneSpawnRequestCount = 0;
      }
      if (this.anInt1410 === void 0) {
        this.anInt1410 = 0;
      }
      if (this.physicalLevel === void 0) {
        this.physicalLevel = 0;
      }
      if (this.draw === void 0) {
        this.draw = false;
      }
      if (this.visible === void 0) {
        this.visible = false;
      }
      if (this.drawEntities === void 0) {
        this.drawEntities = false;
      }
      if (this.wallCullDirection === void 0) {
        this.wallCullDirection = 0;
      }
      if (this.wallUncullDirection === void 0) {
        this.wallUncullDirection = 0;
      }
      if (this.wallCullOppositeDirection === void 0) {
        this.wallCullOppositeDirection = 0;
      }
      if (this.wallDrawFlags === void 0) {
        this.wallDrawFlags = 0;
      }
      if (this.bridge === void 0) {
        this.bridge = null;
      }
      this.renderLevel = this.plane = i;
      this.x = j;
      this.y = k;
    }
  };

  // osrs/scene/tile/Wall.ts
  init_inject();
  var Wall = class {
    constructor() {
      if (this.plane === void 0) {
        this.plane = 0;
      }
      if (this.x === void 0) {
        this.x = 0;
      }
      if (this.y === void 0) {
        this.y = 0;
      }
      if (this.orientationA === void 0) {
        this.orientationA = 0;
      }
      if (this.face === void 0) {
        this.face = 0;
      }
      if (this.aRenderable769 === void 0) {
        this.aRenderable769 = null;
      }
      if (this.aRenderable770 === void 0) {
        this.aRenderable770 = null;
      }
      if (this.hash === void 0) {
        this.hash = 0;
      }
      if (this.config === void 0) {
        this.config = 0;
      }
    }
  };

  // osrs/scene/tile/WallDecoration.ts
  init_inject();
  var WallDecoration = class {
    constructor() {
      if (this.plane === void 0) {
        this.plane = 0;
      }
      if (this.y === void 0) {
        this.y = 0;
      }
      if (this.x === void 0) {
        this.x = 0;
      }
      if (this.faceUnknown === void 0) {
        this.faceUnknown = 0;
      }
      if (this.face === void 0) {
        this.face = 0;
      }
      if (this.renderable === void 0) {
        this.renderable = null;
      }
      if (this.hash === void 0) {
        this.hash = 0;
      }
      if (this.config === void 0) {
        this.config = 0;
      }
    }
  };

  // osrs/scene/Scene.ts
  var _Scene = class {
    constructor(ai, i, j, k, byte0) {
      this.anIntArrayArray504 = [
        ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(16),
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1],
        [1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1],
        [0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],
        [1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1]
      ];
      this.anIntArrayArray505 = [
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
        [12, 8, 4, 0, 13, 9, 5, 1, 14, 10, 6, 2, 15, 11, 7, 3],
        [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0],
        [3, 7, 11, 15, 2, 6, 10, 14, 1, 5, 9, 13, 0, 4, 8, 12]
      ];
      if (this.anInt450 === void 0) {
        this.anInt450 = 0;
      }
      if (this.anInt452 === void 0) {
        this.anInt452 = 0;
      }
      if (this.anInt453 === void 0) {
        this.anInt453 = 0;
      }
      if (this.anInt454 === void 0) {
        this.anInt454 = 0;
      }
      if (this.anIntArrayArrayArray455 === void 0) {
        this.anIntArrayArrayArray455 = null;
      }
      if (this.tiles === void 0) {
        this.tiles = null;
      }
      if (this.anInt457 === void 0) {
        this.anInt457 = 0;
      }
      if (this.anInt458 === void 0) {
        this.anInt458 = 0;
      }
      if (this.sceneSpawnRequests === void 0) {
        this.sceneSpawnRequests = null;
      }
      if (this.anIntArrayArrayArray460 === void 0) {
        this.anIntArrayArrayArray460 = null;
      }
      if (this.anIntArray501 === void 0) {
        this.anIntArray501 = null;
      }
      if (this.anIntArray502 === void 0) {
        this.anIntArray502 = null;
      }
      if (this.anInt503 === void 0) {
        this.anInt503 = 0;
      }
      this.sceneSpawnRequests = Array(5e3).fill(null);
      this.anIntArray501 = Array(1e4).fill(0);
      this.anIntArray502 = Array(1e4).fill(0);
      this.anInt452 = j;
      this.anInt453 = k;
      this.anInt454 = i;
      this.tiles = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return null;
          } else {
            const array = [];
            for (let i2 = 0; i2 < dims2[0]; i2++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([j, k, i]);
      this.anIntArrayArrayArray460 = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i2 = 0; i2 < dims2[0]; i2++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([j, k + 1, i + 1]);
      this.anIntArrayArrayArray455 = ai;
      this.method241();
    }
    static method240() {
      _Scene.entityBuffer = null;
      _Scene.anIntArray488 = null;
      _Scene.aSceneClusterArrayArray554 = null;
      _Scene.tileList = null;
      _Scene.aBooleanArrayArrayArrayArray506 = null;
      _Scene.aBooleanArrayArray507 = null;
    }
    static createCullingOcclussionBox(j, k, l, i1, j1, k1, l1, i2) {
      const scenecluster = new SceneCluster();
      scenecluster.anInt675 = j / 128 | 0;
      scenecluster.anInt676 = l / 128 | 0;
      scenecluster.anInt677 = k1 / 128 | 0;
      scenecluster.anInt678 = i1 / 128 | 0;
      scenecluster.anInt679 = i2;
      scenecluster.anInt680 = j;
      scenecluster.anInt681 = l;
      scenecluster.anInt682 = k1;
      scenecluster.anInt683 = i1;
      scenecluster.anInt684 = l1;
      scenecluster.anInt685 = k;
      _Scene.aSceneClusterArrayArray554[j1][_Scene.anIntArray488[j1]++] = scenecluster;
    }
    static method277(l, k, i1, i, ai) {
      _Scene.anInt510 = 0;
      _Scene.anInt511 = 0;
      _Scene.anInt512 = i1;
      _Scene.anInt513 = i;
      _Scene.anInt508 = i1 / 2 | 0;
      _Scene.anInt509 = i / 2 | 0;
      const aflag = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return false;
          } else {
            const array = [];
            for (let i2 = 0; i2 < dims2[0]; i2++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([9, 32, 53, 53]);
      for (let j1 = 128; j1 <= 384; j1 += 32) {
        {
          for (let k1 = 0; k1 < 2048; k1 += 64) {
            {
              _Scene.pitchSin = Model.SINE[j1];
              _Scene.pitchCos = Model.COSINE[j1];
              _Scene.yawSin = Model.SINE[k1];
              _Scene.yawCos = Model.COSINE[k1];
              const i2 = (j1 - 128) / 32 | 0;
              const k2 = k1 / 64 | 0;
              for (let i3 = -26; i3 <= 26; i3++) {
                {
                  for (let k3 = -26; k3 <= 26; k3++) {
                    {
                      const l3 = i3 * 128;
                      const j4 = k3 * 128;
                      let flag1 = false;
                      for (let l4 = -l; l4 <= k; l4 += 128) {
                        {
                          if (!_Scene.method278(j4, l3, _Scene.anInt444, ai[i2] + l4)) {
                            continue;
                          }
                          flag1 = true;
                          break;
                        }
                      }
                      aflag[i2][k2][i3 + 25 + 1][k3 + 25 + 1] = flag1;
                    }
                  }
                }
              }
            }
          }
        }
      }
      for (let l1 = 0; l1 < 8; l1++) {
        {
          for (let j2 = 0; j2 < 32; j2++) {
            {
              for (let l2 = -25; l2 < 25; l2++) {
                {
                  for (let j3 = -25; j3 < 25; j3++) {
                    {
                      let flag = false;
                      label0:
                        for (let i4 = -1; i4 <= 1; i4++) {
                          {
                            for (let k4 = -1; k4 <= 1; k4++) {
                              {
                                if (aflag[l1][j2][l2 + i4 + 25 + 1][j3 + k4 + 25 + 1]) {
                                  flag = true;
                                } else if (aflag[l1][(j2 + 1) % 31][l2 + i4 + 25 + 1][j3 + k4 + 25 + 1]) {
                                  flag = true;
                                } else if (aflag[l1 + 1][j2][l2 + i4 + 25 + 1][j3 + k4 + 25 + 1]) {
                                  flag = true;
                                } else {
                                  if (!aflag[l1 + 1][(j2 + 1) % 31][l2 + i4 + 25 + 1][j3 + k4 + 25 + 1]) {
                                    continue;
                                  }
                                  flag = true;
                                }
                                break label0;
                              }
                            }
                          }
                        }
                      _Scene.aBooleanArrayArrayArrayArray506[l1][j2][l2 + 25][j3 + 25] = flag;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    static method278(i, j, k, l) {
      const i1 = i * _Scene.yawSin + j * _Scene.yawCos >> 16;
      const j1 = i * _Scene.yawCos - j * _Scene.yawSin >> 16;
      const k1 = l * _Scene.pitchSin + j1 * _Scene.pitchCos >> 16;
      const l1 = l * _Scene.pitchCos - j1 * _Scene.pitchSin >> 16;
      if (k1 < 50 || k1 > 3500) {
        return false;
      }
      const i2 = _Scene.anInt508 + ((i1 << 9) / k1 | 0);
      const j2 = _Scene.anInt509 + ((l1 << 9) / k1 | 0);
      return i2 >= _Scene.anInt510 && i2 <= _Scene.anInt512 && j2 >= _Scene.anInt511 && j2 <= _Scene.anInt513;
    }
    method241() {
      for (let i = 0; i < this.anInt452; i++) {
        {
          for (let j = 0; j < this.anInt453; j++) {
            {
              for (let i1 = 0; i1 < this.anInt454; i1++) {
                this.tiles[i][j][i1] = null;
              }
            }
          }
        }
      }
      for (let l = 0; l < _Scene.anInt487; l++) {
        {
          for (let j1 = 0; j1 < _Scene.anIntArray488[l]; j1++) {
            _Scene.aSceneClusterArrayArray554[l][j1] = null;
          }
          _Scene.anIntArray488[l] = 0;
        }
      }
      for (let k1 = 0; k1 < this.anInt458; k1++) {
        this.sceneSpawnRequests[k1] = null;
      }
      this.anInt458 = 0;
      for (let l1 = 0; l1 < _Scene.entityBuffer.length; l1++) {
        _Scene.entityBuffer[l1] = null;
      }
    }
    method242(i) {
      this.anInt457 = i;
      for (let j = 0; j < this.anInt453; j++) {
        {
          for (let k = 0; k < this.anInt454; k++) {
            if (this.tiles[i][j][k] == null) {
              this.tiles[i][j][k] = new SceneTile(i, j, k);
            }
          }
        }
      }
    }
    setBridgeMode(i, j) {
      const scenetile = this.tiles[0][i][j];
      for (let k = 0; k < 3; k++) {
        {
          const scenetile_15_ = this.tiles[k][i][j] = this.tiles[k + 1][i][j];
          if (scenetile_15_ != null) {
            scenetile_15_.plane--;
            for (let i1 = 0; i1 < scenetile_15_.sceneSpawnRequestCount; i1++) {
              {
                const sceneSpawnRequest = scenetile_15_.sceneSpawnRequests[i1];
                if ((sceneSpawnRequest.hash >> 29 & 3) === 2 && sceneSpawnRequest.relativeX === i && sceneSpawnRequest.relativeY === j) {
                  sceneSpawnRequest.anInt113--;
                }
              }
            }
          }
        }
      }
      if (this.tiles[0][i][j] == null) {
        this.tiles[0][i][j] = new SceneTile(0, i, j);
      }
      this.tiles[0][i][j].bridge = scenetile;
      this.tiles[3][i][j] = null;
    }
    setPhysicalLevel(i, j, k, l) {
      const sceneTile = this.tiles[i][j][k];
      if (sceneTile != null) {
        sceneTile.physicalLevel = l;
      }
    }
    addTile(i, j, k, l, i1, j1, k1, l1, i2, j2, k2, l2, i3, j3, k3, l3, i4, j4, k4, l4) {
      if (l === 0) {
        const genericTile = new GenericTile(k2, l2, i3, j3, -1, k4, false);
        for (let i5 = i; i5 >= 0; i5--) {
          if (this.tiles[i5][j][k] == null) {
            this.tiles[i5][j][k] = new SceneTile(i5, j, k);
          }
        }
        this.tiles[i][j][k].paint = genericTile;
        return;
      }
      if (l === 1) {
        const genericTile_1 = new GenericTile(k3, l3, i4, j4, j1, l4, k1 === l1 && k1 === i2 && k1 === j2);
        for (let j5 = i; j5 >= 0; j5--) {
          if (this.tiles[j5][j][k] == null) {
            this.tiles[j5][j][k] = new SceneTile(j5, j, k);
          }
        }
        this.tiles[i][j][k].paint = genericTile_1;
        return;
      }
      const complexTile = new ComplexTile(j2, k3, i2, k1, j, i3, j3, l4, l2, i4, 0, k2, l, l1, j4, j1, k4, l3, k, i1);
      for (let k5 = i; k5 >= 0; k5--) {
        if (this.tiles[k5][j][k] == null) {
          this.tiles[k5][j][k] = new SceneTile(k5, j, k);
        }
      }
      this.tiles[i][j][k].complexTile = complexTile;
    }
    addGroundDecoration(i, j, k, byte0, l, i1, j1, renderable) {
      if (k <= 0) {
        return;
      }
      if (renderable == null) {
        return;
      }
      const floorDecoration = new FloorDecoration();
      floorDecoration.renderable = renderable;
      floorDecoration.y = i * 128 + 64;
      floorDecoration.z = j * 128 + 64;
      floorDecoration.x = i1;
      floorDecoration.hash = l;
      floorDecoration.config = byte0;
      if (this.tiles[j1][i][j] == null) {
        this.tiles[j1][i][j] = new SceneTile(j1, i, j);
      }
      this.tiles[j1][i][j].floorDecoration = floorDecoration;
    }
    addItemPile(i, plane, renderable_59_, renderable, k, renderable_58_, l, y, x2) {
      const cameraAngle = new CameraAngle();
      cameraAngle.aRenderable150 = renderable_59_;
      cameraAngle.y = x2 * 128 + 64;
      cameraAngle.z = y * 128 + 64;
      cameraAngle.x = i;
      cameraAngle.anInt179 = k;
      cameraAngle.aRenderable151 = renderable;
      cameraAngle.aRenderable152 = renderable_58_;
      let k1 = 0;
      const sceneTile = this.tiles[plane][x2][y];
      if (sceneTile != null) {
        for (let l1 = 0; l1 < sceneTile.sceneSpawnRequestCount; l1++) {
          if (sceneTile.sceneSpawnRequests[l1].renderable != null && sceneTile.sceneSpawnRequests[l1].renderable instanceof Model) {
            const i2 = sceneTile.sceneSpawnRequests[l1].renderable.anInt1675;
            if (i2 > k1) {
              k1 = i2;
            }
          }
        }
      }
      cameraAngle.anInt180 = k1;
      if (this.tiles[plane][x2][y] == null) {
        this.tiles[plane][x2][y] = new SceneTile(plane, x2, y);
      }
      this.tiles[plane][x2][y].cameraAngle = cameraAngle;
    }
    method249(faceUnknown, renderable, hash, y, config, x2, renderable_68_, plane, face, l1) {
      if (renderable != null || renderable_68_ != null) {
        const wall = new Wall();
        wall.hash = hash;
        wall.config = config;
        wall.x = x2 * 128 + 64;
        wall.y = y * 128 + 64;
        wall.plane = plane;
        wall.aRenderable769 = renderable;
        wall.aRenderable770 = renderable_68_;
        wall.orientationA = faceUnknown;
        wall.face = face;
        for (let j2 = l1; j2 >= 0; j2--) {
          if (this.tiles[j2][x2][y] == null) {
            this.tiles[j2][x2][y] = new SceneTile(j2, x2, y);
          }
        }
        this.tiles[l1][x2][y].wall = wall;
      }
    }
    addWallDecoration(plane, faceUnknown, face, hash, config, x2, j1, y, l1, z, renderable, j2) {
      if (renderable != null) {
        const wallDecoration = new WallDecoration();
        wallDecoration.hash = hash;
        wallDecoration.config = config;
        wallDecoration.y = x2 * 128 + 64 + l1;
        wallDecoration.x = y * 128 + 64 + j1;
        wallDecoration.plane = z;
        wallDecoration.renderable = renderable;
        wallDecoration.faceUnknown = faceUnknown;
        wallDecoration.face = face;
        for (let planeCounter = plane; planeCounter >= 0; planeCounter--) {
          if (this.tiles[planeCounter][x2][y] == null) {
            this.tiles[planeCounter][x2][y] = new SceneTile(planeCounter, x2, y);
          }
        }
        this.tiles[plane][x2][y].wallDecoration = wallDecoration;
      }
    }
    method251(i, j, k, class50_sub1_sub4, byte0, l, i1, j1, k1, l1, i2) {
      while (j1 >= 0) {
        throw Error("NullPointerException()");
      }
      if (class50_sub1_sub4 == null) {
        return true;
      } else {
        const j2 = i1 * 128 + 64 * j;
        const k2 = k * 128 + 64 * k1;
        return this.addSceneSpawnRequest(i, i1, k, j, k1, j2, k2, l1, class50_sub1_sub4, l, false, i2, byte0);
      }
    }
    addEntity(i, entity, x2, z, flag, l, plane, j1, y, l1) {
      if (entity == null) {
        return true;
      }
      let i2 = x2 - j1;
      let j2 = y - j1;
      let k2 = x2 + j1;
      let l2 = y + j1;
      if (flag) {
        if (l1 > 640 && l1 < 1408) {
          l2 += 128;
        }
        if (l1 > 1152 && l1 < 1920) {
          k2 += 128;
        }
        if (l1 > 1664 || l1 < 384) {
          j2 -= 128;
        }
        if (l1 > 128 && l1 < 896) {
          i2 -= 128;
        }
      }
      i2 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(i2 / 128);
      j2 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(j2 / 128);
      k2 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(k2 / 128);
      l2 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(l2 / 128);
      return this.addSceneSpawnRequest(plane, i2, j2, k2 - i2 + 1, l2 - j2 + 1, x2, y, z, entity, l1, true, i, 0 | 0);
    }
    addRenderable(i, j, k, l, renderable, i1, j1, k1, l1, i2, j2, k2, l2) {
      if (renderable == null) {
        return true;
      } else {
        return this.addSceneSpawnRequest(k2, i1, j, j2 - i1 + 1, k1 - j + 1, l1, j1, i, renderable, i2, true, l2, 0);
      }
    }
    addSceneSpawnRequest(i, j, k, l, i1, x2, y, z, renderable, i2, flag, j2, byte0) {
      for (let k2 = j; k2 < j + l; k2++) {
        {
          for (let l2 = k; l2 < k + i1; l2++) {
            {
              if (k2 < 0 || l2 < 0 || k2 >= this.anInt453 || l2 >= this.anInt454) {
                return false;
              }
              const class50_sub3 = this.tiles[i][k2][l2];
              if (class50_sub3 != null && class50_sub3.sceneSpawnRequestCount >= 5) {
                return false;
              }
            }
          }
        }
      }
      const sceneSpawnRequest = new SceneSpawnRequest();
      sceneSpawnRequest.hash = j2;
      sceneSpawnRequest.config = byte0;
      sceneSpawnRequest.anInt113 = i;
      sceneSpawnRequest.x = x2;
      sceneSpawnRequest.y = y;
      sceneSpawnRequest.tileHeight = z;
      sceneSpawnRequest.renderable = renderable;
      sceneSpawnRequest.anInt118 = i2;
      sceneSpawnRequest.relativeX = j;
      sceneSpawnRequest.relativeY = k;
      sceneSpawnRequest.offsetX = j + l - 1;
      sceneSpawnRequest.offsetY = k + i1 - 1;
      for (let i3 = j; i3 < j + l; i3++) {
        {
          for (let j3 = k; j3 < k + i1; j3++) {
            {
              let k3 = 0;
              if (i3 > j) {
                k3++;
              }
              if (i3 < j + l - 1) {
                k3 += 4;
              }
              if (j3 > k) {
                k3 += 8;
              }
              if (j3 < k + i1 - 1) {
                k3 += 2;
              }
              for (let l3 = i; l3 >= 0; l3--) {
                if (this.tiles[l3][i3][j3] == null) {
                  this.tiles[l3][i3][j3] = new SceneTile(l3, i3, j3);
                }
              }
              const sceneTile = this.tiles[i][i3][j3];
              sceneTile.sceneSpawnRequests[sceneTile.sceneSpawnRequestCount] = sceneSpawnRequest;
              sceneTile.anIntArray1409[sceneTile.sceneSpawnRequestCount] = k3;
              sceneTile.anInt1410 |= k3;
              sceneTile.sceneSpawnRequestCount++;
            }
          }
        }
      }
      if (flag) {
        this.sceneSpawnRequests[this.anInt458++] = sceneSpawnRequest;
      }
      return true;
    }
    method255() {
      for (let j = 0; j < this.anInt458; j++) {
        {
          const sceneSpawnRequest = this.sceneSpawnRequests[j];
          this.method256(sceneSpawnRequest);
          this.sceneSpawnRequests[j] = null;
        }
      }
      this.anInt458 = 0;
    }
    method256(sceneSpawnRequest) {
      for (let j = sceneSpawnRequest.relativeX; j <= sceneSpawnRequest.offsetX; j++) {
        {
          for (let k = sceneSpawnRequest.relativeY; k <= sceneSpawnRequest.offsetY; k++) {
            {
              const class50_sub3 = this.tiles[sceneSpawnRequest.anInt113][j][k];
              if (class50_sub3 != null) {
                for (let l = 0; l < class50_sub3.sceneSpawnRequestCount; l++) {
                  {
                    if (class50_sub3.sceneSpawnRequests[l] !== sceneSpawnRequest) {
                      continue;
                    }
                    class50_sub3.sceneSpawnRequestCount--;
                    for (let i1 = l; i1 < class50_sub3.sceneSpawnRequestCount; i1++) {
                      {
                        class50_sub3.sceneSpawnRequests[i1] = class50_sub3.sceneSpawnRequests[i1 + 1];
                        class50_sub3.anIntArray1409[i1] = class50_sub3.anIntArray1409[i1 + 1];
                      }
                    }
                    class50_sub3.sceneSpawnRequests[class50_sub3.sceneSpawnRequestCount] = null;
                    break;
                  }
                }
                class50_sub3.anInt1410 = 0;
                for (let j1 = 0; j1 < class50_sub3.sceneSpawnRequestCount; j1++) {
                  class50_sub3.anInt1410 |= class50_sub3.anIntArray1409[j1];
                }
              }
            }
          }
        }
      }
    }
    method257(i, j, k, l) {
      const sceneTile = this.tiles[k][l][i];
      if (sceneTile == null) {
        return;
      }
      const wallDecoration = sceneTile.wallDecoration;
      if (wallDecoration == null) {
        return;
      }
      const j1 = l * 128 + 64;
      const k1 = i * 128 + 64;
      wallDecoration.y = j1 + ((wallDecoration.y - j1) * j / 16 | 0);
      wallDecoration.x = k1 + ((wallDecoration.x - k1) * j / 16 | 0);
    }
    method258(i, j, k, flag) {
      const class50_sub3 = this.tiles[j][k][i];
      if (class50_sub3 == null) {
        return;
      }
      class50_sub3.wall = null;
    }
    method259(flag, i, j, k) {
      const class50_sub3 = this.tiles[k][i][j];
      if (flag) {
        return;
      }
      if (class50_sub3 == null) {
        return;
      } else {
        class50_sub3.wallDecoration = null;
        return;
      }
    }
    method260(i, j, k, l) {
      if (k >= 0) {
        return;
      }
      const class50_sub3 = this.tiles[j][l][i];
      if (class50_sub3 == null) {
        return;
      }
      for (let i1 = 0; i1 < class50_sub3.sceneSpawnRequestCount; i1++) {
        {
          const sceneSpawnRequest = class50_sub3.sceneSpawnRequests[i1];
          if ((sceneSpawnRequest.hash >> 29 & 3) === 2 && sceneSpawnRequest.relativeX === l && sceneSpawnRequest.relativeY === i) {
            this.method256(sceneSpawnRequest);
            return;
          }
        }
      }
    }
    method261(i, j, flag, k) {
      const class50_sub3 = this.tiles[k][i][j];
      if (class50_sub3 == null) {
        return;
      }
      class50_sub3.floorDecoration = null;
      if (!flag) {
        for (let l = 1; l > 0; l++) {
        }
      }
    }
    clearGroundItem(i, j, k) {
      const class50_sub3 = this.tiles[i][j][k];
      if (class50_sub3 == null) {
        return;
      } else {
        class50_sub3.cameraAngle = null;
        return;
      }
    }
    method263(i, j, k, l) {
      const class50_sub3 = this.tiles[i][k][l];
      if (j !== 17734) {
        throw Error("NullPointerException()");
      }
      if (class50_sub3 == null) {
        return null;
      } else {
        return class50_sub3.wall;
      }
    }
    method264(i, j, k, flag) {
      const class50_sub3 = this.tiles[i][k][j];
      if (flag) {
        throw Error("NullPointerException()");
      }
      if (class50_sub3 == null) {
        return null;
      } else {
        return class50_sub3.wallDecoration;
      }
    }
    method265(i, byte0, j, k) {
      if (byte0 !== 32) {
        for (let l = 1; l > 0; l++) {
        }
      }
      const class50_sub3 = this.tiles[k][i][j];
      if (class50_sub3 == null) {
        return null;
      }
      for (let i1 = 0; i1 < class50_sub3.sceneSpawnRequestCount; i1++) {
        {
          const sceneSpawnRequest = class50_sub3.sceneSpawnRequests[i1];
          if ((sceneSpawnRequest.hash >> 29 & 3) === 2 && sceneSpawnRequest.relativeX === i && sceneSpawnRequest.relativeY === j) {
            return sceneSpawnRequest;
          }
        }
      }
      return null;
    }
    method266(i, j, k, l) {
      if (k !== 0) {
        throw Error("NullPointerException()");
      }
      const class50_sub3 = this.tiles[i][l][j];
      if (class50_sub3 == null || class50_sub3.floorDecoration == null) {
        return null;
      } else {
        return class50_sub3.floorDecoration;
      }
    }
    method267(i, j, k) {
      const class50_sub3 = this.tiles[i][j][k];
      if (class50_sub3 == null || class50_sub3.wall == null) {
        return 0;
      } else {
        return class50_sub3.wall.hash;
      }
    }
    method268(i, byte0, j, k) {
      const class50_sub3 = this.tiles[j][i][k];
      if (class50_sub3 == null || class50_sub3.wallDecoration == null) {
        return 0;
      } else {
        return class50_sub3.wallDecoration.hash;
      }
    }
    method269(i, j, k) {
      const class50_sub3 = this.tiles[i][j][k];
      if (class50_sub3 == null) {
        return 0;
      }
      for (let l = 0; l < class50_sub3.sceneSpawnRequestCount; l++) {
        {
          const sceneSpawnRequest = class50_sub3.sceneSpawnRequests[l];
          if ((sceneSpawnRequest.hash >> 29 & 3) === 2 && sceneSpawnRequest.relativeX === j && sceneSpawnRequest.relativeY === k) {
            return sceneSpawnRequest.hash;
          }
        }
      }
      return 0;
    }
    getFloorDecorationHash(i, j, k) {
      const class50_sub3 = this.tiles[i][j][k];
      if (class50_sub3 == null || class50_sub3.floorDecoration == null) {
        return 0;
      } else {
        return class50_sub3.floorDecoration.hash;
      }
    }
    method271(i, j, k, l) {
      const class50_sub3 = this.tiles[i][j][k];
      if (class50_sub3 == null) {
        return -1;
      }
      if (class50_sub3.wall != null && class50_sub3.wall.hash === l) {
        return class50_sub3.wall.config & 255;
      }
      if (class50_sub3.wallDecoration != null && class50_sub3.wallDecoration.hash === l) {
        return class50_sub3.wallDecoration.config & 255;
      }
      if (class50_sub3.floorDecoration != null && class50_sub3.floorDecoration.hash === l) {
        return class50_sub3.floorDecoration.config & 255;
      }
      for (let i1 = 0; i1 < class50_sub3.sceneSpawnRequestCount; i1++) {
        if (class50_sub3.sceneSpawnRequests[i1].hash === l) {
          return class50_sub3.sceneSpawnRequests[i1].config & 255;
        }
      }
      return -1;
    }
    method272(byte0, i, j, k) {
      for (let l = 0; l < this.anInt452; l++) {
        {
          for (let i1 = 0; i1 < this.anInt453; i1++) {
            {
              for (let j1 = 0; j1 < this.anInt454; j1++) {
                {
                  const class50_sub3 = this.tiles[l][i1][j1];
                  if (class50_sub3 != null) {
                    const wall = class50_sub3.wall;
                    if (wall != null && wall.aRenderable769 != null && wall.aRenderable769.verticesNormal != null) {
                      this.method274(j1, l, 0, 1, wall.aRenderable769, i1, 1);
                      if (wall.aRenderable770 != null && wall.aRenderable770.verticesNormal != null) {
                        this.method274(j1, l, 0, 1, wall.aRenderable770, i1, 1);
                        this.method275(wall.aRenderable769, wall.aRenderable770, 0, 0, 0, false);
                        wall.aRenderable770.method595(i, j, 0, k);
                      }
                      wall.aRenderable769.method595(i, j, 0, k);
                    }
                    for (let k1 = 0; k1 < class50_sub3.sceneSpawnRequestCount; k1++) {
                      {
                        const sceneSpawnRequest = class50_sub3.sceneSpawnRequests[k1];
                        if (sceneSpawnRequest != null && sceneSpawnRequest.renderable != null && sceneSpawnRequest.renderable.verticesNormal != null) {
                          this.method274(
                            j1,
                            l,
                            0,
                            sceneSpawnRequest.offsetX - sceneSpawnRequest.relativeX + 1,
                            sceneSpawnRequest.renderable,
                            i1,
                            sceneSpawnRequest.offsetY - sceneSpawnRequest.relativeY + 1
                          );
                          sceneSpawnRequest.renderable.method595(i, j, 0, k);
                        }
                      }
                    }
                    const floorDecoration = class50_sub3.floorDecoration;
                    if (floorDecoration != null && floorDecoration.renderable.verticesNormal != null) {
                      this.method273(i1, floorDecoration.renderable, j1, l, 0);
                      floorDecoration.renderable.method595(i, j, 0, k);
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (byte0 === 2) {
        byte0 = 0;
      }
    }
    method273(i, class50_sub1_sub4_sub4, j, k, l) {
      if (l !== 0) {
        return;
      }
      if (i < this.anInt453) {
        const class50_sub3 = this.tiles[k][i + 1][j];
        if (class50_sub3 != null && class50_sub3.floorDecoration != null && class50_sub3.floorDecoration.renderable.verticesNormal != null) {
          this.method275(class50_sub1_sub4_sub4, class50_sub3.floorDecoration.renderable, 128, 0, 0, true);
        }
      }
      if (j < this.anInt453) {
        const class50_sub3_1 = this.tiles[k][i][j + 1];
        if (class50_sub3_1 != null && class50_sub3_1.floorDecoration != null && class50_sub3_1.floorDecoration.renderable.verticesNormal != null) {
          this.method275(class50_sub1_sub4_sub4, class50_sub3_1.floorDecoration.renderable, 0, 0, 128, true);
        }
      }
      if (i < this.anInt453 && j < this.anInt454) {
        const class50_sub3_2 = this.tiles[k][i + 1][j + 1];
        if (class50_sub3_2 != null && class50_sub3_2.floorDecoration != null && class50_sub3_2.floorDecoration.renderable.verticesNormal != null) {
          this.method275(class50_sub1_sub4_sub4, class50_sub3_2.floorDecoration.renderable, 128, 0, 128, true);
        }
      }
      if (i < this.anInt453 && j > 0) {
        const class50_sub3_3 = this.tiles[k][i + 1][j - 1];
        if (class50_sub3_3 != null && class50_sub3_3.floorDecoration != null && class50_sub3_3.floorDecoration.renderable.verticesNormal != null) {
          this.method275(class50_sub1_sub4_sub4, class50_sub3_3.floorDecoration.renderable, 128, 0, -128, true);
        }
      }
    }
    method274(i, j, k, l, class50_sub1_sub4_sub4, i1, j1) {
      let flag = true;
      let k1 = i1;
      const l1 = i1 + l;
      const i2 = i - 1;
      const j2 = i + j1;
      for (let k2 = j; k2 <= j + 1; k2++) {
        if (k2 !== this.anInt452) {
          for (let l2 = k1; l2 <= l1; l2++) {
            if (l2 >= 0 && l2 < this.anInt453) {
              for (let i3 = i2; i3 <= j2; i3++) {
                if (i3 >= 0 && i3 < this.anInt454 && (!flag || l2 >= l1 || i3 >= j2 || i3 < i && l2 !== i1)) {
                  const class50_sub3 = this.tiles[k2][l2][i3];
                  if (class50_sub3 != null) {
                    const j3 = ((this.anIntArrayArrayArray455[k2][l2][i3] + this.anIntArrayArrayArray455[k2][l2 + 1][i3] + this.anIntArrayArrayArray455[k2][l2][i3 + 1] + this.anIntArrayArrayArray455[k2][l2 + 1][i3 + 1]) / 4 | 0) - ((this.anIntArrayArrayArray455[j][i1][i] + this.anIntArrayArrayArray455[j][i1 + 1][i] + this.anIntArrayArrayArray455[j][i1][i + 1] + this.anIntArrayArrayArray455[j][i1 + 1][i + 1]) / 4 | 0);
                    const wall = class50_sub3.wall;
                    if (wall != null && wall.aRenderable769 != null && wall.aRenderable769.verticesNormal != null) {
                      this.method275(
                        class50_sub1_sub4_sub4,
                        wall.aRenderable769,
                        (l2 - i1) * 128 + (1 - l) * 64,
                        j3,
                        (i3 - i) * 128 + (1 - j1) * 64,
                        flag
                      );
                    }
                    if (wall != null && wall.aRenderable770 != null && wall.aRenderable770.verticesNormal != null) {
                      this.method275(
                        class50_sub1_sub4_sub4,
                        wall.aRenderable770,
                        (l2 - i1) * 128 + (1 - l) * 64,
                        j3,
                        (i3 - i) * 128 + (1 - j1) * 64,
                        flag
                      );
                    }
                    for (let k3 = 0; k3 < class50_sub3.sceneSpawnRequestCount; k3++) {
                      {
                        const sceneSpawnRequest = class50_sub3.sceneSpawnRequests[k3];
                        if (sceneSpawnRequest != null && sceneSpawnRequest.renderable != null && sceneSpawnRequest.renderable.verticesNormal != null) {
                          const l3 = sceneSpawnRequest.offsetX - sceneSpawnRequest.relativeX + 1;
                          const i4 = sceneSpawnRequest.offsetY - sceneSpawnRequest.relativeY + 1;
                          this.method275(
                            class50_sub1_sub4_sub4,
                            sceneSpawnRequest.renderable,
                            (sceneSpawnRequest.relativeX - i1) * 128 + (l3 - l) * 64,
                            j3,
                            (sceneSpawnRequest.relativeY - i) * 128 + (i4 - j1) * 64,
                            flag
                          );
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          k1--;
          flag = false;
        }
      }
      if (k === 0) {
      }
    }
    method275(class50_sub1_sub4_sub4, class50_sub1_sub4_sub4_1, i, j, k, flag) {
      this.anInt503++;
      let l = 0;
      const ai = class50_sub1_sub4_sub4_1.verticesX;
      const i1 = class50_sub1_sub4_sub4_1.vertexCount;
      const j1 = class50_sub1_sub4_sub4_1.anInt1669 >> 16;
      const k1 = class50_sub1_sub4_sub4_1.anInt1669 << 16 >> 16;
      const l1 = class50_sub1_sub4_sub4_1.anInt1670 >> 16;
      const i2 = class50_sub1_sub4_sub4_1.anInt1670 << 16 >> 16;
      for (let j2 = 0; j2 < class50_sub1_sub4_sub4.vertexCount; j2++) {
        {
          const class40 = class50_sub1_sub4_sub4.verticesNormal[j2];
          const class40_1 = class50_sub1_sub4_sub4.aClass40Array1681[j2];
          if (class40_1.magnitude !== 0) {
            const i3 = class50_sub1_sub4_sub4.verticesY[j2] - j;
            if (i3 <= class50_sub1_sub4_sub4_1.maxY) {
              const j3 = class50_sub1_sub4_sub4.verticesX[j2] - i;
              if (j3 >= j1 && j3 <= k1) {
                const k3 = class50_sub1_sub4_sub4.verticesZ[j2] - k;
                if (k3 >= i2 && k3 <= l1) {
                  for (let l3 = 0; l3 < i1; l3++) {
                    {
                      const class40_2 = class50_sub1_sub4_sub4_1.verticesNormal[l3];
                      const class40_3 = class50_sub1_sub4_sub4_1.aClass40Array1681[l3];
                      if (j3 === ai[l3] && k3 === class50_sub1_sub4_sub4_1.verticesZ[l3] && i3 === class50_sub1_sub4_sub4_1.verticesY[l3] && class40_3.magnitude !== 0) {
                        class40.x += class40_3.x;
                        class40.y += class40_3.y;
                        class40.z += class40_3.z;
                        class40.magnitude += class40_3.magnitude;
                        class40_2.x += class40_1.x;
                        class40_2.y += class40_1.y;
                        class40_2.z += class40_1.z;
                        class40_2.magnitude += class40_1.magnitude;
                        l++;
                        this.anIntArray501[j2] = this.anInt503;
                        this.anIntArray502[l3] = this.anInt503;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (l < 3 || !flag) {
        return;
      }
      for (let k2 = 0; k2 < class50_sub1_sub4_sub4.triangleCount; k2++) {
        if (this.anIntArray501[class50_sub1_sub4_sub4.trianglePointsX[k2]] === this.anInt503 && this.anIntArray501[class50_sub1_sub4_sub4.trianglePointsY[k2]] === this.anInt503 && this.anIntArray501[class50_sub1_sub4_sub4.trianglePointsZ[k2]] === this.anInt503) {
          class50_sub1_sub4_sub4.texturePoints[k2] = -1;
        }
      }
      for (let l2 = 0; l2 < class50_sub1_sub4_sub4_1.triangleCount; l2++) {
        if (this.anIntArray502[class50_sub1_sub4_sub4_1.trianglePointsX[l2]] === this.anInt503 && this.anIntArray502[class50_sub1_sub4_sub4_1.trianglePointsY[l2]] === this.anInt503 && this.anIntArray502[class50_sub1_sub4_sub4_1.trianglePointsZ[l2]] === this.anInt503) {
          class50_sub1_sub4_sub4_1.texturePoints[l2] = -1;
        }
      }
    }
    renderMinimapDot(ai, i, j, k, l, i1) {
      const class50_sub3 = this.tiles[k][l][i1];
      if (class50_sub3 == null) {
        return;
      }
      const genericTile = class50_sub3.paint;
      if (genericTile != null) {
        const j1 = genericTile.rgbColor;
        if (j1 === 0) {
          return;
        }
        for (let k1 = 0; k1 < 4; k1++) {
          {
            ai[i] = j1;
            ai[i + 1] = j1;
            ai[i + 2] = j1;
            ai[i + 3] = j1;
            i += j;
          }
        }
        return;
      }
      const complexTile = class50_sub3.complexTile;
      if (complexTile == null) {
        return;
      }
      const l1 = complexTile.anInt414;
      const i2 = complexTile.anInt415;
      const j2 = complexTile.anInt416;
      const k2 = complexTile.anInt417;
      const ai1 = this.anIntArrayArray504[l1];
      const ai2 = this.anIntArrayArray505[i2];
      let l2 = 0;
      if (j2 !== 0) {
        for (let i3 = 0; i3 < 4; i3++) {
          {
            ai[i] = ai1[ai2[l2++]] !== 0 ? k2 : j2;
            ai[i + 1] = ai1[ai2[l2++]] !== 0 ? k2 : j2;
            ai[i + 2] = ai1[ai2[l2++]] !== 0 ? k2 : j2;
            ai[i + 3] = ai1[ai2[l2++]] !== 0 ? k2 : j2;
            i += j;
          }
        }
        return;
      }
      for (let j3 = 0; j3 < 4; j3++) {
        {
          if (ai1[ai2[l2++]] !== 0) {
            ai[i] = k2;
          }
          if (ai1[ai2[l2++]] !== 0) {
            ai[i + 1] = k2;
          }
          if (ai1[ai2[l2++]] !== 0) {
            ai[i + 2] = k2;
          }
          if (ai1[ai2[l2++]] !== 0) {
            ai[i + 3] = k2;
          }
          i += j;
        }
      }
    }
    method279(i, j, k) {
      _Scene.aBoolean482 = true;
      _Scene.anInt483 = j;
      _Scene.anInt484 = k;
      _Scene.clickedTileX = -1;
      if (i !== 0) {
        return;
      } else {
        _Scene.anInt486 = -1;
        return;
      }
    }
    method280(i, j, k, l, i1, j1, k1) {
      if (i < 0) {
        i = 0;
      } else if (i >= this.anInt453 * 128) {
        i = this.anInt453 * 128 - 1;
      }
      if (i1 < 0) {
        i1 = 0;
      } else if (i1 >= this.anInt454 * 128) {
        i1 = this.anInt454 * 128 - 1;
      }
      _Scene.cycle++;
      _Scene.pitchSin = Model.SINE[k1];
      _Scene.pitchCos = Model.COSINE[k1];
      _Scene.yawSin = Model.SINE[j1];
      _Scene.yawCos = Model.COSINE[j1];
      _Scene.aBooleanArrayArray507 = _Scene.aBooleanArrayArrayArrayArray506[(k1 - 128) / 32 | 0][j1 / 64 | 0];
      _Scene.cameraX2 = i;
      _Scene.cameraY2 = l;
      _Scene.cameraZ2 = i1;
      _Scene.screenCenterX = i / 128 | 0;
      _Scene.screenCenterZ = i1 / 128 | 0;
      _Scene.anInt462 = j;
      _Scene.anInt464 = _Scene.screenCenterX - 25;
      if (k !== 0) {
        return;
      }
      if (_Scene.anInt464 < 0) {
        _Scene.anInt464 = 0;
      }
      _Scene.anInt466 = _Scene.screenCenterZ - 25;
      if (_Scene.anInt466 < 0) {
        _Scene.anInt466 = 0;
      }
      _Scene.anInt465 = _Scene.screenCenterX + 25;
      if (_Scene.anInt465 > this.anInt453) {
        _Scene.anInt465 = this.anInt453;
      }
      _Scene.anInt467 = _Scene.screenCenterZ + 25;
      if (_Scene.anInt467 > this.anInt454) {
        _Scene.anInt467 = this.anInt454;
      }
      this.method286();
      _Scene.anInt461 = 0;
      for (let l1 = this.anInt457; l1 < this.anInt452; l1++) {
        {
          const aclass50_sub3 = this.tiles[l1];
          for (let j2 = _Scene.anInt464; j2 < _Scene.anInt465; j2++) {
            {
              for (let l2 = _Scene.anInt466; l2 < _Scene.anInt467; l2++) {
                {
                  const class50_sub3 = aclass50_sub3[j2][l2];
                  if (class50_sub3 != null) {
                    if (class50_sub3.physicalLevel > j || !_Scene.aBooleanArrayArray507[j2 - _Scene.screenCenterX + 25][l2 - _Scene.screenCenterZ + 25] && this.anIntArrayArrayArray455[l1][j2][l2] - l < 2e3) {
                      class50_sub3.draw = false;
                      class50_sub3.visible = false;
                      class50_sub3.wallCullDirection = 0;
                    } else {
                      class50_sub3.draw = true;
                      class50_sub3.visible = true;
                      if (class50_sub3.sceneSpawnRequestCount > 0) {
                        class50_sub3.drawEntities = true;
                      } else {
                        class50_sub3.drawEntities = false;
                      }
                      _Scene.anInt461++;
                    }
                  }
                }
              }
            }
          }
        }
      }
      for (let i2 = this.anInt457; i2 < this.anInt452; i2++) {
        {
          const aclass50_sub3_1 = this.tiles[i2];
          for (let i3 = -25; i3 <= 0; i3++) {
            {
              const j3 = _Scene.screenCenterX + i3;
              const l3 = _Scene.screenCenterX - i3;
              if (j3 >= _Scene.anInt464 || l3 < _Scene.anInt465) {
                for (let j4 = -25; j4 <= 0; j4++) {
                  {
                    const l4 = _Scene.screenCenterZ + j4;
                    const j5 = _Scene.screenCenterZ - j4;
                    if (j3 >= _Scene.anInt464) {
                      if (l4 >= _Scene.anInt466) {
                        const class50_sub3_1 = aclass50_sub3_1[j3][l4];
                        if (class50_sub3_1 != null && class50_sub3_1.draw) {
                          this.drawTile(class50_sub3_1, true);
                        }
                      }
                      if (j5 < _Scene.anInt467) {
                        const class50_sub3_2 = aclass50_sub3_1[j3][j5];
                        if (class50_sub3_2 != null && class50_sub3_2.draw) {
                          this.drawTile(class50_sub3_2, true);
                        }
                      }
                    }
                    if (l3 < _Scene.anInt465) {
                      if (l4 >= _Scene.anInt466) {
                        const class50_sub3_3 = aclass50_sub3_1[l3][l4];
                        if (class50_sub3_3 != null && class50_sub3_3.draw) {
                          this.drawTile(class50_sub3_3, true);
                        }
                      }
                      if (j5 < _Scene.anInt467) {
                        const class50_sub3_4 = aclass50_sub3_1[l3][j5];
                        if (class50_sub3_4 != null && class50_sub3_4.draw) {
                          this.drawTile(class50_sub3_4, true);
                        }
                      }
                    }
                    if (_Scene.anInt461 === 0) {
                      _Scene.aBoolean482 = false;
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
      for (let k2 = this.anInt457; k2 < this.anInt452; k2++) {
        {
          const aclass50_sub3_2 = this.tiles[k2];
          for (let k3 = -25; k3 <= 0; k3++) {
            {
              const i4 = _Scene.screenCenterX + k3;
              const k4 = _Scene.screenCenterX - k3;
              if (i4 >= _Scene.anInt464 || k4 < _Scene.anInt465) {
                for (let i5 = -25; i5 <= 0; i5++) {
                  {
                    const k5 = _Scene.screenCenterZ + i5;
                    const l5 = _Scene.screenCenterZ - i5;
                    if (i4 >= _Scene.anInt464) {
                      if (k5 >= _Scene.anInt466) {
                        const class50_sub3_5 = aclass50_sub3_2[i4][k5];
                        if (class50_sub3_5 != null && class50_sub3_5.draw) {
                          this.drawTile(class50_sub3_5, false);
                        }
                      }
                      if (l5 < _Scene.anInt467) {
                        const class50_sub3_6 = aclass50_sub3_2[i4][l5];
                        if (class50_sub3_6 != null && class50_sub3_6.draw) {
                          this.drawTile(class50_sub3_6, false);
                        }
                      }
                    }
                    if (k4 < _Scene.anInt465) {
                      if (k5 >= _Scene.anInt466) {
                        const class50_sub3_7 = aclass50_sub3_2[k4][k5];
                        if (class50_sub3_7 != null && class50_sub3_7.draw) {
                          this.drawTile(class50_sub3_7, false);
                        }
                      }
                      if (l5 < _Scene.anInt467) {
                        const class50_sub3_8 = aclass50_sub3_2[k4][l5];
                        if (class50_sub3_8 != null && class50_sub3_8.draw) {
                          this.drawTile(class50_sub3_8, false);
                        }
                      }
                    }
                    if (_Scene.anInt461 === 0) {
                      _Scene.aBoolean482 = false;
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
      _Scene.aBoolean482 = false;
    }
    drawTile(tile, flag) {
      _Scene.tileList.insertBack(tile);
      do {
        {
          let tileFromList;
          do {
            {
              tileFromList = _Scene.tileList.removeFirst();
              if (tileFromList == null) {
                return;
              }
            }
          } while (!tileFromList.visible);
          const i = tileFromList.x;
          const j = tileFromList.y;
          const k = tileFromList.plane;
          const l = tileFromList.renderLevel;
          const aclass50_sub3 = this.tiles[k];
          if (tileFromList.draw) {
            if (flag) {
              if (k > 0) {
                const class50_sub3_2 = this.tiles[k - 1][i][j];
                if (class50_sub3_2 != null && class50_sub3_2.visible) {
                  continue;
                }
              }
              if (i <= _Scene.screenCenterX && i > _Scene.anInt464) {
                const class50_sub3_3 = aclass50_sub3[i - 1][j];
                if (class50_sub3_3 != null && class50_sub3_3.visible && (class50_sub3_3.draw || (tileFromList.anInt1410 & 1) === 0)) {
                  continue;
                }
              }
              if (i >= _Scene.screenCenterX && i < _Scene.anInt465 - 1) {
                const class50_sub3_4 = aclass50_sub3[i + 1][j];
                if (class50_sub3_4 != null && class50_sub3_4.visible && (class50_sub3_4.draw || (tileFromList.anInt1410 & 4) === 0)) {
                  continue;
                }
              }
              if (j <= _Scene.screenCenterZ && j > _Scene.anInt466) {
                const class50_sub3_5 = aclass50_sub3[i][j - 1];
                if (class50_sub3_5 != null && class50_sub3_5.visible && (class50_sub3_5.draw || (tileFromList.anInt1410 & 8) === 0)) {
                  continue;
                }
              }
              if (j >= _Scene.screenCenterZ && j < _Scene.anInt467 - 1) {
                const class50_sub3_6 = aclass50_sub3[i][j + 1];
                if (class50_sub3_6 != null && class50_sub3_6.visible && (class50_sub3_6.draw || (tileFromList.anInt1410 & 2) === 0)) {
                  continue;
                }
              }
            } else {
              flag = true;
            }
            tileFromList.draw = false;
            if (tileFromList.bridge != null) {
              const class50_sub3_7 = tileFromList.bridge;
              if (class50_sub3_7.paint != null) {
                if (!this.isTileOccluded(0, i, j)) {
                  this.drawTileUnderlay(
                    class50_sub3_7.paint,
                    0,
                    _Scene.pitchSin,
                    _Scene.pitchCos,
                    _Scene.yawSin,
                    _Scene.yawCos,
                    i,
                    j
                  );
                }
              } else if (class50_sub3_7.complexTile != null && !this.isTileOccluded(0, i, j)) {
                this.drawTileOverlay(
                  _Scene.pitchCos,
                  _Scene.yawCos,
                  class50_sub3_7.complexTile,
                  _Scene.pitchSin,
                  j,
                  i,
                  _Scene.yawSin,
                  3 | 0
                );
              }
              const wall = class50_sub3_7.wall;
              if (wall != null) {
                wall.aRenderable769.renderAtPoint(
                  0,
                  _Scene.pitchSin,
                  _Scene.pitchCos,
                  _Scene.yawSin,
                  _Scene.yawCos,
                  wall.x - _Scene.cameraX2,
                  wall.plane - _Scene.cameraY2,
                  wall.y - _Scene.cameraZ2,
                  wall.hash
                );
              }
              for (let i2 = 0; i2 < class50_sub3_7.sceneSpawnRequestCount; i2++) {
                {
                  const sceneSpawnRequest = class50_sub3_7.sceneSpawnRequests[i2];
                  if (sceneSpawnRequest != null) {
                    sceneSpawnRequest.renderable.renderAtPoint(
                      sceneSpawnRequest.anInt118,
                      _Scene.pitchSin,
                      _Scene.pitchCos,
                      _Scene.yawSin,
                      _Scene.yawCos,
                      sceneSpawnRequest.x - _Scene.cameraX2,
                      sceneSpawnRequest.tileHeight - _Scene.cameraY2,
                      sceneSpawnRequest.y - _Scene.cameraZ2,
                      sceneSpawnRequest.hash
                    );
                  }
                }
              }
            }
            let flag1 = false;
            if (tileFromList.paint != null) {
              if (!this.isTileOccluded(l, i, j)) {
                flag1 = true;
                this.drawTileUnderlay(tileFromList.paint, l, _Scene.pitchSin, _Scene.pitchCos, _Scene.yawSin, _Scene.yawCos, i, j);
              }
            } else if (tileFromList.complexTile != null && !this.isTileOccluded(l, i, j)) {
              flag1 = true;
              this.drawTileOverlay(
                _Scene.pitchCos,
                _Scene.yawCos,
                tileFromList.complexTile,
                _Scene.pitchSin,
                j,
                i,
                _Scene.yawSin,
                3 | 0
              );
            }
            let j1 = 0;
            let j2 = 0;
            const wall_3 = tileFromList.wall;
            const wallDecoration_1 = tileFromList.wallDecoration;
            if (wall_3 != null || wallDecoration_1 != null) {
              if (_Scene.screenCenterX === i) {
                j1++;
              } else if (_Scene.screenCenterX < i) {
                j1 += 2;
              }
              if (_Scene.screenCenterZ === j) {
                j1 += 3;
              } else if (_Scene.screenCenterZ > j) {
                j1 += 6;
              }
              j2 = _Scene.anIntArray493[j1];
              tileFromList.wallDrawFlags = _Scene.TILE_WALL_DRAW_FLAGS_1[j1];
            }
            if (wall_3 != null) {
              if ((wall_3.orientationA & _Scene.anIntArray494[j1]) !== 0) {
                if (wall_3.orientationA === 16) {
                  tileFromList.wallCullDirection = 3;
                  tileFromList.wallUncullDirection = _Scene.WALL_UNCULL_FLAGS_0[j1];
                  tileFromList.wallCullOppositeDirection = 3 - tileFromList.wallUncullDirection;
                } else if (wall_3.orientationA === 32) {
                  tileFromList.wallCullDirection = 6;
                  tileFromList.wallUncullDirection = _Scene.anIntArray497[j1];
                  tileFromList.wallCullOppositeDirection = 6 - tileFromList.wallUncullDirection;
                } else if (wall_3.orientationA === 64) {
                  tileFromList.wallCullDirection = 12;
                  tileFromList.wallUncullDirection = _Scene.anIntArray498[j1];
                  tileFromList.wallCullOppositeDirection = 12 - tileFromList.wallUncullDirection;
                } else {
                  tileFromList.wallCullDirection = 9;
                  tileFromList.wallUncullDirection = _Scene.anIntArray499[j1];
                  tileFromList.wallCullOppositeDirection = 9 - tileFromList.wallUncullDirection;
                }
              } else {
                tileFromList.wallCullDirection = 0;
              }
              if ((wall_3.orientationA & j2) !== 0 && !this.isWallOccluded(l, i, j, wall_3.orientationA)) {
                wall_3.aRenderable769.renderAtPoint(
                  0,
                  _Scene.pitchSin,
                  _Scene.pitchCos,
                  _Scene.yawSin,
                  _Scene.yawCos,
                  wall_3.x - _Scene.cameraX2,
                  wall_3.plane - _Scene.cameraY2,
                  wall_3.y - _Scene.cameraZ2,
                  wall_3.hash
                );
              }
              if ((wall_3.face & j2) !== 0 && !this.isWallOccluded(l, i, j, wall_3.face)) {
                wall_3.aRenderable770.renderAtPoint(
                  0,
                  _Scene.pitchSin,
                  _Scene.pitchCos,
                  _Scene.yawSin,
                  _Scene.yawCos,
                  wall_3.x - _Scene.cameraX2,
                  wall_3.plane - _Scene.cameraY2,
                  wall_3.y - _Scene.cameraZ2,
                  wall_3.hash
                );
              }
            }
            if (wallDecoration_1 != null && !this.isOccluded(l, i, j, wallDecoration_1.renderable.modelHeight)) {
              if ((wallDecoration_1.faceUnknown & j2) !== 0) {
                wallDecoration_1.renderable.renderAtPoint(
                  wallDecoration_1.face,
                  _Scene.pitchSin,
                  _Scene.pitchCos,
                  _Scene.yawSin,
                  _Scene.yawCos,
                  wallDecoration_1.y - _Scene.cameraX2,
                  wallDecoration_1.plane - _Scene.cameraY2,
                  wallDecoration_1.x - _Scene.cameraZ2,
                  wallDecoration_1.hash
                );
              } else if ((wallDecoration_1.faceUnknown & 768) !== 0) {
                const j4 = wallDecoration_1.y - _Scene.cameraX2;
                const l5 = wallDecoration_1.plane - _Scene.cameraY2;
                const k6 = wallDecoration_1.x - _Scene.cameraZ2;
                const i8 = wallDecoration_1.face;
                let k9;
                if (i8 === 1 || i8 === 2) {
                  k9 = -j4;
                } else {
                  k9 = j4;
                }
                let k10;
                if (i8 === 2 || i8 === 3) {
                  k10 = -k6;
                } else {
                  k10 = k6;
                }
                if ((wallDecoration_1.faceUnknown & 256) !== 0 && k10 < k9) {
                  const i11 = j4 + _Scene.anIntArray478[i8];
                  const k11 = k6 + _Scene.anIntArray479[i8];
                  wallDecoration_1.renderable.renderAtPoint(
                    i8 * 512 + 256,
                    _Scene.pitchSin,
                    _Scene.pitchCos,
                    _Scene.yawSin,
                    _Scene.yawCos,
                    i11,
                    l5,
                    k11,
                    wallDecoration_1.hash
                  );
                }
                if ((wallDecoration_1.faceUnknown & 512) !== 0 && k10 > k9) {
                  const j11 = j4 + _Scene.anIntArray480[i8];
                  const l11 = k6 + _Scene.anIntArray481[i8];
                  wallDecoration_1.renderable.renderAtPoint(
                    i8 * 512 + 1280 & 2047,
                    _Scene.pitchSin,
                    _Scene.pitchCos,
                    _Scene.yawSin,
                    _Scene.yawCos,
                    j11,
                    l5,
                    l11,
                    wallDecoration_1.hash
                  );
                }
              }
            }
            if (flag1) {
              const floorDecoration = tileFromList.floorDecoration;
              if (floorDecoration != null) {
                floorDecoration.renderable.renderAtPoint(
                  0,
                  _Scene.pitchSin,
                  _Scene.pitchCos,
                  _Scene.yawSin,
                  _Scene.yawCos,
                  floorDecoration.y - _Scene.cameraX2,
                  floorDecoration.x - _Scene.cameraY2,
                  floorDecoration.z - _Scene.cameraZ2,
                  floorDecoration.hash
                );
              }
              const cameraAngle_1 = tileFromList.cameraAngle;
              if (cameraAngle_1 != null && cameraAngle_1.anInt180 === 0) {
                if (cameraAngle_1.aRenderable151 != null) {
                  cameraAngle_1.aRenderable151.renderAtPoint(
                    0,
                    _Scene.pitchSin,
                    _Scene.pitchCos,
                    _Scene.yawSin,
                    _Scene.yawCos,
                    cameraAngle_1.y - _Scene.cameraX2,
                    cameraAngle_1.x - _Scene.cameraY2,
                    cameraAngle_1.z - _Scene.cameraZ2,
                    cameraAngle_1.anInt179
                  );
                }
                if (cameraAngle_1.aRenderable152 != null) {
                  cameraAngle_1.aRenderable152.renderAtPoint(
                    0,
                    _Scene.pitchSin,
                    _Scene.pitchCos,
                    _Scene.yawSin,
                    _Scene.yawCos,
                    cameraAngle_1.y - _Scene.cameraX2,
                    cameraAngle_1.x - _Scene.cameraY2,
                    cameraAngle_1.z - _Scene.cameraZ2,
                    cameraAngle_1.anInt179
                  );
                }
                if (cameraAngle_1.aRenderable150 != null) {
                  cameraAngle_1.aRenderable150.renderAtPoint(
                    0,
                    _Scene.pitchSin,
                    _Scene.pitchCos,
                    _Scene.yawSin,
                    _Scene.yawCos,
                    cameraAngle_1.y - _Scene.cameraX2,
                    cameraAngle_1.x - _Scene.cameraY2,
                    cameraAngle_1.z - _Scene.cameraZ2,
                    cameraAngle_1.anInt179
                  );
                }
              }
            }
            const k4 = tileFromList.anInt1410;
            if (k4 !== 0) {
              if (i < _Scene.screenCenterX && (k4 & 4) !== 0) {
                const class50_sub3_17 = aclass50_sub3[i + 1][j];
                if (class50_sub3_17 != null && class50_sub3_17.visible) {
                  _Scene.tileList.insertBack(class50_sub3_17);
                }
              }
              if (j < _Scene.screenCenterZ && (k4 & 2) !== 0) {
                const class50_sub3_18 = aclass50_sub3[i][j + 1];
                if (class50_sub3_18 != null && class50_sub3_18.visible) {
                  _Scene.tileList.insertBack(class50_sub3_18);
                }
              }
              if (i > _Scene.screenCenterX && (k4 & 1) !== 0) {
                const class50_sub3_19 = aclass50_sub3[i - 1][j];
                if (class50_sub3_19 != null && class50_sub3_19.visible) {
                  _Scene.tileList.insertBack(class50_sub3_19);
                }
              }
              if (j > _Scene.screenCenterZ && (k4 & 8) !== 0) {
                const class50_sub3_20 = aclass50_sub3[i][j - 1];
                if (class50_sub3_20 != null && class50_sub3_20.visible) {
                  _Scene.tileList.insertBack(class50_sub3_20);
                }
              }
            }
          }
          if (tileFromList.wallCullDirection !== 0) {
            let flag2 = true;
            for (let k1 = 0; k1 < tileFromList.sceneSpawnRequestCount; k1++) {
              {
                if (tileFromList.sceneSpawnRequests[k1].cycle === _Scene.cycle || (tileFromList.anIntArray1409[k1] & tileFromList.wallCullDirection) !== tileFromList.wallUncullDirection) {
                  continue;
                }
                flag2 = false;
                break;
              }
            }
            if (flag2) {
              const wall_1 = tileFromList.wall;
              if (!this.isWallOccluded(l, i, j, wall_1.orientationA)) {
                wall_1.aRenderable769.renderAtPoint(
                  0,
                  _Scene.pitchSin,
                  _Scene.pitchCos,
                  _Scene.yawSin,
                  _Scene.yawCos,
                  wall_1.x - _Scene.cameraX2,
                  wall_1.plane - _Scene.cameraY2,
                  wall_1.y - _Scene.cameraZ2,
                  wall_1.hash
                );
              }
              tileFromList.wallCullDirection = 0;
            }
          }
          if (tileFromList.drawEntities) {
            try {
              const i1 = tileFromList.sceneSpawnRequestCount;
              tileFromList.drawEntities = false;
              let l1 = 0;
              label0:
                for (let k2 = 0; k2 < i1; k2++) {
                  {
                    const sceneSpawnRequest_1 = tileFromList.sceneSpawnRequests[k2];
                    if (sceneSpawnRequest_1.cycle === _Scene.cycle) {
                      continue;
                    }
                    for (let k3 = sceneSpawnRequest_1.relativeX; k3 <= sceneSpawnRequest_1.offsetX; k3++) {
                      {
                        for (let l4 = sceneSpawnRequest_1.relativeY; l4 <= sceneSpawnRequest_1.offsetY; l4++) {
                          {
                            const class50_sub3_21 = aclass50_sub3[k3][l4];
                            if (class50_sub3_21.draw) {
                              tileFromList.drawEntities = true;
                            } else {
                              if (class50_sub3_21.wallCullDirection === 0) {
                                continue;
                              }
                              let l6 = 0;
                              if (k3 > sceneSpawnRequest_1.relativeX) {
                                l6++;
                              }
                              if (k3 < sceneSpawnRequest_1.offsetX) {
                                l6 += 4;
                              }
                              if (l4 > sceneSpawnRequest_1.relativeY) {
                                l6 += 8;
                              }
                              if (l4 < sceneSpawnRequest_1.offsetY) {
                                l6 += 2;
                              }
                              if ((l6 & class50_sub3_21.wallCullDirection) !== tileFromList.wallCullOppositeDirection) {
                                continue;
                              }
                              tileFromList.drawEntities = true;
                            }
                            continue label0;
                          }
                        }
                      }
                    }
                    _Scene.entityBuffer[l1++] = sceneSpawnRequest_1;
                    let i5 = _Scene.screenCenterX - sceneSpawnRequest_1.relativeX;
                    const i6 = sceneSpawnRequest_1.offsetX - _Scene.screenCenterX;
                    if (i6 > i5) {
                      i5 = i6;
                    }
                    const i7 = _Scene.screenCenterZ - sceneSpawnRequest_1.relativeY;
                    const j8 = sceneSpawnRequest_1.offsetY - _Scene.screenCenterZ;
                    if (j8 > i7) {
                      sceneSpawnRequest_1.anInt123 = i5 + j8;
                    } else {
                      sceneSpawnRequest_1.anInt123 = i5 + i7;
                    }
                  }
                }
              while (l1 > 0) {
                {
                  let i3 = -50;
                  let l3 = -1;
                  for (let j5 = 0; j5 < l1; j5++) {
                    {
                      const sceneSpawnRequest_2 = _Scene.entityBuffer[j5];
                      if (sceneSpawnRequest_2.cycle !== _Scene.cycle) {
                        if (sceneSpawnRequest_2.anInt123 > i3) {
                          i3 = sceneSpawnRequest_2.anInt123;
                          l3 = j5;
                        } else if (sceneSpawnRequest_2.anInt123 === i3) {
                          const j7 = sceneSpawnRequest_2.x - _Scene.cameraX2;
                          const k8 = sceneSpawnRequest_2.y - _Scene.cameraZ2;
                          const l9 = _Scene.entityBuffer[l3].x - _Scene.cameraX2;
                          const l10 = _Scene.entityBuffer[l3].y - _Scene.cameraZ2;
                          if (j7 * j7 + k8 * k8 > l9 * l9 + l10 * l10) {
                            l3 = j5;
                          }
                        }
                      }
                    }
                  }
                  if (l3 === -1) {
                    break;
                  }
                  const sceneSpawnRequest_3 = _Scene.entityBuffer[l3];
                  sceneSpawnRequest_3.cycle = _Scene.cycle;
                  if (!this.isAreaOccluded(
                    l,
                    sceneSpawnRequest_3.relativeX,
                    sceneSpawnRequest_3.offsetX,
                    sceneSpawnRequest_3.relativeY,
                    sceneSpawnRequest_3.offsetY,
                    sceneSpawnRequest_3.renderable.modelHeight
                  )) {
                    sceneSpawnRequest_3.renderable.renderAtPoint(
                      sceneSpawnRequest_3.anInt118,
                      _Scene.pitchSin,
                      _Scene.pitchCos,
                      _Scene.yawSin,
                      _Scene.yawCos,
                      sceneSpawnRequest_3.x - _Scene.cameraX2,
                      sceneSpawnRequest_3.tileHeight - _Scene.cameraY2,
                      sceneSpawnRequest_3.y - _Scene.cameraZ2,
                      sceneSpawnRequest_3.hash
                    );
                  }
                  for (let k7 = sceneSpawnRequest_3.relativeX; k7 <= sceneSpawnRequest_3.offsetX; k7++) {
                    {
                      for (let l8 = sceneSpawnRequest_3.relativeY; l8 <= sceneSpawnRequest_3.offsetY; l8++) {
                        {
                          const class50_sub3_22 = aclass50_sub3[k7][l8];
                          if (class50_sub3_22.wallCullDirection !== 0) {
                            _Scene.tileList.insertBack(class50_sub3_22);
                          } else if ((k7 !== i || l8 !== j) && class50_sub3_22.visible) {
                            _Scene.tileList.insertBack(class50_sub3_22);
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (tileFromList.drawEntities) {
                continue;
              }
            } catch (_ex) {
              tileFromList.drawEntities = false;
            }
          }
          if (!tileFromList.visible || tileFromList.wallCullDirection !== 0) {
            continue;
          }
          if (i <= _Scene.screenCenterX && i > _Scene.anInt464) {
            const class50_sub3_8 = aclass50_sub3[i - 1][j];
            if (class50_sub3_8 != null && class50_sub3_8.visible) {
              continue;
            }
          }
          if (i >= _Scene.screenCenterX && i < _Scene.anInt465 - 1) {
            const class50_sub3_9 = aclass50_sub3[i + 1][j];
            if (class50_sub3_9 != null && class50_sub3_9.visible) {
              continue;
            }
          }
          if (j <= _Scene.screenCenterZ && j > _Scene.anInt466) {
            const class50_sub3_10 = aclass50_sub3[i][j - 1];
            if (class50_sub3_10 != null && class50_sub3_10.visible) {
              continue;
            }
          }
          if (j >= _Scene.screenCenterZ && j < _Scene.anInt467 - 1) {
            const class50_sub3_11 = aclass50_sub3[i][j + 1];
            if (class50_sub3_11 != null && class50_sub3_11.visible) {
              continue;
            }
          }
          tileFromList.visible = false;
          _Scene.anInt461--;
          const cameraAngle = tileFromList.cameraAngle;
          if (cameraAngle != null && cameraAngle.anInt180 !== 0) {
            if (cameraAngle.aRenderable151 != null) {
              cameraAngle.aRenderable151.renderAtPoint(
                0,
                _Scene.pitchSin,
                _Scene.pitchCos,
                _Scene.yawSin,
                _Scene.yawCos,
                cameraAngle.y - _Scene.cameraX2,
                cameraAngle.x - _Scene.cameraY2 - cameraAngle.anInt180,
                cameraAngle.z - _Scene.cameraZ2,
                cameraAngle.anInt179
              );
            }
            if (cameraAngle.aRenderable152 != null) {
              cameraAngle.aRenderable152.renderAtPoint(
                0,
                _Scene.pitchSin,
                _Scene.pitchCos,
                _Scene.yawSin,
                _Scene.yawCos,
                cameraAngle.y - _Scene.cameraX2,
                cameraAngle.x - _Scene.cameraY2 - cameraAngle.anInt180,
                cameraAngle.z - _Scene.cameraZ2,
                cameraAngle.anInt179
              );
            }
            if (cameraAngle.aRenderable150 != null) {
              cameraAngle.aRenderable150.renderAtPoint(
                0,
                _Scene.pitchSin,
                _Scene.pitchCos,
                _Scene.yawSin,
                _Scene.yawCos,
                cameraAngle.y - _Scene.cameraX2,
                cameraAngle.x - _Scene.cameraY2 - cameraAngle.anInt180,
                cameraAngle.z - _Scene.cameraZ2,
                cameraAngle.anInt179
              );
            }
          }
          if (tileFromList.wallDrawFlags !== 0) {
            const wallDecoration = tileFromList.wallDecoration;
            if (wallDecoration != null && !this.isOccluded(l, i, j, wallDecoration.renderable.modelHeight)) {
              if ((wallDecoration.faceUnknown & tileFromList.wallDrawFlags) !== 0) {
                wallDecoration.renderable.renderAtPoint(
                  wallDecoration.face,
                  _Scene.pitchSin,
                  _Scene.pitchCos,
                  _Scene.yawSin,
                  _Scene.yawCos,
                  wallDecoration.y - _Scene.cameraX2,
                  wallDecoration.plane - _Scene.cameraY2,
                  wallDecoration.x - _Scene.cameraZ2,
                  wallDecoration.hash
                );
              } else if ((wallDecoration.faceUnknown & 768) !== 0) {
                const l2 = wallDecoration.y - _Scene.cameraX2;
                const j3 = wallDecoration.plane - _Scene.cameraY2;
                const i4 = wallDecoration.x - _Scene.cameraZ2;
                const k5 = wallDecoration.face;
                let j6;
                if (k5 === 1 || k5 === 2) {
                  j6 = -l2;
                } else {
                  j6 = l2;
                }
                let l7;
                if (k5 === 2 || k5 === 3) {
                  l7 = -i4;
                } else {
                  l7 = i4;
                }
                if ((wallDecoration.faceUnknown & 256) !== 0 && l7 >= j6) {
                  const i9 = l2 + _Scene.anIntArray478[k5];
                  const i10 = i4 + _Scene.anIntArray479[k5];
                  wallDecoration.renderable.renderAtPoint(
                    k5 * 512 + 256,
                    _Scene.pitchSin,
                    _Scene.pitchCos,
                    _Scene.yawSin,
                    _Scene.yawCos,
                    i9,
                    j3,
                    i10,
                    wallDecoration.hash
                  );
                }
                if ((wallDecoration.faceUnknown & 512) !== 0 && l7 <= j6) {
                  const j9 = l2 + _Scene.anIntArray480[k5];
                  const j10 = i4 + _Scene.anIntArray481[k5];
                  wallDecoration.renderable.renderAtPoint(
                    k5 * 512 + 1280 & 2047,
                    _Scene.pitchSin,
                    _Scene.pitchCos,
                    _Scene.yawSin,
                    _Scene.yawCos,
                    j9,
                    j3,
                    j10,
                    wallDecoration.hash
                  );
                }
              }
            }
            const wall_2 = tileFromList.wall;
            if (wall_2 != null) {
              if ((wall_2.face & tileFromList.wallDrawFlags) !== 0 && !this.isWallOccluded(l, i, j, wall_2.face)) {
                wall_2.aRenderable770.renderAtPoint(
                  0,
                  _Scene.pitchSin,
                  _Scene.pitchCos,
                  _Scene.yawSin,
                  _Scene.yawCos,
                  wall_2.x - _Scene.cameraX2,
                  wall_2.plane - _Scene.cameraY2,
                  wall_2.y - _Scene.cameraZ2,
                  wall_2.hash
                );
              }
              if ((wall_2.orientationA & tileFromList.wallDrawFlags) !== 0 && !this.isWallOccluded(l, i, j, wall_2.orientationA)) {
                wall_2.aRenderable769.renderAtPoint(
                  0,
                  _Scene.pitchSin,
                  _Scene.pitchCos,
                  _Scene.yawSin,
                  _Scene.yawCos,
                  wall_2.x - _Scene.cameraX2,
                  wall_2.plane - _Scene.cameraY2,
                  wall_2.y - _Scene.cameraZ2,
                  wall_2.hash
                );
              }
            }
          }
          if (k < this.anInt452 - 1) {
            const class50_sub3_12 = this.tiles[k + 1][i][j];
            if (class50_sub3_12 != null && class50_sub3_12.visible) {
              _Scene.tileList.insertBack(class50_sub3_12);
            }
          }
          if (i < _Scene.screenCenterX) {
            const class50_sub3_13 = aclass50_sub3[i + 1][j];
            if (class50_sub3_13 != null && class50_sub3_13.visible) {
              _Scene.tileList.insertBack(class50_sub3_13);
            }
          }
          if (j < _Scene.screenCenterZ) {
            const class50_sub3_14 = aclass50_sub3[i][j + 1];
            if (class50_sub3_14 != null && class50_sub3_14.visible) {
              _Scene.tileList.insertBack(class50_sub3_14);
            }
          }
          if (i > _Scene.screenCenterX) {
            const class50_sub3_15 = aclass50_sub3[i - 1][j];
            if (class50_sub3_15 != null && class50_sub3_15.visible) {
              _Scene.tileList.insertBack(class50_sub3_15);
            }
          }
          if (j > _Scene.screenCenterZ) {
            const class50_sub3_16 = aclass50_sub3[i][j - 1];
            if (class50_sub3_16 != null && class50_sub3_16.visible) {
              _Scene.tileList.insertBack(class50_sub3_16);
            }
          }
        }
      } while (true);
    }
    drawTileUnderlay(genericTile, i, j, k, l, i1, j1, k1) {
      let l1;
      let i2 = l1 = (j1 << 7) - _Scene.cameraX2;
      let j2;
      let k2 = j2 = (k1 << 7) - _Scene.cameraZ2;
      let l2;
      let i3 = l2 = i2 + 128;
      let j3;
      let k3 = j3 = k2 + 128;
      let l3 = this.anIntArrayArrayArray455[i][j1][k1] - _Scene.cameraY2;
      let i4 = this.anIntArrayArrayArray455[i][j1 + 1][k1] - _Scene.cameraY2;
      let j4 = this.anIntArrayArrayArray455[i][j1 + 1][k1 + 1] - _Scene.cameraY2;
      let k4 = this.anIntArrayArrayArray455[i][j1][k1 + 1] - _Scene.cameraY2;
      let l4 = k2 * l + i2 * i1 >> 16;
      k2 = k2 * i1 - i2 * l >> 16;
      i2 = l4;
      l4 = l3 * k - k2 * j >> 16;
      k2 = l3 * j + k2 * k >> 16;
      l3 = l4;
      if (k2 < 50) {
        return;
      }
      l4 = j2 * l + i3 * i1 >> 16;
      j2 = j2 * i1 - i3 * l >> 16;
      i3 = l4;
      l4 = i4 * k - j2 * j >> 16;
      j2 = i4 * j + j2 * k >> 16;
      i4 = l4;
      if (j2 < 50) {
        return;
      }
      l4 = k3 * l + l2 * i1 >> 16;
      k3 = k3 * i1 - l2 * l >> 16;
      l2 = l4;
      l4 = j4 * k - k3 * j >> 16;
      k3 = j4 * j + k3 * k >> 16;
      j4 = l4;
      if (k3 < 50) {
        return;
      }
      l4 = j3 * l + l1 * i1 >> 16;
      j3 = j3 * i1 - l1 * l >> 16;
      l1 = l4;
      l4 = k4 * k - j3 * j >> 16;
      j3 = k4 * j + j3 * k >> 16;
      k4 = l4;
      if (j3 < 50) {
        return;
      }
      const i5 = Rasterizer3D.centerX + ((i2 << 9) / k2 | 0);
      const j5 = Rasterizer3D.centerY + ((l3 << 9) / k2 | 0);
      const k5 = Rasterizer3D.centerX + ((i3 << 9) / j2 | 0);
      const l5 = Rasterizer3D.centerY + ((i4 << 9) / j2 | 0);
      const i6 = Rasterizer3D.centerX + ((l2 << 9) / k3 | 0);
      const j6 = Rasterizer3D.centerY + ((j4 << 9) / k3 | 0);
      const k6 = Rasterizer3D.centerX + ((l1 << 9) / j3 | 0);
      const l6 = Rasterizer3D.centerY + ((k4 << 9) / j3 | 0);
      Rasterizer3D.anInt1531 = 0;
      if ((i6 - k6) * (l5 - l6) - (j6 - l6) * (k5 - k6) > 0) {
        Rasterizer3D.aBoolean1528 = false;
        if (i6 < 0 || k6 < 0 || k5 < 0 || i6 > Rasterizer.virtualBottomX || k6 > Rasterizer.virtualBottomX || k5 > Rasterizer.virtualBottomX) {
          Rasterizer3D.aBoolean1528 = true;
        }
        if (_Scene.aBoolean482 && this.method285(_Scene.anInt483, _Scene.anInt484, j6, l6, l5, i6, k6, k5)) {
          _Scene.clickedTileX = j1;
          _Scene.anInt486 = k1;
        }
        if (genericTile.texture === -1) {
          if (genericTile.anInt97 !== 12345678) {
            Rasterizer3D.method503(j6, l6, l5, i6, k6, k5, genericTile.anInt97, genericTile.anInt98, genericTile.anInt96);
          }
        } else if (!_Scene.lowMemory) {
          if (genericTile.flat) {
            Rasterizer3D.method507(
              j6,
              l6,
              l5,
              i6,
              k6,
              k5,
              genericTile.anInt97,
              genericTile.anInt98,
              genericTile.anInt96,
              i2,
              i3,
              l1,
              l3,
              i4,
              k4,
              k2,
              j2,
              j3,
              genericTile.texture
            );
          } else {
            Rasterizer3D.method507(
              j6,
              l6,
              l5,
              i6,
              k6,
              k5,
              genericTile.anInt97,
              genericTile.anInt98,
              genericTile.anInt96,
              l2,
              l1,
              i3,
              j4,
              k4,
              i4,
              k3,
              j3,
              j2,
              genericTile.texture
            );
          }
        } else {
          const i7 = _Scene.anIntArray500[genericTile.texture];
          Rasterizer3D.method503(
            j6,
            l6,
            l5,
            i6,
            k6,
            k5,
            this.method284(genericTile.anInt97, i7, 0),
            this.method284(genericTile.anInt98, i7, 0),
            this.method284(genericTile.anInt96, i7, 0)
          );
        }
      }
      if ((i5 - k5) * (l6 - l5) - (j5 - l5) * (k6 - k5) > 0) {
        Rasterizer3D.aBoolean1528 = false;
        if (i5 < 0 || k5 < 0 || k6 < 0 || i5 > Rasterizer.virtualBottomX || k5 > Rasterizer.virtualBottomX || k6 > Rasterizer.virtualBottomX) {
          Rasterizer3D.aBoolean1528 = true;
        }
        if (_Scene.aBoolean482 && this.method285(_Scene.anInt483, _Scene.anInt484, j5, l5, l6, i5, k5, k6)) {
          _Scene.clickedTileX = j1;
          _Scene.anInt486 = k1;
        }
        if (genericTile.texture === -1) {
          if (genericTile.anInt95 !== 12345678) {
            Rasterizer3D.method503(j5, l5, l6, i5, k5, k6, genericTile.anInt95, genericTile.anInt96, genericTile.anInt98);
            return;
          }
        } else {
          if (!_Scene.lowMemory) {
            Rasterizer3D.method507(
              j5,
              l5,
              l6,
              i5,
              k5,
              k6,
              genericTile.anInt95,
              genericTile.anInt96,
              genericTile.anInt98,
              i2,
              i3,
              l1,
              l3,
              i4,
              k4,
              k2,
              j2,
              j3,
              genericTile.texture
            );
            return;
          }
          const j7 = _Scene.anIntArray500[genericTile.texture];
          Rasterizer3D.method503(
            j5,
            l5,
            l6,
            i5,
            k5,
            k6,
            this.method284(genericTile.anInt95, j7, 0),
            this.method284(genericTile.anInt96, j7, 0),
            this.method284(genericTile.anInt98, j7, 0)
          );
        }
      }
    }
    drawTileOverlay(i, j, complexTile, k, l, i1, j1, byte0) {
      let k1 = complexTile.anIntArray403.length;
      for (let l1 = 0; l1 < k1; l1++) {
        {
          let i2 = complexTile.anIntArray403[l1] - _Scene.cameraX2;
          let k2 = complexTile.anIntArray404[l1] - _Scene.cameraY2;
          let i3 = complexTile.anIntArray405[l1] - _Scene.cameraZ2;
          let k3 = i3 * j1 + i2 * j >> 16;
          i3 = i3 * j - i2 * j1 >> 16;
          i2 = k3;
          k3 = k2 * i - i3 * k >> 16;
          i3 = k2 * k + i3 * i >> 16;
          k2 = k3;
          if (i3 < 50) {
            return;
          }
          if (complexTile.anIntArray412 != null) {
            ComplexTile.anIntArray420[l1] = i2;
            ComplexTile.anIntArray421[l1] = k2;
            ComplexTile.anIntArray422[l1] = i3;
          }
          ComplexTile.anIntArray418[l1] = Rasterizer3D.centerX + ((i2 << 9) / i3 | 0);
          ComplexTile.anIntArray419[l1] = Rasterizer3D.centerY + ((k2 << 9) / i3 | 0);
        }
      }
      Rasterizer3D.anInt1531 = 0;
      k1 = complexTile.anIntArray409.length;
      if (byte0 !== 3) {
        return;
      }
      for (let j2 = 0; j2 < k1; j2++) {
        {
          const l2 = complexTile.anIntArray409[j2];
          const j3 = complexTile.anIntArray410[j2];
          const l3 = complexTile.anIntArray411[j2];
          const i4 = ComplexTile.anIntArray418[l2];
          const j4 = ComplexTile.anIntArray418[j3];
          const k4 = ComplexTile.anIntArray418[l3];
          const l4 = ComplexTile.anIntArray419[l2];
          const i5 = ComplexTile.anIntArray419[j3];
          const j5 = ComplexTile.anIntArray419[l3];
          if ((i4 - j4) * (j5 - i5) - (l4 - i5) * (k4 - j4) > 0) {
            Rasterizer3D.aBoolean1528 = false;
            if (i4 < 0 || j4 < 0 || k4 < 0 || i4 > Rasterizer.virtualBottomX || j4 > Rasterizer.virtualBottomX || k4 > Rasterizer.virtualBottomX) {
              Rasterizer3D.aBoolean1528 = true;
            }
            if (_Scene.aBoolean482 && this.method285(_Scene.anInt483, _Scene.anInt484, l4, i5, j5, i4, j4, k4)) {
              _Scene.clickedTileX = i1;
              _Scene.anInt486 = l;
            }
            if (complexTile.anIntArray412 == null || complexTile.anIntArray412[j2] === -1) {
              if (complexTile.anIntArray406[j2] !== 12345678) {
                Rasterizer3D.method503(
                  l4,
                  i5,
                  j5,
                  i4,
                  j4,
                  k4,
                  complexTile.anIntArray406[j2],
                  complexTile.anIntArray407[j2],
                  complexTile.anIntArray408[j2]
                );
              }
            } else if (!_Scene.lowMemory) {
              if (complexTile.aBoolean413) {
                Rasterizer3D.method507(
                  l4,
                  i5,
                  j5,
                  i4,
                  j4,
                  k4,
                  complexTile.anIntArray406[j2],
                  complexTile.anIntArray407[j2],
                  complexTile.anIntArray408[j2],
                  ComplexTile.anIntArray420[0],
                  ComplexTile.anIntArray420[1],
                  ComplexTile.anIntArray420[3],
                  ComplexTile.anIntArray421[0],
                  ComplexTile.anIntArray421[1],
                  ComplexTile.anIntArray421[3],
                  ComplexTile.anIntArray422[0],
                  ComplexTile.anIntArray422[1],
                  ComplexTile.anIntArray422[3],
                  complexTile.anIntArray412[j2]
                );
              } else {
                Rasterizer3D.method507(
                  l4,
                  i5,
                  j5,
                  i4,
                  j4,
                  k4,
                  complexTile.anIntArray406[j2],
                  complexTile.anIntArray407[j2],
                  complexTile.anIntArray408[j2],
                  ComplexTile.anIntArray420[l2],
                  ComplexTile.anIntArray420[j3],
                  ComplexTile.anIntArray420[l3],
                  ComplexTile.anIntArray421[l2],
                  ComplexTile.anIntArray421[j3],
                  ComplexTile.anIntArray421[l3],
                  ComplexTile.anIntArray422[l2],
                  ComplexTile.anIntArray422[j3],
                  ComplexTile.anIntArray422[l3],
                  complexTile.anIntArray412[j2]
                );
              }
            } else {
              const k5 = _Scene.anIntArray500[complexTile.anIntArray412[j2]];
              Rasterizer3D.method503(
                l4,
                i5,
                j5,
                i4,
                j4,
                k4,
                this.method284(complexTile.anIntArray406[j2], k5, 0),
                this.method284(complexTile.anIntArray407[j2], k5, 0),
                this.method284(complexTile.anIntArray408[j2], k5, 0)
              );
            }
          }
        }
      }
    }
    method284(i, j, k) {
      i = 127 - i;
      i = i * (j & 127) / 160 | 0;
      if (i < 2) {
        i = 2;
      } else if (i > 126) {
        i = 126;
      }
      return (j & 65408) + i;
    }
    method285(i, j, k, l, i1, j1, k1, l1) {
      if (j < k && j < l && j < i1) {
        return false;
      }
      if (j > k && j > l && j > i1) {
        return false;
      }
      if (i < j1 && i < k1 && i < l1) {
        return false;
      }
      if (i > j1 && i > k1 && i > l1) {
        return false;
      }
      const i2 = (j - k) * (k1 - j1) - (i - j1) * (l - k);
      const j2 = (j - i1) * (j1 - l1) - (i - l1) * (k - i1);
      const k2 = (j - l) * (l1 - k1) - (i - k1) * (i1 - l);
      return i2 * k2 > 0 && k2 * j2 > 0;
    }
    method286() {
      const j = _Scene.anIntArray488[_Scene.anInt462];
      const aclass39 = _Scene.aSceneClusterArrayArray554[_Scene.anInt462];
      _Scene.anInt490 = 0;
      for (let k = 0; k < j; k++) {
        {
          const class39 = aclass39[k];
          if (class39.anInt679 === 1) {
            const l = class39.anInt675 - _Scene.screenCenterX + 25;
            if (l < 0 || l > 50) {
              continue;
            }
            let k1 = class39.anInt677 - _Scene.screenCenterZ + 25;
            if (k1 < 0) {
              k1 = 0;
            }
            let j2 = class39.anInt678 - _Scene.screenCenterZ + 25;
            if (j2 > 50) {
              j2 = 50;
            }
            let flag = false;
            while (k1 <= j2) {
              if (_Scene.aBooleanArrayArray507[l][k1++]) {
                flag = true;
                break;
              }
            }
            if (!flag) {
              continue;
            }
            let j3 = _Scene.cameraX2 - class39.anInt680;
            if (j3 > 32) {
              class39.anInt686 = 1;
            } else {
              if (j3 >= -32) {
                continue;
              }
              class39.anInt686 = 2;
              j3 = -j3;
            }
            class39.anInt689 = (class39.anInt682 - _Scene.cameraZ2 << 8) / j3 | 0;
            class39.anInt690 = (class39.anInt683 - _Scene.cameraZ2 << 8) / j3 | 0;
            class39.anInt691 = (class39.anInt684 - _Scene.cameraY2 << 8) / j3 | 0;
            class39.anInt692 = (class39.anInt685 - _Scene.cameraY2 << 8) / j3 | 0;
            _Scene.aClass39Array491[_Scene.anInt490++] = class39;
            continue;
          }
          if (class39.anInt679 === 2) {
            const i1 = class39.anInt677 - _Scene.screenCenterZ + 25;
            if (i1 < 0 || i1 > 50) {
              continue;
            }
            let l1 = class39.anInt675 - _Scene.screenCenterX + 25;
            if (l1 < 0) {
              l1 = 0;
            }
            let k2 = class39.anInt676 - _Scene.screenCenterX + 25;
            if (k2 > 50) {
              k2 = 50;
            }
            let flag1 = false;
            while (l1 <= k2) {
              if (_Scene.aBooleanArrayArray507[l1++][i1]) {
                flag1 = true;
                break;
              }
            }
            if (!flag1) {
              continue;
            }
            let k3 = _Scene.cameraZ2 - class39.anInt682;
            if (k3 > 32) {
              class39.anInt686 = 3;
            } else {
              if (k3 >= -32) {
                continue;
              }
              class39.anInt686 = 4;
              k3 = -k3;
            }
            class39.anInt687 = (class39.anInt680 - _Scene.cameraX2 << 8) / k3 | 0;
            class39.anInt688 = (class39.anInt681 - _Scene.cameraX2 << 8) / k3 | 0;
            class39.anInt691 = (class39.anInt684 - _Scene.cameraY2 << 8) / k3 | 0;
            class39.anInt692 = (class39.anInt685 - _Scene.cameraY2 << 8) / k3 | 0;
            _Scene.aClass39Array491[_Scene.anInt490++] = class39;
          } else if (class39.anInt679 === 4) {
            const j1 = class39.anInt684 - _Scene.cameraY2;
            if (j1 > 128) {
              let i2 = class39.anInt677 - _Scene.screenCenterZ + 25;
              if (i2 < 0) {
                i2 = 0;
              }
              let l2 = class39.anInt678 - _Scene.screenCenterZ + 25;
              if (l2 > 50) {
                l2 = 50;
              }
              if (i2 <= l2) {
                let i3 = class39.anInt675 - _Scene.screenCenterX + 25;
                if (i3 < 0) {
                  i3 = 0;
                }
                let l3 = class39.anInt676 - _Scene.screenCenterX + 25;
                if (l3 > 50) {
                  l3 = 50;
                }
                let flag2 = false;
                label0:
                  for (let i4 = i3; i4 <= l3; i4++) {
                    {
                      for (let j4 = i2; j4 <= l2; j4++) {
                        {
                          if (!_Scene.aBooleanArrayArray507[i4][j4]) {
                            continue;
                          }
                          flag2 = true;
                          break label0;
                        }
                      }
                    }
                  }
                if (flag2) {
                  class39.anInt686 = 5;
                  class39.anInt687 = (class39.anInt680 - _Scene.cameraX2 << 8) / j1 | 0;
                  class39.anInt688 = (class39.anInt681 - _Scene.cameraX2 << 8) / j1 | 0;
                  class39.anInt689 = (class39.anInt682 - _Scene.cameraZ2 << 8) / j1 | 0;
                  class39.anInt690 = (class39.anInt683 - _Scene.cameraZ2 << 8) / j1 | 0;
                  _Scene.aClass39Array491[_Scene.anInt490++] = class39;
                }
              }
            }
          }
        }
      }
    }
    isTileOccluded(i, j, k) {
      const l = this.anIntArrayArrayArray460[i][j][k];
      if (l === -_Scene.cycle) {
        return false;
      }
      if (l === _Scene.cycle) {
        return true;
      }
      const i1 = j << 7;
      const j1 = k << 7;
      if (this.method291(i1 + 1, this.anIntArrayArrayArray455[i][j][k], j1 + 1) && this.method291(i1 + 128 - 1, this.anIntArrayArrayArray455[i][j + 1][k], j1 + 1) && this.method291(i1 + 128 - 1, this.anIntArrayArrayArray455[i][j + 1][k + 1], j1 + 128 - 1) && this.method291(i1 + 1, this.anIntArrayArrayArray455[i][j][k + 1], j1 + 128 - 1)) {
        this.anIntArrayArrayArray460[i][j][k] = _Scene.cycle;
        return true;
      } else {
        this.anIntArrayArrayArray460[i][j][k] = -_Scene.cycle;
        return false;
      }
    }
    isWallOccluded(i, j, k, l) {
      if (!this.isTileOccluded(i, j, k)) {
        return false;
      }
      const i1 = j << 7;
      const j1 = k << 7;
      const k1 = this.anIntArrayArrayArray455[i][j][k] - 1;
      const l1 = k1 - 120;
      const i2 = k1 - 230;
      const j2 = k1 - 238;
      if (l < 16) {
        if (l === 1) {
          if (i1 > _Scene.cameraX2) {
            if (!this.method291(i1, k1, j1)) {
              return false;
            }
            if (!this.method291(i1, k1, j1 + 128)) {
              return false;
            }
          }
          if (i > 0) {
            if (!this.method291(i1, l1, j1)) {
              return false;
            }
            if (!this.method291(i1, l1, j1 + 128)) {
              return false;
            }
          }
          if (!this.method291(i1, i2, j1)) {
            return false;
          }
          return this.method291(i1, i2, j1 + 128);
        }
        if (l === 2) {
          if (j1 < _Scene.cameraZ2) {
            if (!this.method291(i1, k1, j1 + 128)) {
              return false;
            }
            if (!this.method291(i1 + 128, k1, j1 + 128)) {
              return false;
            }
          }
          if (i > 0) {
            if (!this.method291(i1, l1, j1 + 128)) {
              return false;
            }
            if (!this.method291(i1 + 128, l1, j1 + 128)) {
              return false;
            }
          }
          if (!this.method291(i1, i2, j1 + 128)) {
            return false;
          }
          return this.method291(i1 + 128, i2, j1 + 128);
        }
        if (l === 4) {
          if (i1 < _Scene.cameraX2) {
            if (!this.method291(i1 + 128, k1, j1)) {
              return false;
            }
            if (!this.method291(i1 + 128, k1, j1 + 128)) {
              return false;
            }
          }
          if (i > 0) {
            if (!this.method291(i1 + 128, l1, j1)) {
              return false;
            }
            if (!this.method291(i1 + 128, l1, j1 + 128)) {
              return false;
            }
          }
          if (!this.method291(i1 + 128, i2, j1)) {
            return false;
          }
          return this.method291(i1 + 128, i2, j1 + 128);
        }
        if (l === 8) {
          if (j1 > _Scene.cameraZ2) {
            if (!this.method291(i1, k1, j1)) {
              return false;
            }
            if (!this.method291(i1 + 128, k1, j1)) {
              return false;
            }
          }
          if (i > 0) {
            if (!this.method291(i1, l1, j1)) {
              return false;
            }
            if (!this.method291(i1 + 128, l1, j1)) {
              return false;
            }
          }
          if (!this.method291(i1, i2, j1)) {
            return false;
          }
          return this.method291(i1 + 128, i2, j1);
        }
      }
      if (!this.method291(i1 + 64, j2, j1 + 64)) {
        return false;
      }
      if (l === 16) {
        return this.method291(i1, i2, j1 + 128);
      }
      if (l === 32) {
        return this.method291(i1 + 128, i2, j1 + 128);
      }
      if (l === 64) {
        return this.method291(i1 + 128, i2, j1);
      }
      if (l === 128) {
        return this.method291(i1, i2, j1);
      } else {
        console.info("Warning unsupported wall type");
        return true;
      }
    }
    isOccluded(i, j, k, l) {
      if (!this.isTileOccluded(i, j, k)) {
        return false;
      }
      const i1 = j << 7;
      const j1 = k << 7;
      return this.method291(i1 + 1, this.anIntArrayArrayArray455[i][j][k] - l, j1 + 1) && this.method291(i1 + 128 - 1, this.anIntArrayArrayArray455[i][j + 1][k] - l, j1 + 1) && this.method291(i1 + 128 - 1, this.anIntArrayArrayArray455[i][j + 1][k + 1] - l, j1 + 128 - 1) && this.method291(i1 + 1, this.anIntArrayArrayArray455[i][j][k + 1] - l, j1 + 128 - 1);
    }
    isAreaOccluded(i, j, k, l, i1, j1) {
      if (j === k && l === i1) {
        if (!this.isTileOccluded(i, j, l)) {
          return false;
        }
        const k1 = j << 7;
        const i2 = l << 7;
        return this.method291(k1 + 1, this.anIntArrayArrayArray455[i][j][l] - j1, i2 + 1) && this.method291(k1 + 128 - 1, this.anIntArrayArrayArray455[i][j + 1][l] - j1, i2 + 1) && this.method291(k1 + 128 - 1, this.anIntArrayArrayArray455[i][j + 1][l + 1] - j1, i2 + 128 - 1) && this.method291(k1 + 1, this.anIntArrayArrayArray455[i][j][l + 1] - j1, i2 + 128 - 1);
      }
      for (let l1 = j; l1 <= k; l1++) {
        {
          for (let j2 = l; j2 <= i1; j2++) {
            if (this.anIntArrayArrayArray460[i][l1][j2] === -_Scene.cycle) {
              return false;
            }
          }
        }
      }
      const k2 = (j << 7) + 1;
      const l2 = (l << 7) + 2;
      const i3 = this.anIntArrayArrayArray455[i][j][l] - j1;
      if (!this.method291(k2, i3, l2)) {
        return false;
      }
      const j3 = (k << 7) - 1;
      if (!this.method291(j3, i3, l2)) {
        return false;
      }
      const k3 = (i1 << 7) - 1;
      if (!this.method291(k2, i3, k3)) {
        return false;
      }
      return this.method291(j3, i3, k3);
    }
    method291(i, j, k) {
      for (let l = 0; l < _Scene.anInt490; l++) {
        {
          const class39 = _Scene.aClass39Array491[l];
          if (class39.anInt686 === 1) {
            const i1 = class39.anInt680 - i;
            if (i1 > 0) {
              const j2 = class39.anInt682 + (class39.anInt689 * i1 >> 8);
              const k3 = class39.anInt683 + (class39.anInt690 * i1 >> 8);
              const l4 = class39.anInt684 + (class39.anInt691 * i1 >> 8);
              const i6 = class39.anInt685 + (class39.anInt692 * i1 >> 8);
              if (k >= j2 && k <= k3 && j >= l4 && j <= i6) {
                return true;
              }
            }
          } else if (class39.anInt686 === 2) {
            const j1 = i - class39.anInt680;
            if (j1 > 0) {
              const k2 = class39.anInt682 + (class39.anInt689 * j1 >> 8);
              const l3 = class39.anInt683 + (class39.anInt690 * j1 >> 8);
              const i5 = class39.anInt684 + (class39.anInt691 * j1 >> 8);
              const j6 = class39.anInt685 + (class39.anInt692 * j1 >> 8);
              if (k >= k2 && k <= l3 && j >= i5 && j <= j6) {
                return true;
              }
            }
          } else if (class39.anInt686 === 3) {
            const k1 = class39.anInt682 - k;
            if (k1 > 0) {
              const l2 = class39.anInt680 + (class39.anInt687 * k1 >> 8);
              const i4 = class39.anInt681 + (class39.anInt688 * k1 >> 8);
              const j5 = class39.anInt684 + (class39.anInt691 * k1 >> 8);
              const k6 = class39.anInt685 + (class39.anInt692 * k1 >> 8);
              if (i >= l2 && i <= i4 && j >= j5 && j <= k6) {
                return true;
              }
            }
          } else if (class39.anInt686 === 4) {
            const l1 = k - class39.anInt682;
            if (l1 > 0) {
              const i3 = class39.anInt680 + (class39.anInt687 * l1 >> 8);
              const j4 = class39.anInt681 + (class39.anInt688 * l1 >> 8);
              const k5 = class39.anInt684 + (class39.anInt691 * l1 >> 8);
              const l6 = class39.anInt685 + (class39.anInt692 * l1 >> 8);
              if (i >= i3 && i <= j4 && j >= k5 && j <= l6) {
                return true;
              }
            }
          } else if (class39.anInt686 === 5) {
            const i2 = j - class39.anInt684;
            if (i2 > 0) {
              const j3 = class39.anInt680 + (class39.anInt687 * i2 >> 8);
              const k4 = class39.anInt681 + (class39.anInt688 * i2 >> 8);
              const l5 = class39.anInt682 + (class39.anInt689 * i2 >> 8);
              const i7 = class39.anInt683 + (class39.anInt690 * i2 >> 8);
              if (i >= j3 && i <= k4 && k >= l5 && k <= i7) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }
  };
  var Scene = _Scene;
  Scene.anInt444 = 0;
  Scene.lowMemory = true;
  Scene.anInt461 = 0;
  Scene.anInt462 = 0;
  Scene.cycle = 0;
  Scene.anInt464 = 0;
  Scene.anInt465 = 0;
  Scene.anInt466 = 0;
  Scene.anInt467 = 0;
  Scene.screenCenterX = 0;
  Scene.screenCenterZ = 0;
  Scene.cameraX2 = 0;
  Scene.cameraY2 = 0;
  Scene.cameraZ2 = 0;
  Scene.pitchSin = 0;
  Scene.pitchCos = 0;
  Scene.yawSin = 0;
  Scene.yawCos = 0;
  Scene.entityBuffer = Array(100).fill(null);
  Scene.anIntArray478 = [53, -53, -53, 53];
  Scene.anIntArray479 = [-53, -53, 53, 53];
  Scene.anIntArray480 = [-45, 45, 45, -45];
  Scene.anIntArray481 = [45, 45, -45, -45];
  Scene.aBoolean482 = false;
  Scene.anInt483 = 0;
  Scene.anInt484 = 0;
  Scene.clickedTileX = -1;
  Scene.anInt486 = -1;
  Scene.anInt487 = 4;
  Scene.anIntArray488 = Array(_Scene.anInt487).fill(0);
  Scene.aSceneClusterArrayArray554 = array2d(_Scene.anInt487, 500, null);
  Scene.anInt490 = 0;
  Scene.aClass39Array491 = Array(500).fill(null);
  Scene.tileList = new LinkedList();
  Scene.anIntArray493 = [19, 55, 38, 155, 255, 110, 137, 205, 76];
  Scene.anIntArray494 = [160, 192, 80, 96, 0, 144, 80, 48, 160];
  Scene.TILE_WALL_DRAW_FLAGS_1 = [76, 8, 137, 4, 0, 1, 38, 2, 19];
  Scene.WALL_UNCULL_FLAGS_0 = [0, 0, 2, 0, 0, 2, 1, 1, 0];
  Scene.anIntArray497 = [2, 0, 0, 2, 0, 0, 0, 4, 4];
  Scene.anIntArray498 = [0, 4, 4, 8, 0, 0, 8, 0, 0];
  Scene.anIntArray499 = [1, 1, 0, 0, 0, 8, 0, 0, 8];
  Scene.anIntArray500 = [
    41,
    39248,
    41,
    4643,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    43086,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    8602,
    41,
    28992,
    41,
    41,
    41,
    41,
    41,
    5056,
    41,
    41,
    41,
    7079,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    3131,
    41,
    41,
    41
  ];
  Scene.aBooleanArrayArrayArrayArray506 = Array(8).fill(array3d(32, 51, 51, false));
  Scene.aBooleanArrayArray507 = null;
  Scene.anInt508 = 0;
  Scene.anInt509 = 0;
  Scene.anInt510 = 0;
  Scene.anInt511 = 0;
  Scene.anInt512 = 0;
  Scene.anInt513 = 0;

  // osrs/scene/util/CollisionMap.ts
  init_inject();
  var CollisionMap = class {
    constructor(height, width) {
      if (this.insetX === void 0) {
        this.insetX = 0;
      }
      if (this.insetY === void 0) {
        this.insetY = 0;
      }
      if (this.width === void 0) {
        this.width = 0;
      }
      if (this.height === void 0) {
        this.height = 0;
      }
      if (this.adjacency === void 0) {
        this.adjacency = null;
      }
      this.insetX = 0;
      this.insetY = 0;
      this.width = width;
      this.height = height;
      this.adjacency = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([width, height]);
      this.reset();
    }
    reset() {
      for (let x2 = 0; x2 < this.width; x2++) {
        {
          for (let y = 0; y < this.height; y++) {
            if (x2 === 0 || y === 0 || x2 === this.width - 1 || y === this.height - 1) {
              this.adjacency[x2][y] = 16777215;
            } else {
              this.adjacency[x2][y] = 16777216;
            }
          }
        }
      }
    }
    markWall(x2, y, position, orientation, impenetrable) {
      x2 -= this.insetX;
      y -= this.insetY;
      if (position === 0) {
        if (orientation === 0) {
          this.set(x2, y, 128);
          this.set(x2 - 1, y, 8);
        }
        if (orientation === 1) {
          this.set(x2, y, 2);
          this.set(x2, y + 1, 32);
        }
        if (orientation === 2) {
          this.set(x2, y, 8);
          this.set(x2 + 1, y, 128);
        }
        if (orientation === 3) {
          this.set(x2, y, 32);
          this.set(x2, y - 1, 2);
        }
      }
      if (position === 1 || position === 3) {
        if (orientation === 0) {
          this.set(x2, y, 1);
          this.set(x2 - 1, y + 1, 16);
        }
        if (orientation === 1) {
          this.set(x2, y, 4);
          this.set(x2 + 1, y + 1, 64);
        }
        if (orientation === 2) {
          this.set(x2, y, 16);
          this.set(x2 + 1, y - 1, 1);
        }
        if (orientation === 3) {
          this.set(x2, y, 64);
          this.set(x2 - 1, y - 1, 4);
        }
      }
      if (position === 2) {
        if (orientation === 0) {
          this.set(x2, y, 130);
          this.set(x2 - 1, y, 8);
          this.set(x2, y + 1, 32);
        }
        if (orientation === 1) {
          this.set(x2, y, 10);
          this.set(x2, y + 1, 32);
          this.set(x2 + 1, y, 128);
        }
        if (orientation === 2) {
          this.set(x2, y, 40);
          this.set(x2 + 1, y, 128);
          this.set(x2, y - 1, 2);
        }
        if (orientation === 3) {
          this.set(x2, y, 160);
          this.set(x2, y - 1, 2);
          this.set(x2 - 1, y, 8);
        }
      }
      if (impenetrable) {
        if (position === 0) {
          if (orientation === 0) {
            this.set(x2, y, 65536);
            this.set(x2 - 1, y, 4096);
          }
          if (orientation === 1) {
            this.set(x2, y, 1024);
            this.set(x2, y + 1, 16384);
          }
          if (orientation === 2) {
            this.set(x2, y, 4096);
            this.set(x2 + 1, y, 65536);
          }
          if (orientation === 3) {
            this.set(x2, y, 16384);
            this.set(x2, y - 1, 1024);
          }
        }
        if (position === 1 || position === 3) {
          if (orientation === 0) {
            this.set(x2, y, 512);
            this.set(x2 - 1, y + 1, 8192);
          }
          if (orientation === 1) {
            this.set(x2, y, 2048);
            this.set(x2 + 1, y + 1, 32768);
          }
          if (orientation === 2) {
            this.set(x2, y, 8192);
            this.set(x2 + 1, y - 1, 512);
          }
          if (orientation === 3) {
            this.set(x2, y, 32768);
            this.set(x2 - 1, y - 1, 2048);
          }
        }
        if (position === 2) {
          if (orientation === 0) {
            this.set(x2, y, 66560);
            this.set(x2 - 1, y, 4096);
            this.set(x2, y + 1, 16384);
          }
          if (orientation === 1) {
            this.set(x2, y, 5120);
            this.set(x2, y + 1, 16384);
            this.set(x2 + 1, y, 65536);
          }
          if (orientation === 2) {
            this.set(x2, y, 20480);
            this.set(x2 + 1, y, 65536);
            this.set(x2, y - 1, 1024);
          }
          if (orientation === 3) {
            this.set(x2, y, 81920);
            this.set(x2, y - 1, 1024);
            this.set(x2 - 1, y, 4096);
          }
        }
      }
    }
    method413(y, orient, h, w, impenetrable, x2, byte0) {
      let occupied = 256;
      if (impenetrable) {
        occupied += 131072;
      }
      x2 -= this.insetX;
      y -= this.insetY;
      if (orient === 1 || orient === 3) {
        const tmp = w;
        w = h;
        h = tmp;
      }
      for (let l1 = x2; l1 < x2 + w; l1++) {
        if (l1 >= 0 && l1 < this.width) {
          for (let i2 = y; i2 < y + h; i2++) {
            if (i2 >= 0 && i2 < this.height) {
              this.set(l1, i2, occupied);
            }
          }
        }
      }
    }
    markBlocked(x2, y) {
      x2 -= this.insetX;
      y -= this.insetY;
      this.adjacency[x2][y] |= 2097152;
    }
    set(x2, y, flag) {
      this.adjacency[x2][y] |= flag;
    }
    unmarkWall(orientation, x2, y, position, impenetrable) {
      x2 -= this.insetX;
      y -= this.insetY;
      if (position === 0) {
        if (orientation === 0) {
          this.unset(x2, y, 128);
          this.unset(x2 - 1, y, 8);
        }
        if (orientation === 1) {
          this.unset(x2, y, 2);
          this.unset(x2, y + 1, 32);
        }
        if (orientation === 2) {
          this.unset(x2, y, 8);
          this.unset(x2 + 1, y, 128);
        }
        if (orientation === 3) {
          this.unset(x2, y, 32);
          this.unset(x2, y - 1, 2);
        }
      }
      if (position === 1 || position === 3) {
        if (orientation === 0) {
          this.unset(x2, y, 1);
          this.unset(x2 - 1, y + 1, 16);
        }
        if (orientation === 1) {
          this.unset(x2, y, 4);
          this.unset(x2 + 1, y + 1, 64);
        }
        if (orientation === 2) {
          this.unset(x2, y, 16);
          this.unset(x2 + 1, y - 1, 1);
        }
        if (orientation === 3) {
          this.unset(x2, y, 64);
          this.unset(x2 - 1, y - 1, 4);
        }
      }
      if (position === 2) {
        if (orientation === 0) {
          this.unset(x2, y, 130);
          this.unset(x2 - 1, y, 8);
          this.unset(x2, y + 1, 32);
        }
        if (orientation === 1) {
          this.unset(x2, y, 10);
          this.unset(x2, y + 1, 32);
          this.unset(x2 + 1, y, 128);
        }
        if (orientation === 2) {
          this.unset(x2, y, 40);
          this.unset(x2 + 1, y, 128);
          this.unset(x2, y - 1, 2);
        }
        if (orientation === 3) {
          this.unset(x2, y, 160);
          this.unset(x2, y - 1, 2);
          this.unset(x2 - 1, y, 8);
        }
      }
      if (impenetrable) {
        if (position === 0) {
          if (orientation === 0) {
            this.unset(x2, y, 65536);
            this.unset(x2 - 1, y, 4096);
          }
          if (orientation === 1) {
            this.unset(x2, y, 1024);
            this.unset(x2, y + 1, 16384);
          }
          if (orientation === 2) {
            this.unset(x2, y, 4096);
            this.unset(x2 + 1, y, 65536);
          }
          if (orientation === 3) {
            this.unset(x2, y, 16384);
            this.unset(x2, y - 1, 1024);
          }
        }
        if (position === 1 || position === 3) {
          if (orientation === 0) {
            this.unset(x2, y, 512);
            this.unset(x2 - 1, y + 1, 8192);
          }
          if (orientation === 1) {
            this.unset(x2, y, 2048);
            this.unset(x2 + 1, y + 1, 32768);
          }
          if (orientation === 2) {
            this.unset(x2, y, 8192);
            this.unset(x2 + 1, y - 1, 512);
          }
          if (orientation === 3) {
            this.unset(x2, y, 32768);
            this.unset(x2 - 1, y - 1, 2048);
          }
        }
        if (position === 2) {
          if (orientation === 0) {
            this.unset(x2, y, 66560);
            this.unset(x2 - 1, y, 4096);
            this.unset(x2, y + 1, 16384);
          }
          if (orientation === 1) {
            this.unset(x2, y, 5120);
            this.unset(x2, y + 1, 16384);
            this.unset(x2 + 1, y, 65536);
          }
          if (orientation === 2) {
            this.unset(x2, y, 20480);
            this.unset(x2 + 1, y, 65536);
            this.unset(x2, y - 1, 1024);
          }
          if (orientation === 3) {
            this.unset(x2, y, 81920);
            this.unset(x2, y - 1, 1024);
            this.unset(x2 - 1, y, 4096);
          }
        }
      }
    }
    unmarkSolidOccupant(impenetrable, y, x2, orientation, height, flag, width) {
      const occupied = 256;
      x2 -= this.insetX;
      y -= this.insetY;
      if (orientation === 1 || orientation === 3) {
        const originalWidth = width;
        width = height;
        height = originalWidth;
      }
      for (let xCounter = x2; xCounter < x2 + width; xCounter++) {
        if (xCounter >= 0 && xCounter < this.width) {
          for (let yCounter = y; yCounter < y + height; yCounter++) {
            if (yCounter >= 0 && yCounter < this.height) {
              this.unset(xCounter, yCounter, occupied);
            }
          }
        }
      }
    }
    unset(x2, y, flag) {
      this.adjacency[x2][y] &= 16777215 - flag;
    }
    unmarkConcealed(x2, y) {
      x2 -= this.insetX;
      y -= this.insetY;
      this.adjacency[x2][y] &= 14680063;
    }
    reachedWall(currentX, currentY, goalX, goalY, goalPosition, goalOrientation) {
      if (currentX === goalX && currentY === goalY) {
        return true;
      }
      currentX -= this.insetX;
      currentY -= this.insetY;
      goalX -= this.insetX;
      goalY -= this.insetY;
      if (goalPosition === 0) {
        if (goalOrientation === 0) {
          if (currentX === goalX - 1 && currentY === goalY) {
            return true;
          }
          if (currentX === goalX && currentY === goalY + 1 && (this.adjacency[currentX][currentY] & 19398944) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY - 1 && (this.adjacency[currentX][currentY] & 19398914) === 0) {
            return true;
          }
        } else if (goalOrientation === 1) {
          if (currentX === goalX && currentY === goalY + 1) {
            return true;
          }
          if (currentX === goalX - 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 19398920) === 0) {
            return true;
          }
          if (currentX === goalX + 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 19399040) === 0) {
            return true;
          }
        } else if (goalOrientation === 2) {
          if (currentX === goalX + 1 && currentY === goalY) {
            return true;
          }
          if (currentX === goalX && currentY === goalY + 1 && (this.adjacency[currentX][currentY] & 19398944) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY - 1 && (this.adjacency[currentX][currentY] & 19398914) === 0) {
            return true;
          }
        } else if (goalOrientation === 3) {
          if (currentX === goalX && currentY === goalY - 1) {
            return true;
          }
          if (currentX === goalX - 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 19398920) === 0) {
            return true;
          }
          if (currentX === goalX + 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 19399040) === 0) {
            return true;
          }
        }
      }
      if (goalPosition === 2) {
        if (goalOrientation === 0) {
          if (currentX === goalX - 1 && currentY === goalY) {
            return true;
          }
          if (currentX === goalX && currentY === goalY + 1) {
            return true;
          }
          if (currentX === goalX + 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 19399040) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY - 1 && (this.adjacency[currentX][currentY] & 19398914) === 0) {
            return true;
          }
        } else if (goalOrientation === 1) {
          if (currentX === goalX - 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 19398920) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY + 1) {
            return true;
          }
          if (currentX === goalX + 1 && currentY === goalY) {
            return true;
          }
          if (currentX === goalX && currentY === goalY - 1 && (this.adjacency[currentX][currentY] & 19398914) === 0) {
            return true;
          }
        } else if (goalOrientation === 2) {
          if (currentX === goalX - 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 19398920) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY + 1 && (this.adjacency[currentX][currentY] & 19398944) === 0) {
            return true;
          }
          if (currentX === goalX + 1 && currentY === goalY) {
            return true;
          }
          if (currentX === goalX && currentY === goalY - 1) {
            return true;
          }
        } else if (goalOrientation === 3) {
          if (currentX === goalX - 1 && currentY === goalY) {
            return true;
          }
          if (currentX === goalX && currentY === goalY + 1 && (this.adjacency[currentX][currentY] & 19398944) === 0) {
            return true;
          }
          if (currentX === goalX + 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 19399040) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY - 1) {
            return true;
          }
        }
      }
      if (goalPosition === 9) {
        if (currentX === goalX && currentY === goalY + 1 && (this.adjacency[currentX][currentY] & 32) === 0) {
          return true;
        }
        if (currentX === goalX && currentY === goalY - 1 && (this.adjacency[currentX][currentY] & 2) === 0) {
          return true;
        }
        if (currentX === goalX - 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 8) === 0) {
          return true;
        }
        if (currentX === goalX + 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 128) === 0) {
          return true;
        }
      }
      return false;
    }
    reachedWallDecoration(currentX, currentY, goalX, goalY, goalPosition, goalOrientation) {
      currentX -= this.insetX;
      currentY -= this.insetY;
      goalX -= this.insetX;
      goalY -= this.insetY;
      if (goalPosition === 6 || goalPosition === 7) {
        if (goalPosition === 7) {
          goalOrientation = goalOrientation + 2 & 3;
        }
        if (goalOrientation === 0) {
          if (currentX === goalX + 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 128) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY - 1 && (this.adjacency[currentX][currentY] & 2) === 0) {
            return true;
          }
        } else if (goalOrientation === 1) {
          if (currentX === goalX - 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 8) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY - 1 && (this.adjacency[currentX][currentY] & 2) === 0) {
            return true;
          }
        } else if (goalOrientation === 2) {
          if (currentX === goalX - 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 8) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY + 1 && (this.adjacency[currentX][currentY] & 32) === 0) {
            return true;
          }
        } else if (goalOrientation === 3) {
          if (currentX === goalX + 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 128) === 0) {
            return true;
          }
          if (currentX === goalX && currentY === goalY + 1 && (this.adjacency[currentX][currentY] & 32) === 0) {
            return true;
          }
        }
      }
      if (goalPosition === 8) {
        if (currentX === goalX && currentY === goalY + 1 && (this.adjacency[currentX][currentY] & 32) === 0) {
          return true;
        }
        if (currentX === goalX && currentY === goalY - 1 && (this.adjacency[currentX][currentY] & 2) === 0) {
          return true;
        }
        if (currentX === goalX - 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 8) === 0) {
          return true;
        }
        if (currentX === goalX + 1 && currentY === goalY && (this.adjacency[currentX][currentY] & 128) === 0) {
          return true;
        }
      }
      return false;
    }
    reachedFacingObject(currentX, currentY, goalX, goalY, goalDX, goalDY, surroundings) {
      const goalX2 = goalX + goalDX - 1;
      const goalY2 = goalY + goalDY - 1;
      if (currentX >= goalX && currentX <= goalX2 && currentY >= goalY && currentY <= goalY2) {
        return true;
      }
      if (currentX === goalX - 1 && currentY >= goalY && currentY <= goalY2 && (this.adjacency[currentX - this.insetX][currentY - this.insetY] & 8) === 0 && (surroundings & 8) === 0) {
        return true;
      }
      if (currentX === goalX2 + 1 && currentY >= goalY && currentY <= goalY2 && (this.adjacency[currentX - this.insetX][currentY - this.insetY] & 128) === 0 && (surroundings & 2) === 0) {
        return true;
      }
      if (currentY === goalY - 1 && currentX >= goalX && currentX <= goalX2 && (this.adjacency[currentX - this.insetX][currentY - this.insetY] & 2) === 0 && (surroundings & 4) === 0) {
        return true;
      }
      return currentY === goalY2 + 1 && currentX >= goalX && currentX <= goalX2 && (this.adjacency[currentX - this.insetX][currentY - this.insetY] & 32) === 0 && (surroundings & 1) === 0;
    }
  };

  // osrs/net/Socket.ts
  init_inject();

  // osrs/net/WebSocketClient.ts
  init_inject();
  var WebSocketClient = class {
    constructor() {
      this._reset();
    }
    get connected() {
      return this._socket != null && this._socket.readyState === WebSocket.OPEN;
    }
    get dataAvailable() {
      return this._receiveDataQueue.length;
    }
    get dataBytesAvailable() {
      return this._receiveDataQueue.reduce((a, b) => a + b.byteLength, 0);
    }
    connect(url, protocols) {
      return this.disconnect().then(() => {
        this._reset();
        this._socket = new WebSocket(url, protocols);
        this._socket.binaryType = "arraybuffer";
        return this._setupListenersOnConnect();
      });
    }
    send(data) {
      if (!this.connected) {
        throw this._closeEvent || new Error("Not connected.");
      }
      this._socket.send(data);
    }
    receive() {
      if (this._receiveDataQueue.length !== 0) {
        return Promise.resolve(this._receiveDataQueue.shift());
      }
      if (!this.connected) {
        return Promise.reject(this._closeEvent || new Error("Not connected."));
      }
      const receivePromise = new Promise((resolve, reject) => {
        this._receiveCallbacksQueue.push({ resolve, reject });
      });
      return receivePromise;
    }
    receiveLocal() {
      if (this._receiveDataQueue.length !== 0) {
        return this._receiveDataQueue.shift();
      }
      return null;
    }
    disconnect(code, reason) {
      if (!this.connected) {
        return Promise.resolve(this._closeEvent);
      }
      return new Promise((resolve, reject) => {
        const callbacks = {
          resolve: (dummy) => {
            this._receiveCallbacksQueue.push(callbacks);
          },
          reject: resolve
        };
        this._receiveCallbacksQueue.push(callbacks);
        this._socket.close(code, reason);
      });
    }
    _setupListenersOnConnect() {
      const socket = this._socket;
      return new Promise((resolve, reject) => {
        const handleMessage = (event) => {
          const messageEvent = event;
          if (this._receiveCallbacksQueue.length !== 0) {
            this._receiveCallbacksQueue.shift().resolve(messageEvent.data);
            return;
          }
          const data = messageEvent.data;
          if (data instanceof ArrayBuffer) {
            this._receiveDataQueue.push(data);
          }
        };
        const handleOpen = (event) => {
          socket.addEventListener("message", handleMessage);
          socket.addEventListener("close", (event2) => {
            this._closeEvent = event2;
            while (this._receiveCallbacksQueue.length !== 0) {
              this._receiveCallbacksQueue.shift().reject(this._closeEvent);
            }
          });
          resolve();
        };
        socket.addEventListener("error", reject);
        socket.addEventListener("open", handleOpen);
      });
    }
    _reset() {
      this._receiveDataQueue = [];
      this._receiveCallbacksQueue = [];
      this._closeEvent = null;
    }
  };

  // osrs/net/Socket.ts
  var Socket = class {
    constructor(host, port) {
      this.lastArrayBufferReceived = null;
      this.lastArrayBufferReadIndex = 0;
      this.host = host;
      this.port = port;
      this.client = new WebSocketClient();
    }
    async connect() {
      await this.client.connect(`ws://${this.host}:${this.port}`);
    }
    write$int(buf) {
      this.client.send(new Int8Array([buf]));
    }
    write$byte_A$int$int(bytes, off, len) {
      if (bytes instanceof Int8Array) {
        this.client.send(bytes.slice(off, off + len));
      } else {
        this.client.send(new Int8Array(bytes.slice(off, off + len)));
      }
    }
    write$byte_A(bytes) {
      if (bytes instanceof Int8Array) {
        this.client.send(bytes.slice);
      } else {
        this.client.send(new Int8Array(bytes));
      }
    }
    async read() {
      if (this.lastArrayBufferReceived != null && this.lastArrayBufferReadIndex < this.lastArrayBufferReceived.length) {
        return this.readFromLastArray();
      }
      const received = await this.client.receive();
      if (received instanceof Error) {
        throw received;
      }
      this.lastArrayBufferReceived = new Int8Array(received);
      this.lastArrayBufferReadIndex = 0;
      return this.readFromLastArray();
    }
    readFromLastArray() {
      if (this.lastArrayBufferReadIndex == this.lastArrayBufferReceived.length - 1) {
        const lastByte = this.lastArrayBufferReceived[this.lastArrayBufferReadIndex];
        this.lastArrayBufferReadIndex = 0;
        this.lastArrayBufferReceived = null;
        return lastByte;
      }
      return this.lastArrayBufferReceived[this.lastArrayBufferReadIndex++];
    }
    async read$byte_A$int$int(b, off, len) {
      let c2 = await this.read();
      b[off] = c2;
      let i = 1;
      for (; i < len; i++) {
        c2 = await this.read();
        b[off + i] = c2;
      }
      return i;
    }
    async close() {
      console.warn("closed");
      await this.client.disconnect();
    }
    available() {
      return this.client.dataBytesAvailable;
    }
  };

  // osrs/net/requester/OnDemandRequester.ts
  init_inject();

  // osrs/net/requester/OnDemandNode.ts
  init_inject();
  var OnDemandNode = class extends CacheableNode {
    constructor() {
      super();
      this.type = 0;
      this.id = 0;
      this.cyclesSinceSend = 0;
      this.buffer = null;
      this.immediate = true;
    }
  };

  // osrs/net/requester/Requester.ts
  init_inject();
  var Requester = class {
    requestModel(model) {
    }
  };

  // osrs/net/requester/OnDemandRequester.ts
  var import_pako = __toESM(require_pako(), 1);

  // node_modules/@stardazed/zlib/dist/sd-zlib.esm.js
  init_inject();
  var swap32 = (q) => (q >>> 24 & 255 | q >>> 8 & 65280 | (q & 65280) << 8 | (q & 255) << 24) >>> 0;
  function u8ArrayFromBufferSource(source) {
    if (source instanceof ArrayBuffer) {
      return new Uint8Array(source);
    }
    if (!ArrayBuffer.isView(source)) {
      return void 0;
    }
    if (!(source instanceof Uint8Array)) {
      return new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    }
    return source;
  }
  function crc32(source, seed = 0) {
    const view = u8ArrayFromBufferSource(source);
    if (!view) {
      throw new TypeError("source must be a BufferSource");
    }
    return computeCRC32(view, seed);
  }
  var endian = new Uint32Array([1]);
  var endianCheck = new Uint8Array(endian.buffer, 0, 1)[0];
  var computeCRC32 = endianCheck === 1 ? computeCRC32Little : computeCRC32Big;
  function computeCRC32Little(buf, crc = 0) {
    let c2 = ~crc;
    let offset = buf.byteOffset;
    let position = 0;
    let len = buf.byteLength;
    const table0 = crcTables[0];
    const table1 = crcTables[1];
    const table2 = crcTables[2];
    const table3 = crcTables[3];
    while (len && offset & 3) {
      c2 = table0[(c2 ^ buf[position++]) & 255] ^ c2 >>> 8;
      len--;
      offset++;
    }
    const buf4 = new Uint32Array(buf.buffer, offset, len >>> 2);
    let pos4 = 0;
    while (len >= 32) {
      c2 ^= buf4[pos4++];
      c2 = table3[c2 & 255] ^ table2[c2 >>> 8 & 255] ^ table1[c2 >>> 16 & 255] ^ table0[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table3[c2 & 255] ^ table2[c2 >>> 8 & 255] ^ table1[c2 >>> 16 & 255] ^ table0[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table3[c2 & 255] ^ table2[c2 >>> 8 & 255] ^ table1[c2 >>> 16 & 255] ^ table0[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table3[c2 & 255] ^ table2[c2 >>> 8 & 255] ^ table1[c2 >>> 16 & 255] ^ table0[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table3[c2 & 255] ^ table2[c2 >>> 8 & 255] ^ table1[c2 >>> 16 & 255] ^ table0[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table3[c2 & 255] ^ table2[c2 >>> 8 & 255] ^ table1[c2 >>> 16 & 255] ^ table0[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table3[c2 & 255] ^ table2[c2 >>> 8 & 255] ^ table1[c2 >>> 16 & 255] ^ table0[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table3[c2 & 255] ^ table2[c2 >>> 8 & 255] ^ table1[c2 >>> 16 & 255] ^ table0[c2 >>> 24];
      len -= 32;
    }
    while (len >= 4) {
      c2 ^= buf4[pos4++];
      c2 = table3[c2 & 255] ^ table2[c2 >>> 8 & 255] ^ table1[c2 >>> 16 & 255] ^ table0[c2 >>> 24];
      len -= 4;
    }
    if (len) {
      position += pos4 * 4;
      do {
        c2 = table0[(c2 ^ buf[position++]) & 255] ^ c2 >>> 8;
      } while (--len);
    }
    c2 = ~c2;
    return c2;
  }
  function computeCRC32Big(buf, crc = 0) {
    let c2 = ~swap32(crc);
    let offset = buf.byteOffset;
    let position = 0;
    let len = buf.byteLength;
    const table4 = crcTables[4];
    const table5 = crcTables[5];
    const table6 = crcTables[6];
    const table7 = crcTables[7];
    while (len && offset & 3) {
      c2 = table4[c2 >>> 24 ^ buf[position++]] ^ c2 << 8;
      len--;
      offset++;
    }
    const buf4 = new Uint32Array(buf.buffer, offset, len >>> 2);
    let pos4 = 0;
    while (len >= 32) {
      c2 ^= buf4[pos4++];
      c2 = table4[c2 & 255] ^ table5[c2 >>> 8 & 255] ^ table6[c2 >>> 16 & 255] ^ table7[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table4[c2 & 255] ^ table5[c2 >>> 8 & 255] ^ table6[c2 >>> 16 & 255] ^ table7[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table4[c2 & 255] ^ table5[c2 >>> 8 & 255] ^ table6[c2 >>> 16 & 255] ^ table7[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table4[c2 & 255] ^ table5[c2 >>> 8 & 255] ^ table6[c2 >>> 16 & 255] ^ table7[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table4[c2 & 255] ^ table5[c2 >>> 8 & 255] ^ table6[c2 >>> 16 & 255] ^ table7[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table4[c2 & 255] ^ table5[c2 >>> 8 & 255] ^ table6[c2 >>> 16 & 255] ^ table7[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table4[c2 & 255] ^ table5[c2 >>> 8 & 255] ^ table6[c2 >>> 16 & 255] ^ table7[c2 >>> 24];
      c2 ^= buf4[pos4++];
      c2 = table4[c2 & 255] ^ table5[c2 >>> 8 & 255] ^ table6[c2 >>> 16 & 255] ^ table7[c2 >>> 24];
      len -= 32;
    }
    while (len >= 4) {
      c2 ^= buf4[pos4++];
      c2 = table4[c2 & 255] ^ table5[c2 >>> 8 & 255] ^ table6[c2 >>> 16 & 255] ^ table7[c2 >>> 24];
      len -= 4;
    }
    if (len) {
      position += pos4 * 4;
      do {
        c2 = table4[c2 >>> 24 ^ buf[position++]] ^ c2 << 8;
      } while (--len);
    }
    c2 = ~c2;
    return swap32(c2);
  }
  function makeCRCTables() {
    const buf = new ArrayBuffer(256 * 4 * 8);
    const tables = [
      new Uint32Array(buf, 256 * 4 * 0, 256),
      new Uint32Array(buf, 256 * 4 * 1, 256),
      new Uint32Array(buf, 256 * 4 * 2, 256),
      new Uint32Array(buf, 256 * 4 * 3, 256),
      new Uint32Array(buf, 256 * 4 * 4, 256),
      new Uint32Array(buf, 256 * 4 * 5, 256),
      new Uint32Array(buf, 256 * 4 * 6, 256),
      new Uint32Array(buf, 256 * 4 * 7, 256)
    ];
    for (let n = 0; n < 256; n++) {
      let c2 = n;
      for (let k = 0; k < 8; k++) {
        c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
      }
      tables[0][n] = c2;
      tables[4][n] = swap32(c2);
    }
    for (let n = 0; n < 256; n++) {
      let c2 = tables[0][n];
      for (let k = 1; k < 4; k++) {
        c2 = tables[0][c2 & 255] ^ c2 >>> 8;
        tables[k][n] = c2;
        tables[k + 4][n] = swap32(c2);
      }
    }
    return tables;
  }
  var crcTables = makeCRCTables();
  var BMAX = 15;
  var c = new Int32Array(BMAX + 1);
  var r = new Int32Array(3);
  var u = new Int32Array(BMAX);
  var x = new Int32Array(BMAX + 1);
  var D_CODES = 30;
  var BL_CODES = 19;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BL_BITS = 7;
  var _dist_code = [
    0,
    1,
    2,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    6,
    6,
    7,
    7,
    7,
    7,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    14,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    15,
    0,
    0,
    16,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    28,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29,
    29
  ];
  var Tree = class {
    constructor(tree, desc) {
      this.dyn_tree = tree;
      this.stat_desc = desc;
      this.max_code = 0;
    }
    gen_bitlen(s) {
      var tree = this.dyn_tree;
      var stree = this.stat_desc.static_tree;
      var extra = this.stat_desc.extra_bits;
      var base = this.stat_desc.extra_base;
      var max_length = this.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= 15; bits++)
        s.bl_count[bits] = 0;
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > this.max_code)
          continue;
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base)
          xbits = extra[n - base];
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (stree)
          s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
      if (overflow === 0)
        return;
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0)
          bits--;
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > this.max_code)
            continue;
          if (tree[m * 2 + 1] != bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    bi_reverse(code, len) {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    gen_codes(tree, max_code, bl_count) {
      const next_code = new Uint16Array(15 + 1);
      let code = 0;
      for (let bits = 1; bits <= 15; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (let n = 0; n <= max_code; n++) {
        const len = tree[n * 2 + 1];
        if (len === 0)
          continue;
        tree[n * 2] = this.bi_reverse(next_code[len]++, len);
      }
    }
    build_tree(s) {
      var tree = this.dyn_tree;
      var stree = this.stat_desc.static_tree;
      var elems = this.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (stree)
          s.static_len -= stree[node * 2 + 1];
      }
      this.max_code = max_code;
      for (n = Math.floor(s.heap_len / 2); n >= 1; n--)
        s.pqdownheap(tree, n);
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        s.pqdownheap(tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        s.pqdownheap(tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      this.gen_bitlen(s);
      this.gen_codes(tree, this.max_code, s.bl_count);
    }
    static d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
  };
  Tree._length_code = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    12,
    12,
    13,
    13,
    13,
    13,
    14,
    14,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    25,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    26,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    27,
    28
  ];
  Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];
  Tree.base_dist = [
    0,
    1,
    2,
    3,
    4,
    6,
    8,
    12,
    16,
    24,
    32,
    48,
    64,
    96,
    128,
    192,
    256,
    384,
    512,
    768,
    1024,
    1536,
    2048,
    3072,
    4096,
    6144,
    8192,
    12288,
    16384,
    24576
  ];
  Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var StaticTree = class {
    constructor(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
    }
  };
  StaticTree.static_ltree = new Uint16Array([
    12,
    8,
    140,
    8,
    76,
    8,
    204,
    8,
    44,
    8,
    172,
    8,
    108,
    8,
    236,
    8,
    28,
    8,
    156,
    8,
    92,
    8,
    220,
    8,
    60,
    8,
    188,
    8,
    124,
    8,
    252,
    8,
    2,
    8,
    130,
    8,
    66,
    8,
    194,
    8,
    34,
    8,
    162,
    8,
    98,
    8,
    226,
    8,
    18,
    8,
    146,
    8,
    82,
    8,
    210,
    8,
    50,
    8,
    178,
    8,
    114,
    8,
    242,
    8,
    10,
    8,
    138,
    8,
    74,
    8,
    202,
    8,
    42,
    8,
    170,
    8,
    106,
    8,
    234,
    8,
    26,
    8,
    154,
    8,
    90,
    8,
    218,
    8,
    58,
    8,
    186,
    8,
    122,
    8,
    250,
    8,
    6,
    8,
    134,
    8,
    70,
    8,
    198,
    8,
    38,
    8,
    166,
    8,
    102,
    8,
    230,
    8,
    22,
    8,
    150,
    8,
    86,
    8,
    214,
    8,
    54,
    8,
    182,
    8,
    118,
    8,
    246,
    8,
    14,
    8,
    142,
    8,
    78,
    8,
    206,
    8,
    46,
    8,
    174,
    8,
    110,
    8,
    238,
    8,
    30,
    8,
    158,
    8,
    94,
    8,
    222,
    8,
    62,
    8,
    190,
    8,
    126,
    8,
    254,
    8,
    1,
    8,
    129,
    8,
    65,
    8,
    193,
    8,
    33,
    8,
    161,
    8,
    97,
    8,
    225,
    8,
    17,
    8,
    145,
    8,
    81,
    8,
    209,
    8,
    49,
    8,
    177,
    8,
    113,
    8,
    241,
    8,
    9,
    8,
    137,
    8,
    73,
    8,
    201,
    8,
    41,
    8,
    169,
    8,
    105,
    8,
    233,
    8,
    25,
    8,
    153,
    8,
    89,
    8,
    217,
    8,
    57,
    8,
    185,
    8,
    121,
    8,
    249,
    8,
    5,
    8,
    133,
    8,
    69,
    8,
    197,
    8,
    37,
    8,
    165,
    8,
    101,
    8,
    229,
    8,
    21,
    8,
    149,
    8,
    85,
    8,
    213,
    8,
    53,
    8,
    181,
    8,
    117,
    8,
    245,
    8,
    13,
    8,
    141,
    8,
    77,
    8,
    205,
    8,
    45,
    8,
    173,
    8,
    109,
    8,
    237,
    8,
    29,
    8,
    157,
    8,
    93,
    8,
    221,
    8,
    61,
    8,
    189,
    8,
    125,
    8,
    253,
    8,
    19,
    9,
    275,
    9,
    147,
    9,
    403,
    9,
    83,
    9,
    339,
    9,
    211,
    9,
    467,
    9,
    51,
    9,
    307,
    9,
    179,
    9,
    435,
    9,
    115,
    9,
    371,
    9,
    243,
    9,
    499,
    9,
    11,
    9,
    267,
    9,
    139,
    9,
    395,
    9,
    75,
    9,
    331,
    9,
    203,
    9,
    459,
    9,
    43,
    9,
    299,
    9,
    171,
    9,
    427,
    9,
    107,
    9,
    363,
    9,
    235,
    9,
    491,
    9,
    27,
    9,
    283,
    9,
    155,
    9,
    411,
    9,
    91,
    9,
    347,
    9,
    219,
    9,
    475,
    9,
    59,
    9,
    315,
    9,
    187,
    9,
    443,
    9,
    123,
    9,
    379,
    9,
    251,
    9,
    507,
    9,
    7,
    9,
    263,
    9,
    135,
    9,
    391,
    9,
    71,
    9,
    327,
    9,
    199,
    9,
    455,
    9,
    39,
    9,
    295,
    9,
    167,
    9,
    423,
    9,
    103,
    9,
    359,
    9,
    231,
    9,
    487,
    9,
    23,
    9,
    279,
    9,
    151,
    9,
    407,
    9,
    87,
    9,
    343,
    9,
    215,
    9,
    471,
    9,
    55,
    9,
    311,
    9,
    183,
    9,
    439,
    9,
    119,
    9,
    375,
    9,
    247,
    9,
    503,
    9,
    15,
    9,
    271,
    9,
    143,
    9,
    399,
    9,
    79,
    9,
    335,
    9,
    207,
    9,
    463,
    9,
    47,
    9,
    303,
    9,
    175,
    9,
    431,
    9,
    111,
    9,
    367,
    9,
    239,
    9,
    495,
    9,
    31,
    9,
    287,
    9,
    159,
    9,
    415,
    9,
    95,
    9,
    351,
    9,
    223,
    9,
    479,
    9,
    63,
    9,
    319,
    9,
    191,
    9,
    447,
    9,
    127,
    9,
    383,
    9,
    255,
    9,
    511,
    9,
    0,
    7,
    64,
    7,
    32,
    7,
    96,
    7,
    16,
    7,
    80,
    7,
    48,
    7,
    112,
    7,
    8,
    7,
    72,
    7,
    40,
    7,
    104,
    7,
    24,
    7,
    88,
    7,
    56,
    7,
    120,
    7,
    4,
    7,
    68,
    7,
    36,
    7,
    100,
    7,
    20,
    7,
    84,
    7,
    52,
    7,
    116,
    7,
    3,
    8,
    131,
    8,
    67,
    8,
    195,
    8,
    35,
    8,
    163,
    8,
    99,
    8,
    227,
    8
  ]);
  StaticTree.static_dtree = new Uint16Array([
    0,
    5,
    16,
    5,
    8,
    5,
    24,
    5,
    4,
    5,
    20,
    5,
    12,
    5,
    28,
    5,
    2,
    5,
    18,
    5,
    10,
    5,
    26,
    5,
    6,
    5,
    22,
    5,
    14,
    5,
    30,
    5,
    1,
    5,
    17,
    5,
    9,
    5,
    25,
    5,
    5,
    5,
    21,
    5,
    13,
    5,
    29,
    5,
    3,
    5,
    19,
    5,
    11,
    5,
    27,
    5,
    7,
    5,
    23,
    5
  ]);
  StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, 15);
  StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, 15);
  StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  var makeConfig = (gl, ml, nl, mc, func) => ({
    good_length: gl,
    max_lazy: ml,
    nice_length: nl,
    max_chain: mc,
    func
  });
  var config_table = [
    makeConfig(0, 0, 0, 0, 0),
    makeConfig(4, 4, 8, 4, 1),
    makeConfig(4, 5, 16, 8, 1),
    makeConfig(4, 6, 32, 32, 1),
    makeConfig(4, 4, 16, 16, 2),
    makeConfig(8, 16, 32, 32, 2),
    makeConfig(8, 16, 128, 128, 2),
    makeConfig(8, 32, 128, 256, 2),
    makeConfig(32, 128, 258, 1024, 2),
    makeConfig(32, 258, 258, 4096, 2)
  ];
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var hash_bits = 8 + 7;
  var hash_size = 1 << hash_bits;
  var hash_mask = hash_size - 1;
  var hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  var lit_bufsize = 1 << 8 + 6;
  var pending_buf_size = lit_bufsize * 4;
  var d_buf = Math.floor(lit_bufsize / 2);
  var l_buf = (1 + 2) * lit_bufsize;
  var window_size = 2 * 32768;

  // osrs/net/requester/OnDemandRequester.ts
  var OnDemandRequester = class extends Requester {
    constructor() {
      super();
      this.filePriorities = [null, null, null, null];
      this.expectData = false;
      this.running = true;
      this.wanted = new LinkedList();
      this.fileCrc = [null, null, null, null];
      this.message = "";
      this.wantedToSend = new LinkedList();
      this.aBoolean1352 = false;
      this.socket = null;
      this.completed = new LinkedList();
      this.immediateRequests = new LinkedList();
      this.deflateOut = Array(65e3).fill(0);
      this.inputBuffer = Array(500).fill(0);
      this.anInt1367 = 591;
      this.toRequest = new LinkedList();
      this.fileVersions = [null, null, null, null];
      if (this.anInt1334 === void 0) {
        this.anInt1334 = 0;
      }
      if (this.modelIndex === void 0) {
        this.modelIndex = null;
      }
      if (this.regShouldPreload === void 0) {
        this.regShouldPreload = null;
      }
      if (this.highestPriority === void 0) {
        this.highestPriority = 0;
      }
      if (this.immediateRequestsSent === void 0) {
        this.immediateRequestsSent = 0;
      }
      if (this.anInt1343 === void 0) {
        this.anInt1343 = 0;
      }
      if (this.anInt1345 === void 0) {
        this.anInt1345 = 0;
      }
      if (this.regHash === void 0) {
        this.regHash = null;
      }
      if (this.cycle === void 0) {
        this.cycle = 0;
      }
      if (this.anInt1350 === void 0) {
        this.anInt1350 = 0;
      }
      if (this.idleCycles === void 0) {
        this.idleCycles = 0;
      }
      if (this.regMapIndex === void 0) {
        this.regMapIndex = null;
      }
      if (this.offset === void 0) {
        this.offset = 0;
      }
      if (this.toRead === void 0) {
        this.toRead = 0;
      }
      if (this.anInt1363 === void 0) {
        this.anInt1363 = 0;
      }
      if (this.regLandIndex === void 0) {
        this.regLandIndex = null;
      }
      if (this.midiIndex === void 0) {
        this.midiIndex = null;
      }
      if (this.onDemandNode === void 0) {
        this.onDemandNode = null;
      }
      if (this.client === void 0) {
        this.client = null;
      }
      if (this.sinceKeepAlive === void 0) {
        this.sinceKeepAlive = 0;
      }
      if (this.animIndex === void 0) {
        this.animIndex = null;
      }
      if (this.lastSocketOpen === void 0) {
        this.lastSocketOpen = 0;
      }
      if (this.requestFails === void 0) {
        this.requestFails = 0;
      }
    }
    verify(expectedVersion, expectedCrc, data) {
      if (data == null || data.length < 2) {
        return false;
      }
      const length = data.length - 2;
      const version = ((data[length] & 255) << 8) + (data[length + 1] & 255);
      if (version !== expectedVersion) {
        return false;
      }
      const buffer = new Int8Array(data);
      const byteCrc = crc32(buffer.slice(0, buffer.length - 2));
      return byteCrc === expectedCrc;
    }
    async handleResp() {
      try {
        const available = this.socket.available();
        if (this.toRead === 0 && available >= 6) {
          this.expectData = true;
          for (let read2 = 0; read2 < 6; read2 += await this.socket.read$byte_A$int$int(this.inputBuffer, read2, 6 - read2)) {
          }
          const type = this.inputBuffer[0] & 255;
          const id = ((this.inputBuffer[1] & 255) << 8) + (this.inputBuffer[2] & 255);
          const size = ((this.inputBuffer[3] & 255) << 8) + (this.inputBuffer[4] & 255);
          const chunk = this.inputBuffer[5] & 255;
          this.onDemandNode = null;
          for (let ondemandnode = this.toRequest.first(); ondemandnode != null; ondemandnode = this.toRequest.next()) {
            {
              if (ondemandnode.type === type && ondemandnode.id === id) {
                this.onDemandNode = ondemandnode;
              }
              if (this.onDemandNode != null) {
                ondemandnode.cyclesSinceSend = 0;
              }
            }
          }
          if (this.onDemandNode != null) {
            this.idleCycles = 0;
            if (size === 0) {
              console.error("Rej: " + type + "," + id);
              this.onDemandNode.buffer = null;
              if (this.onDemandNode.immediate) {
                {
                  this.completed.insertBack(this.onDemandNode);
                }
              } else {
                this.onDemandNode.remove();
              }
              this.onDemandNode = null;
            } else {
              if (this.onDemandNode.buffer == null && chunk === 0) {
                this.onDemandNode.buffer = Array(size).fill(0);
              }
              if (this.onDemandNode.buffer == null && chunk !== 0) {
                throw Error("missing initializeApplication of file");
              }
            }
          }
          this.offset = chunk * 500;
          this.toRead = 500;
          if (this.toRead > size - chunk * 500) {
            this.toRead = size - chunk * 500;
          }
        }
        if (this.toRead > 0 && available >= this.toRead) {
          this.expectData = true;
          let buffer = this.inputBuffer;
          let bufferOffset = 0;
          if (this.onDemandNode != null) {
            buffer = this.onDemandNode.buffer;
            bufferOffset = this.offset;
          }
          for (let i = 0; i < this.toRead; i += await this.socket.read$byte_A$int$int(buffer, i + bufferOffset, this.toRead - i)) {
          }
          if (this.toRead + this.offset >= buffer.length && this.onDemandNode != null) {
            if (this.client.stores[0] != null) {
              this.client.stores[this.onDemandNode.type + 1].put$int$byte_A$int(buffer.length, buffer, this.onDemandNode.id);
            }
            if (!this.onDemandNode.immediate && this.onDemandNode.type === 3) {
              this.onDemandNode.immediate = true;
              this.onDemandNode.type = 93;
            }
            if (this.onDemandNode.immediate) {
              {
                this.completed.insertBack(this.onDemandNode);
              }
            } else {
              this.onDemandNode.remove();
            }
          }
          this.toRead = 0;
          return;
        }
      } catch (ioexception) {
        try {
          await this.socket.close();
        } catch (_ex) {
        }
        this.socket = null;
        this.toRead = 0;
      }
    }
    modelId(model) {
      return this.modelIndex[model] & 255;
    }
    requestModel(id) {
      this.request(0, id);
    }
    async passivesRequest(i) {
      if (i !== 0) {
        return;
      }
      while (this.immediateRequestsSent === 0 && this.anInt1343 < 10) {
        {
          if (this.highestPriority === 0) {
            break;
          }
          let class50_sub1_sub3;
          {
            class50_sub1_sub3 = this.immediateRequests.removeFirst();
          }
          while (class50_sub1_sub3 != null) {
            {
              if (this.filePriorities[class50_sub1_sub3.type][class50_sub1_sub3.id] !== 0) {
                this.filePriorities[class50_sub1_sub3.type][class50_sub1_sub3.id] = 0;
                this.toRequest.insertBack(class50_sub1_sub3);
                await this.sendRequest(class50_sub1_sub3);
                this.expectData = true;
                if (this.anInt1334 < this.anInt1350) {
                  this.anInt1334++;
                }
                this.message = "Loading extra files - " + (this.anInt1334 * 100 / this.anInt1350 | 0) + "%";
                this.anInt1343++;
                if (this.anInt1343 === 10) {
                  return;
                }
              }
              {
                class50_sub1_sub3 = this.immediateRequests.removeFirst();
              }
            }
          }
          for (let j = 0; j < 4; j++) {
            {
              const abyte0 = this.filePriorities[j];
              const k = abyte0.length;
              for (let l = 0; l < k; l++) {
                if (abyte0[l] === this.highestPriority) {
                  abyte0[l] = 0;
                  const class50_sub1_sub3_1 = new OnDemandNode();
                  class50_sub1_sub3_1.type = j;
                  class50_sub1_sub3_1.id = l;
                  class50_sub1_sub3_1.immediate = false;
                  this.toRequest.insertBack(class50_sub1_sub3_1);
                  await this.sendRequest(class50_sub1_sub3_1);
                  this.expectData = true;
                  if (this.anInt1334 < this.anInt1350) {
                    this.anInt1334++;
                  }
                  this.message = "Loading extra files - " + (this.anInt1334 * 100 / this.anInt1350 | 0) + "%";
                  this.anInt1343++;
                  if (this.anInt1343 === 10) {
                    return;
                  }
                }
              }
            }
          }
          this.highestPriority--;
        }
      }
    }
    setPriority(byte0, j, k) {
      if (this.client.stores[0] == null) {
        return;
      }
      if (this.fileVersions[j][k] === 0) {
        return;
      }
      const abyte0 = this.client.stores[j + 1].get(k);
      if (this.verify(this.fileVersions[j][k], this.fileCrc[j][k], abyte0)) {
        return;
      }
      this.filePriorities[j][k] = byte0;
      if (byte0 > this.highestPriority) {
        this.highestPriority = byte0;
      }
      this.anInt1350++;
    }
    midiIdEqualsOne(i) {
      return this.midiIndex[i] === 1;
    }
    request(type, id) {
      if (type < 0 || type > this.fileVersions.length || id < 0 || id > this.fileVersions[type].length) {
        return;
      }
      if (this.fileVersions[type][id] === 0) {
        return;
      }
      for (let onDemandNode2 = this.wanted.first(); onDemandNode2 != null; onDemandNode2 = this.wanted.next()) {
        if (onDemandNode2.type === type && onDemandNode2.id === id) {
          return;
        }
      }
      for (let onDemandNode2 = this.wantedToSend.first(); onDemandNode2 != null; onDemandNode2 = this.wantedToSend.next()) {
        if (onDemandNode2.type === type && onDemandNode2.id === id) {
          return;
        }
      }
      const onDemandNode = new OnDemandNode();
      onDemandNode.type = type;
      onDemandNode.id = id;
      onDemandNode.immediate = true;
      this.wanted.insertBack(onDemandNode);
    }
    next() {
      let onDemandNode = this.completed.removeFirst();
      if (onDemandNode == null) {
        return null;
      }
      {
        onDemandNode.clear();
      }
      if (onDemandNode.buffer == null) {
        return onDemandNode;
      }
      this.deflateOut = Array.from(new Int8Array((0, import_pako.ungzip)(new Uint8Array(onDemandNode.buffer))));
      onDemandNode.buffer = [...this.deflateOut];
      return onDemandNode;
    }
    async run() {
      try {
        this.cycle++;
        let toWait = 20;
        if (this.highestPriority === 0 && this.client.stores[0] != null) {
          toWait = 50;
        }
        await sleep(toWait);
        this.expectData = true;
        for (let i = 0; i < 100; i++) {
          {
            if (!this.expectData) {
              break;
            }
            this.expectData = false;
            this.localComplete();
            await this.remainingRequest(0);
            if (this.immediateRequestsSent === 0 && i >= 5) {
              break;
            }
            this.passivesRequest(0);
            if (this.socket != null) {
              await this.handleResp();
            }
          }
        }
        let idle = false;
        for (let onDemandNode = this.toRequest.first(); onDemandNode != null; onDemandNode = this.toRequest.next()) {
          if (onDemandNode.immediate) {
            idle = true;
            onDemandNode.cyclesSinceSend++;
            if (onDemandNode.cyclesSinceSend > 50) {
              onDemandNode.cyclesSinceSend = 0;
              await this.sendRequest(onDemandNode);
            }
          }
        }
        if (!idle) {
          for (let onDemandNode = this.toRequest.first(); onDemandNode != null; onDemandNode = this.toRequest.next()) {
            {
              idle = true;
              onDemandNode.cyclesSinceSend++;
              if (onDemandNode.cyclesSinceSend > 50) {
                onDemandNode.cyclesSinceSend = 0;
                await this.sendRequest(onDemandNode);
              }
            }
          }
        }
        if (idle) {
          this.idleCycles++;
          if (this.idleCycles > 750) {
            try {
              this.socket.close();
            } catch (_ex) {
            }
            this.socket = null;
            this.toRead = 0;
          }
        } else {
          this.idleCycles = 0;
          this.message = "";
        }
        if (this.client.loggedIn && this.socket != null && (this.highestPriority > 0 || this.client.stores[0] == null)) {
          this.sinceKeepAlive++;
          if (this.sinceKeepAlive > 500) {
            this.sinceKeepAlive = 0;
            this.inputBuffer[0] = 0;
            this.inputBuffer[1] = 0;
            this.inputBuffer[2] = 0;
            this.inputBuffer[3] = 10;
            try {
              this.socket.write$byte_A$int$int(this.inputBuffer, 0, 4);
            } catch (_ex) {
              this.idleCycles = 5e3;
            }
          }
        }
        return this.running;
      } catch (exception) {
        console.error(exception);
      }
      return false;
    }
    async remainingRequest(i) {
      this.immediateRequestsSent = 0;
      this.anInt1343 = 0;
      if (i !== 0) {
        return;
      }
      for (let class50_sub1_sub3 = this.toRequest.first(); class50_sub1_sub3 != null; class50_sub1_sub3 = this.toRequest.next()) {
        if (class50_sub1_sub3.immediate) {
          this.immediateRequestsSent++;
        } else {
          this.anInt1343++;
        }
      }
      while (this.immediateRequestsSent < 10) {
        {
          const class50_sub1_sub3_1 = this.wantedToSend.removeFirst();
          if (class50_sub1_sub3_1 == null) {
            break;
          }
          if (this.filePriorities[class50_sub1_sub3_1.type][class50_sub1_sub3_1.id] !== 0) {
            this.anInt1334++;
          }
          this.filePriorities[class50_sub1_sub3_1.type][class50_sub1_sub3_1.id] = 0;
          this.toRequest.insertBack(class50_sub1_sub3_1);
          this.immediateRequestsSent++;
          await this.sendRequest(class50_sub1_sub3_1);
          this.expectData = true;
        }
      }
    }
    preloadRegions(members) {
      for (let reg = 0; reg < this.regHash.length; reg++) {
        if (members || this.regShouldPreload[reg] !== 0) {
          this.setPriority(2 | 0, 3, this.regLandIndex[reg]);
          this.setPriority(2 | 0, 3, this.regMapIndex[reg]);
        }
      }
    }
    immediateRequestsCount() {
      let i = 0;
      for (let n = this.wanted.first(); n != null; n = this.wanted.next()) {
        i++;
      }
      for (let j = this.wantedToSend.first(); j != null; j = this.wantedToSend.next()) {
        i++;
      }
      return i;
    }
    method334(i, flag) {
      for (let j = 0; j < this.regHash.length; j++) {
        if (this.regLandIndex[j] === i) {
          return true;
        }
      }
      if (flag) {
        this.anInt1363 = -405;
      }
      return false;
    }
    init(archive, client) {
      const versionFiles = ["model_version", "anim_version", "midi_version", "map_version"];
      for (let version = 0; version < 4; version++) {
        {
          const data2 = archive.getFile(versionFiles[version]);
          const versionCount = data2.length / 2 | 0;
          const buffer2 = new Buffer3(data2);
          this.fileVersions[version] = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(versionCount);
          this.filePriorities[version] = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(0);
            }
            return a;
          })(versionCount);
          for (let file = 0; file < versionCount; file++) {
            this.fileVersions[version][file] = buffer2.getUnsignedLEShort();
          }
        }
      }
      const crcFiles = ["model_crc", "anim_crc", "midi_crc", "map_crc"];
      for (let crc = 0; crc < 4; crc++) {
        {
          const data2 = archive.getFile(crcFiles[crc]);
          const crcCount = data2.length / 4 | 0;
          const buffer2 = new Buffer3(data2);
          this.fileCrc[crc] = Array(crcCount).fill(0);
          for (let file = 0; file < crcCount; file++) {
            this.fileCrc[crc][file] = buffer2.getInt();
          }
        }
      }
      let data = archive.getFile("model_index");
      let count = this.fileVersions[0].length;
      this.modelIndex = Array(count).fill(0);
      for (let i = 0; i < count; i++) {
        if (i < data.length) {
          this.modelIndex[i] = data[i];
        } else {
          this.modelIndex[i] = 0;
        }
      }
      data = archive.getFile("map_index");
      let buffer = new Buffer3(data);
      count = data.length / 7 | 0;
      this.regHash = Array(count).fill(0);
      this.regMapIndex = Array(count).fill(0);
      this.regLandIndex = Array(count).fill(0);
      this.regShouldPreload = Array(count).fill(0);
      for (let reg = 0; reg < count; reg++) {
        {
          this.regHash[reg] = buffer.getUnsignedLEShort();
          this.regMapIndex[reg] = buffer.getUnsignedLEShort();
          this.regLandIndex[reg] = buffer.getUnsignedLEShort();
          this.regShouldPreload[reg] = buffer.getUnsignedByte();
        }
      }
      data = archive.getFile("anim_index");
      buffer = new Buffer3(data);
      count = data.length / 2 | 0;
      this.animIndex = Array(count).fill(0);
      for (let i = 0; i < count; i++) {
        this.animIndex[i] = buffer.getUnsignedLEShort();
      }
      data = archive.getFile("midi_index");
      buffer = new Buffer3(data);
      count = data.length;
      this.midiIndex = Array(count).fill(0);
      for (let i = 0; i < count; i++) {
        this.midiIndex[i] = buffer.getUnsignedByte();
      }
      this.client = client;
      this.running = true;
      Game.parallelExecutor.start(this);
    }
    immediateRequestCount() {
      this.immediateRequests.getNodeCount();
    }
    passiveRequest(i, j) {
      if (this.client.stores[0] == null) {
        return;
      }
      if (this.fileVersions[j][i] === 0) {
        return;
      }
      if (this.filePriorities[j][i] === 0) {
        return;
      }
      if (this.highestPriority === 0) {
        return;
      }
      const class50_sub1_sub3 = new OnDemandNode();
      class50_sub1_sub3.type = j;
      class50_sub1_sub3.id = i;
      class50_sub1_sub3.immediate = false;
      {
        this.immediateRequests.insertBack(class50_sub1_sub3);
      }
    }
    localComplete() {
      let onDemandNode = this.wanted.removeFirst();
      while (onDemandNode != null && onDemandNode instanceof OnDemandNode) {
        this.expectData = true;
        let abyte0 = null;
        if (this.client.stores[0] != null) {
          abyte0 = this.client.stores[onDemandNode.type + 1].get(onDemandNode.id);
        }
        if (!this.verify(
          this.fileVersions[onDemandNode.type][onDemandNode.id],
          this.fileCrc[onDemandNode.type][onDemandNode.id],
          abyte0
        )) {
          abyte0 = null;
        }
        if (abyte0 == null) {
          this.wantedToSend.insertBack(onDemandNode);
        } else {
          onDemandNode.buffer = abyte0;
          this.completed.insertBack(onDemandNode);
        }
        onDemandNode = this.wanted.removeFirst();
      }
    }
    stop() {
      this.running = false;
    }
    fileCount(file) {
      return this.fileVersions[file].length;
    }
    async sendRequest(onDemandNode) {
      try {
        if (this.socket == null) {
          const currentTime = new Date().getTime();
          if (currentTime - this.lastSocketOpen < 4e3) {
            return;
          }
          this.lastSocketOpen = currentTime;
          this.socket = await this.client.openSocket(43594 + Game.portOffset);
          this.socket.write$int(15);
          for (let i = 0; i < 8; i++) {
            await this.socket.read();
          }
          this.idleCycles = 0;
        }
        this.inputBuffer[0] = onDemandNode.type | 0;
        this.inputBuffer[1] = onDemandNode.id >> 8 | 0;
        this.inputBuffer[2] = onDemandNode.id | 0;
        if (onDemandNode.immediate) {
          this.inputBuffer[3] = 2;
        } else if (!this.client.loggedIn) {
          this.inputBuffer[3] = 1;
        } else {
          this.inputBuffer[3] = 0;
        }
        this.socket.write$byte_A$int$int(this.inputBuffer, 0, 4);
        this.sinceKeepAlive = 0;
        this.requestFails = -1e4;
        return;
      } catch (ioexception) {
      }
      try {
        this.socket.close();
      } catch (_ex) {
      }
      this.socket = null;
      this.toRead = 0;
      this.requestFails++;
    }
    animCount() {
      return this.animIndex.length;
    }
    regId(i, regX, regY, l) {
      const localRegHash = (regX << 8) + regY;
      for (let reg = 0; reg < this.regHash.length; reg++) {
        if (this.regHash[reg] === localRegHash) {
          if (l === 0) {
            return this.regMapIndex[reg];
          } else {
            return this.regLandIndex[reg];
          }
        }
      }
      return -1;
    }
  };

  // osrs/scene/Region.ts
  init_inject();

  // osrs/cache/def/FloorDefinition.ts
  init_inject();
  var _FloorDefinition = class {
    constructor() {
      this.aBoolean312 = true;
      this.textureId = -1;
      this.aBoolean318 = false;
      this.occlude = true;
      if (this.anInt311 === void 0) {
        this.anInt311 = 0;
      }
      if (this.name === void 0) {
        this.name = null;
      }
      if (this.rgbColor === void 0) {
        this.rgbColor = 0;
      }
      if (this.hue2 === void 0) {
        this.hue2 = 0;
      }
      if (this.saturation === void 0) {
        this.saturation = 0;
      }
      if (this.lightness === void 0) {
        this.lightness = 0;
      }
      if (this.hue === void 0) {
        this.hue = 0;
      }
      if (this.hueDivisor === void 0) {
        this.hueDivisor = 0;
      }
      if (this.hslColor2 === void 0) {
        this.hslColor2 = 0;
      }
    }
    static load(archive) {
      const buffer = new Buffer3(archive.getFile("flo.dat"));
      _FloorDefinition.count = buffer.getUnsignedLEShort();
      if (_FloorDefinition.cache == null) {
        _FloorDefinition.cache = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(_FloorDefinition.count);
      }
      for (let floor = 0; floor < _FloorDefinition.count; floor++) {
        {
          if (_FloorDefinition.cache[floor] == null) {
            _FloorDefinition.cache[floor] = new _FloorDefinition();
          }
          _FloorDefinition.cache[floor].loadDefinition(buffer);
        }
      }
    }
    loadDefinition(buffer) {
      while (true) {
        {
          const attributeId = buffer.getUnsignedByte();
          if (attributeId === 0) {
            return;
          }
          switch (attributeId) {
            case 1:
              this.rgbColor = buffer.get24BitInt();
              this.shiftRGBColors(this.rgbColor);
              break;
            case 2:
              this.textureId = buffer.getUnsignedByte();
              break;
            case 3:
              this.aBoolean318 = true;
              break;
            case 5:
              this.occlude = false;
              break;
            case 6:
              this.name = buffer.getString();
              break;
            case 7:
              const oldHue2 = this.hue2;
              const oldSaturation = this.saturation;
              const oldLightness = this.lightness;
              const oldHue = this.hue;
              this.shiftRGBColors(buffer.get24BitInt());
              this.hue2 = oldHue2;
              this.saturation = oldSaturation;
              this.lightness = oldLightness;
              this.hue = oldHue;
              this.hueDivisor = oldHue;
              break;
            default:
              console.info("Error unrecognised config code: " + attributeId);
              break;
          }
        }
      }
    }
    shiftRGBColors(color) {
      const r2 = (color >> 16 & 255) / 256;
      const b = (color >> 8 & 255) / 256;
      const g = (color & 255) / 256;
      let cmin = r2;
      if (b < cmin) {
        cmin = b;
      }
      if (g < cmin) {
        cmin = g;
      }
      let cmax = r2;
      if (b > cmax) {
        cmax = b;
      }
      if (g > cmax) {
        cmax = g;
      }
      let d5 = 0;
      let d6 = 0;
      const d7 = (cmin + cmax) / 2;
      if (cmin !== cmax) {
        if (d7 < 0.5) {
          d6 = (cmax - cmin) / (cmax + cmin);
        }
        if (d7 >= 0.5) {
          d6 = (cmax - cmin) / (2 - cmax - cmin);
        }
        if (r2 === cmax) {
          d5 = (b - g) / (cmax - cmin);
        } else if (b === cmax) {
          d5 = 2 + (g - r2) / (cmax - cmin);
        } else if (g === cmax) {
          d5 = 4 + (r2 - b) / (cmax - cmin);
        }
      }
      d5 /= 6;
      this.hue2 = d5 * 256 | 0;
      this.saturation = d6 * 256 | 0;
      this.lightness = d7 * 256 | 0;
      if (this.saturation < 0) {
        this.saturation = 0;
      } else if (this.saturation > 255) {
        this.saturation = 255;
      }
      if (this.lightness < 0) {
        this.lightness = 0;
      } else if (this.lightness > 255) {
        this.lightness = 255;
      }
      if (d7 > 0.5) {
        this.hueDivisor = (1 - d7) * d6 * 512 | 0;
      } else {
        this.hueDivisor = d7 * d6 * 512 | 0;
      }
      if (this.hueDivisor < 1) {
        this.hueDivisor = 1;
      }
      this.hue = d5 * this.hueDivisor | 0;
      let huerand = this.hue2 + (Math.random() * 16 | 0) - 8;
      if (huerand < 0) {
        huerand = 0;
      } else if (huerand > 255) {
        huerand = 255;
      }
      let satrand = this.saturation + (Math.random() * 48 | 0) - 24;
      if (satrand < 0) {
        satrand = 0;
      } else if (satrand > 255) {
        satrand = 255;
      }
      let lightrand = this.lightness + (Math.random() * 48 | 0) - 24;
      if (lightrand < 0) {
        lightrand = 0;
      } else if (lightrand > 255) {
        lightrand = 255;
      }
      this.hslColor2 = this.shiftHSLColors(huerand, satrand, lightrand);
    }
    shiftHSLColors(i, j, k) {
      if (k > 179) {
        j = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(j / 2);
      }
      if (k > 192) {
        j = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(j / 2);
      }
      if (k > 217) {
        j = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(j / 2);
      }
      if (k > 243) {
        j = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(j / 2);
      }
      const l = ((i / 4 | 0) << 10) + ((j / 32 | 0) << 7) + (k / 2 | 0);
      return l;
    }
  };
  var FloorDefinition = _FloorDefinition;
  FloorDefinition.aByte310 = 6;
  FloorDefinition.count = 0;
  FloorDefinition.cache = null;

  // osrs/cache/def/GameObjectDefinition.ts
  init_inject();

  // osrs/collection/Cache.ts
  init_inject();
  var Cache = class {
    constructor(size) {
      this.map = /* @__PURE__ */ new Map();
    }
    get(id) {
      return this.map[id];
    }
    put(cacheableNode, id) {
      this.map.set(cacheableNode.id, cacheableNode);
    }
    removeAll() {
      this.map = /* @__PURE__ */ new Map();
    }
  };

  // osrs/cache/cfg/Varbit.ts
  init_inject();

  // osrs/cache/cfg/Varp.ts
  init_inject();
  var _Varp = class {
    constructor() {
      this.aBoolean710 = false;
      this.aBoolean711 = true;
      this.aBoolean713 = false;
      this.aBoolean716 = false;
      this.anInt717 = -1;
      this.aBoolean718 = true;
      if (this.aString707 === void 0) {
        this.aString707 = null;
      }
      if (this.anInt708 === void 0) {
        this.anInt708 = 0;
      }
      if (this.anInt709 === void 0) {
        this.anInt709 = 0;
      }
      if (this.anInt712 === void 0) {
        this.anInt712 = 0;
      }
      if (this.anInt714 === void 0) {
        this.anInt714 = 0;
      }
      if (this.anInt715 === void 0) {
        this.anInt715 = 0;
      }
    }
    static load(archive) {
      const buffer = new Buffer3(archive.getFile("varp.dat"));
      _Varp.currentIndex = 0;
      _Varp.count = buffer.getUnsignedLEShort();
      if (_Varp.cache == null) {
        _Varp.cache = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(_Varp.count);
      }
      if (_Varp.anIntArray706 == null) {
        _Varp.anIntArray706 = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(_Varp.count);
      }
      for (let index = 0; index < _Varp.count; index++) {
        {
          if (_Varp.cache[index] == null) {
            _Varp.cache[index] = new _Varp();
          }
          _Varp.cache[index].loadDefinition(index, buffer);
        }
      }
      if (buffer.currentPosition !== buffer.buffer.length) {
        console.info("varptype load mismatch");
      }
    }
    loadDefinition(index, buffer) {
      while (true) {
        {
          const attribute = buffer.getUnsignedByte();
          if (attribute === 0) {
            return;
          }
          if (attribute === 1) {
            this.anInt708 = buffer.getUnsignedByte();
          } else if (attribute === 2) {
            this.anInt709 = buffer.getUnsignedByte();
          } else if (attribute === 3) {
            this.aBoolean710 = true;
            _Varp.anIntArray706[_Varp.currentIndex++] = index;
          } else if (attribute === 4) {
            this.aBoolean711 = false;
          } else if (attribute === 5) {
            this.anInt712 = buffer.getUnsignedLEShort();
          } else if (attribute === 6) {
            this.aBoolean713 = true;
          } else if (attribute === 7) {
            this.anInt714 = buffer.getInt();
          } else if (attribute === 8) {
            this.anInt715 = 1;
            this.aBoolean716 = true;
          } else if (attribute === 10) {
            this.aString707 = buffer.getString();
          } else if (attribute === 11) {
            this.aBoolean716 = true;
          } else if (attribute === 12) {
            this.anInt717 = buffer.getInt();
          } else if (attribute === 13) {
            this.anInt715 = 2;
            this.aBoolean716 = true;
          } else if (attribute === 14) {
            this.aBoolean718 = false;
          } else {
            console.info("Error unrecognised config code: " + attribute);
          }
        }
      }
    }
  };
  var Varp = _Varp;
  Varp.count = 0;
  Varp.cache = null;
  Varp.currentIndex = 0;
  Varp.anIntArray706 = null;

  // osrs/cache/cfg/Varbit.ts
  var _Varbit = class {
    constructor() {
      this.aBoolean829 = false;
      this.aBoolean832 = true;
      if (this.configId === void 0) {
        this.configId = 0;
      }
      if (this.leastSignificantBit === void 0) {
        this.leastSignificantBit = 0;
      }
      if (this.mostSignificantBit === void 0) {
        this.mostSignificantBit = 0;
      }
    }
    static load(archive) {
      const buffer = new Buffer3(archive.getFile("varbit.dat"));
      _Varbit.count = buffer.getUnsignedLEShort();
      if (_Varbit.cache == null) {
        _Varbit.cache = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(_Varbit.count);
      }
      for (let index = 0; index < _Varbit.count; index++) {
        {
          if (_Varbit.cache[index] == null) {
            _Varbit.cache[index] = new _Varbit();
          }
          _Varbit.cache[index].init(buffer);
          if (_Varbit.cache[index].aBoolean829) {
            Varp.cache[_Varbit.cache[index].configId].aBoolean716 = true;
          }
        }
      }
      if (buffer.currentPosition !== buffer.buffer.length) {
        console.info("varbit load mismatch");
      }
    }
    init(buf) {
      while (true) {
        {
          const attribute = buf.getUnsignedByte();
          if (attribute === 0) {
            return;
          }
          if (attribute === 1) {
            this.configId = buf.getUnsignedLEShort();
            this.leastSignificantBit = buf.getUnsignedByte();
            this.mostSignificantBit = buf.getUnsignedByte();
          } else if (attribute === 10) {
            buf.getString();
          } else if (attribute === 2) {
            this.aBoolean829 = true;
          } else if (attribute === 3) {
            buf.getInt();
          } else if (attribute === 4) {
            buf.getInt();
          } else if (attribute === 5) {
            this.aBoolean832 = false;
          } else {
            console.info("Error unrecognised config code: " + attribute);
          }
        }
      }
    }
  };
  var Varbit = _Varbit;
  Varbit.count = 0;
  Varbit.cache = null;

  // osrs/cache/def/GameObjectDefinition.ts
  var _GameObjectDefinition = class {
    constructor() {
      this.anInt768 = -992;
      this.id = -1;
      this.aBoolean774 = true;
      this.name = "null";
      this.aBoolean786 = true;
      this.aByte793 = -113;
      if (this.actionsBoolean === void 0) {
        this.actionsBoolean = false;
      }
      if (this.modelSizeY === void 0) {
        this.modelSizeY = 0;
      }
      if (this.translateX === void 0) {
        this.translateX = 0;
      }
      if (this.modelIds === void 0) {
        this.modelIds = null;
      }
      if (this.anInt764 === void 0) {
        this.anInt764 = 0;
      }
      if (this.unknown === void 0) {
        this.unknown = false;
      }
      if (this.translateZ === void 0) {
        this.translateZ = 0;
      }
      if (this.adjustToTerrain === void 0) {
        this.adjustToTerrain = false;
      }
      if (this.sizeY === void 0) {
        this.sizeY = 0;
      }
      if (this.varbitId === void 0) {
        this.varbitId = 0;
      }
      if (this.modelSizeX === void 0) {
        this.modelSizeX = 0;
      }
      if (this.configId === void 0) {
        this.configId = 0;
      }
      if (this.description === void 0) {
        this.description = null;
      }
      if (this.modelLightFalloff === void 0) {
        this.modelLightFalloff = 0;
      }
      if (this.translateY === void 0) {
        this.translateY = 0;
      }
      if (this.modelLightAmbient === void 0) {
        this.modelLightAmbient = 0;
      }
      if (this.anInt788 === void 0) {
        this.anInt788 = 0;
      }
      if (this.modelTypes === void 0) {
        this.modelTypes = null;
      }
      if (this.options === void 0) {
        this.options = null;
      }
      if (this.aBoolean791 === void 0) {
        this.aBoolean791 = false;
      }
      if (this.anIntArray792 === void 0) {
        this.anIntArray792 = null;
      }
      if (this.anInt794 === void 0) {
        this.anInt794 = 0;
      }
      if (this.anInt795 === void 0) {
        this.anInt795 = 0;
      }
      if (this.modelSizeZ === void 0) {
        this.modelSizeZ = 0;
      }
      if (this.aBoolean797 === void 0) {
        this.aBoolean797 = false;
      }
      if (this.unknown3 === void 0) {
        this.unknown3 = false;
      }
      if (this.modifiedModelColors === void 0) {
        this.modifiedModelColors = null;
      }
      if (this.sizeX === void 0) {
        this.sizeX = 0;
      }
      if (this.unknown4 === void 0) {
        this.unknown4 = 0;
      }
      if (this.animationId === void 0) {
        this.animationId = 0;
      }
      if (this.nonFlatShading === void 0) {
        this.nonFlatShading = false;
      }
      if (this.childrenIds === void 0) {
        this.childrenIds = null;
      }
      if (this.icon === void 0) {
        this.icon = 0;
      }
      if (this.unknown2 === void 0) {
        this.unknown2 = false;
      }
      if (this.walkable === void 0) {
        this.walkable = false;
      }
      if (this.solid === void 0) {
        this.solid = false;
      }
    }
    static getDefinition(id) {
      for (let index = 0; index < 20; index++) {
        if (_GameObjectDefinition.cache[index].id === id) {
          return _GameObjectDefinition.cache[index];
        }
      }
      _GameObjectDefinition.cacheIndex = (_GameObjectDefinition.cacheIndex + 1) % 20;
      const definition = _GameObjectDefinition.cache[_GameObjectDefinition.cacheIndex];
      _GameObjectDefinition.buffer.currentPosition = _GameObjectDefinition.bufferOffsets[id];
      definition.id = id;
      definition.setDefaultValues();
      definition.load(_GameObjectDefinition.buffer);
      return definition;
    }
    static load(archive) {
      _GameObjectDefinition.buffer = new Buffer3(archive.getFile("loc.dat"));
      const buffer = new Buffer3(archive.getFile("loc.idx"));
      _GameObjectDefinition.definitionCount = buffer.getUnsignedLEShort();
      _GameObjectDefinition.bufferOffsets = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(_GameObjectDefinition.definitionCount);
      let offset = 2;
      for (let index = 0; index < _GameObjectDefinition.definitionCount; index++) {
        {
          _GameObjectDefinition.bufferOffsets[index] = offset;
          offset += buffer.getUnsignedLEShort();
        }
      }
      _GameObjectDefinition.cache = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(20);
      for (let definition = 0; definition < 20; definition++) {
        _GameObjectDefinition.cache[definition] = new _GameObjectDefinition();
      }
    }
    static method433(flag) {
      _GameObjectDefinition.modelCache = null;
      _GameObjectDefinition.animatedModelCache = null;
      _GameObjectDefinition.bufferOffsets = null;
      if (flag) {
        for (let i = 1; i > 0; i++) {
        }
      }
      _GameObjectDefinition.cache = null;
      _GameObjectDefinition.buffer = null;
    }
    getChildDefinition() {
      let child = -1;
      if (this.varbitId !== -1) {
        const varbit = Varbit.cache[this.varbitId];
        const configId = varbit.configId;
        const leastSignificantBit = varbit.leastSignificantBit;
        const mostSignificantBit = varbit.mostSignificantBit;
        const bit = Game.BITFIELD_MAX_VALUE[mostSignificantBit - leastSignificantBit];
        child = _GameObjectDefinition.client.widgetSettings[configId] >> leastSignificantBit & bit;
      } else if (this.configId !== -1) {
        child = _GameObjectDefinition.client.widgetSettings[this.configId];
      }
      if (child < 0 || child >= this.childrenIds.length || this.childrenIds[child] === -1) {
        return null;
      } else {
        return _GameObjectDefinition.getDefinition(this.childrenIds[child]);
      }
    }
    setDefaultValues() {
      this.modelIds = null;
      this.modelTypes = null;
      this.name = "null";
      this.description = null;
      this.modifiedModelColors = null;
      this.anIntArray792 = null;
      this.sizeX = 1;
      this.sizeY = 1;
      this.solid = true;
      this.walkable = true;
      this.actionsBoolean = false;
      this.adjustToTerrain = false;
      this.nonFlatShading = false;
      this.aBoolean797 = false;
      this.animationId = -1;
      this.unknown4 = 16;
      this.modelLightFalloff = 0;
      this.modelLightAmbient = 0;
      this.options = null;
      this.icon = -1;
      this.anInt795 = -1;
      this.unknown3 = false;
      this.unknown2 = true;
      this.modelSizeX = 128;
      this.modelSizeY = 128;
      this.modelSizeZ = 128;
      this.anInt764 = 0;
      this.translateX = 0;
      this.translateY = 0;
      this.translateZ = 0;
      this.unknown = false;
      this.aBoolean791 = false;
      this.anInt794 = -1;
      this.varbitId = -1;
      this.configId = -1;
      this.childrenIds = null;
    }
    passiveRequestModels(onDemandRequester) {
      if (this.modelIds != null) {
        for (let index618 = 0; index618 < this.modelIds.length; index618++) {
          const modelId = this.modelIds[index618];
          {
            onDemandRequester.passiveRequest(modelId & 65535, 0);
          }
        }
      }
    }
    getGameObjectAnimatedModel(type, animationId, face) {
      let subModel = null;
      let hash;
      if (this.modelTypes == null) {
        if (type !== 10) {
          return null;
        }
        hash = (this.id << 6) + face + (((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(animationId + 1) << 32);
        const cachedModel = _GameObjectDefinition.animatedModelCache.get(hash);
        if (cachedModel != null) {
          return cachedModel;
        }
        if (this.modelIds == null) {
          return null;
        }
        const mirror = this.unknown3 !== face > 3;
        const modelCount = this.modelIds.length;
        for (let modelId = 0; modelId < modelCount; modelId++) {
          {
            let subModelId = this.modelIds[modelId];
            if (mirror) {
              subModelId += 65536;
            }
            subModel = _GameObjectDefinition.modelCache.get(subModelId);
            if (subModel == null) {
              subModel = Model.getModel(subModelId & 65535);
              if (subModel == null) {
                return null;
              }
              if (mirror) {
                subModel.mirror(0);
              }
              _GameObjectDefinition.modelCache.put(subModel, subModelId);
            }
            if (modelCount > 1) {
              _GameObjectDefinition.models[modelId] = subModel;
            }
          }
        }
        if (modelCount > 1) {
          subModel = new Model(modelCount, _GameObjectDefinition.models);
        }
      } else {
        let modelType = -1;
        for (let index = 0; index < this.modelTypes.length; index++) {
          {
            if (this.modelTypes[index] !== type) {
              continue;
            }
            modelType = index;
            break;
          }
        }
        if (modelType === -1) {
          return null;
        }
        hash = (this.id << 6) + (modelType << 3) + face + (((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(animationId + 1) << 32);
        const model = _GameObjectDefinition.animatedModelCache.get(hash);
        if (model != null) {
          return model;
        }
        let j2 = this.modelIds[modelType];
        const mirror = this.unknown3 !== face > 3;
        if (mirror) {
          j2 += 65536;
        }
        subModel = _GameObjectDefinition.modelCache.get(j2);
        if (subModel == null) {
          subModel = Model.getModel(j2 & 65535);
          if (subModel == null) {
            return null;
          }
          if (mirror) {
            subModel.mirror(0);
          }
          _GameObjectDefinition.modelCache.put(subModel, j2);
        }
      }
      let scale;
      if (this.modelSizeX !== 128 || this.modelSizeY !== 128 || this.modelSizeZ !== 128) {
        scale = true;
      } else {
        scale = false;
      }
      let needsTranslation;
      if (this.translateX !== 0 || this.translateY !== 0 || this.translateZ !== 0) {
        needsTranslation = true;
      } else {
        needsTranslation = false;
      }
      const animtedModel = new Model(this.modifiedModelColors == null, subModel, Animation.exists(animationId));
      if (animationId !== -1) {
        animtedModel.createBones();
        animtedModel.applyTransform(animationId);
        animtedModel.triangleSkin = null;
        animtedModel.vectorSkin = null;
      }
      while (face-- > 0) {
        animtedModel.rotate90Degrees();
      }
      if (this.modifiedModelColors != null) {
        for (let k2 = 0; k2 < this.modifiedModelColors.length; k2++) {
          animtedModel.replaceColor(this.modifiedModelColors[k2], this.anIntArray792[k2]);
        }
      }
      if (scale) {
        animtedModel.scaleT(this.modelSizeY, this.modelSizeZ, 9, this.modelSizeX);
      }
      if (needsTranslation) {
        animtedModel.translate(this.translateX, this.translateZ, this.translateY);
      }
      animtedModel.applyLighting(64 + this.modelLightFalloff, 768 + this.modelLightAmbient * 5, -50, -10, -50, !this.nonFlatShading);
      if (this.anInt794 === 1) {
        animtedModel.anInt1675 = animtedModel.modelHeight;
      }
      _GameObjectDefinition.animatedModelCache.put(animtedModel, hash);
      return animtedModel;
    }
    isModelCached() {
      if (this.modelIds == null) {
        return true;
      }
      let cached = true;
      for (let index619 = 0; index619 < this.modelIds.length; index619++) {
        const modelId = this.modelIds[index619];
        {
          cached = Model.loaded(modelId & 65535) && cached;
        }
      }
      return cached;
    }
    load(buf) {
      let i = -1;
      label0:
        while (true) {
          {
            let attribute;
            do {
              {
                attribute = buf.getUnsignedByte();
                if (attribute === 0) {
                  break label0;
                }
                switch (attribute) {
                  case 1:
                    const k = buf.getUnsignedByte();
                    if (k > 0) {
                      if (this.modelIds == null || _GameObjectDefinition.lowMemory) {
                        this.modelTypes = ((s) => {
                          const a = [];
                          while (s-- > 0) {
                            a.push(0);
                          }
                          return a;
                        })(k);
                        this.modelIds = ((s) => {
                          const a = [];
                          while (s-- > 0) {
                            a.push(0);
                          }
                          return a;
                        })(k);
                        for (let k1 = 0; k1 < k; k1++) {
                          {
                            this.modelIds[k1] = buf.getUnsignedLEShort();
                            this.modelTypes[k1] = buf.getUnsignedByte();
                          }
                        }
                      } else {
                        buf.currentPosition += k * 3;
                      }
                    }
                    break;
                  case 2:
                    this.name = buf.getString();
                    break;
                  case 3:
                    this.description = buf.getStringBytes();
                    break;
                  case 5:
                    const l = buf.getUnsignedByte();
                    if (l > 0) {
                      if (this.modelIds == null || _GameObjectDefinition.lowMemory) {
                        this.modelTypes = null;
                        this.modelIds = ((s) => {
                          const a = [];
                          while (s-- > 0) {
                            a.push(0);
                          }
                          return a;
                        })(l);
                        for (let l1 = 0; l1 < l; l1++) {
                          this.modelIds[l1] = buf.getUnsignedLEShort();
                        }
                      } else {
                        buf.currentPosition += l * 2;
                      }
                    }
                    break;
                  case 14:
                    this.sizeX = buf.getUnsignedByte();
                    break;
                  case 15:
                    this.sizeY = buf.getUnsignedByte();
                    break;
                  case 17:
                    this.solid = false;
                    break;
                  case 18:
                    this.walkable = false;
                    break;
                  case 19:
                    i = buf.getUnsignedByte();
                    if (i === 1) {
                      this.actionsBoolean = true;
                    }
                    break;
                  case 21:
                    this.adjustToTerrain = true;
                    break;
                  case 22:
                    this.nonFlatShading = true;
                    break;
                  case 23:
                    this.aBoolean797 = true;
                    break;
                  case 24:
                    this.animationId = buf.getUnsignedLEShort();
                    if (this.animationId === 65535) {
                      this.animationId = -1;
                    }
                    break;
                  case 28:
                    this.unknown4 = buf.getUnsignedByte();
                    break;
                  case 29:
                    this.modelLightFalloff = buf.getSignedByte();
                    break;
                  case 39:
                    this.modelLightAmbient = buf.getSignedByte();
                    break;
                }
                if (attribute < 30 || attribute >= 39) {
                  switch (attribute) {
                    case 40:
                      const i1 = buf.getUnsignedByte();
                      this.modifiedModelColors = ((s) => {
                        const a = [];
                        while (s-- > 0) {
                          a.push(0);
                        }
                        return a;
                      })(i1);
                      this.anIntArray792 = ((s) => {
                        const a = [];
                        while (s-- > 0) {
                          a.push(0);
                        }
                        return a;
                      })(i1);
                      for (let i2 = 0; i2 < i1; i2++) {
                        {
                          this.modifiedModelColors[i2] = buf.getUnsignedLEShort();
                          this.anIntArray792[i2] = buf.getUnsignedLEShort();
                        }
                      }
                      break;
                    case 60:
                      this.icon = buf.getUnsignedLEShort();
                      break;
                    case 62:
                      this.unknown3 = true;
                      break;
                    case 64:
                      this.unknown2 = false;
                      break;
                    case 65:
                      this.modelSizeX = buf.getUnsignedLEShort();
                      break;
                    case 66:
                      this.modelSizeY = buf.getUnsignedLEShort();
                      break;
                    case 67:
                      this.modelSizeZ = buf.getUnsignedLEShort();
                      break;
                    case 68:
                      this.anInt795 = buf.getUnsignedLEShort();
                      break;
                    case 69:
                      this.anInt764 = buf.getUnsignedByte();
                      break;
                    case 70:
                      this.translateX = buf.getSignedShort();
                      break;
                    case 71:
                      this.translateY = buf.getSignedShort();
                      break;
                    case 72:
                      this.translateZ = buf.getSignedShort();
                      break;
                    case 73:
                      this.unknown = true;
                      break;
                    case 74:
                      this.aBoolean791 = true;
                      break;
                    default:
                      if (attribute !== 75) {
                        continue;
                      }
                      this.anInt794 = buf.getUnsignedByte();
                      break;
                  }
                } else {
                  if (this.options == null) {
                    this.options = [null, null, null, null, null];
                  }
                  this.options[attribute - 30] = buf.getString();
                  if (((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(this.options[attribute - 30], "hidden")) {
                    this.options[attribute - 30] = null;
                  }
                }
                continue label0;
              }
            } while (attribute !== 77);
            this.varbitId = buf.getUnsignedLEShort();
            if (this.varbitId === 65535) {
              this.varbitId = -1;
            }
            this.configId = buf.getUnsignedLEShort();
            if (this.configId === 65535) {
              this.configId = -1;
            }
            const j1 = buf.getUnsignedByte();
            this.childrenIds = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(j1 + 1);
            for (let j2 = 0; j2 <= j1; j2++) {
              {
                this.childrenIds[j2] = buf.getUnsignedLEShort();
                if (this.childrenIds[j2] === 65535) {
                  this.childrenIds[j2] = -1;
                }
              }
            }
          }
        }
      if (i === -1) {
        this.actionsBoolean = false;
        if (this.modelIds != null && (this.modelTypes == null || this.modelTypes[0] === 10)) {
          this.actionsBoolean = true;
        }
        if (this.options != null) {
          this.actionsBoolean = true;
        }
      }
      if (this.aBoolean791) {
        this.solid = false;
        this.walkable = false;
      }
      if (this.anInt794 === -1) {
        this.anInt794 = this.solid ? 1 : 0;
      }
    }
    getGameObjectModel(type, face, vertexHeight, vertexHeightRight, vertexHeightTopRight, vertexHeightTop, animationId) {
      let model = this.getGameObjectAnimatedModel(type, animationId, face);
      if (model == null) {
        return null;
      }
      if (this.adjustToTerrain || this.nonFlatShading) {
        model = new Model(this.adjustToTerrain, this.nonFlatShading, 0, model);
      }
      if (this.adjustToTerrain) {
        const l1 = (vertexHeight + vertexHeightRight + vertexHeightTopRight + vertexHeightTop) / 4 | 0;
        for (let i2 = 0; i2 < model.vertexCount; i2++) {
          {
            const j2 = model.verticesX[i2];
            const k2 = model.verticesZ[i2];
            const l2 = vertexHeight + ((vertexHeightRight - vertexHeight) * (j2 + 64) / 128 | 0);
            const i3 = vertexHeightTop + ((vertexHeightTopRight - vertexHeightTop) * (j2 + 64) / 128 | 0);
            const j3 = l2 + ((i3 - l2) * (k2 + 64) / 128 | 0);
            model.verticesY[i2] += j3 - l1;
          }
        }
        model.normalise();
      }
      return model;
    }
    method432(i, j) {
      if (i !== 26261) {
        this.aBoolean786 = !this.aBoolean786;
      }
      if (this.modelTypes == null) {
        if (this.modelIds == null) {
          return true;
        }
        if (j !== 10) {
          return true;
        }
        let flag = true;
        for (let l = 0; l < this.modelIds.length; l++) {
          flag = Model.loaded(this.modelIds[l] & 65535) && flag;
        }
        return flag;
      }
      for (let k = 0; k < this.modelTypes.length; k++) {
        if (this.modelTypes[k] === j) {
          return Model.loaded(this.modelIds[k] & 65535);
        }
      }
      return true;
    }
  };
  var GameObjectDefinition = _GameObjectDefinition;
  GameObjectDefinition.bufferOffsets = null;
  GameObjectDefinition.animatedModelCache = new Cache(40);
  GameObjectDefinition.buffer = null;
  GameObjectDefinition.client = null;
  GameObjectDefinition.models = [null, null, null, null];
  GameObjectDefinition.lowMemory = false;
  GameObjectDefinition.cacheIndex = 0;
  GameObjectDefinition.modelCache = new Cache(500);
  GameObjectDefinition.cache = null;
  GameObjectDefinition.definitionCount = 0;

  // osrs/media/renderable/GameObject.ts
  init_inject();

  // osrs/cache/media/AnimationSequence.ts
  init_inject();
  var _AnimationSequence = class {
    constructor() {
      this.frameStep = -1;
      this.aBoolean300 = false;
      this.anInt301 = 5;
      this.getPlayerShieldDelta = -1;
      this.getPlayerWeaponDelta = -1;
      this.anInt304 = 99;
      this.anInt305 = -1;
      this.priority = -1;
      this.anInt307 = 2;
      if (this.frameCount === void 0) {
        this.frameCount = 0;
      }
      if (this.getPrimaryFrame === void 0) {
        this.getPrimaryFrame = null;
      }
      if (this.frame1Ids === void 0) {
        this.frame1Ids = null;
      }
      if (this.frameLenghts === void 0) {
        this.frameLenghts = null;
      }
      if (this.flowControl === void 0) {
        this.flowControl = null;
      }
    }
    static load(archive) {
      const buffer = new Buffer3(archive.getFile("seq.dat"));
      _AnimationSequence.count = buffer.getUnsignedLEShort();
      if (_AnimationSequence.animations == null) {
        _AnimationSequence.animations = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(_AnimationSequence.count);
      }
      for (let animation = 0; animation < _AnimationSequence.count; animation++) {
        {
          if (_AnimationSequence.animations[animation] == null) {
            _AnimationSequence.animations[animation] = new _AnimationSequence();
          }
          _AnimationSequence.animations[animation].loadDefinition(buffer);
        }
      }
    }
    getFrameLength(animationId) {
      let frameLength = this.frameLenghts[animationId];
      if (frameLength === 0) {
        const animation = Animation.getAnimation(this.getPrimaryFrame[animationId]);
        if (animation != null) {
          frameLength = this.frameLenghts[animationId] = animation.anInt431;
        }
      }
      if (frameLength === 0) {
        frameLength = 1;
      }
      return frameLength;
    }
    loadDefinition(buf) {
      while (true) {
        {
          const attributeId = buf.getUnsignedByte();
          if (attributeId === 0) {
            break;
          }
          switch (attributeId) {
            case 1:
              this.frameCount = buf.getUnsignedByte();
              this.getPrimaryFrame = ((s) => {
                const a = [];
                while (s-- > 0) {
                  a.push(0);
                }
                return a;
              })(this.frameCount);
              this.frame1Ids = ((s) => {
                const a = [];
                while (s-- > 0) {
                  a.push(0);
                }
                return a;
              })(this.frameCount);
              this.frameLenghts = ((s) => {
                const a = [];
                while (s-- > 0) {
                  a.push(0);
                }
                return a;
              })(this.frameCount);
              for (let frame = 0; frame < this.frameCount; frame++) {
                {
                  this.getPrimaryFrame[frame] = buf.getUnsignedLEShort();
                  this.frame1Ids[frame] = buf.getUnsignedLEShort();
                  if (this.frame1Ids[frame] === 65535) {
                    this.frame1Ids[frame] = -1;
                  }
                  this.frameLenghts[frame] = buf.getUnsignedLEShort();
                }
              }
              break;
            case 2:
              this.frameStep = buf.getUnsignedLEShort();
              break;
            case 3:
              const flowCount = buf.getUnsignedByte();
              this.flowControl = ((s) => {
                const a = [];
                while (s-- > 0) {
                  a.push(0);
                }
                return a;
              })(flowCount + 1);
              for (let flow = 0; flow < flowCount; flow++) {
                this.flowControl[flow] = buf.getUnsignedByte();
              }
              this.flowControl[flowCount] = 9999999;
              break;
            case 4:
              this.aBoolean300 = true;
              break;
            case 5:
              this.anInt301 = buf.getUnsignedByte();
              break;
            case 6:
              this.getPlayerShieldDelta = buf.getUnsignedLEShort();
              break;
            case 7:
              this.getPlayerWeaponDelta = buf.getUnsignedLEShort();
              break;
            case 8:
              this.anInt304 = buf.getUnsignedByte();
              break;
            case 9:
              this.anInt305 = buf.getUnsignedByte();
              break;
            case 10:
              this.priority = buf.getUnsignedByte();
              break;
            case 11:
              this.anInt307 = buf.getUnsignedByte();
              break;
            case 12:
              buf.getInt();
              break;
            default:
              console.info("Error unrecognised seq config code: " + attributeId);
              break;
          }
        }
      }
      if (this.frameCount === 0) {
        this.frameCount = 1;
        this.getPrimaryFrame = [0];
        this.getPrimaryFrame[0] = -1;
        this.frame1Ids = [0];
        this.frame1Ids[0] = -1;
        this.frameLenghts = [0];
        this.frameLenghts[0] = -1;
      }
      if (this.anInt305 === -1) {
        if (this.flowControl != null) {
          this.anInt305 = 2;
        } else {
          this.anInt305 = 0;
        }
      }
      if (this.priority === -1) {
        if (this.flowControl != null) {
          this.priority = 2;
          return;
        }
        this.priority = 0;
      }
    }
  };
  var AnimationSequence = _AnimationSequence;
  AnimationSequence.count = 0;
  AnimationSequence.animations = null;

  // osrs/media/renderable/GameObject.ts
  var _GameObject = class extends Renderable {
    constructor(id, face, clickType, vertexHeightRight, vertexHeightTopRight, vertexHeight, vertexHeightTop, animationId, flag) {
      super();
      if (this.vertexHeight === void 0) {
        this.vertexHeight = 0;
      }
      if (this.vertexHeightRight === void 0) {
        this.vertexHeightRight = 0;
      }
      if (this.vertexHeightTopRight === void 0) {
        this.vertexHeightTopRight = 0;
      }
      if (this.vertexHeightTop === void 0) {
        this.vertexHeightTop = 0;
      }
      if (this.id === void 0) {
        this.id = 0;
      }
      if (this.clickType === void 0) {
        this.clickType = 0;
      }
      if (this.face === void 0) {
        this.face = 0;
      }
      if (this.animationSequence === void 0) {
        this.animationSequence = null;
      }
      if (this.varbitId === void 0) {
        this.varbitId = 0;
      }
      if (this.configId === void 0) {
        this.configId = 0;
      }
      if (this.childrenIds === void 0) {
        this.childrenIds = null;
      }
      if (this.animationCycleDelay === void 0) {
        this.animationCycleDelay = 0;
      }
      if (this.animationFrame === void 0) {
        this.animationFrame = 0;
      }
      this.id = id;
      this.clickType = clickType;
      this.face = face;
      this.vertexHeight = vertexHeight;
      this.vertexHeightRight = vertexHeightRight;
      this.vertexHeightTopRight = vertexHeightTopRight;
      this.vertexHeightTop = vertexHeightTop;
      if (animationId !== -1) {
        this.animationSequence = AnimationSequence.animations[animationId];
        this.animationFrame = 0;
        this.animationCycleDelay = Game.pulseCycle - 1;
        if (flag && this.animationSequence.frameStep !== -1) {
          this.animationFrame = Math.random() * this.animationSequence.frameCount | 0;
          this.animationCycleDelay -= Math.random() * this.animationSequence.getFrameLength(this.animationFrame) | 0;
        }
      }
      const gameObjectDefinition = GameObjectDefinition.getDefinition(this.id);
      this.varbitId = gameObjectDefinition.varbitId;
      this.configId = gameObjectDefinition.configId;
      this.childrenIds = gameObjectDefinition.childrenIds;
    }
    getChildDefinition() {
      let child = -1;
      if (this.varbitId !== -1) {
        const varbit = Varbit.cache[this.varbitId];
        const configId = varbit.configId;
        const leastSignificantBit = varbit.leastSignificantBit;
        const mostSignificantBit = varbit.mostSignificantBit;
        const bit = Game.BITFIELD_MAX_VALUE[mostSignificantBit - leastSignificantBit];
        child = _GameObject.client.widgetSettings[configId] >> leastSignificantBit & bit;
      } else if (this.configId !== -1) {
        child = _GameObject.client.widgetSettings[this.configId];
      }
      if (child < 0 || child >= this.childrenIds.length || this.childrenIds[child] === -1) {
        return null;
      } else {
        return GameObjectDefinition.getDefinition(this.childrenIds[child]);
      }
    }
    getRotatedModel() {
      let animation = -1;
      if (this.animationSequence != null) {
        let step = Game.pulseCycle - this.animationCycleDelay;
        if (step > 100 && this.animationSequence.frameStep > 0) {
          step = 100;
        }
        while (step > this.animationSequence.getFrameLength(this.animationFrame)) {
          {
            step -= this.animationSequence.getFrameLength(this.animationFrame);
            this.animationFrame++;
            if (this.animationFrame < this.animationSequence.frameCount) {
              continue;
            }
            this.animationFrame -= this.animationSequence.frameStep;
            if (this.animationFrame >= 0 && this.animationFrame < this.animationSequence.frameCount) {
              continue;
            }
            this.animationSequence = null;
            break;
          }
        }
        this.animationCycleDelay = Game.pulseCycle - step;
        if (this.animationSequence != null) {
          animation = this.animationSequence.getPrimaryFrame[this.animationFrame];
        }
      }
      let gameObjectDefinition;
      if (this.childrenIds != null) {
        gameObjectDefinition = this.getChildDefinition();
      } else {
        gameObjectDefinition = GameObjectDefinition.getDefinition(this.id);
      }
      if (gameObjectDefinition == null) {
        return null;
      } else {
        const model = gameObjectDefinition.getGameObjectModel(
          this.clickType,
          this.face,
          this.vertexHeight,
          this.vertexHeightRight,
          this.vertexHeightTopRight,
          this.vertexHeightTop,
          animation
        );
        return model;
      }
    }
  };
  var GameObject = _GameObject;
  GameObject.client = null;

  // osrs/scene/util/TiledUtils.ts
  init_inject();
  var TiledUtils = class {
    static getRotatedMapChunkX(x2, y, rotation) {
      rotation &= 3;
      if (rotation === 0) {
        return x2;
      }
      if (rotation === 1) {
        return y;
      }
      if (rotation === 2) {
        return 7 - x2;
      } else {
        return 7 - y;
      }
    }
    static getRotatedMapChunkY(x2, y, rotation) {
      rotation &= 3;
      if (rotation === 0) {
        return y;
      }
      if (rotation === 1) {
        return 7 - x2;
      }
      if (rotation === 2) {
        return 7 - y;
      } else {
        return x2;
      }
    }
    static getRotatedLandscapeChunkX(rotation, objectSizeY, x2, y, objectSizeX) {
      rotation &= 3;
      if (rotation === 0) {
        return x2;
      }
      if (rotation === 1) {
        return y;
      }
      if (rotation === 2) {
        return 7 - x2 - (objectSizeX - 1);
      } else {
        return 7 - y - (objectSizeY - 1);
      }
    }
    static getRotatedLandscapeChunkY(y, objectSizeY, rotation, objectSizeX, x2) {
      rotation &= 3;
      if (rotation === 0) {
        return y;
      }
      if (rotation === 1) {
        return 7 - x2 - (objectSizeX - 1);
      }
      if (rotation === 2) {
        return 7 - y - (objectSizeY - 1);
      } else {
        return x2;
      }
    }
  };

  // osrs/scene/Region.ts
  var _Region = class {
    constructor(renderRuleFlags, regionSizeY, regionSizeX, vertexHeights) {
      this.aByte139 = 0;
      this.aBoolean140 = true;
      this.aByte156 = 0;
      this.aBoolean157 = true;
      this.anInt160 = 20411;
      this.anInt166 = 69;
      if (this.renderRuleFlags === void 0) {
        this.renderRuleFlags = null;
      }
      if (this.overlayRotations === void 0) {
        this.overlayRotations = null;
      }
      if (this.blendedHue === void 0) {
        this.blendedHue = null;
      }
      if (this.blendedSaturation === void 0) {
        this.blendedSaturation = null;
      }
      if (this.blendedLightness === void 0) {
        this.blendedLightness = null;
      }
      if (this.blendedHueDivisor === void 0) {
        this.blendedHueDivisor = null;
      }
      if (this.blendDirectionTracker === void 0) {
        this.blendDirectionTracker = null;
      }
      if (this.vertexHeights === void 0) {
        this.vertexHeights = null;
      }
      if (this.regionSizeX === void 0) {
        this.regionSizeX = 0;
      }
      if (this.regionSizeY === void 0) {
        this.regionSizeY = 0;
      }
      if (this.overlayClippingPaths === void 0) {
        this.overlayClippingPaths = null;
      }
      if (this.overlayFloorIds === void 0) {
        this.overlayFloorIds = null;
      }
      if (this.underlayFloorIds === void 0) {
        this.underlayFloorIds = null;
      }
      if (this.tileShadowIntensity === void 0) {
        this.tileShadowIntensity = null;
      }
      if (this.tileLightingIntensity === void 0) {
        this.tileLightingIntensity = null;
      }
      if (this.tileCullingBitsets === void 0) {
        this.tileCullingBitsets = null;
      }
      _Region.lowestPlane = 99;
      this.regionSizeX = regionSizeX;
      this.regionSizeY = regionSizeY;
      this.vertexHeights = vertexHeights;
      this.renderRuleFlags = renderRuleFlags;
      this.underlayFloorIds = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([4, this.regionSizeX, this.regionSizeY]);
      this.overlayFloorIds = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([4, this.regionSizeX, this.regionSizeY]);
      this.overlayClippingPaths = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([4, this.regionSizeX, this.regionSizeY]);
      this.overlayRotations = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([4, this.regionSizeX, this.regionSizeY]);
      this.tileCullingBitsets = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([4, this.regionSizeX + 1, this.regionSizeY + 1]);
      this.tileShadowIntensity = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([4, this.regionSizeX + 1, this.regionSizeY + 1]);
      this.tileLightingIntensity = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([this.regionSizeX + 1, this.regionSizeY + 1]);
      this.blendedHue = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.regionSizeY);
      this.blendedSaturation = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.regionSizeY);
      this.blendedLightness = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.regionSizeY);
      this.blendedHueDivisor = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.regionSizeY);
      this.blendDirectionTracker = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.regionSizeY);
    }
    static calculateNoise(x2, seed) {
      return noise(x2, seed);
    }
    static method163(i, i_0_, i_1_) {
      const i_2_ = i / i_1_ | 0;
      const i_3_ = i & i_1_ - 1;
      const i_4_ = i_0_ / i_1_ | 0;
      const i_5_ = i_0_ & i_1_ - 1;
      const i_6_ = _Region.method178(i_2_, i_4_);
      const i_7_ = _Region.method178(i_2_ + 1, i_4_);
      const i_8_ = _Region.method178(i_2_, i_4_ + 1);
      const i_9_ = _Region.method178(i_2_ + 1, i_4_ + 1);
      const i_10_ = _Region.method176(i_6_, i_7_, i_3_, i_1_);
      const i_11_ = _Region.method176(i_8_, i_9_, i_3_, i_1_);
      return _Region.method176(i_10_, i_11_, i_5_, i_1_);
    }
    static method165(i, i_15_, i_16_, i_17_, class46, i_18_, i_19_, i_20_, i_21_, class22, is) {
      let i_22_ = is[i_15_][i_19_][i_17_];
      let i_23_ = is[i_15_][i_19_ + 1][i_17_];
      let i_24_ = is[i_15_][i_19_ + 1][i_17_ + 1];
      let i_25_ = is[i_15_][i_19_][i_17_ + 1];
      const i_26_ = i_22_ + i_23_ + i_24_ + i_25_ >> 2;
      const class47 = GameObjectDefinition.getDefinition(i);
      if (i_20_ === 0) {
        let i_27_ = i_19_ + (i_17_ << 7) + (i << 14) + 1073741824;
        if (!class47.actionsBoolean) {
          i_27_ += -2147483648;
        }
        const i_28_ = (i_18_ << 6) + i_16_ | 0;
        if (i_16_ === 22) {
          let class50_sub1_sub4;
          if (class47.animationId === -1 && class47.childrenIds == null) {
            class50_sub1_sub4 = class47.getGameObjectModel(22, i_18_, i_22_, i_23_, i_24_, i_25_, -1);
          } else {
            class50_sub1_sub4 = new GameObject(i, i_18_, 22, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
          }
          class22.addGroundDecoration(i_19_, i_17_, 669, i_28_, i_27_, i_26_, i_21_, class50_sub1_sub4);
          if (class47.solid && class47.actionsBoolean) {
            class46.markBlocked(i_19_, i_17_);
          }
        } else if (i_16_ === 10 || i_16_ === 11) {
          let class50_sub1_sub4;
          if (class47.animationId === -1 && class47.childrenIds == null) {
            class50_sub1_sub4 = class47.getGameObjectModel(10, i_18_, i_22_, i_23_, i_24_, i_25_, -1);
          } else {
            class50_sub1_sub4 = new GameObject(i, i_18_, 10, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
          }
          if (class50_sub1_sub4 != null) {
            let i_29_ = 0;
            if (i_16_ === 11) {
              i_29_ += 256;
            }
            let i_30_;
            let i_31_;
            if (i_18_ === 1 || i_18_ === 3) {
              i_30_ = class47.sizeY;
              i_31_ = class47.sizeX;
            } else {
              i_30_ = class47.sizeX;
              i_31_ = class47.sizeY;
            }
            class22.method251(i_21_, i_30_, i_17_, class50_sub1_sub4, i_28_, i_29_, i_19_, -896, i_31_, i_26_, i_27_);
          }
          if (class47.solid) {
            class46.method413(i_17_, i_18_, class47.sizeY, class47.sizeX, class47.walkable, i_19_, 52 | 0);
          }
        } else if (i_16_ >= 12) {
          let class50_sub1_sub4;
          if (class47.animationId === -1 && class47.childrenIds == null) {
            class50_sub1_sub4 = class47.getGameObjectModel(i_16_, i_18_, i_22_, i_23_, i_24_, i_25_, -1);
          } else {
            class50_sub1_sub4 = new GameObject(i, i_18_, i_16_, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
          }
          class22.method251(i_21_, 1, i_17_, class50_sub1_sub4, i_28_, 0, i_19_, -896, 1, i_26_, i_27_);
          if (class47.solid) {
            class46.method413(i_17_, i_18_, class47.sizeY, class47.sizeX, class47.walkable, i_19_, 52 | 0);
          }
        } else if (i_16_ === 0) {
          let class50_sub1_sub4;
          if (class47.animationId === -1 && class47.childrenIds == null) {
            class50_sub1_sub4 = class47.getGameObjectModel(0, i_18_, i_22_, i_23_, i_24_, i_25_, -1);
          } else {
            class50_sub1_sub4 = new GameObject(i, i_18_, 0, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
          }
          class22.method249(_Region.anIntArray158[i_18_], class50_sub1_sub4, i_27_, i_17_, i_28_, i_19_, null, i_26_, 0, i_21_);
          if (class47.solid) {
            class46.markWall(i_19_, i_17_, i_16_, i_18_, class47.walkable);
          }
        } else if (i_16_ === 1) {
          let class50_sub1_sub4;
          if (class47.animationId === -1 && class47.childrenIds == null) {
            class50_sub1_sub4 = class47.getGameObjectModel(1, i_18_, i_22_, i_23_, i_24_, i_25_, -1);
          } else {
            class50_sub1_sub4 = new GameObject(i, i_18_, 1, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
          }
          class22.method249(_Region.anIntArray167[i_18_], class50_sub1_sub4, i_27_, i_17_, i_28_, i_19_, null, i_26_, 0, i_21_);
          if (class47.solid) {
            class46.markWall(i_19_, i_17_, i_16_, i_18_, class47.walkable);
          }
        } else if (i_16_ === 2) {
          const i_32_ = i_18_ + 1 & 3;
          let class50_sub1_sub4;
          let class50_sub1_sub4_33_;
          if (class47.animationId === -1 && class47.childrenIds == null) {
            class50_sub1_sub4 = class47.getGameObjectModel(2, 4 + i_18_, i_22_, i_23_, i_24_, i_25_, -1);
            class50_sub1_sub4_33_ = class47.getGameObjectModel(2, i_32_, i_22_, i_23_, i_24_, i_25_, -1);
          } else {
            class50_sub1_sub4 = new GameObject(i, 4 + i_18_, 2, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
            class50_sub1_sub4_33_ = new GameObject(i, i_32_, 2, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
          }
          class22.method249(
            _Region.anIntArray158[i_18_],
            class50_sub1_sub4,
            i_27_,
            i_17_,
            i_28_,
            i_19_,
            class50_sub1_sub4_33_,
            i_26_,
            _Region.anIntArray158[i_32_],
            i_21_
          );
          if (class47.solid) {
            class46.markWall(i_19_, i_17_, i_16_, i_18_, class47.walkable);
          }
        } else if (i_16_ === 3) {
          let class50_sub1_sub4;
          if (class47.animationId === -1 && class47.childrenIds == null) {
            class50_sub1_sub4 = class47.getGameObjectModel(3, i_18_, i_22_, i_23_, i_24_, i_25_, -1);
          } else {
            class50_sub1_sub4 = new GameObject(i, i_18_, 3, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
          }
          class22.method249(_Region.anIntArray167[i_18_], class50_sub1_sub4, i_27_, i_17_, i_28_, i_19_, null, i_26_, 0, i_21_);
          if (class47.solid) {
            class46.markWall(i_19_, i_17_, i_16_, i_18_, class47.walkable);
          }
        } else if (i_16_ === 9) {
          let class50_sub1_sub4;
          if (class47.animationId === -1 && class47.childrenIds == null) {
            class50_sub1_sub4 = class47.getGameObjectModel(i_16_, i_18_, i_22_, i_23_, i_24_, i_25_, -1);
          } else {
            class50_sub1_sub4 = new GameObject(i, i_18_, i_16_, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
          }
          class22.method251(i_21_, 1, i_17_, class50_sub1_sub4, i_28_, 0, i_19_, -896, 1, i_26_, i_27_);
          if (class47.solid) {
            class46.method413(i_17_, i_18_, class47.sizeY, class47.sizeX, class47.walkable, i_19_, 52 | 0);
          }
        } else {
          if (class47.adjustToTerrain) {
            if (i_18_ === 1) {
              const i_34_ = i_25_;
              i_25_ = i_24_;
              i_24_ = i_23_;
              i_23_ = i_22_;
              i_22_ = i_34_;
            } else if (i_18_ === 2) {
              let i_35_ = i_25_;
              i_25_ = i_23_;
              i_23_ = i_35_;
              i_35_ = i_24_;
              i_24_ = i_22_;
              i_22_ = i_35_;
            } else if (i_18_ === 3) {
              const i_36_ = i_25_;
              i_25_ = i_22_;
              i_22_ = i_23_;
              i_23_ = i_24_;
              i_24_ = i_36_;
            }
          }
          if (i_16_ === 4) {
            let class50_sub1_sub4;
            if (class47.animationId === -1 && class47.childrenIds == null) {
              class50_sub1_sub4 = class47.getGameObjectModel(4, 0, i_22_, i_23_, i_24_, i_25_, -1);
            } else {
              class50_sub1_sub4 = new GameObject(i, 0, 4, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
            }
            class22.addWallDecoration(
              i_21_,
              _Region.anIntArray158[i_18_],
              i_18_ * 512,
              i_27_,
              i_28_,
              i_19_,
              0,
              i_17_,
              0,
              i_26_,
              class50_sub1_sub4,
              -930
            );
          } else if (i_16_ === 5) {
            let i_37_ = 16;
            const i_38_ = class22.method267(i_21_, i_19_, i_17_);
            if (i_38_ > 0) {
              i_37_ = GameObjectDefinition.getDefinition(i_38_ >> 14 & 32767).unknown4;
            }
            let class50_sub1_sub4;
            if (class47.animationId === -1 && class47.childrenIds == null) {
              class50_sub1_sub4 = class47.getGameObjectModel(4, 0, i_22_, i_23_, i_24_, i_25_, -1);
            } else {
              class50_sub1_sub4 = new GameObject(i, 0, 4, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
            }
            class22.addWallDecoration(
              i_21_,
              _Region.anIntArray158[i_18_],
              i_18_ * 512,
              i_27_,
              i_28_,
              i_19_,
              _Region.anIntArray143[i_18_] * i_37_,
              i_17_,
              _Region.anIntArray161[i_18_] * i_37_,
              i_26_,
              class50_sub1_sub4,
              -930
            );
          } else if (i_16_ === 6) {
            let class50_sub1_sub4;
            if (class47.animationId === -1 && class47.childrenIds == null) {
              class50_sub1_sub4 = class47.getGameObjectModel(4, 0, i_22_, i_23_, i_24_, i_25_, -1);
            } else {
              class50_sub1_sub4 = new GameObject(i, 0, 4, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
            }
            class22.addWallDecoration(i_21_, 256, i_18_, i_27_, i_28_, i_19_, 0, i_17_, 0, i_26_, class50_sub1_sub4, -930);
          } else if (i_16_ === 7) {
            let class50_sub1_sub4;
            if (class47.animationId === -1 && class47.childrenIds == null) {
              class50_sub1_sub4 = class47.getGameObjectModel(4, 0, i_22_, i_23_, i_24_, i_25_, -1);
            } else {
              class50_sub1_sub4 = new GameObject(i, 0, 4, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
            }
            class22.addWallDecoration(i_21_, 512, i_18_, i_27_, i_28_, i_19_, 0, i_17_, 0, i_26_, class50_sub1_sub4, -930);
          } else if (i_16_ === 8) {
            let class50_sub1_sub4;
            if (class47.animationId === -1 && class47.childrenIds == null) {
              class50_sub1_sub4 = class47.getGameObjectModel(4, 0, i_22_, i_23_, i_24_, i_25_, -1);
            } else {
              class50_sub1_sub4 = new GameObject(i, 0, 4, i_23_, i_24_, i_22_, i_25_, class47.animationId, true);
            }
            class22.addWallDecoration(i_21_, 768, i_18_, i_27_, i_28_, i_19_, 0, i_17_, 0, i_26_, class50_sub1_sub4, -930);
          }
        }
      }
    }
    static passiveRequestGameObjectModels(onDemandRequester, buffer) {
      let gameObjectId = -1;
      while (true) {
        {
          const gameObjectIdOffset = buffer.getSmart();
          if (gameObjectIdOffset === 0) {
            break;
          }
          gameObjectId += gameObjectIdOffset;
          const gameObjectDefinition = GameObjectDefinition.getDefinition(gameObjectId);
          gameObjectDefinition.passiveRequestModels(onDemandRequester);
          while (true) {
            {
              const terminate = buffer.getSmart();
              if (terminate === 0) {
                break;
              }
              buffer.getUnsignedByte();
            }
          }
        }
      }
    }
    static method170(i, i_162_, i_163_) {
      const gameObjectDefinition = GameObjectDefinition.getDefinition(i_163_);
      if (i_162_ !== _Region.aByte154) {
        for (let i_164_ = 1; i_164_ > 0; i_164_++) {
          {
          }
        }
      }
      if (i === 11) {
        i = 10;
      }
      if (i >= 5 && i <= 8) {
        i = 4;
      }
      return gameObjectDefinition.method432(26261, i);
    }
    static trimHSLLightness(i, i_165_) {
      if (i === -1) {
        return 12345678;
      }
      i_165_ = i_165_ * (i & 127) / 128 | 0;
      if (i_165_ < 2) {
        i_165_ = 2;
      } else if (i_165_ > 126) {
        i_165_ = 126;
      }
      return (i & 65408) + i_165_;
    }
    static method176(i, i_226_, i_227_, i_228_) {
      const i_229_ = 65536 - Rasterizer3D.COSINE[i_227_ * 1024 / i_228_ | 0] >> 1;
      return (i * (65536 - i_229_) >> 16) + (i_226_ * i_229_ >> 16);
    }
    static method178(i, i_233_) {
      const i_234_ = _Region.calculateNoise(i - 1, i_233_ - 1) + _Region.calculateNoise(i + 1, i_233_ - 1) + _Region.calculateNoise(i - 1, i_233_ + 1) + _Region.calculateNoise(i + 1, i_233_ + 1);
      const i_235_ = _Region.calculateNoise(i - 1, i_233_) + _Region.calculateNoise(i + 1, i_233_) + _Region.calculateNoise(i, i_233_ - 1) + _Region.calculateNoise(i, i_233_ + 1);
      const i_236_ = _Region.calculateNoise(i, i_233_);
      return (i_234_ / 16 | 0) + (i_235_ / 8 | 0) + (i_236_ / 4 | 0);
    }
    static method181(i, i_258_, is, i_259_) {
      let bool = true;
      const class50_sub1_sub2 = new Buffer3(is);
      if (i_259_ !== 24515) {
        throw Error("NullPointerException");
      }
      let i_260_ = -1;
      for (; ; ) {
        {
          const i_261_ = class50_sub1_sub2.getSmart();
          if (i_261_ === 0) {
            break;
          }
          i_260_ += i_261_;
          let i_262_ = 0;
          let bool_263_ = false;
          for (; ; ) {
            {
              if (bool_263_) {
                const i_264_ = class50_sub1_sub2.getSmart();
                if (i_264_ === 0) {
                  break;
                }
                class50_sub1_sub2.getUnsignedByte();
              } else {
                const i_265_ = class50_sub1_sub2.getSmart();
                if (i_265_ === 0) {
                  break;
                }
                i_262_ += i_265_ - 1;
                const i_266_ = i_262_ & 63;
                const i_267_ = i_262_ >> 6 & 63;
                const i_268_ = class50_sub1_sub2.getUnsignedByte() >> 2;
                const i_269_ = i_267_ + i;
                const i_270_ = i_266_ + i_258_;
                if (i_269_ > 0 && i_270_ > 0 && i_269_ < 103 && i_270_ < 103) {
                  const class47 = GameObjectDefinition.getDefinition(i_260_);
                  if (i_268_ !== 22 || !_Region.lowMemory || class47.actionsBoolean || class47.unknown) {
                    bool = class47.isModelCached() && bool;
                    bool_263_ = true;
                  }
                }
              }
            }
          }
        }
      }
      return bool;
    }
    static calculateVertexHeight(i, i_281_) {
      let mapHeight = _Region.method163(i + 45365, i_281_ + 91923, 4) - 128 + (_Region.method163(i + 10294, i_281_ + 37821, 2) - 128 >> 1) + (_Region.method163(i, i_281_, 1) - 128 >> 2);
      mapHeight = (mapHeight * 0.3 | 0) + 35;
      if (mapHeight < 10) {
        mapHeight = 10;
      } else if (mapHeight > 60) {
        mapHeight = 60;
      }
      return mapHeight;
    }
    getVisibilityPlaneFor(i, i_12_, i_13_, i_14_) {
      if (i_14_ === this.aByte156) {
      } else {
        return 2;
      }
      if ((this.renderRuleFlags[i_12_][i_13_][i] & 8) !== 0) {
        return 0;
      }
      if (i_12_ > 0 && (this.renderRuleFlags[1][i_13_][i] & 2) !== 0) {
        return i_12_ - 1;
      }
      return i_12_;
    }
    method166(i, i_39_, i_40_, i_41_) {
      if (i === this.anInt160) {
        for (let i_42_ = 0; i_42_ < 8; i_42_++) {
          {
            for (let i_43_ = 0; i_43_ < 8; i_43_++) {
              this.vertexHeights[i_39_][i_41_ + i_42_][i_40_ + i_43_] = 0;
            }
          }
        }
        if (i_41_ > 0) {
          for (let i_44_ = 1; i_44_ < 8; i_44_++) {
            this.vertexHeights[i_39_][i_41_][i_40_ + i_44_] = this.vertexHeights[i_39_][i_41_ - 1][i_40_ + i_44_];
          }
        }
        if (i_40_ > 0) {
          for (let i_45_ = 1; i_45_ < 8; i_45_++) {
            this.vertexHeights[i_39_][i_41_ + i_45_][i_40_] = this.vertexHeights[i_39_][i_41_ + i_45_][i_40_ - 1];
          }
        }
        if (i_41_ > 0 && this.vertexHeights[i_39_][i_41_ - 1][i_40_] !== 0) {
          this.vertexHeights[i_39_][i_41_][i_40_] = this.vertexHeights[i_39_][i_41_ - 1][i_40_];
        } else if (i_40_ > 0 && this.vertexHeights[i_39_][i_41_][i_40_ - 1] !== 0) {
          this.vertexHeights[i_39_][i_41_][i_40_] = this.vertexHeights[i_39_][i_41_][i_40_ - 1];
        } else if (i_41_ > 0 && i_40_ > 0 && this.vertexHeights[i_39_][i_41_ - 1][i_40_ - 1] !== 0) {
          this.vertexHeights[i_39_][i_41_][i_40_] = this.vertexHeights[i_39_][i_41_ - 1][i_40_ - 1];
        }
      }
    }
    createRegionScene(collisionMaps, scene) {
      for (let plane = 0; plane < 4; plane++) {
        {
          for (let x2 = 0; x2 < 104; x2++) {
            {
              for (let y = 0; y < 104; y++) {
                {
                  if ((this.renderRuleFlags[plane][x2][y] & 1) === 1) {
                    let originalPlane = plane;
                    if ((this.renderRuleFlags[1][x2][y] & 2) === 2) {
                      originalPlane--;
                    }
                    if (originalPlane >= 0) {
                      collisionMaps[originalPlane].markBlocked(x2, y);
                    }
                  }
                }
              }
            }
          }
        }
      }
      _Region.hueRandomizer = _Region.hueRandomizer + (Math.random() * 5 | 0) - 2;
      if (_Region.hueRandomizer < -8) {
        _Region.hueRandomizer = -8;
      }
      if (_Region.hueRandomizer > 8) {
        _Region.hueRandomizer = 8;
      }
      _Region.lightnessRandomizer = _Region.lightnessRandomizer + (Math.random() * 5 | 0) - 2;
      if (_Region.lightnessRandomizer < -16) {
        _Region.lightnessRandomizer = -16;
      }
      if (_Region.lightnessRandomizer > 16) {
        _Region.lightnessRandomizer = 16;
      }
      for (let plane = 0; plane < 4; plane++) {
        {
          const shadowIntensity = this.tileShadowIntensity[plane];
          const directionalLightInitialIntensity = 96;
          const specularDistributionFactor = 768;
          const directionalLightX = -50;
          const directionalLightY = -10;
          const directionalLightZ = -50;
          const directionalLightLength = Math.sqrt(
            directionalLightX * directionalLightX + directionalLightY * directionalLightY + directionalLightZ * directionalLightZ
          ) | 0;
          const specularDistribution = specularDistributionFactor * directionalLightLength >> 8;
          for (let y = 1; y < this.regionSizeY - 1; y++) {
            {
              for (let x2 = 1; x2 < this.regionSizeX - 1; x2++) {
                {
                  const xHeightDifference = this.vertexHeights[plane][x2 + 1][y] - this.vertexHeights[plane][x2 - 1][y];
                  const yHeightDifference = this.vertexHeights[plane][x2][y + 1] - this.vertexHeights[plane][x2][y - 1];
                  const normalizedLength = Math.sqrt(
                    xHeightDifference * xHeightDifference + 65536 + yHeightDifference * yHeightDifference
                  ) | 0;
                  const normalizedNormalX = (xHeightDifference << 8) / normalizedLength | 0;
                  const normalizedNormalY = 65536 / normalizedLength | 0;
                  const normalizedNormalZ = (yHeightDifference << 8) / normalizedLength | 0;
                  const directionalLightIntensity = directionalLightInitialIntensity + ((directionalLightX * normalizedNormalX + directionalLightY * normalizedNormalY + directionalLightZ * normalizedNormalZ) / specularDistribution | 0);
                  const weightedShadowIntensity = (shadowIntensity[x2 - 1][y] >> 2) + (shadowIntensity[x2 + 1][y] >> 3) + (shadowIntensity[x2][y - 1] >> 2) + (shadowIntensity[x2][y + 1] >> 3) + (shadowIntensity[x2][y] >> 1);
                  this.tileLightingIntensity[x2][y] = directionalLightIntensity - weightedShadowIntensity;
                }
              }
            }
          }
          for (let y = 0; y < this.regionSizeY; y++) {
            {
              this.blendedHue[y] = 0;
              this.blendedSaturation[y] = 0;
              this.blendedLightness[y] = 0;
              this.blendedHueDivisor[y] = 0;
              this.blendDirectionTracker[y] = 0;
            }
          }
          for (let x2 = -5; x2 < this.regionSizeX + 5; x2++) {
            {
              for (let y = 0; y < this.regionSizeY; y++) {
                {
                  const xPositiveOffset = x2 + 5;
                  if (xPositiveOffset >= 0 && xPositiveOffset < this.regionSizeX) {
                    const floorId = this.underlayFloorIds[plane][xPositiveOffset][y] & 255;
                    if (floorId > 0) {
                      const floor = FloorDefinition.cache[floorId - 1];
                      this.blendedHue[y] += floor.hue;
                      this.blendedSaturation[y] += floor.saturation;
                      this.blendedLightness[y] += floor.lightness;
                      this.blendedHueDivisor[y] += floor.hueDivisor;
                      this.blendDirectionTracker[y]++;
                    }
                  }
                  const xNegativeOffset = x2 - 5;
                  if (xNegativeOffset >= 0 && xNegativeOffset < this.regionSizeX) {
                    const floorId = this.underlayFloorIds[plane][xNegativeOffset][y] & 255;
                    if (floorId > 0) {
                      const floor = FloorDefinition.cache[floorId - 1];
                      this.blendedHue[y] -= floor.hue;
                      this.blendedSaturation[y] -= floor.saturation;
                      this.blendedLightness[y] -= floor.lightness;
                      this.blendedHueDivisor[y] -= floor.hueDivisor;
                      this.blendDirectionTracker[y]--;
                    }
                  }
                }
              }
              if (x2 >= 1 && x2 < this.regionSizeX - 1) {
                let i_75_ = 0;
                let i_76_ = 0;
                let i_77_ = 0;
                let i_78_ = 0;
                let i_79_ = 0;
                for (let y = -5; y < this.regionSizeY + 5; y++) {
                  {
                    const yPositiveOffset = y + 5;
                    if (yPositiveOffset >= 0 && yPositiveOffset < this.regionSizeY) {
                      i_75_ += this.blendedHue[yPositiveOffset];
                      i_76_ += this.blendedSaturation[yPositiveOffset];
                      i_77_ += this.blendedLightness[yPositiveOffset];
                      i_78_ += this.blendedHueDivisor[yPositiveOffset];
                      i_79_ += this.blendDirectionTracker[yPositiveOffset];
                    }
                    const yNegativeOffset = y - 5;
                    if (yNegativeOffset >= 0 && yNegativeOffset < this.regionSizeY) {
                      i_75_ -= this.blendedHue[yNegativeOffset];
                      i_76_ -= this.blendedSaturation[yNegativeOffset];
                      i_77_ -= this.blendedLightness[yNegativeOffset];
                      i_78_ -= this.blendedHueDivisor[yNegativeOffset];
                      i_79_ -= this.blendDirectionTracker[yNegativeOffset];
                    }
                    if (y >= 1 && y < this.regionSizeY - 1 && (!_Region.lowMemory || (this.renderRuleFlags[0][x2][y] & 2) !== 0 || (this.renderRuleFlags[plane][x2][y] & 16) === 0 && this.getVisibilityPlaneFor(y, plane, x2, 0 | 0) === _Region.onBuildTimePlane)) {
                      if (plane < _Region.lowestPlane) {
                        _Region.lowestPlane = plane;
                      }
                      const underlayFloorId = this.underlayFloorIds[plane][x2][y] & 255;
                      const overlayFloorId = this.overlayFloorIds[plane][x2][y] & 255;
                      if (underlayFloorId > 0 || overlayFloorId > 0) {
                        const vertexSouthWest = this.vertexHeights[plane][x2][y];
                        const vertexSouthEast = this.vertexHeights[plane][x2 + 1][y];
                        const vertexNorthEast = this.vertexHeights[plane][x2 + 1][y + 1];
                        const vertexNorthWest = this.vertexHeights[plane][x2][y + 1];
                        const lightSouthWest = this.tileLightingIntensity[x2][y];
                        const lightSouthEast = this.tileLightingIntensity[x2 + 1][y];
                        const lightNorthEast = this.tileLightingIntensity[x2 + 1][y + 1];
                        const lightNorthWest = this.tileLightingIntensity[x2][y + 1];
                        let hslBitsetUnmodified = -1;
                        let hslBitsetRandomized = -1;
                        if (underlayFloorId > 0) {
                          let hue = i_75_ * 256 / i_78_ | 0;
                          const saturation = i_76_ / i_79_ | 0;
                          let lightness = i_77_ / i_79_ | 0;
                          hslBitsetUnmodified = this.getHSLBitset(hue, saturation, lightness);
                          hue = hue + _Region.hueRandomizer & 255;
                          lightness += _Region.lightnessRandomizer;
                          if (lightness < 0) {
                            lightness = 0;
                          } else if (lightness > 255) {
                            lightness = 255;
                          }
                          hslBitsetRandomized = this.getHSLBitset(hue, saturation, lightness);
                        }
                        if (plane > 0) {
                          let bool = true;
                          if (underlayFloorId === 0 && this.overlayClippingPaths[plane][x2][y] !== 0) {
                            bool = false;
                          }
                          if (overlayFloorId > 0 && !FloorDefinition.cache[overlayFloorId - 1].occlude) {
                            bool = false;
                          }
                          if (bool && vertexSouthWest === vertexSouthEast && vertexSouthWest === vertexNorthEast && vertexSouthWest === vertexNorthWest) {
                            this.tileCullingBitsets[plane][x2][y] |= 2340;
                          }
                        }
                        let rgbBitsetRandomized = 0;
                        if (hslBitsetUnmodified !== -1) {
                          rgbBitsetRandomized = Rasterizer3D.getRgbLookupTableId[_Region.trimHSLLightness(hslBitsetRandomized, 96)];
                        }
                        if (overlayFloorId === 0) {
                          scene.addTile(
                            plane,
                            x2,
                            y,
                            0,
                            0,
                            -1,
                            vertexSouthWest,
                            vertexSouthEast,
                            vertexNorthEast,
                            vertexNorthWest,
                            _Region.trimHSLLightness(hslBitsetUnmodified, lightSouthWest),
                            _Region.trimHSLLightness(hslBitsetUnmodified, lightSouthEast),
                            _Region.trimHSLLightness(hslBitsetUnmodified, lightNorthEast),
                            _Region.trimHSLLightness(hslBitsetUnmodified, lightNorthWest),
                            0,
                            0,
                            0,
                            0,
                            rgbBitsetRandomized,
                            0
                          );
                        } else {
                          const clippingPath = this.overlayClippingPaths[plane][x2][y] + 1;
                          const clippingPathRotation = this.overlayRotations[plane][x2][y];
                          const floor = FloorDefinition.cache[overlayFloorId - 1];
                          let textureid = floor.textureId;
                          let hslBitset;
                          let rgbBitset;
                          if (textureid >= 0) {
                            rgbBitset = Rasterizer3D.getAverageRgbColorForTexture(textureid, 0);
                            hslBitset = -1;
                          } else if (floor.rgbColor === 16711935) {
                            hslBitset = -2;
                            textureid = -1;
                            rgbBitset = Rasterizer3D.getRgbLookupTableId[this.method182(floor.hslColor2, 96)];
                          } else {
                            hslBitset = this.getHSLBitset(floor.hue2, floor.saturation, floor.lightness);
                            rgbBitset = Rasterizer3D.getRgbLookupTableId[this.method182(floor.hslColor2, 96)];
                          }
                          scene.addTile(
                            plane,
                            x2,
                            y,
                            clippingPath,
                            clippingPathRotation,
                            textureid,
                            vertexSouthWest,
                            vertexSouthEast,
                            vertexNorthEast,
                            vertexNorthWest,
                            _Region.trimHSLLightness(hslBitsetUnmodified, lightSouthWest),
                            _Region.trimHSLLightness(hslBitsetUnmodified, lightSouthEast),
                            _Region.trimHSLLightness(hslBitsetUnmodified, lightNorthEast),
                            _Region.trimHSLLightness(hslBitsetUnmodified, lightNorthWest),
                            this.method182(hslBitset, lightSouthWest),
                            this.method182(hslBitset, lightSouthEast),
                            this.method182(hslBitset, lightNorthEast),
                            this.method182(hslBitset, lightNorthWest),
                            rgbBitsetRandomized,
                            rgbBitset
                          );
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (let i_104_ = 1; i_104_ < this.regionSizeY - 1; i_104_++) {
            {
              for (let i_105_ = 1; i_105_ < this.regionSizeX - 1; i_105_++) {
                scene.setPhysicalLevel(plane, i_105_, i_104_, this.getVisibilityPlaneFor(i_104_, plane, i_105_, 0 | 0));
              }
            }
          }
        }
      }
      scene.method272(2 | 0, -10, -50, -50);
      for (let y = 0; y < this.regionSizeX; y++) {
        {
          for (let x2 = 0; x2 < this.regionSizeY; x2++) {
            {
              if ((this.renderRuleFlags[1][y][x2] & 2) === 2) {
                scene.setBridgeMode(y, x2);
              }
            }
          }
        }
      }
      let renderRule1 = 1;
      let renderRule2 = 2;
      let renderRule3 = 4;
      for (let currentPlane = 0; currentPlane < 4; currentPlane++) {
        {
          if (currentPlane > 0) {
            renderRule1 <<= 3;
            renderRule2 <<= 3;
            renderRule3 <<= 3;
          }
          for (let plane = 0; plane <= currentPlane; plane++) {
            {
              for (let y = 0; y <= this.regionSizeY; y++) {
                {
                  for (let x2 = 0; x2 <= this.regionSizeX; x2++) {
                    {
                      if ((this.tileCullingBitsets[plane][x2][y] & renderRule1) !== 0) {
                        let lowestOcclussionY = y;
                        let higestOcclussionY = y;
                        let lowestOcclussionPlane = plane;
                        let higestOcclussionPlane = plane;
                        for (; lowestOcclussionY > 0; lowestOcclussionY--) {
                          {
                            if ((this.tileCullingBitsets[plane][x2][lowestOcclussionY - 1] & renderRule1) === 0) {
                              break;
                            }
                          }
                        }
                        for (; higestOcclussionY < this.regionSizeY; higestOcclussionY++) {
                          {
                            if ((this.tileCullingBitsets[plane][x2][higestOcclussionY + 1] & renderRule1) === 0) {
                              break;
                            }
                          }
                        }
                        while_0_:
                          for (; lowestOcclussionPlane > 0; lowestOcclussionPlane--) {
                            {
                              for (let occludedY = lowestOcclussionY; occludedY <= higestOcclussionY; occludedY++) {
                                {
                                  if ((this.tileCullingBitsets[lowestOcclussionPlane - 1][x2][occludedY] & renderRule1) === 0) {
                                    break while_0_;
                                  }
                                }
                              }
                            }
                          }
                        while_1_:
                          for (; higestOcclussionPlane < currentPlane; higestOcclussionPlane++) {
                            {
                              for (let occludedY = lowestOcclussionY; occludedY <= higestOcclussionY; occludedY++) {
                                {
                                  if ((this.tileCullingBitsets[higestOcclussionPlane + 1][x2][occludedY] & renderRule1) === 0) {
                                    break while_1_;
                                  }
                                }
                              }
                            }
                          }
                        const occlussionSurface = (higestOcclussionPlane + 1 - lowestOcclussionPlane) * (higestOcclussionY - lowestOcclussionY + 1);
                        if (occlussionSurface >= 8) {
                          const highestOcclussionVertexHeightOffset = 240;
                          const highestOcclussionVertexHeight = this.vertexHeights[higestOcclussionPlane][x2][lowestOcclussionY] - highestOcclussionVertexHeightOffset;
                          const lowestOcclussionVertexHeight = this.vertexHeights[lowestOcclussionPlane][x2][lowestOcclussionY];
                          Scene.createCullingOcclussionBox(
                            x2 * 128,
                            lowestOcclussionVertexHeight,
                            x2 * 128,
                            higestOcclussionY * 128 + 128,
                            currentPlane,
                            lowestOcclussionY * 128,
                            highestOcclussionVertexHeight,
                            1
                          );
                          for (let occludedPlane = lowestOcclussionPlane; occludedPlane <= higestOcclussionPlane; occludedPlane++) {
                            {
                              for (let occludedY = lowestOcclussionY; occludedY <= higestOcclussionY; occludedY++) {
                                this.tileCullingBitsets[occludedPlane][x2][occludedY] &= renderRule1 ^ -1;
                              }
                            }
                          }
                        }
                      }
                      if ((this.tileCullingBitsets[plane][x2][y] & renderRule2) !== 0) {
                        let i_127_ = x2;
                        let i_128_ = x2;
                        let i_129_ = plane;
                        let i_130_ = plane;
                        for (; i_127_ > 0; i_127_--) {
                          {
                            if ((this.tileCullingBitsets[plane][i_127_ - 1][y] & renderRule2) === 0) {
                              break;
                            }
                          }
                        }
                        for (; i_128_ < this.regionSizeX; i_128_++) {
                          {
                            if ((this.tileCullingBitsets[plane][i_128_ + 1][y] & renderRule2) === 0) {
                              break;
                            }
                          }
                        }
                        while_2_:
                          for (; i_129_ > 0; i_129_--) {
                            {
                              for (let i_131_ = i_127_; i_131_ <= i_128_; i_131_++) {
                                {
                                  if ((this.tileCullingBitsets[i_129_ - 1][i_131_][y] & renderRule2) === 0) {
                                    break while_2_;
                                  }
                                }
                              }
                            }
                          }
                        while_3_:
                          for (; i_130_ < currentPlane; i_130_++) {
                            {
                              for (let i_132_ = i_127_; i_132_ <= i_128_; i_132_++) {
                                {
                                  if ((this.tileCullingBitsets[i_130_ + 1][i_132_][y] & renderRule2) === 0) {
                                    break while_3_;
                                  }
                                }
                              }
                            }
                          }
                        const i_133_ = (i_130_ + 1 - i_129_) * (i_128_ - i_127_ + 1);
                        if (i_133_ >= 8) {
                          const i_134_ = 240;
                          const i_135_ = this.vertexHeights[i_130_][i_127_][y] - i_134_;
                          const i_136_ = this.vertexHeights[i_129_][i_127_][y];
                          Scene.createCullingOcclussionBox(
                            i_127_ * 128,
                            i_136_,
                            i_128_ * 128 + 128,
                            y * 128,
                            currentPlane,
                            y * 128,
                            i_135_,
                            2
                          );
                          for (let i_137_ = i_129_; i_137_ <= i_130_; i_137_++) {
                            {
                              for (let i_138_ = i_127_; i_138_ <= i_128_; i_138_++) {
                                this.tileCullingBitsets[i_137_][i_138_][y] &= renderRule2 ^ -1;
                              }
                            }
                          }
                        }
                      }
                      if ((this.tileCullingBitsets[plane][x2][y] & renderRule3) !== 0) {
                        let i_139_ = x2;
                        let i_140_ = x2;
                        let i_141_ = y;
                        let i_142_ = y;
                        for (; i_141_ > 0; i_141_--) {
                          {
                            if ((this.tileCullingBitsets[plane][x2][i_141_ - 1] & renderRule3) === 0) {
                              break;
                            }
                          }
                        }
                        for (; i_142_ < this.regionSizeY; i_142_++) {
                          {
                            if ((this.tileCullingBitsets[plane][x2][i_142_ + 1] & renderRule3) === 0) {
                              break;
                            }
                          }
                        }
                        while_4_:
                          for (; i_139_ > 0; i_139_--) {
                            {
                              for (let i_143_ = i_141_; i_143_ <= i_142_; i_143_++) {
                                {
                                  if ((this.tileCullingBitsets[plane][i_139_ - 1][i_143_] & renderRule3) === 0) {
                                    break while_4_;
                                  }
                                }
                              }
                            }
                          }
                        while_5_:
                          for (; i_140_ < this.regionSizeX; i_140_++) {
                            {
                              for (let i_144_ = i_141_; i_144_ <= i_142_; i_144_++) {
                                {
                                  if ((this.tileCullingBitsets[plane][i_140_ + 1][i_144_] & renderRule3) === 0) {
                                    break while_5_;
                                  }
                                }
                              }
                            }
                          }
                        if ((i_140_ - i_139_ + 1) * (i_142_ - i_141_ + 1) >= 4) {
                          const i_145_ = this.vertexHeights[plane][i_139_][i_141_];
                          Scene.createCullingOcclussionBox(
                            i_139_ * 128,
                            i_145_,
                            i_140_ * 128 + 128,
                            i_142_ * 128 + 128,
                            currentPlane,
                            i_141_ * 128,
                            i_145_,
                            4
                          );
                          for (let i_146_ = i_139_; i_146_ <= i_140_; i_146_++) {
                            {
                              for (let i_147_ = i_141_; i_147_ <= i_142_; i_147_++) {
                                this.tileCullingBitsets[plane][i_146_][i_147_] &= renderRule3 ^ -1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    method168(i, i_148_, bool, is, i_149_, i_150_, i_151_, class46s, i_152_, i_153_) {
      if (bool) {
        this.anInt166 = 476;
      }
      for (let i_154_ = 0; i_154_ < 8; i_154_++) {
        {
          for (let i_155_ = 0; i_155_ < 8; i_155_++) {
            {
              if (i_151_ + i_154_ > 0 && i_151_ + i_154_ < 103 && i_152_ + i_155_ > 0 && i_152_ + i_155_ < 103) {
                class46s[i_149_].adjacency[i_151_ + i_154_][i_152_ + i_155_] &= ~16777216;
              }
            }
          }
        }
      }
      const class50_sub1_sub2 = new Buffer3(is);
      for (let i_156_ = 0; i_156_ < 4; i_156_++) {
        {
          for (let i_157_ = 0; i_157_ < 64; i_157_++) {
            {
              for (let i_158_ = 0; i_158_ < 64; i_158_++) {
                {
                  if (i_156_ === i_150_ && i_157_ >= i_153_ && i_157_ < i_153_ + 8 && i_158_ >= i_148_ && i_158_ < i_148_ + 8) {
                    this.method183(
                      0,
                      -61 | 0,
                      0,
                      class50_sub1_sub2,
                      i,
                      i_151_ + TiledUtils.getRotatedMapChunkX(i_157_ & 7, i_158_ & 7, i),
                      i_149_,
                      i_152_ + TiledUtils.getRotatedMapChunkY(i_157_ & 7, i_158_ & 7, i)
                    );
                  } else {
                    this.method183(0, -61 | 0, 0, class50_sub1_sub2, 0, -1, 0, -1);
                  }
                }
              }
            }
          }
        }
      }
    }
    method172(i, class46s, class22, bool, is, i_166_, i_167_, i_168_, i_169_, i_170_, i_171_) {
      const class50_sub1_sub2 = new Buffer3(is);
      if (!bool) {
        let i_172_ = -1;
        for (; ; ) {
          {
            const i_173_ = class50_sub1_sub2.getSmart();
            if (i_173_ === 0) {
              break;
            }
            i_172_ += i_173_;
            let i_174_ = 0;
            for (; ; ) {
              {
                const i_175_ = class50_sub1_sub2.getSmart();
                if (i_175_ === 0) {
                  break;
                }
                i_174_ += i_175_ - 1;
                const i_176_ = i_174_ & 63;
                const i_177_ = i_174_ >> 6 & 63;
                const i_178_ = i_174_ >> 12;
                const i_179_ = class50_sub1_sub2.getUnsignedByte();
                const i_180_ = i_179_ >> 2;
                const i_181_ = i_179_ & 3;
                if (i_178_ === i_171_ && i_177_ >= i_168_ && i_177_ < i_168_ + 8 && i_176_ >= i_170_ && i_176_ < i_170_ + 8) {
                  const class47 = GameObjectDefinition.getDefinition(i_172_);
                  const i_182_ = i_169_ + TiledUtils.getRotatedLandscapeChunkX(i_167_, class47.sizeY, i_177_ & 7, i_176_ & 7, class47.sizeX);
                  const i_183_ = i_166_ + TiledUtils.getRotatedLandscapeChunkY(i_176_ & 7, class47.sizeY, i_167_, class47.sizeX, i_177_ & 7);
                  if (i_182_ > 0 && i_183_ > 0 && i_182_ < 103 && i_183_ < 103) {
                    let i_184_ = i;
                    if ((this.renderRuleFlags[1][i_182_][i_183_] & 2) === 2) {
                      i_184_--;
                    }
                    let class46 = null;
                    if (i_184_ >= 0) {
                      class46 = class46s[i_184_];
                    }
                    this.renderObject(
                      class22,
                      class46,
                      i_183_,
                      i,
                      i_182_,
                      this.aByte139,
                      i_181_ + i_167_ & 3,
                      i_180_,
                      i_172_
                    );
                  }
                }
              }
            }
          }
        }
      }
    }
    renderObject(scene, collisionMap, y, plane, x2, i_187_, face, type, objectId) {
      if (!_Region.lowMemory || (this.renderRuleFlags[0][x2][y] & 2) !== 0 || (this.renderRuleFlags[plane][x2][y] & 16) === 0 && this.getVisibilityPlaneFor(y, plane, x2, 0 | 0) === _Region.onBuildTimePlane) {
        if (plane < _Region.lowestPlane) {
          _Region.lowestPlane = plane;
        }
        let vertexHeight = this.vertexHeights[plane][x2][y];
        let vertexHeightRight = this.vertexHeights[plane][x2 + 1][y];
        let vertexHeightTopRight = this.vertexHeights[plane][x2 + 1][y + 1];
        let vertexHeightTop = this.vertexHeights[plane][x2][y + 1];
        const vertexMix = vertexHeight + vertexHeightRight + vertexHeightTopRight + vertexHeightTop >> 2;
        const gameObjectDefinition = GameObjectDefinition.getDefinition(objectId);
        let hash = x2 + (y << 7) + (objectId << 14) + 1073741824;
        if (!gameObjectDefinition.actionsBoolean) {
          hash += -2147483648;
        }
        const objectConfig = (face << 6) + type | 0;
        if (type === 22) {
          if (!_Region.lowMemory || gameObjectDefinition.actionsBoolean || gameObjectDefinition.unknown) {
            let renderable;
            if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
              renderable = gameObjectDefinition.getGameObjectModel(
                22,
                face,
                vertexHeight,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeightTop,
                -1
              );
            } else {
              renderable = new GameObject(
                objectId,
                face,
                22,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeight,
                vertexHeightTop,
                gameObjectDefinition.animationId,
                true
              );
            }
            scene.addGroundDecoration(x2, y, 669, objectConfig, hash, vertexMix, plane, renderable);
            if (gameObjectDefinition.solid && gameObjectDefinition.actionsBoolean && collisionMap != null) {
              collisionMap.markBlocked(x2, y);
            }
          }
        } else if (type === 10 || type === 11) {
          let renderable;
          if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
            renderable = gameObjectDefinition.getGameObjectModel(
              10,
              face,
              vertexHeight,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeightTop,
              -1
            );
          } else {
            renderable = new GameObject(
              objectId,
              face,
              10,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeight,
              vertexHeightTop,
              gameObjectDefinition.animationId,
              true
            );
          }
          if (renderable != null) {
            let i_198_ = 0;
            if (type === 11) {
              i_198_ += 256;
            }
            let sizeX;
            let sizeY;
            if (face === 1 || face === 3) {
              sizeX = gameObjectDefinition.sizeY;
              sizeY = gameObjectDefinition.sizeX;
            } else {
              sizeX = gameObjectDefinition.sizeX;
              sizeY = gameObjectDefinition.sizeY;
            }
            if (scene.method251(plane, sizeX, y, renderable, objectConfig, i_198_, x2, -896, sizeY, vertexMix, hash) && gameObjectDefinition.unknown2) {
              let model;
              if (renderable != null && renderable instanceof Model) {
                model = renderable;
              } else {
                model = gameObjectDefinition.getGameObjectModel(
                  10,
                  face,
                  vertexHeight,
                  vertexHeightRight,
                  vertexHeightTopRight,
                  vertexHeightTop,
                  -1
                );
              }
              if (model != null) {
                for (let sizeXCounter = 0; sizeXCounter <= sizeX; sizeXCounter++) {
                  {
                    for (let sizeYCounter = 0; sizeYCounter <= sizeY; sizeYCounter++) {
                      {
                        let shadowIntensity = model.shadowIntensity / 4 | 0;
                        if (shadowIntensity > 30) {
                          shadowIntensity = 30;
                        }
                        if (shadowIntensity > this.tileShadowIntensity[plane][x2 + sizeXCounter][y + sizeYCounter]) {
                          this.tileShadowIntensity[plane][x2 + sizeXCounter][y + sizeYCounter] = shadowIntensity | 0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (gameObjectDefinition.solid && collisionMap != null) {
            collisionMap.method413(
              y,
              face,
              gameObjectDefinition.sizeY,
              gameObjectDefinition.sizeX,
              gameObjectDefinition.walkable,
              x2,
              52 | 0
            );
          }
        } else if (type >= 12) {
          let renderable;
          if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
            renderable = gameObjectDefinition.getGameObjectModel(
              type,
              face,
              vertexHeight,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeightTop,
              -1
            );
          } else {
            renderable = new GameObject(
              objectId,
              face,
              type,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeight,
              vertexHeightTop,
              gameObjectDefinition.animationId,
              true
            );
          }
          scene.method251(plane, 1, y, renderable, objectConfig, 0, x2, -896, 1, vertexMix, hash);
          if (type >= 12 && type <= 17 && type !== 13 && plane > 0) {
            this.tileCullingBitsets[plane][x2][y] |= 2340;
          }
          if (gameObjectDefinition.solid && collisionMap != null) {
            collisionMap.method413(
              y,
              face,
              gameObjectDefinition.sizeY,
              gameObjectDefinition.sizeX,
              gameObjectDefinition.walkable,
              x2,
              52 | 0
            );
          }
        } else if (type === 0) {
          let renderable;
          if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
            renderable = gameObjectDefinition.getGameObjectModel(
              0,
              face,
              vertexHeight,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeightTop,
              -1
            );
          } else {
            renderable = new GameObject(
              objectId,
              face,
              0,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeight,
              vertexHeightTop,
              gameObjectDefinition.animationId,
              true
            );
          }
          scene.method249(_Region.anIntArray158[face], renderable, hash, y, objectConfig, x2, null, vertexMix, 0, plane);
          if (face === 0) {
            if (gameObjectDefinition.unknown2) {
              this.tileShadowIntensity[plane][x2][y] = 50 | 0;
              this.tileShadowIntensity[plane][x2][y + 1] = 50 | 0;
            }
            if (gameObjectDefinition.aBoolean797) {
              this.tileCullingBitsets[plane][x2][y] |= 585;
            }
          } else if (face === 1) {
            if (gameObjectDefinition.unknown2) {
              this.tileShadowIntensity[plane][x2][y + 1] = 50 | 0;
              this.tileShadowIntensity[plane][x2 + 1][y + 1] = 50 | 0;
            }
            if (gameObjectDefinition.aBoolean797) {
              this.tileCullingBitsets[plane][x2][y + 1] |= 1170;
            }
          } else if (face === 2) {
            if (gameObjectDefinition.unknown2) {
              this.tileShadowIntensity[plane][x2 + 1][y] = 50 | 0;
              this.tileShadowIntensity[plane][x2 + 1][y + 1] = 50 | 0;
            }
            if (gameObjectDefinition.aBoolean797) {
              this.tileCullingBitsets[plane][x2 + 1][y] |= 585;
            }
          } else if (face === 3) {
            if (gameObjectDefinition.unknown2) {
              this.tileShadowIntensity[plane][x2][y] = 50 | 0;
              this.tileShadowIntensity[plane][x2 + 1][y] = 50 | 0;
            }
            if (gameObjectDefinition.aBoolean797) {
              this.tileCullingBitsets[plane][x2][y] |= 1170;
            }
          }
          if (gameObjectDefinition.solid && collisionMap != null) {
            collisionMap.markWall(x2, y, type, face, gameObjectDefinition.walkable);
          }
          if (gameObjectDefinition.unknown4 !== 16) {
            scene.method257(y, gameObjectDefinition.unknown4, plane, x2);
          }
        } else if (type === 1) {
          let renderable;
          if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
            renderable = gameObjectDefinition.getGameObjectModel(
              1,
              face,
              vertexHeight,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeightTop,
              -1
            );
          } else {
            renderable = new GameObject(
              objectId,
              face,
              1,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeight,
              vertexHeightTop,
              gameObjectDefinition.animationId,
              true
            );
          }
          scene.method249(_Region.anIntArray167[face], renderable, hash, y, objectConfig, x2, null, vertexMix, 0, plane);
          if (gameObjectDefinition.unknown2) {
            if (face === 0) {
              this.tileShadowIntensity[plane][x2][y + 1] = 50 | 0;
            } else if (face === 1) {
              this.tileShadowIntensity[plane][x2 + 1][y + 1] = 50 | 0;
            } else if (face === 2) {
              this.tileShadowIntensity[plane][x2 + 1][y] = 50 | 0;
            } else if (face === 3) {
              this.tileShadowIntensity[plane][x2][y] = 50 | 0;
            }
          }
          if (gameObjectDefinition.solid && collisionMap != null) {
            collisionMap.markWall(x2, y, type, face, gameObjectDefinition.walkable);
          }
        } else if (type === 2) {
          const i_204_ = face + 1 & 3;
          let renderable;
          let renderable1;
          if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
            renderable = gameObjectDefinition.getGameObjectModel(
              2,
              4 + face,
              vertexHeight,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeightTop,
              -1
            );
            renderable1 = gameObjectDefinition.getGameObjectModel(
              2,
              i_204_,
              vertexHeight,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeightTop,
              -1
            );
          } else {
            renderable = new GameObject(
              objectId,
              4 + face,
              2,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeight,
              vertexHeightTop,
              gameObjectDefinition.animationId,
              true
            );
            renderable1 = new GameObject(
              objectId,
              i_204_,
              2,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeight,
              vertexHeightTop,
              gameObjectDefinition.animationId,
              true
            );
          }
          scene.method249(
            _Region.anIntArray158[face],
            renderable,
            hash,
            y,
            objectConfig,
            x2,
            renderable1,
            vertexMix,
            _Region.anIntArray158[i_204_],
            plane
          );
          if (gameObjectDefinition.aBoolean797) {
            if (face === 0) {
              this.tileCullingBitsets[plane][x2][y] |= 585;
              this.tileCullingBitsets[plane][x2][y + 1] |= 1170;
            } else if (face === 1) {
              this.tileCullingBitsets[plane][x2][y + 1] |= 1170;
              this.tileCullingBitsets[plane][x2 + 1][y] |= 585;
            } else if (face === 2) {
              this.tileCullingBitsets[plane][x2 + 1][y] |= 585;
              this.tileCullingBitsets[plane][x2][y] |= 1170;
            } else if (face === 3) {
              this.tileCullingBitsets[plane][x2][y] |= 1170;
              this.tileCullingBitsets[plane][x2][y] |= 585;
            }
          }
          if (gameObjectDefinition.solid && collisionMap != null) {
            collisionMap.markWall(x2, y, type, face, gameObjectDefinition.walkable);
          }
          if (gameObjectDefinition.unknown4 !== 16) {
            scene.method257(y, gameObjectDefinition.unknown4, plane, x2);
          }
        } else if (type === 3) {
          let renderable;
          if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
            renderable = gameObjectDefinition.getGameObjectModel(
              3,
              face,
              vertexHeight,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeightTop,
              -1
            );
          } else {
            renderable = new GameObject(
              objectId,
              face,
              3,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeight,
              vertexHeightTop,
              gameObjectDefinition.animationId,
              true
            );
          }
          scene.method249(_Region.anIntArray167[face], renderable, hash, y, objectConfig, x2, null, vertexMix, 0, plane);
          if (gameObjectDefinition.unknown2) {
            if (face === 0) {
              this.tileShadowIntensity[plane][x2][y + 1] = 50 | 0;
            } else if (face === 1) {
              this.tileShadowIntensity[plane][x2 + 1][y + 1] = 50 | 0;
            } else if (face === 2) {
              this.tileShadowIntensity[plane][x2 + 1][y] = 50 | 0;
            } else if (face === 3) {
              this.tileShadowIntensity[plane][x2][y] = 50 | 0;
            }
          }
          if (gameObjectDefinition.solid && collisionMap != null) {
            collisionMap.markWall(x2, y, type, face, gameObjectDefinition.walkable);
          }
        } else if (type === 9) {
          let renderable;
          if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
            renderable = gameObjectDefinition.getGameObjectModel(
              type,
              face,
              vertexHeight,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeightTop,
              -1
            );
          } else {
            renderable = new GameObject(
              objectId,
              face,
              type,
              vertexHeightRight,
              vertexHeightTopRight,
              vertexHeight,
              vertexHeightTop,
              gameObjectDefinition.animationId,
              true
            );
          }
          scene.method251(plane, 1, y, renderable, objectConfig, 0, x2, -896, 1, vertexMix, hash);
          if (gameObjectDefinition.solid && collisionMap != null) {
            collisionMap.method413(
              y,
              face,
              gameObjectDefinition.sizeY,
              gameObjectDefinition.sizeX,
              gameObjectDefinition.walkable,
              x2,
              52 | 0
            );
          }
        } else {
          if (gameObjectDefinition.adjustToTerrain) {
            if (face === 1) {
              const i_206_ = vertexHeightTop;
              vertexHeightTop = vertexHeightTopRight;
              vertexHeightTopRight = vertexHeightRight;
              vertexHeightRight = vertexHeight;
              vertexHeight = i_206_;
            } else if (face === 2) {
              let i_207_ = vertexHeightTop;
              vertexHeightTop = vertexHeightRight;
              vertexHeightRight = i_207_;
              i_207_ = vertexHeightTopRight;
              vertexHeightTopRight = vertexHeight;
              vertexHeight = i_207_;
            } else if (face === 3) {
              const i_208_ = vertexHeightTop;
              vertexHeightTop = vertexHeight;
              vertexHeight = vertexHeightRight;
              vertexHeightRight = vertexHeightTopRight;
              vertexHeightTopRight = i_208_;
            }
          }
          if (type === 4) {
            let renderable;
            if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
              renderable = gameObjectDefinition.getGameObjectModel(
                4,
                0,
                vertexHeight,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeightTop,
                -1
              );
            } else {
              renderable = new GameObject(
                objectId,
                0,
                4,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeight,
                vertexHeightTop,
                gameObjectDefinition.animationId,
                true
              );
            }
            scene.addWallDecoration(
              plane,
              _Region.anIntArray158[face],
              face * 512,
              hash,
              objectConfig,
              x2,
              0,
              y,
              0,
              vertexMix,
              renderable,
              -930
            );
          } else if (type === 5) {
            let offset = 16;
            const i_210_ = scene.method267(plane, x2, y);
            if (i_210_ > 0) {
              offset = GameObjectDefinition.getDefinition(i_210_ >> 14 & 32767).unknown4;
            }
            let renderable;
            if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
              renderable = gameObjectDefinition.getGameObjectModel(
                4,
                0,
                vertexHeight,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeightTop,
                -1
              );
            } else {
              renderable = new GameObject(
                objectId,
                0,
                4,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeight,
                vertexHeightTop,
                gameObjectDefinition.animationId,
                true
              );
            }
            scene.addWallDecoration(
              plane,
              _Region.anIntArray158[face],
              face * 512,
              hash,
              objectConfig,
              x2,
              _Region.anIntArray143[face] * offset,
              y,
              _Region.anIntArray161[face] * offset,
              vertexMix,
              renderable,
              -930
            );
          } else if (type === 6) {
            let renderable;
            if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
              renderable = gameObjectDefinition.getGameObjectModel(
                4,
                0,
                vertexHeight,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeightTop,
                -1
              );
            } else {
              renderable = new GameObject(
                objectId,
                0,
                4,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeight,
                vertexHeightTop,
                gameObjectDefinition.animationId,
                true
              );
            }
            scene.addWallDecoration(plane, 256, face, hash, objectConfig, x2, 0, y, 0, vertexMix, renderable, -930);
          } else if (type === 7) {
            let renderable;
            if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
              renderable = gameObjectDefinition.getGameObjectModel(
                4,
                0,
                vertexHeight,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeightTop,
                -1
              );
            } else {
              renderable = new GameObject(
                objectId,
                0,
                4,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeight,
                vertexHeightTop,
                gameObjectDefinition.animationId,
                true
              );
            }
            scene.addWallDecoration(plane, 512, face, hash, objectConfig, x2, 0, y, 0, vertexMix, renderable, -930);
          } else if (type === 8) {
            let renderable;
            if (gameObjectDefinition.animationId === -1 && gameObjectDefinition.childrenIds == null) {
              renderable = gameObjectDefinition.getGameObjectModel(
                4,
                0,
                vertexHeight,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeightTop,
                -1
              );
            } else {
              renderable = new GameObject(
                objectId,
                0,
                4,
                vertexHeightRight,
                vertexHeightTopRight,
                vertexHeight,
                vertexHeightTop,
                gameObjectDefinition.animationId,
                true
              );
            }
            scene.addWallDecoration(plane, 768, face, hash, objectConfig, x2, 0, y, 0, vertexMix, renderable, -930);
          }
        }
      }
    }
    method174(i, bool, i_211_, i_212_, is, i_213_, class46s) {
      if (bool) {
        this.anInt166 = -379;
      }
      for (let i_214_ = 0; i_214_ < 4; i_214_++) {
        {
          for (let i_215_ = 0; i_215_ < 64; i_215_++) {
            {
              for (let i_216_ = 0; i_216_ < 64; i_216_++) {
                {
                  if (i_212_ + i_215_ > 0 && i_212_ + i_215_ < 103 && i + i_216_ > 0 && i + i_216_ < 103) {
                    class46s[i_214_].adjacency[i_212_ + i_215_][i + i_216_] &= ~16777216;
                  }
                }
              }
            }
          }
        }
      }
      const class50_sub1_sub2 = new Buffer3(is);
      for (let i_217_ = 0; i_217_ < 4; i_217_++) {
        {
          for (let i_218_ = 0; i_218_ < 64; i_218_++) {
            {
              for (let i_219_ = 0; i_219_ < 64; i_219_++) {
                this.method183(i_213_, -61 | 0, i_211_, class50_sub1_sub2, 0, i_218_ + i_212_, i_217_, i_219_ + i);
              }
            }
          }
        }
      }
    }
    getHSLBitset(i, i_230_, i_231_) {
      if (i_231_ > 179) {
        i_230_ = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(i_230_ / 2);
      }
      if (i_231_ > 192) {
        i_230_ = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(i_230_ / 2);
      }
      if (i_231_ > 217) {
        i_230_ = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(i_230_ / 2);
      }
      if (i_231_ > 243) {
        i_230_ = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(i_230_ / 2);
      }
      const i_232_ = ((i / 4 | 0) << 10) + ((i_230_ / 32 | 0) << 7) + (i_231_ / 2 | 0);
      return i_232_;
    }
    method179(i, class46s, i_237_, i_238_, class22, is) {
      if (i_238_ < 0) {
        const class50_sub1_sub2 = new Buffer3(is);
        let i_239_ = -1;
        for (; ; ) {
          {
            const i_240_ = class50_sub1_sub2.getSmart();
            if (i_240_ === 0) {
              break;
            }
            i_239_ += i_240_;
            let i_241_ = 0;
            for (; ; ) {
              {
                const i_242_ = class50_sub1_sub2.getSmart();
                if (i_242_ === 0) {
                  break;
                }
                i_241_ += i_242_ - 1;
                const i_243_ = i_241_ & 63;
                const i_244_ = i_241_ >> 6 & 63;
                const i_245_ = i_241_ >> 12;
                const i_246_ = class50_sub1_sub2.getUnsignedByte();
                const i_247_ = i_246_ >> 2;
                const i_248_ = i_246_ & 3;
                const i_249_ = i_244_ + i_237_;
                const i_250_ = i_243_ + i;
                if (i_249_ > 0 && i_250_ > 0 && i_249_ < 103 && i_250_ < 103) {
                  let i_251_ = i_245_;
                  if ((this.renderRuleFlags[1][i_249_][i_250_] & 2) === 2) {
                    i_251_--;
                  }
                  let class46 = null;
                  if (i_251_ >= 0) {
                    class46 = class46s[i_251_];
                  }
                  this.renderObject(class22, class46, i_250_, i_245_, i_249_, this.aByte139, i_248_, i_247_, i_239_);
                }
              }
            }
          }
        }
      }
    }
    initiateVertexHeights(xOffset, xLength, yOffset, yLength) {
      for (let y = yOffset; y <= yOffset + yLength; y++) {
        {
          for (let x2 = xOffset; x2 <= xOffset + xLength; x2++) {
            {
              if (x2 >= 0 && x2 < this.regionSizeX && y >= 0 && y < this.regionSizeY) {
                this.tileShadowIntensity[0][x2][y] = 127 | 0;
                if (x2 === xOffset && x2 > 0) {
                  this.vertexHeights[0][x2][y] = this.vertexHeights[0][x2 - 1][y];
                }
                if (x2 === xOffset + xLength && x2 < this.regionSizeX - 1) {
                  this.vertexHeights[0][x2][y] = this.vertexHeights[0][x2 + 1][y];
                }
                if (y === yOffset && y > 0) {
                  this.vertexHeights[0][x2][y] = this.vertexHeights[0][x2][y - 1];
                }
                if (y === yOffset + yLength && y < this.regionSizeY - 1) {
                  this.vertexHeights[0][x2][y] = this.vertexHeights[0][x2][y + 1];
                }
              }
            }
          }
        }
      }
    }
    method182(i, i_271_) {
      if (i === -2) {
        return 12345678;
      }
      if (i === -1) {
        if (i_271_ < 0) {
          i_271_ = 0;
        } else if (i_271_ > 127) {
          i_271_ = 127;
        }
        i_271_ = 127 - i_271_;
        return i_271_;
      }
      i_271_ = i_271_ * (i & 127) / 128 | 0;
      if (i_271_ < 2) {
        i_271_ = 2;
      } else if (i_271_ > 126) {
        i_271_ = 126;
      }
      return (i & 65408) + i_271_;
    }
    method183(i, i_272_, i_273_, class50_sub1_sub2, i_274_, i_275_, i_276_, i_277_) {
      if (i_272_ !== -61) {
        this.aBoolean140 = !this.aBoolean140;
      }
      if (i_275_ >= 0 && i_275_ < 104 && i_277_ >= 0 && i_277_ < 104) {
        this.renderRuleFlags[i_276_][i_275_][i_277_] = 0 | 0;
        for (; ; ) {
          {
            const i_278_ = class50_sub1_sub2.getUnsignedByte();
            if (i_278_ === 0) {
              if (i_276_ === 0) {
                this.vertexHeights[0][i_275_][i_277_] = -_Region.calculateVertexHeight(932731 + i_275_ + i, 556238 + i_277_ + i_273_) * 8;
              } else {
                this.vertexHeights[i_276_][i_275_][i_277_] = this.vertexHeights[i_276_ - 1][i_275_][i_277_] - 240;
                break;
              }
              break;
            }
            if (i_278_ === 1) {
              let i_279_ = class50_sub1_sub2.getUnsignedByte();
              if (i_279_ === 1) {
                i_279_ = 0;
              }
              if (i_276_ === 0) {
                this.vertexHeights[0][i_275_][i_277_] = i_279_ != 0 ? -i_279_ * 8 : 0;
              } else {
                this.vertexHeights[i_276_][i_275_][i_277_] = this.vertexHeights[i_276_ - 1][i_275_][i_277_] - i_279_ * 8;
                break;
              }
              break;
            }
            if (i_278_ <= 49) {
              this.overlayFloorIds[i_276_][i_275_][i_277_] = class50_sub1_sub2.getSignedByte();
              this.overlayClippingPaths[i_276_][i_275_][i_277_] = (i_278_ - 2) / 4 | 0 | 0;
              this.overlayRotations[i_276_][i_275_][i_277_] = i_278_ - 2 + i_274_ & 3 | 0;
            } else if (i_278_ <= 81) {
              this.renderRuleFlags[i_276_][i_275_][i_277_] = i_278_ - 49 | 0;
            } else {
              this.underlayFloorIds[i_276_][i_275_][i_277_] = i_278_ - 81 | 0;
            }
          }
        }
      } else {
        for (; ; ) {
          {
            const i_280_ = class50_sub1_sub2.getUnsignedByte();
            if (i_280_ === 0) {
              break;
            }
            if (i_280_ === 1) {
              class50_sub1_sub2.getUnsignedByte();
              break;
            }
            if (i_280_ <= 49) {
              class50_sub1_sub2.getUnsignedByte();
            }
          }
        }
      }
    }
  };
  var Region = _Region;
  Region.hueRandomizer = (Math.random() * 17 | 0) - 8;
  Region.anIntArray143 = [0, -1, 0, 1];
  Region.lowestPlane = 99;
  Region.aByte154 = -80;
  Region.anIntArray158 = [1, 2, 4, 8];
  Region.anIntArray161 = [1, 0, -1, 0];
  Region.onBuildTimePlane = 0;
  Region.lightnessRandomizer = (Math.random() * 33 | 0) - 16;
  Region.anIntArray167 = [16, 32, 64, 128];
  Region.lowMemory = true;

  // osrs/cache/def/ItemDefinition.ts
  init_inject();
  var _ItemDefinition = class {
    constructor() {
      this.id = -1;
      if (this.primaryFemaleModel === void 0) {
        this.primaryFemaleModel = 0;
      }
      if (this.modelOffsetX === void 0) {
        this.modelOffsetX = 0;
      }
      if (this.description === void 0) {
        this.description = null;
      }
      if (this.name === void 0) {
        this.name = null;
      }
      if (this.femaleTranslation === void 0) {
        this.femaleTranslation = 0;
      }
      if (this.secondaryMaleModel === void 0) {
        this.secondaryMaleModel = 0;
      }
      if (this.team === void 0) {
        this.team = 0;
      }
      if (this.notedInfoId === void 0) {
        this.notedInfoId = 0;
      }
      if (this.primaryMaleHeadPiece === void 0) {
        this.primaryMaleHeadPiece = 0;
      }
      if (this.groundActions === void 0) {
        this.groundActions = null;
      }
      if (this.anInt339 === void 0) {
        this.anInt339 = 0;
      }
      if (this.modelOffsetY === void 0) {
        this.modelOffsetY = 0;
      }
      if (this.destColors === void 0) {
        this.destColors = null;
      }
      if (this.notedTemplateId === void 0) {
        this.notedTemplateId = 0;
      }
      if (this.value === void 0) {
        this.value = 0;
      }
      if (this.inventoryActions === void 0) {
        this.inventoryActions = null;
      }
      if (this.primaryMaleModel === void 0) {
        this.primaryMaleModel = 0;
      }
      if (this.ambience === void 0) {
        this.ambience = 0;
      }
      if (this.secondaryFemaleModel === void 0) {
        this.secondaryFemaleModel = 0;
      }
      if (this.modelRotationY === void 0) {
        this.modelRotationY = 0;
      }
      if (this.groundScaleY === void 0) {
        this.groundScaleY = 0;
      }
      if (this.diffusion === void 0) {
        this.diffusion = 0;
      }
      if (this.modelRotationX === void 0) {
        this.modelRotationX = 0;
      }
      if (this.modelId === void 0) {
        this.modelId = 0;
      }
      if (this.secondaryMaleHeadPiece === void 0) {
        this.secondaryMaleHeadPiece = 0;
      }
      if (this.secondaryFemaleHeadPiece === void 0) {
        this.secondaryFemaleHeadPiece = 0;
      }
      if (this.originalColours === void 0) {
        this.originalColours = null;
      }
      if (this.stackIds === void 0) {
        this.stackIds = null;
      }
      if (this.groundScaleX === void 0) {
        this.groundScaleX = 0;
      }
      if (this.tertiaryFemaleEquipmentModel === void 0) {
        this.tertiaryFemaleEquipmentModel = 0;
      }
      if (this.groundScaleZ === void 0) {
        this.groundScaleZ = 0;
      }
      if (this.modelScale === void 0) {
        this.modelScale = 0;
      }
      if (this.tertiaryMaleEquipmentModel === void 0) {
        this.tertiaryMaleEquipmentModel = 0;
      }
      if (this.stackable === void 0) {
        this.stackable = false;
      }
      if (this.anInt372 === void 0) {
        this.anInt372 = 0;
      }
      if (this.primaryFemaleHeadPiece === void 0) {
        this.primaryFemaleHeadPiece = 0;
      }
      if (this.stackAmounts === void 0) {
        this.stackAmounts = null;
      }
      if (this.members === void 0) {
        this.members = false;
      }
      if (this.maleTranslation === void 0) {
        this.maleTranslation = 0;
      }
    }
    static dispose() {
      _ItemDefinition.modelCache = null;
      _ItemDefinition.rgbImageCache = null;
      _ItemDefinition.offsets = null;
      _ItemDefinition.cache = null;
      _ItemDefinition.buffer = null;
    }
    static lookup(id) {
      for (let i = 0; i < 10; i++) {
        if (_ItemDefinition.cache[i].id === id) {
          return _ItemDefinition.cache[i];
        }
      }
      _ItemDefinition.cacheIndex = (_ItemDefinition.cacheIndex + 1) % 10;
      const definition = _ItemDefinition.cache[_ItemDefinition.cacheIndex];
      _ItemDefinition.buffer.currentPosition = _ItemDefinition.offsets[id];
      definition.id = id;
      definition.reset();
      definition.decode(_ItemDefinition.buffer);
      if (definition.notedTemplateId !== -1) {
        definition.toNote();
      }
      if (!_ItemDefinition.memberServer && definition.members) {
        definition.name = "Members Object";
        definition.description = "Login to a members' server to use this object.".split("").map((s) => s.charCodeAt(0));
        definition.groundActions = null;
        definition.inventoryActions = null;
        definition.team = 0;
      }
      return definition;
    }
    static load(archive) {
      _ItemDefinition.buffer = new Buffer3(archive.getFile("obj.dat"));
      const buffer = new Buffer3(archive.getFile("obj.idx"));
      _ItemDefinition.count = buffer.getUnsignedLEShort();
      _ItemDefinition.offsets = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(_ItemDefinition.count);
      let index = 2;
      for (let i = 0; i < _ItemDefinition.count; i++) {
        {
          _ItemDefinition.offsets[i] = index;
          index += buffer.getUnsignedLEShort();
        }
      }
      _ItemDefinition.cache = [null, null, null, null, null, null, null, null, null, null];
      for (let i = 0; i < 10; i++) {
        _ItemDefinition.cache[i] = new _ItemDefinition();
      }
    }
    static sprite(id, stackSize, backColour) {
      if (backColour === 0) {
        let sprite = _ItemDefinition.rgbImageCache.get(id);
        if (sprite != null && sprite.maxHeight !== stackSize && sprite.maxHeight !== -1) {
          sprite.remove();
          sprite = null;
        }
        if (sprite != null) {
          return sprite;
        }
      }
      let definition = _ItemDefinition.lookup(id);
      if (definition.stackIds == null) {
        stackSize = -1;
      }
      if (stackSize > 1) {
        let stackId = -1;
        for (let i = 0; i < 10; i++) {
          if (stackSize >= definition.stackAmounts[i] && definition.stackAmounts[i] !== 0) {
            stackId = definition.stackIds[i];
          }
        }
        if (stackId !== -1) {
          definition = _ItemDefinition.lookup(stackId);
        }
      }
      const model = definition.asGroundStack(1);
      if (model == null) {
        return null;
      }
      let notedSprite = null;
      if (definition.notedTemplateId !== -1) {
        notedSprite = _ItemDefinition.sprite(definition.notedInfoId, 10, -1);
        if (notedSprite == null) {
          return null;
        }
      }
      const rendered = ImageRGB.from(32, 32);
      const centreX = Rasterizer3D.centerX;
      const centerY = Rasterizer3D.centerY;
      const lineOffsets = Rasterizer3D.lineOffsets;
      const pixels = Rasterizer.pixels;
      const width = Rasterizer.width;
      const height = Rasterizer.height;
      const topX = Rasterizer.topX;
      const bottomX = Rasterizer.bottomX;
      const topY = Rasterizer.topY;
      const bottomY = Rasterizer.bottomY;
      Rasterizer3D.approximateAlphaBlending = false;
      Rasterizer.createRasterizer(rendered.pixels, 32, 32);
      Rasterizer.drawFilledRectangle(0, 0, 32, 32, 0);
      Rasterizer3D.setDefaultBoundaries();
      let scale = definition.modelScale;
      if (backColour === -1) {
        scale = scale * 1.5 | 0;
      }
      if (backColour > 0) {
        scale = scale * 1.04 | 0;
      }
      const sin = Rasterizer3D.SINE[definition.modelRotationX] * scale >> 16;
      const cos = Rasterizer3D.COSINE[definition.modelRotationX] * scale >> 16;
      model.render(0, definition.modelRotationY, definition.anInt339, definition.modelRotationX, definition.modelOffsetX, sin + (model.modelHeight / 2 | 0) + definition.modelOffsetY, cos + definition.modelOffsetY);
      for (let x2 = 31; x2 >= 0; x2--) {
        {
          for (let y = 31; y >= 0; y--) {
            if (rendered.pixels[x2 + y * 32] === 0) {
              if (x2 > 0 && rendered.pixels[x2 - 1 + y * 32] > 1) {
                rendered.pixels[x2 + y * 32] = 1;
              } else if (y > 0 && rendered.pixels[x2 + (y - 1) * 32] > 1) {
                rendered.pixels[x2 + y * 32] = 1;
              } else if (x2 < 31 && rendered.pixels[x2 + 1 + y * 32] > 1) {
                rendered.pixels[x2 + y * 32] = 1;
              } else if (y < 31 && rendered.pixels[x2 + (y + 1) * 32] > 1) {
                rendered.pixels[x2 + y * 32] = 1;
              }
            }
          }
        }
      }
      if (backColour > 0) {
        for (let x2 = 31; x2 >= 0; x2--) {
          {
            for (let y = 31; y >= 0; y--) {
              if (rendered.pixels[x2 + y * 32] === 0) {
                if (x2 > 0 && rendered.pixels[x2 - 1 + y * 32] === 1) {
                  rendered.pixels[x2 + y * 32] = backColour;
                } else if (y > 0 && rendered.pixels[x2 + (y - 1) * 32] === 1) {
                  rendered.pixels[x2 + y * 32] = backColour;
                } else if (x2 < 31 && rendered.pixels[x2 + 1 + y * 32] === 1) {
                  rendered.pixels[x2 + y * 32] = backColour;
                } else if (y < 31 && rendered.pixels[x2 + (y + 1) * 32] === 1) {
                  rendered.pixels[x2 + y * 32] = backColour;
                }
              }
            }
          }
        }
      } else if (backColour === 0) {
        for (let x2 = 31; x2 >= 0; x2--) {
          {
            for (let y = 31; y >= 0; y--) {
              if (rendered.pixels[x2 + y * 32] === 0 && x2 > 0 && y > 0 && rendered.pixels[x2 - 1 + (y - 1) * 32] > 0) {
                rendered.pixels[x2 + y * 32] = 3153952;
              }
            }
          }
        }
      }
      if (definition.notedTemplateId !== -1) {
        const resizeWidth = notedSprite.maxWidth;
        const resizeHeight = notedSprite.maxHeight;
        notedSprite.maxWidth = 32;
        notedSprite.maxHeight = 32;
        notedSprite.drawImage(0, 0);
        notedSprite.maxWidth = resizeWidth;
        notedSprite.maxHeight = resizeHeight;
      }
      if (backColour === 0) {
        _ItemDefinition.rgbImageCache.put(rendered, id);
      }
      Rasterizer.createRasterizer(pixels, width, height);
      Rasterizer.setCoordinates(topY, topX, bottomY, bottomX);
      Rasterizer3D.centerX = centreX;
      Rasterizer3D.centerY = centerY;
      Rasterizer3D.lineOffsets = lineOffsets;
      Rasterizer3D.approximateAlphaBlending = true;
      if (definition.stackable) {
        rendered.maxWidth = 33;
      } else {
        rendered.maxWidth = 32;
      }
      rendered.maxHeight = stackSize;
      return rendered;
    }
    reset() {
      this.modelId = 0;
      this.name = null;
      this.description = null;
      this.originalColours = null;
      this.destColors = null;
      this.modelScale = 2e3;
      this.modelRotationX = 0;
      this.modelRotationY = 0;
      this.anInt339 = 0;
      this.modelOffsetX = 0;
      this.modelOffsetY = 0;
      this.anInt372 = -1;
      this.stackable = false;
      this.value = 1;
      this.members = false;
      this.groundActions = null;
      this.inventoryActions = null;
      this.primaryMaleModel = -1;
      this.secondaryMaleModel = -1;
      this.maleTranslation = 0;
      this.primaryFemaleModel = -1;
      this.secondaryFemaleModel = -1;
      this.femaleTranslation = 0;
      this.tertiaryMaleEquipmentModel = -1;
      this.tertiaryFemaleEquipmentModel = -1;
      this.primaryMaleHeadPiece = -1;
      this.secondaryMaleHeadPiece = -1;
      this.primaryFemaleHeadPiece = -1;
      this.secondaryFemaleHeadPiece = -1;
      this.stackIds = null;
      this.stackAmounts = null;
      this.notedInfoId = -1;
      this.notedTemplateId = -1;
      this.groundScaleX = 128;
      this.groundScaleY = 128;
      this.groundScaleZ = 128;
      this.ambience = 0;
      this.diffusion = 0;
      this.team = 0;
    }
    headPieceReady(gender) {
      let primary = this.primaryMaleHeadPiece;
      let secondary = this.secondaryMaleHeadPiece;
      if (gender === 1) {
        primary = this.primaryFemaleHeadPiece;
        secondary = this.secondaryFemaleHeadPiece;
      }
      if (primary === -1) {
        return true;
      }
      let ready = true;
      if (!Model.loaded(primary)) {
        ready = false;
      }
      if (secondary !== -1 && !Model.loaded(secondary)) {
        ready = false;
      }
      return ready;
    }
    asEquipment(gender) {
      let primaryId = this.primaryMaleModel;
      let secondaryId = this.secondaryMaleModel;
      let tertiaryId = this.tertiaryMaleEquipmentModel;
      if (gender === 1) {
        primaryId = this.primaryFemaleModel;
        secondaryId = this.secondaryFemaleModel;
        tertiaryId = this.tertiaryFemaleEquipmentModel;
      }
      if (primaryId === -1) {
        return null;
      }
      let primary = Model.getModel(primaryId);
      if (secondaryId !== -1) {
        if (tertiaryId !== -1) {
          const secondary = Model.getModel(secondaryId);
          const tertiary = Model.getModel(tertiaryId);
          const parts = [primary, secondary, tertiary];
          primary = new Model(3, parts);
        } else {
          const secondary = Model.getModel(secondaryId);
          const parts = [primary, secondary];
          primary = new Model(2, parts);
        }
      }
      if (gender === 0 && this.maleTranslation !== 0) {
        primary.translate(0, 0, this.maleTranslation);
      }
      if (gender === 1 && this.femaleTranslation !== 0) {
        primary.translate(0, 0, this.femaleTranslation);
      }
      if (this.originalColours != null) {
        for (let color = 0; color < this.originalColours.length; color++) {
          primary.replaceColor(this.originalColours[color], this.destColors[color]);
        }
      }
      return primary;
    }
    toNote() {
      const graphics = _ItemDefinition.lookup(this.notedTemplateId);
      this.modelId = graphics.modelId;
      this.modelScale = graphics.modelScale;
      this.modelRotationX = graphics.modelRotationX;
      this.modelRotationY = graphics.modelRotationY;
      this.anInt339 = graphics.anInt339;
      this.modelOffsetX = graphics.modelOffsetX;
      this.modelOffsetY = graphics.modelOffsetY;
      this.originalColours = graphics.originalColours;
      this.destColors = graphics.destColors;
      const info = _ItemDefinition.lookup(this.notedInfoId);
      this.name = info.name;
      this.members = info.members;
      this.value = info.value;
      let prefix = "a";
      const firstChar = info.name.charAt(0);
      if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(firstChar) == "A".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(firstChar) == "E".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(firstChar) == "I".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(firstChar) == "O".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(firstChar) == "U".charCodeAt(0)) {
        prefix = "an";
      }
      this.description = ("Swap this note at any bank for " + prefix + " " + info.name + ".").split("").map((s) => s.charCodeAt(0));
      this.stackable = true;
    }
    equipmentReady(gender) {
      let primary = this.primaryMaleModel;
      let secondary = this.secondaryMaleModel;
      let tertiary = this.tertiaryMaleEquipmentModel;
      if (gender === 1) {
        primary = this.primaryFemaleModel;
        secondary = this.secondaryFemaleModel;
        tertiary = this.tertiaryFemaleEquipmentModel;
      }
      if (primary === -1) {
        return true;
      }
      let ready = true;
      if (!Model.loaded(primary)) {
        ready = false;
      }
      if (secondary !== -1 && !Model.loaded(secondary)) {
        ready = false;
      }
      if (tertiary !== -1 && !Model.loaded(tertiary)) {
        ready = false;
      }
      return ready;
    }
    asStack(stackSize) {
      if (this.stackIds != null && stackSize > 1) {
        let id = -1;
        for (let i = 0; i < 10; i++) {
          if (stackSize >= this.stackAmounts[i] && this.stackAmounts[i] !== 0) {
            id = this.stackIds[i];
          }
        }
        if (id !== -1) {
          return _ItemDefinition.lookup(id).asStack(1);
        }
      }
      const model = Model.getModel(this.modelId);
      if (model == null) {
        return null;
      }
      if (this.originalColours != null) {
        for (let i = 0; i < this.originalColours.length; i++) {
          model.replaceColor(this.originalColours[i], this.destColors[i]);
        }
      }
      return model;
    }
    decode(buffer) {
      while (true) {
        {
          const opcode = buffer.getUnsignedByte();
          if (opcode === 0) {
            return;
          }
          if (opcode === 1) {
            this.modelId = buffer.getUnsignedLEShort();
          } else if (opcode === 2) {
            this.name = buffer.getString();
          } else if (opcode === 3) {
            this.description = buffer.getStringBytes();
          } else if (opcode === 4) {
            this.modelScale = buffer.getUnsignedLEShort();
          } else if (opcode === 5) {
            this.modelRotationX = buffer.getUnsignedLEShort();
          } else if (opcode === 6) {
            this.modelRotationY = buffer.getUnsignedLEShort();
          } else if (opcode === 7) {
            this.modelOffsetX = buffer.getUnsignedLEShort();
            if (this.modelOffsetX > 32767) {
              this.modelOffsetX -= 65536;
            }
          } else if (opcode === 8) {
            this.modelOffsetY = buffer.getUnsignedLEShort();
            if (this.modelOffsetY > 32767) {
              this.modelOffsetY -= 65536;
            }
          } else if (opcode === 10) {
            buffer.getUnsignedLEShort();
          } else if (opcode === 11) {
            this.stackable = true;
          } else if (opcode === 12) {
            this.value = buffer.getInt();
          } else if (opcode === 16) {
            this.members = true;
          } else if (opcode === 23) {
            this.primaryMaleModel = buffer.getUnsignedLEShort();
            this.maleTranslation = buffer.getSignedByte();
          } else if (opcode === 24) {
            this.secondaryMaleModel = buffer.getUnsignedLEShort();
          } else if (opcode === 25) {
            this.primaryFemaleModel = buffer.getUnsignedLEShort();
            this.femaleTranslation = buffer.getSignedByte();
          } else if (opcode === 26) {
            this.secondaryFemaleModel = buffer.getUnsignedLEShort();
          } else if (opcode >= 30 && opcode < 35) {
            if (this.groundActions == null) {
              this.groundActions = [null, null, null, null, null];
            }
            this.groundActions[opcode - 30] = buffer.getString();
            if (((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(this.groundActions[opcode - 30], "hidden")) {
              this.groundActions[opcode - 30] = null;
            }
          } else if (opcode >= 35 && opcode < 40) {
            if (this.inventoryActions == null) {
              this.inventoryActions = [null, null, null, null, null];
            }
            this.inventoryActions[opcode - 35] = buffer.getString();
          } else if (opcode === 40) {
            const colorCount = buffer.getUnsignedByte();
            this.originalColours = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(colorCount);
            this.destColors = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(colorCount);
            for (let k = 0; k < colorCount; k++) {
              {
                this.originalColours[k] = buffer.getUnsignedLEShort();
                this.destColors[k] = buffer.getUnsignedLEShort();
              }
            }
          } else if (opcode === 78) {
            this.tertiaryMaleEquipmentModel = buffer.getUnsignedLEShort();
          } else if (opcode === 79) {
            this.tertiaryFemaleEquipmentModel = buffer.getUnsignedLEShort();
          } else if (opcode === 90) {
            this.primaryMaleHeadPiece = buffer.getUnsignedLEShort();
          } else if (opcode === 91) {
            this.primaryFemaleHeadPiece = buffer.getUnsignedLEShort();
          } else if (opcode === 92) {
            this.secondaryMaleHeadPiece = buffer.getUnsignedLEShort();
          } else if (opcode === 93) {
            this.secondaryFemaleHeadPiece = buffer.getUnsignedLEShort();
          } else if (opcode === 95) {
            this.anInt339 = buffer.getUnsignedLEShort();
          } else if (opcode === 97) {
            this.notedInfoId = buffer.getUnsignedLEShort();
          } else if (opcode === 98) {
            this.notedTemplateId = buffer.getUnsignedLEShort();
          } else if (opcode >= 100 && opcode < 110) {
            if (this.stackIds == null) {
              this.stackIds = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              this.stackAmounts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            }
            this.stackIds[opcode - 100] = buffer.getUnsignedLEShort();
            this.stackAmounts[opcode - 100] = buffer.getUnsignedLEShort();
          } else if (opcode === 110) {
            this.groundScaleX = buffer.getUnsignedLEShort();
          } else if (opcode === 111) {
            this.groundScaleY = buffer.getUnsignedLEShort();
          } else if (opcode === 112) {
            this.groundScaleZ = buffer.getUnsignedLEShort();
          } else if (opcode === 113) {
            this.ambience = buffer.getSignedByte();
          } else if (opcode === 114) {
            this.diffusion = buffer.getSignedByte() * 5;
          } else if (opcode === 115) {
            this.team = buffer.getUnsignedByte();
          }
        }
      }
    }
    asHeadPiece(gender) {
      let primaryId = this.primaryMaleHeadPiece;
      let secondaryId = this.secondaryMaleHeadPiece;
      if (gender === 1) {
        primaryId = this.primaryFemaleHeadPiece;
        secondaryId = this.secondaryFemaleHeadPiece;
      }
      if (primaryId === -1) {
        return null;
      }
      let primary = Model.getModel(primaryId);
      if (secondaryId !== -1) {
        const secondary = Model.getModel(secondaryId);
        primary = new Model(2, [primary, secondary]);
      }
      if (this.originalColours != null) {
        for (let index = 0; index < this.originalColours.length; index++) {
          primary.replaceColor(this.originalColours[index], this.destColors[index]);
        }
      }
      return primary;
    }
    asGroundStack(amount) {
      if (this.stackIds != null && amount > 1) {
        let id = -1;
        for (let i = 0; i < 10; i++) {
          if (amount >= this.stackAmounts[i] && this.stackAmounts[i] !== 0) {
            id = this.stackIds[i];
          }
        }
        if (id !== -1) {
          return _ItemDefinition.lookup(id).asGroundStack(1);
        }
      }
      let model = _ItemDefinition.modelCache.get(this.id);
      if (model != null) {
        return model;
      }
      model = Model.getModel(this.modelId);
      if (model == null) {
        return null;
      }
      if (this.groundScaleX !== 128 || this.groundScaleY !== 128 || this.groundScaleZ !== 128) {
        model.scaleT(this.groundScaleY, this.groundScaleZ, 9, this.groundScaleX);
      }
      if (this.originalColours != null) {
        for (let l = 0; l < this.originalColours.length; l++) {
          model.replaceColor(this.originalColours[l], this.destColors[l]);
        }
      }
      model.applyLighting(64 + this.ambience, 768 + this.diffusion, -50, -10, -50, true);
      model.oneSquareModel = true;
      _ItemDefinition.modelCache.put(model, this.id);
      return model;
    }
  };
  var ItemDefinition = _ItemDefinition;
  ItemDefinition.count = 0;
  ItemDefinition.cache = null;
  ItemDefinition.modelCache = new Cache(50);
  ItemDefinition.offsets = null;
  ItemDefinition.memberServer = true;
  ItemDefinition.rgbImageCache = new Cache(100);
  ItemDefinition.aBoolean350 = true;
  ItemDefinition.cacheIndex = 0;
  ItemDefinition.buffer = null;
  ItemDefinition.rgbImageCache;
  ItemDefinition.modelCache;

  // osrs/cache/def/ActorDefinition.ts
  init_inject();
  var _ActorDefinition = class {
    constructor() {
      this.standAnimationId = -1;
      this.anInt627 = -1;
      this.id = -1;
      this.sizeY = 128;
      this.clickable = true;
      this.sizeXZ = 128;
      this.turnLeftAnimationId = -1;
      this.minimapVisible = true;
      this.anInt637 = -1;
      this.headIcon = -1;
      this.combatLevel = -1;
      this.turnRightAnimationId = -1;
      this.boundaryDimension = 1;
      this.turnAroundAnimationId = -1;
      this.visible = false;
      this.walkAnimationId = -1;
      this.anInt648 = -1;
      this.degreesToTurn = 32;
      this.name = "null";
      this.varBitId = -1;
      this.settingId = -1;
      if (this.childrenIds === void 0) {
        this.childrenIds = null;
      }
      if (this.headModelIndexes === void 0) {
        this.headModelIndexes = null;
      }
      if (this.modelIds === void 0) {
        this.modelIds = null;
      }
      if (this.modifiedModelColors === void 0) {
        this.modifiedModelColors = null;
      }
      if (this.actions === void 0) {
        this.actions = null;
      }
      if (this.originalModelColors === void 0) {
        this.originalModelColors = null;
      }
      if (this.contrast === void 0) {
        this.contrast = 0;
      }
      if (this.description === void 0) {
        this.description = null;
      }
      if (this.brightness === void 0) {
        this.brightness = 0;
      }
    }
    static getDefinition(id) {
      for (let j = 0; j < 20; j++) {
        if (_ActorDefinition.cache[j].id === id) {
          return _ActorDefinition.cache[j];
        }
      }
      _ActorDefinition.bufferIndex = (_ActorDefinition.bufferIndex + 1) % 20;
      const definition = _ActorDefinition.cache[_ActorDefinition.bufferIndex] = new _ActorDefinition();
      _ActorDefinition.buffer.currentPosition = _ActorDefinition.bufferOffsets[id];
      definition.id = id;
      definition.loadDefinition(_ActorDefinition.buffer);
      return definition;
    }
    static reset() {
      _ActorDefinition.modelCache = null;
      _ActorDefinition.bufferOffsets = null;
      _ActorDefinition.cache = null;
      _ActorDefinition.buffer = null;
    }
    static load(archive) {
      _ActorDefinition.buffer = new Buffer3(archive.getFile("npc.dat"));
      const buffer = new Buffer3(archive.getFile("npc.idx"));
      _ActorDefinition.size = buffer.getUnsignedLEShort();
      _ActorDefinition.bufferOffsets = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(_ActorDefinition.size);
      let offset = 2;
      for (let bufferIndex = 0; bufferIndex < _ActorDefinition.size; bufferIndex++) {
        {
          _ActorDefinition.bufferOffsets[bufferIndex] = offset;
          offset += buffer.getUnsignedLEShort();
        }
      }
      _ActorDefinition.cache = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(20);
      for (let cacheIndex = 0; cacheIndex < 20; cacheIndex++) {
        _ActorDefinition.cache[cacheIndex] = new _ActorDefinition();
      }
    }
    loadDefinition(buffer) {
      do {
        {
          const attributeId = buffer.getUnsignedByte();
          if (attributeId === 0) {
            return;
          }
          if (attributeId === 1) {
            const modelCount = buffer.getUnsignedByte();
            this.modelIds = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(modelCount);
            for (let model = 0; model < modelCount; model++) {
              this.modelIds[model] = buffer.getUnsignedLEShort();
            }
          } else if (attributeId === 2) {
            this.name = buffer.getString();
          } else if (attributeId === 3) {
            this.description = buffer.getStringBytes();
          } else if (attributeId === 12) {
            this.boundaryDimension = buffer.getSignedByte();
          } else if (attributeId === 13) {
            this.standAnimationId = buffer.getUnsignedLEShort();
          } else if (attributeId === 14) {
            this.walkAnimationId = buffer.getUnsignedLEShort();
          } else if (attributeId === 17) {
            this.walkAnimationId = buffer.getUnsignedLEShort();
            this.turnAroundAnimationId = buffer.getUnsignedLEShort();
            this.turnRightAnimationId = buffer.getUnsignedLEShort();
            this.turnLeftAnimationId = buffer.getUnsignedLEShort();
          } else if (attributeId >= 30 && attributeId < 40) {
            if (this.actions == null) {
              this.actions = [null, null, null, null, null];
            }
            this.actions[attributeId - 30] = buffer.getString();
            if (((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(this.actions[attributeId - 30], "hidden")) {
              this.actions[attributeId - 30] = null;
            }
          } else if (attributeId === 40) {
            const modelColorCount = buffer.getUnsignedByte();
            this.modifiedModelColors = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(modelColorCount);
            this.originalModelColors = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(modelColorCount);
            for (let colour = 0; colour < modelColorCount; colour++) {
              {
                this.modifiedModelColors[colour] = buffer.getUnsignedLEShort();
                this.originalModelColors[colour] = buffer.getUnsignedLEShort();
              }
            }
          } else if (attributeId === 60) {
            const additionalModelCount = buffer.getUnsignedByte();
            this.headModelIndexes = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(additionalModelCount);
            for (let model = 0; model < additionalModelCount; model++) {
              this.headModelIndexes[model] = buffer.getUnsignedLEShort();
            }
          } else if (attributeId === 90) {
            this.anInt648 = buffer.getUnsignedLEShort();
          } else if (attributeId === 91) {
            this.anInt627 = buffer.getUnsignedLEShort();
          } else if (attributeId === 92) {
            this.anInt637 = buffer.getUnsignedLEShort();
          } else if (attributeId === 93) {
            this.minimapVisible = false;
          } else if (attributeId === 95) {
            this.combatLevel = buffer.getUnsignedLEShort();
          } else if (attributeId === 97) {
            this.sizeXZ = buffer.getUnsignedLEShort();
          } else if (attributeId === 98) {
            this.sizeY = buffer.getUnsignedLEShort();
          } else if (attributeId === 99) {
            this.visible = true;
          } else if (attributeId === 100) {
            this.brightness = buffer.getSignedByte();
          } else if (attributeId === 101) {
            this.contrast = buffer.getSignedByte() * 5;
          } else if (attributeId === 102) {
            this.headIcon = buffer.getUnsignedLEShort();
          } else if (attributeId === 103) {
            this.degreesToTurn = buffer.getUnsignedLEShort();
          } else if (attributeId === 106) {
            this.varBitId = buffer.getUnsignedLEShort();
            if (this.varBitId === 65535) {
              this.varBitId = -1;
            }
            this.settingId = buffer.getUnsignedLEShort();
            if (this.settingId === 65535) {
              this.settingId = -1;
            }
            const childrenCount = buffer.getUnsignedByte();
            this.childrenIds = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(childrenCount + 1);
            for (let child = 0; child <= childrenCount; child++) {
              {
                this.childrenIds[child] = buffer.getUnsignedLEShort();
                if (this.childrenIds[child] === 65535) {
                  this.childrenIds[child] = -1;
                }
              }
            }
          } else if (attributeId === 107) {
            this.clickable = false;
          }
        }
      } while (true);
    }
    getHeadModel() {
      if (this.childrenIds != null) {
        const definition = this.getChildDefinition();
        if (definition == null) {
          return null;
        } else {
          return definition.getHeadModel();
        }
      }
      if (this.headModelIndexes == null) {
        return null;
      }
      let cached = false;
      for (let headModel2 = 0; headModel2 < this.headModelIndexes.length; headModel2++) {
        if (!Model.loaded(this.headModelIndexes[headModel2])) {
          cached = true;
        }
      }
      if (cached) {
        return null;
      }
      const headModels = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(this.headModelIndexes.length);
      for (let model = 0; model < this.headModelIndexes.length; model++) {
        headModels[model] = Model.getModel(this.headModelIndexes[model]);
      }
      let headModel;
      if (headModels.length === 1) {
        headModel = headModels[0];
      } else {
        headModel = new Model(headModels.length, headModels);
      }
      if (this.modifiedModelColors != null) {
        for (let colour = 0; colour < this.modifiedModelColors.length; colour++) {
          headModel.replaceColor(this.modifiedModelColors[colour], this.originalModelColors[colour]);
        }
      }
      return headModel;
    }
    method360() {
      if (this.childrenIds == null) {
        return true;
      }
      let j = -1;
      if (this.varBitId !== -1) {
        const class49 = Varbit.cache[this.varBitId];
        const k = class49.configId;
        const l = class49.leastSignificantBit;
        const i1 = class49.mostSignificantBit;
        const j1 = Game.BITFIELD_MAX_VALUE[i1 - l];
        j = _ActorDefinition.client.widgetSettings[k] >> l & j1;
      } else if (this.settingId !== -1) {
        j = _ActorDefinition.client.widgetSettings[this.settingId];
      }
      return j >= 0 && j < this.childrenIds.length && this.childrenIds[j] !== -1;
    }
    getChildModel(frameId2, frameId, framesFrom2) {
      if (this.childrenIds != null) {
        const childDefinition = this.getChildDefinition();
        if (childDefinition == null) {
          return null;
        } else {
          return childDefinition.getChildModel(frameId2, frameId, framesFrom2);
        }
      }
      let childIdModel = _ActorDefinition.modelCache.get(this.id);
      if (childIdModel == null) {
        let cached = false;
        for (let modelId = 0; modelId < this.modelIds.length; modelId++) {
          if (!Model.loaded(this.modelIds[modelId])) {
            cached = true;
          }
        }
        if (cached) {
          return null;
        }
        const childModels = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(this.modelIds.length);
        for (let model = 0; model < this.modelIds.length; model++) {
          childModels[model] = Model.getModel(this.modelIds[model]);
        }
        if (childModels.length === 1) {
          childIdModel = childModels[0];
        } else {
          childIdModel = new Model(childModels.length, childModels);
        }
        if (this.modifiedModelColors != null) {
          for (let colour = 0; colour < this.modifiedModelColors.length; colour++) {
            childIdModel.replaceColor(this.modifiedModelColors[colour], this.originalModelColors[colour]);
          }
        }
        childIdModel.createBones();
        childIdModel.applyLighting(64 + this.brightness, 850 + this.contrast, -30, -50, -30, true);
        _ActorDefinition.modelCache.put(childIdModel, this.id);
      }
      const childModel = Model.EMPTY_MODEL;
      childModel.replaceWithModel(childIdModel, ((lhs, rhs) => lhs && rhs)(Animation.exists(frameId2), Animation.exists(frameId)));
      if (frameId2 !== -1 && frameId !== -1) {
        childModel.mixAnimationFrames(frameId, 0, frameId2, framesFrom2);
      } else if (frameId2 !== -1) {
        childModel.applyTransform(frameId2);
      }
      if (this.sizeXZ !== 128 || this.sizeY !== 128) {
        childModel.scaleT(this.sizeY, this.sizeXZ, 9, this.sizeXZ);
      }
      childModel.calculateDiagonals();
      childModel.triangleSkin = null;
      childModel.vectorSkin = null;
      if (this.boundaryDimension === 1) {
        childModel.oneSquareModel = true;
      }
      return childModel;
    }
    getChildDefinition() {
      let childId = -1;
      if (this.varBitId !== -1) {
        const varbit = Varbit.cache[this.varBitId];
        const configId = varbit.configId;
        const leastSignificantBit = varbit.leastSignificantBit;
        const mostSignificantBit = varbit.mostSignificantBit;
        const bit = Game.BITFIELD_MAX_VALUE[mostSignificantBit - leastSignificantBit];
        childId = _ActorDefinition.client.widgetSettings[configId] >> leastSignificantBit & bit;
      } else if (this.settingId !== -1) {
        childId = _ActorDefinition.client.widgetSettings[this.settingId];
      }
      if (childId < 0 || childId >= this.childrenIds.length || this.childrenIds[childId] === -1) {
        return null;
      } else {
        return _ActorDefinition.getDefinition(this.childrenIds[childId]);
      }
    }
  };
  var ActorDefinition = _ActorDefinition;
  ActorDefinition.client = null;
  ActorDefinition.modelCache = new Cache(30);
  ActorDefinition.size = 0;
  ActorDefinition.bufferOffsets = null;
  ActorDefinition.cache = null;
  ActorDefinition.buffer = null;
  ActorDefinition.bufferIndex = 0;

  // osrs/cache/media/IdentityKit.ts
  init_inject();
  var _IdentityKit = class {
    constructor() {
      this.partId = -1;
      this.originalModelColors = [0, 0, 0, 0, 0, 0];
      this.modifiedModelColors = [0, 0, 0, 0, 0, 0];
      this.headModelIds = [-1, -1, -1, -1, -1];
      this.widgetDisplayed = false;
      if (this.modelId === void 0) {
        this.modelId = null;
      }
    }
    static load(archive) {
      const buffer = new Buffer3(archive.getFile("idk.dat"));
      _IdentityKit.count = buffer.getUnsignedLEShort();
      if (_IdentityKit.cache == null) {
        _IdentityKit.cache = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(_IdentityKit.count);
      }
      for (let identityKit = 0; identityKit < _IdentityKit.count; identityKit++) {
        {
          if (_IdentityKit.cache[identityKit] == null) {
            _IdentityKit.cache[identityKit] = new _IdentityKit();
          }
          _IdentityKit.cache[identityKit].loadDefinition(buffer);
        }
      }
    }
    loadDefinition(buffer) {
      while (true) {
        {
          const attributeId = buffer.getUnsignedByte();
          if (attributeId === 0) {
            return;
          }
          if (attributeId === 1) {
            this.partId = buffer.getUnsignedByte();
          } else if (attributeId === 2) {
            const modelCount = buffer.getUnsignedByte();
            this.modelId = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(modelCount);
            for (let model = 0; model < modelCount; model++) {
              this.modelId[model] = buffer.getUnsignedLEShort();
            }
          } else if (attributeId === 3) {
            this.widgetDisplayed = true;
          } else if (attributeId >= 40 && attributeId < 50) {
            this.originalModelColors[attributeId - 40] = buffer.getUnsignedLEShort();
          } else if (attributeId >= 50 && attributeId < 60) {
            this.modifiedModelColors[attributeId - 50] = buffer.getUnsignedLEShort();
          } else if (attributeId >= 60 && attributeId < 70) {
            this.headModelIds[attributeId - 60] = buffer.getUnsignedLEShort();
          } else {
            console.info("Error unrecognised config code: " + attributeId);
          }
        }
      }
    }
    isBodyModelCached() {
      if (this.modelId == null) {
        return true;
      }
      let isCached = true;
      for (let i = 0; i < this.modelId.length; i++) {
        if (!Model.loaded(this.modelId[i])) {
          isCached = false;
        }
      }
      return isCached;
    }
    getBodyModel() {
      if (this.modelId == null) {
        return null;
      }
      const models = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(this.modelId.length);
      for (let model2 = 0; model2 < this.modelId.length; model2++) {
        models[model2] = Model.getModel(this.modelId[model2]);
      }
      let model;
      if (models.length === 1) {
        model = models[0];
      } else {
        model = new Model(models.length, models);
      }
      for (let color = 0; color < 6; color++) {
        {
          if (this.originalModelColors[color] === 0) {
            break;
          }
          model.replaceColor(this.originalModelColors[color], this.modifiedModelColors[color]);
        }
      }
      return model;
    }
    isHeadModelCached() {
      let cached = true;
      for (let model = 0; model < 5; model++) {
        if (this.headModelIds[model] !== -1 && !Model.loaded(this.headModelIds[model])) {
          cached = false;
        }
      }
      return cached;
    }
    getHeadModel() {
      const models = [null, null, null, null, null];
      let count = 0;
      for (let model2 = 0; model2 < 5; model2++) {
        if (this.headModelIds[model2] !== -1) {
          models[count++] = Model.getModel(this.headModelIds[model2]);
        }
      }
      const model = new Model(count, models);
      for (let color = 0; color < 6; color++) {
        {
          if (this.originalModelColors[color] === 0) {
            break;
          }
          model.replaceColor(this.originalModelColors[color], this.modifiedModelColors[color]);
        }
      }
      return model;
    }
  };
  var IdentityKit = _IdentityKit;
  IdentityKit.count = 0;
  IdentityKit.cache = null;

  // osrs/cache/media/SpotAnimation.ts
  init_inject();
  var _SpotAnimation = class {
    constructor() {
      this.animationId = -1;
      this.originalModelColors = [0, 0, 0, 0, 0, 0];
      this.modifiedModelColors = [0, 0, 0, 0, 0, 0];
      this.resizeXY = 128;
      this.resizeZ = 128;
      if (this.id === void 0) {
        this.id = 0;
      }
      if (this.modelId === void 0) {
        this.modelId = 0;
      }
      if (this.sequences === void 0) {
        this.sequences = null;
      }
      if (this.rotation === void 0) {
        this.rotation = 0;
      }
      if (this.modelLightFalloff === void 0) {
        this.modelLightFalloff = 0;
      }
      if (this.modelLightAmbient === void 0) {
        this.modelLightAmbient = 0;
      }
    }
    static load(archive) {
      const buffer = new Buffer3(archive.getFile("spotanim.dat"));
      _SpotAnimation.spotAnimationCount = buffer.getUnsignedLEShort();
      if (_SpotAnimation.cache == null) {
        _SpotAnimation.cache = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(_SpotAnimation.spotAnimationCount);
      }
      for (let spotAnimation = 0; spotAnimation < _SpotAnimation.spotAnimationCount; spotAnimation++) {
        {
          if (_SpotAnimation.cache[spotAnimation] == null) {
            _SpotAnimation.cache[spotAnimation] = new _SpotAnimation();
          }
          _SpotAnimation.cache[spotAnimation].id = spotAnimation;
          _SpotAnimation.cache[spotAnimation].loadDefinition(buffer);
        }
      }
    }
    loadDefinition(buffer) {
      while (true) {
        {
          const attributeId = buffer.getUnsignedByte();
          if (attributeId === 0) {
            return;
          }
          if (attributeId === 1) {
            this.modelId = buffer.getUnsignedLEShort();
          } else if (attributeId === 2) {
            this.animationId = buffer.getUnsignedLEShort();
            if (AnimationSequence.animations != null) {
              this.sequences = AnimationSequence.animations[this.animationId];
            }
          } else if (attributeId === 4) {
            this.resizeXY = buffer.getUnsignedLEShort();
          } else if (attributeId === 5) {
            this.resizeZ = buffer.getUnsignedLEShort();
          } else if (attributeId === 6) {
            this.rotation = buffer.getUnsignedLEShort();
          } else if (attributeId === 7) {
            this.modelLightFalloff = buffer.getUnsignedByte();
          } else if (attributeId === 8) {
            this.modelLightAmbient = buffer.getUnsignedByte();
          } else if (attributeId >= 40 && attributeId < 50) {
            this.originalModelColors[attributeId - 40] = buffer.getUnsignedLEShort();
          } else if (attributeId >= 50 && attributeId < 60) {
            this.modifiedModelColors[attributeId - 50] = buffer.getUnsignedLEShort();
          } else {
            console.info("Error unrecognised spotanim config code: " + attributeId);
          }
        }
      }
    }
    getModel() {
      let model = _SpotAnimation.modelCache.get(this.id);
      if (model != null) {
        return model;
      }
      model = Model.getModel(this.modelId);
      if (model == null) {
        return null;
      }
      for (let nodelColor = 0; nodelColor < 6; nodelColor++) {
        if (this.originalModelColors[0] !== 0) {
          model.replaceColor(this.originalModelColors[nodelColor], this.modifiedModelColors[nodelColor]);
        }
      }
      _SpotAnimation.modelCache.put(model, this.id);
      return model;
    }
  };
  var SpotAnimation = _SpotAnimation;
  SpotAnimation.spotAnimationCount = 0;
  SpotAnimation.cache = null;
  SpotAnimation.modelCache = new Cache(30);

  // osrs/sound/SoundTrack.ts
  init_inject();

  // osrs/sound/SoundTrackInstrument.ts
  init_inject();

  // osrs/sound/SoundFilter.ts
  init_inject();
  var _SoundFilter = class {
    constructor() {
      this.numPairs = [0, 0];
      this.pairPhase = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([2, 2, 4]);
      this.magnitude = function(dims) {
        const allocate = function(dims2) {
          if (dims2.length == 0) {
            return 0;
          } else {
            const array = [];
            for (let i = 0; i < dims2[0]; i++) {
              array.push(allocate(dims2.slice(1)));
            }
            return array;
          }
        };
        return allocate(dims);
      }([2, 2, 4]);
      this.unity = [0, 0];
    }
    adaptMagnitude(i, f, dir) {
      let alpha = Math.fround(this.magnitude[i][0][dir] + Math.fround(f * (this.magnitude[i][1][dir] - this.magnitude[i][0][dir])));
      alpha *= 1525879e-9;
      return Math.fround(1 - Math.fround(Math.pow(10, Math.fround(-alpha / 20))));
    }
    normalize(f) {
      const f1 = Math.fround(32.7032 * Math.fround(Math.pow(2, f)));
      return Math.fround(Math.fround(f1 * 3.141593) / 11025);
    }
    adaptPhase(i, dir, f) {
      let f1 = Math.fround(this.pairPhase[dir][0][i] + Math.fround(f * (this.pairPhase[dir][1][i] - this.pairPhase[dir][0][i])));
      f1 *= 1220703e-10;
      return this.normalize(f1);
    }
    compute(dir, f) {
      if (dir === 0) {
        let f1 = Math.fround(this.unity[0] + Math.fround((this.unity[1] - this.unity[0]) * f));
        f1 *= 3051758e-9;
        _SoundFilter._invUnity = Math.fround(Math.pow(0.1, Math.fround(f1 / 20)));
        _SoundFilter.invUnity = Math.fround(_SoundFilter._invUnity * 65536) | 0;
      }
      if (this.numPairs[dir] === 0) {
        return 0;
      }
      const f2 = this.adaptMagnitude(dir, f, 0);
      _SoundFilter._coefficient[dir][0] = Math.fround(Math.fround(-2 * f2) * Math.fround(Math.cos(this.adaptPhase(0, dir, f))));
      _SoundFilter._coefficient[dir][1] = Math.fround(f2 * f2);
      for (let term = 1; term < this.numPairs[dir]; term++) {
        {
          const f3 = this.adaptMagnitude(dir, f, term);
          const f4 = Math.fround(Math.fround(-2 * f3) * Math.fround(Math.cos(this.adaptPhase(term, dir, f))));
          const f5 = Math.fround(f3 * f3);
          _SoundFilter._coefficient[dir][term * 2 + 1] = Math.fround(_SoundFilter._coefficient[dir][term * 2 - 1] * f5);
          _SoundFilter._coefficient[dir][term * 2] = Math.fround(Math.fround(_SoundFilter._coefficient[dir][term * 2 - 1] * f4) + Math.fround(_SoundFilter._coefficient[dir][term * 2 - 2] * f5));
          for (let i = term * 2 - 1; i >= 2; i--) {
            _SoundFilter._coefficient[dir][i] += Math.fround(Math.fround(_SoundFilter._coefficient[dir][i - 1] * f4) + Math.fround(_SoundFilter._coefficient[dir][i - 2] * f5));
          }
          _SoundFilter._coefficient[dir][1] += Math.fround(Math.fround(_SoundFilter._coefficient[dir][0] * f4) + f5);
          _SoundFilter._coefficient[dir][0] += f4;
        }
      }
      if (dir === 0) {
        for (let l = 0; l < this.numPairs[0] * 2; l++) {
          _SoundFilter._coefficient[0][l] *= _SoundFilter._invUnity;
        }
      }
      for (let term = 0; term < this.numPairs[dir] * 2; term++) {
        _SoundFilter.coefficient[dir][term] = Math.fround(_SoundFilter._coefficient[dir][term] * 65536) | 0;
      }
      return this.numPairs[dir] * 2;
    }
    decode(soundTrackEnvelope, buffer) {
      const numPair = buffer.getUnsignedByte();
      this.numPairs[0] = numPair >> 4;
      this.numPairs[1] = numPair & 15;
      if (numPair !== 0) {
        this.unity[0] = buffer.getUnsignedLEShort();
        this.unity[1] = buffer.getUnsignedLEShort();
        const migrated = buffer.getUnsignedByte();
        for (let dir = 0; dir < 2; dir++) {
          {
            for (let term = 0; term < this.numPairs[dir]; term++) {
              {
                this.pairPhase[dir][0][term] = buffer.getUnsignedLEShort();
                this.magnitude[dir][0][term] = buffer.getUnsignedLEShort();
              }
            }
          }
        }
        for (let dir = 0; dir < 2; dir++) {
          {
            for (let term = 0; term < this.numPairs[dir]; term++) {
              if ((migrated & 1 << dir * 4 << term) !== 0) {
                this.pairPhase[dir][1][term] = buffer.getUnsignedLEShort();
                this.magnitude[dir][1][term] = buffer.getUnsignedLEShort();
              } else {
                this.pairPhase[dir][1][term] = this.pairPhase[dir][0][term];
                this.magnitude[dir][1][term] = this.magnitude[dir][0][term];
              }
            }
          }
        }
        if (migrated !== 0 || this.unity[1] !== this.unity[0]) {
          soundTrackEnvelope.decodeShape(buffer);
        }
        return;
      } else {
        this.unity[0] = this.unity[1] = 0;
        return;
      }
    }
  };
  var SoundFilter = _SoundFilter;
  SoundFilter._coefficient = array2d(2, 8, 0);
  SoundFilter._invUnity = 0;
  SoundFilter.invUnity = 0;

  // osrs/sound/SoundTrackEnvelope.ts
  init_inject();
  var SoundTrackEnvelope = class {
    constructor() {
      if (this.numPhases === void 0) {
        this.numPhases = 0;
      }
      if (this.phaseDuration === void 0) {
        this.phaseDuration = null;
      }
      if (this.phasePeak === void 0) {
        this.phasePeak = null;
      }
      if (this.smart === void 0) {
        this.smart = 0;
      }
      if (this.end === void 0) {
        this.end = 0;
      }
      if (this.form === void 0) {
        this.form = 0;
      }
      if (this.critical === void 0) {
        this.critical = 0;
      }
      if (this.phaseIndex === void 0) {
        this.phaseIndex = 0;
      }
      if (this.__step === void 0) {
        this.__step = 0;
      }
      if (this.amplitude === void 0) {
        this.amplitude = 0;
      }
      if (this.ticks === void 0) {
        this.ticks = 0;
      }
    }
    decode(buffer) {
      this.form = buffer.getUnsignedByte();
      this.smart = buffer.getInt();
      this.end = buffer.getInt();
      this.decodeShape(buffer);
    }
    decodeShape(buffer) {
      this.numPhases = buffer.getUnsignedByte();
      this.phaseDuration = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.numPhases);
      this.phasePeak = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(this.numPhases);
      for (let phase = 0; phase < this.numPhases; phase++) {
        {
          this.phaseDuration[phase] = buffer.getUnsignedLEShort();
          this.phasePeak[phase] = buffer.getUnsignedLEShort();
        }
      }
    }
    reset() {
      this.critical = 0;
      this.phaseIndex = 0;
      this.__step = 0;
      this.amplitude = 0;
      this.ticks = 0;
    }
    step(period) {
      if (this.ticks >= this.critical) {
        this.amplitude = this.phasePeak[this.phaseIndex++] << 15;
        if (this.phaseIndex >= this.numPhases) {
          this.phaseIndex = this.numPhases - 1;
        }
        this.critical = this.phaseDuration[this.phaseIndex] / 65536 * period | 0;
        if (this.critical > this.ticks) {
          this.__step = ((this.phasePeak[this.phaseIndex] << 15) - this.amplitude) / (this.critical - this.ticks) | 0;
        }
      }
      this.amplitude += this.__step;
      this.ticks++;
      return this.amplitude - this.__step >> 15;
    }
  };

  // osrs/sound/SoundTrackInstrument.ts
  var _SoundTrackInstrument = class {
    constructor() {
      this.oscillVolume = [0, 0, 0, 0, 0];
      this.oscillPitchDelta = [0, 0, 0, 0, 0];
      this.oscillDelay = [0, 0, 0, 0, 0];
      this.delayFeedback = 100;
      this.soundMillis = 500;
      if (this.pitchEnvelope === void 0) {
        this.pitchEnvelope = null;
      }
      if (this.volumeEnvelope === void 0) {
        this.volumeEnvelope = null;
      }
      if (this.pitchModEnvelope === void 0) {
        this.pitchModEnvelope = null;
      }
      if (this.pitchModAmpEnvelope === void 0) {
        this.pitchModAmpEnvelope = null;
      }
      if (this.volumeModEnvelope === void 0) {
        this.volumeModEnvelope = null;
      }
      if (this.volumeModAmpEnvelope === void 0) {
        this.volumeModAmpEnvelope = null;
      }
      if (this.gatingReleaseEnvelope === void 0) {
        this.gatingReleaseEnvelope = null;
      }
      if (this.gatingAttackEnvelope === void 0) {
        this.gatingAttackEnvelope = null;
      }
      if (this.delayTime === void 0) {
        this.delayTime = 0;
      }
      if (this.filter === void 0) {
        this.filter = null;
      }
      if (this.filterEnvelope === void 0) {
        this.filterEnvelope = null;
      }
      if (this.pauseMillis === void 0) {
        this.pauseMillis = 0;
      }
    }
    static decode() {
      _SoundTrackInstrument.noise = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(32768);
      for (let noiseId = 0; noiseId < 32768; noiseId++) {
        if (Math.random() > 0.5) {
          _SoundTrackInstrument.noise[noiseId] = 1;
        } else {
          _SoundTrackInstrument.noise[noiseId] = -1;
        }
      }
      _SoundTrackInstrument.sine = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(32768);
      for (let sineId = 0; sineId < 32768; sineId++) {
        _SoundTrackInstrument.sine[sineId] = Math.sin(sineId / 5215.1903) * 16384 | 0;
      }
      _SoundTrackInstrument.buffer = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(220500);
    }
    synthesize(nS, dt) {
      for (let position = 0; position < nS; position++) {
        _SoundTrackInstrument.buffer[position] = 0;
      }
      if (dt < 10) {
        return _SoundTrackInstrument.buffer;
      }
      const fS = nS / (dt + 0);
      this.pitchEnvelope.reset();
      this.volumeEnvelope.reset();
      let pitchModStep = 0;
      let pitchModBaseStep = 0;
      let pitchModPhase = 0;
      if (this.pitchModEnvelope != null) {
        this.pitchModEnvelope.reset();
        this.pitchModAmpEnvelope.reset();
        pitchModStep = (this.pitchModEnvelope.end - this.pitchModEnvelope.smart) * 32.768 / fS | 0;
        pitchModBaseStep = this.pitchModEnvelope.smart * 32.768 / fS | 0;
      }
      let volumeModStep = 0;
      let volumeModBaseStep = 0;
      let volumeModPhase = 0;
      if (this.volumeModEnvelope != null) {
        this.volumeModEnvelope.reset();
        this.volumeModAmpEnvelope.reset();
        volumeModStep = (this.volumeModEnvelope.end - this.volumeModEnvelope.smart) * 32.768 / fS | 0;
        volumeModBaseStep = this.volumeModEnvelope.smart * 32.768 / fS | 0;
      }
      for (let oscillVolumeId = 0; oscillVolumeId < 5; oscillVolumeId++) {
        if (this.oscillVolume[oscillVolumeId] !== 0) {
          _SoundTrackInstrument.phases[oscillVolumeId] = 0;
          _SoundTrackInstrument.delays[oscillVolumeId] = this.oscillDelay[oscillVolumeId] * fS | 0;
          _SoundTrackInstrument.volumeStep[oscillVolumeId] = (this.oscillVolume[oscillVolumeId] << 14) / 100 | 0;
          _SoundTrackInstrument.pitchStep[oscillVolumeId] = (this.pitchEnvelope.end - this.pitchEnvelope.smart) * 32.768 * Math.pow(1.0057929410678534, this.oscillPitchDelta[oscillVolumeId]) / fS | 0;
          _SoundTrackInstrument.pitchBaseStep[oscillVolumeId] = this.pitchEnvelope.smart * 32.768 / fS | 0;
        }
      }
      for (let offset = 0; offset < nS; offset++) {
        {
          let pitchChange = this.pitchEnvelope.step(nS);
          let volumeChange = this.volumeEnvelope.step(nS);
          if (this.pitchModEnvelope != null) {
            const mod = this.pitchModEnvelope.step(nS);
            const modAmp = this.pitchModAmpEnvelope.step(nS);
            pitchChange += this.evaluateWave(modAmp, pitchModPhase, this.pitchModEnvelope.form) >> 1;
            pitchModPhase += (mod * pitchModStep >> 16) + pitchModBaseStep;
          }
          if (this.volumeModEnvelope != null) {
            const mod = this.volumeModEnvelope.step(nS);
            const modAmp = this.volumeModAmpEnvelope.step(nS);
            volumeChange = volumeChange * ((this.evaluateWave(modAmp, volumeModPhase, this.volumeModEnvelope.form) >> 1) + 32768) >> 15;
            volumeModPhase += (mod * volumeModStep >> 16) + volumeModBaseStep;
          }
          for (let oscillVolumeId = 0; oscillVolumeId < 5; oscillVolumeId++) {
            if (this.oscillVolume[oscillVolumeId] !== 0) {
              const position = offset + _SoundTrackInstrument.delays[oscillVolumeId];
              if (position < nS) {
                _SoundTrackInstrument.buffer[position] += this.evaluateWave(
                  volumeChange * _SoundTrackInstrument.volumeStep[oscillVolumeId] >> 15,
                  _SoundTrackInstrument.phases[oscillVolumeId],
                  this.pitchEnvelope.form
                );
                _SoundTrackInstrument.phases[oscillVolumeId] += (pitchChange * _SoundTrackInstrument.pitchStep[oscillVolumeId] >> 16) + _SoundTrackInstrument.pitchBaseStep[oscillVolumeId];
              }
            }
          }
        }
      }
      if (this.gatingReleaseEnvelope != null) {
        this.gatingReleaseEnvelope.reset();
        this.gatingAttackEnvelope.reset();
        let counter = 0;
        let muted = true;
        for (let position = 0; position < nS; position++) {
          {
            const onStep = this.gatingReleaseEnvelope.step(nS);
            const offStep = this.gatingAttackEnvelope.step(nS);
            let threshold;
            if (muted) {
              threshold = this.gatingReleaseEnvelope.smart + ((this.gatingReleaseEnvelope.end - this.gatingReleaseEnvelope.smart) * onStep >> 8);
            } else {
              threshold = this.gatingReleaseEnvelope.smart + ((this.gatingReleaseEnvelope.end - this.gatingReleaseEnvelope.smart) * offStep >> 8);
            }
            if ((counter += 256) >= threshold) {
              counter = 0;
              muted = !muted;
            }
            if (muted) {
              _SoundTrackInstrument.buffer[position] = 0;
            }
          }
        }
      }
      if (this.delayTime > 0 && this.delayFeedback > 0) {
        const delay = this.delayTime * fS | 0;
        for (let position = delay; position < nS; position++) {
          _SoundTrackInstrument.buffer[position] += _SoundTrackInstrument.buffer[position - delay] * this.delayFeedback / 100 | 0;
        }
      }
      if (this.filter.numPairs[0] > 0 || this.filter.numPairs[1] > 0) {
        this.filterEnvelope.reset();
        let t = this.filterEnvelope.step(nS + 1);
        let M = this.filter.compute(0, Math.fround(t / 65536));
        let N = this.filter.compute(1, Math.fround(t / 65536));
        if (nS >= M + N) {
          let n = 0;
          let delay = N;
          if (delay > nS - M) {
            delay = nS - M;
          }
          for (; n < delay; n++) {
            {
              let y = ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(_SoundTrackInstrument.buffer[n + M]) * ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(SoundFilter.invUnity) >> 16 | 0;
              for (let position = 0; position < M; position++) {
                y += ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(_SoundTrackInstrument.buffer[n + M - 1 - position]) * ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(SoundFilter.coefficient[0][position]) >> 16 | 0;
              }
              for (let position = 0; position < n; position++) {
                y -= ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(_SoundTrackInstrument.buffer[n - 1 - position]) * ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(SoundFilter.coefficient[1][position]) >> 16 | 0;
              }
              _SoundTrackInstrument.buffer[n] = y;
              t = this.filterEnvelope.step(nS + 1);
            }
          }
          const offset = "\x80";
          delay = offset.charCodeAt(0);
          do {
            {
              if (delay > nS - M) {
                delay = nS - M;
              }
              for (; n < delay; n++) {
                {
                  let y = ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(_SoundTrackInstrument.buffer[n + M]) * ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(SoundFilter.invUnity) >> 16 | 0;
                  for (let position = 0; position < M; position++) {
                    y += ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(_SoundTrackInstrument.buffer[n + M - 1 - position]) * ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(SoundFilter.coefficient[0][position]) >> 16 | 0;
                  }
                  for (let position = 0; position < N; position++) {
                    y -= ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(_SoundTrackInstrument.buffer[n - 1 - position]) * ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(SoundFilter.coefficient[1][position]) >> 16 | 0;
                  }
                  _SoundTrackInstrument.buffer[n] = y;
                  t = this.filterEnvelope.step(nS + 1);
                }
              }
              if (n >= nS - M) {
                break;
              }
              M = this.filter.compute(0, Math.fround(t / 65536));
              N = this.filter.compute(1, Math.fround(t / 65536));
              delay += offset.charCodeAt(0);
            }
          } while (true);
          for (; n < nS; n++) {
            {
              let y = 0;
              for (let position = n + M - nS; position < M; position++) {
                y += ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(_SoundTrackInstrument.buffer[n + M - 1 - position]) * ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(SoundFilter.coefficient[0][position]) >> 16 | 0;
              }
              for (let position = 0; position < N; position++) {
                y -= ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(_SoundTrackInstrument.buffer[n - 1 - position]) * ((n2) => n2 < 0 ? Math.ceil(n2) : Math.floor(n2))(SoundFilter.coefficient[1][position]) >> 16 | 0;
              }
              _SoundTrackInstrument.buffer[n] = y;
              this.filterEnvelope.step(nS + 1);
            }
          }
        }
      }
      for (let position = 0; position < nS; position++) {
        {
          if (_SoundTrackInstrument.buffer[position] < -32768) {
            _SoundTrackInstrument.buffer[position] = -32768;
          }
          if (_SoundTrackInstrument.buffer[position] > 32767) {
            _SoundTrackInstrument.buffer[position] = 32767;
          }
        }
      }
      return _SoundTrackInstrument.buffer;
    }
    evaluateWave(amplitude, phase, table) {
      if (table === 1) {
        if ((phase & 32767) < 16384) {
          return amplitude;
        } else {
          return -amplitude;
        }
      }
      if (table === 2) {
        return _SoundTrackInstrument.sine[phase & 32767] * amplitude >> 14;
      }
      if (table === 3) {
        return ((phase & 32767) * amplitude >> 14) - amplitude;
      }
      if (table === 4) {
        return _SoundTrackInstrument.noise[(phase / 2607 | 0) & 32767] * amplitude;
      } else {
        return 0;
      }
    }
    decode(buffer) {
      this.pitchEnvelope = new SoundTrackEnvelope();
      this.pitchEnvelope.decode(buffer);
      this.volumeEnvelope = new SoundTrackEnvelope();
      this.volumeEnvelope.decode(buffer);
      let option = buffer.getUnsignedByte();
      if (option !== 0) {
        buffer.currentPosition--;
        this.pitchModEnvelope = new SoundTrackEnvelope();
        this.pitchModEnvelope.decode(buffer);
        this.pitchModAmpEnvelope = new SoundTrackEnvelope();
        this.pitchModAmpEnvelope.decode(buffer);
      }
      option = buffer.getUnsignedByte();
      if (option !== 0) {
        buffer.currentPosition--;
        this.volumeModEnvelope = new SoundTrackEnvelope();
        this.volumeModEnvelope.decode(buffer);
        this.volumeModAmpEnvelope = new SoundTrackEnvelope();
        this.volumeModAmpEnvelope.decode(buffer);
      }
      option = buffer.getUnsignedByte();
      if (option !== 0) {
        buffer.currentPosition--;
        this.gatingReleaseEnvelope = new SoundTrackEnvelope();
        this.gatingReleaseEnvelope.decode(buffer);
        this.gatingAttackEnvelope = new SoundTrackEnvelope();
        this.gatingAttackEnvelope.decode(buffer);
      }
      for (let oscillId = 0; oscillId < 10; oscillId++) {
        {
          const volume = buffer.getSmart();
          if (volume === 0) {
            break;
          }
          this.oscillVolume[oscillId] = volume;
          this.oscillPitchDelta[oscillId] = buffer.getSignedSmart();
          this.oscillDelay[oscillId] = buffer.getSmart();
        }
      }
      this.delayTime = buffer.getSmart();
      this.delayFeedback = buffer.getSmart();
      this.soundMillis = buffer.getUnsignedLEShort();
      this.pauseMillis = buffer.getUnsignedLEShort();
      this.filter = new SoundFilter();
      this.filterEnvelope = new SoundTrackEnvelope();
      this.filter.decode(this.filterEnvelope, buffer);
    }
  };
  var SoundTrackInstrument = _SoundTrackInstrument;
  SoundTrackInstrument.buffer = null;
  SoundTrackInstrument.noise = null;
  SoundTrackInstrument.sine = null;
  SoundTrackInstrument.phases = [0, 0, 0, 0, 0];
  SoundTrackInstrument.delays = [0, 0, 0, 0, 0];
  SoundTrackInstrument.volumeStep = [0, 0, 0, 0, 0];
  SoundTrackInstrument.pitchStep = [0, 0, 0, 0, 0];
  SoundTrackInstrument.pitchBaseStep = [0, 0, 0, 0, 0];

  // osrs/sound/SoundTrack.ts
  function PCMPlayer(option) {
    this.init(option);
  }
  PCMPlayer.prototype.init = function(option) {
    var defaults = {
      encoding: "16bitInt",
      channels: 1,
      sampleRate: 8e3,
      flushingTime: 1e3
    };
    this.option = Object.assign({}, defaults, option);
    this.samples = new Float32Array();
    this.flush = this.flush.bind(this);
    this.interval = setInterval(this.flush, this.option.flushingTime);
    this.maxValue = this.getMaxValue();
    this.typedArray = this.getTypedArray();
    this.createContext();
  };
  PCMPlayer.prototype.getMaxValue = function() {
    var encodings = {
      "8bitInt": 128,
      "16bitInt": 32768,
      "32bitInt": 2147483648,
      "32bitFloat": 1,
      "8bitUint": 255
    };
    return encodings[this.option.encoding] ? encodings[this.option.encoding] : encodings["16bitInt"];
  };
  PCMPlayer.prototype.getTypedArray = function() {
    var typedArrays = {
      "8bitInt": Int8Array,
      "16bitInt": Int16Array,
      "32bitInt": Int32Array,
      "32bitFloat": Float32Array,
      "8bitUint": Uint8Array
    };
    return typedArrays[this.option.encoding] ? typedArrays[this.option.encoding] : typedArrays["16bitInt"];
  };
  PCMPlayer.prototype.createContext = function() {
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.audioCtx.resume();
    this.audioCtx.onstatechange = () => console.log(this.audioCtx.state);
    this.gainNode = this.audioCtx.createGain();
    this.gainNode.gain.value = 1;
    this.gainNode.connect(this.audioCtx.destination);
    this.startTime = this.audioCtx.currentTime;
  };
  PCMPlayer.prototype.isTypedArray = function(data) {
    return data.byteLength && data.buffer && data.buffer.constructor == ArrayBuffer;
  };
  PCMPlayer.prototype.feed = function(data) {
    if (!this.isTypedArray(data))
      return;
    data = this.getFormatedValue(data);
    var tmp = new Float32Array(this.samples.length + data.length);
    tmp.set(this.samples, 0);
    tmp.set(data, this.samples.length);
    this.samples = tmp;
  };
  PCMPlayer.prototype.getFormatedValue = function(data) {
    var data = new this.typedArray(data.buffer), float32 = new Float32Array(data.length), i;
    for (i = 0; i < data.length; i++) {
      float32[i] = data[i] / this.maxValue;
    }
    return float32;
  };
  PCMPlayer.prototype.volume = function(volume) {
    this.gainNode.gain.value = volume;
  };
  PCMPlayer.prototype.destroy = function() {
    if (this.interval) {
      clearInterval(this.interval);
    }
    this.samples = null;
    this.audioCtx.close();
    this.audioCtx = null;
  };
  PCMPlayer.prototype.flush = function() {
    if (!this.samples.length)
      return;
    var bufferSource = this.audioCtx.createBufferSource(), length = this.samples.length / this.option.channels, audioBuffer = this.audioCtx.createBuffer(this.option.channels, length, this.option.sampleRate), audioData, channel, offset, i, decrement;
    for (channel = 0; channel < this.option.channels; channel++) {
      audioData = audioBuffer.getChannelData(channel);
      offset = channel;
      decrement = 50;
      for (i = 0; i < length; i++) {
        audioData[i] = this.samples[offset];
        if (i < 50) {
          audioData[i] = audioData[i] * i / 50;
        }
        if (i >= length - 51) {
          audioData[i] = audioData[i] * decrement-- / 50;
        }
        offset += this.option.channels;
      }
    }
    if (this.startTime < this.audioCtx.currentTime) {
      this.startTime = this.audioCtx.currentTime;
    }
    console.log("start vs current " + this.startTime + " vs " + this.audioCtx.currentTime + " duration: " + audioBuffer.duration);
    bufferSource.buffer = audioBuffer;
    bufferSource.connect(this.gainNode);
    bufferSource.start(this.startTime);
    this.startTime += audioBuffer.duration;
    this.samples = new Float32Array();
  };
  var player = new PCMPlayer({
    encoding: "8bitUint",
    channels: 1,
    sampleRate: 22050,
    flushingTime: 0
  });
  window.PCMPlayer = player;
  var _SoundTrack = class {
    constructor(i) {
      this.instruments = [null, null, null, null, null, null, null, null, null, null];
      if (this.loopBegin === void 0) {
        this.loopBegin = 0;
      }
      if (this.loopEnd === void 0) {
        this.loopEnd = 0;
      }
      while (i >= 0) {
        {
          throw Error("NullPointerException");
        }
      }
    }
    static load(buffer) {
      window.SoundTrack = _SoundTrack;
      const downloadBlob = function(data, fileName, mimeType) {
        var blob, url;
        blob = new Blob([data], {
          type: mimeType
        });
        url = window.URL.createObjectURL(blob);
        downloadURL(url, fileName);
        setTimeout(function() {
          return window.URL.revokeObjectURL(url);
        }, 1e3);
      };
      const downloadURL = function(data, fileName) {
        var a;
        a = document.createElement("a");
        a.href = data;
        a.download = fileName;
        document.body.appendChild(a);
        a.style = "display: none";
        a.click();
        a.remove();
      };
      _SoundTrack._buffer = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(441e3);
      _SoundTrack.buffer = new Buffer3(_SoundTrack._buffer);
      SoundTrackInstrument.decode();
      while (true) {
        {
          const trackId = buffer.getUnsignedLEShort();
          if (trackId === 65535) {
            return;
          }
          _SoundTrack.tracks[trackId] = new _SoundTrack(-524);
          _SoundTrack.tracks[trackId].decode(buffer);
          _SoundTrack.trackDelays[trackId] = _SoundTrack.tracks[trackId].delay();
        }
      }
    }
    static play(trackId) {
      const encoded = _SoundTrack.data(trackId, 1);
      console.log("encoded", encoded);
      player.feed(new Uint8Array(encoded.buffer));
      setTimeout(() => {
        console.log("flushing");
        player.flush();
      }, 1e3);
    }
    static data(trackId, loops) {
      if (_SoundTrack.tracks[trackId] != null) {
        const soundTrack = _SoundTrack.tracks[trackId];
        return soundTrack.encode(loops);
      } else {
        return null;
      }
    }
    decode(buffer) {
      for (let instrument = 0; instrument < 10; instrument++) {
        {
          const active = buffer.getUnsignedByte();
          if (active !== 0) {
            buffer.currentPosition--;
            this.instruments[instrument] = new SoundTrackInstrument();
            this.instruments[instrument].decode(buffer);
          }
        }
      }
      this.loopBegin = buffer.getUnsignedLEShort();
      this.loopEnd = buffer.getUnsignedLEShort();
    }
    delay() {
      let delay = 9999999;
      for (let instrument = 0; instrument < 10; instrument++) {
        if (this.instruments[instrument] != null && (this.instruments[instrument].pauseMillis / 20 | 0) < delay) {
          delay = this.instruments[instrument].pauseMillis / 20 | 0;
        }
      }
      if (this.loopBegin < this.loopEnd && (this.loopBegin / 20 | 0) < delay) {
        delay = this.loopBegin / 20 | 0;
      }
      if (delay === 9999999 || delay === 0) {
        return 0;
      }
      for (let instrument = 0; instrument < 10; instrument++) {
        if (this.instruments[instrument] != null) {
          this.instruments[instrument].pauseMillis -= delay * 20;
        }
      }
      if (this.loopBegin < this.loopEnd) {
        this.loopBegin -= delay * 20;
        this.loopEnd -= delay * 20;
      }
      return delay;
    }
    encode(j) {
      const size = this.mix(j);
      _SoundTrack.buffer.currentPosition = 0;
      _SoundTrack.buffer.putInt(1380533830);
      _SoundTrack.buffer.putLEInt(36 + size);
      _SoundTrack.buffer.putInt(1463899717);
      _SoundTrack.buffer.putInt(1718449184);
      _SoundTrack.buffer.putLEInt(16);
      _SoundTrack.buffer.putLEShort(1);
      _SoundTrack.buffer.putLEShort(1);
      _SoundTrack.buffer.putLEInt(22050);
      _SoundTrack.buffer.putLEInt(22050);
      _SoundTrack.buffer.putLEShort(1);
      _SoundTrack.buffer.putLEShort(8);
      _SoundTrack.buffer.putInt(1684108385);
      _SoundTrack.buffer.putLEInt(size);
      _SoundTrack.buffer.currentPosition += size;
      return _SoundTrack.buffer;
    }
    mix(loops) {
      let millis = 0;
      for (let instrument = 0; instrument < 10; instrument++) {
        if (this.instruments[instrument] != null && this.instruments[instrument].soundMillis + this.instruments[instrument].pauseMillis > millis) {
          millis = this.instruments[instrument].soundMillis + this.instruments[instrument].pauseMillis;
        }
      }
      if (millis === 0) {
        return 0;
      }
      let nS = 22050 * millis / 1e3 | 0;
      let loopBegin = 22050 * this.loopBegin / 1e3 | 0;
      let loopEnd = 22050 * this.loopEnd / 1e3 | 0;
      if (loopBegin < 0 || loopBegin > nS || loopEnd < 0 || loopEnd > nS || loopBegin >= loopEnd) {
        loops = 0;
      }
      let length = nS + (loopEnd - loopBegin) * (loops - 1);
      for (let position = 44; position < length + 44; position++) {
        _SoundTrack._buffer[position] = -128;
      }
      for (let instrument = 0; instrument < 10; instrument++) {
        if (this.instruments[instrument] != null) {
          const soundSamples = this.instruments[instrument].soundMillis * 22050 / 1e3 | 0;
          const pauseSamples = this.instruments[instrument].pauseMillis * 22050 / 1e3 | 0;
          const samples = this.instruments[instrument].synthesize(soundSamples, this.instruments[instrument].soundMillis);
          for (let soundSample = 0; soundSample < soundSamples; soundSample++) {
            {
              let sample = (_SoundTrack._buffer[soundSample + pauseSamples + 44] & 255) + (samples[soundSample] >> 8);
              if ((sample & -256) !== 0) {
                sample = ~(sample >> 31);
              }
              _SoundTrack._buffer[soundSample + pauseSamples + 44] = sample | 0;
            }
          }
        }
      }
      if (loops > 1) {
        loopBegin += 44;
        loopEnd += 44;
        nS += 44;
        let offset = (length += 44) - nS;
        for (let position = nS - 1; position >= loopEnd; position--) {
          _SoundTrack._buffer[position + offset] = _SoundTrack._buffer[position];
        }
        for (let loopCounter = 1; loopCounter < loops; loopCounter++) {
          {
            offset = (loopEnd - loopBegin) * loopCounter;
            for (let position = loopBegin; position < loopEnd; position++) {
              _SoundTrack._buffer[position + offset] = _SoundTrack._buffer[position];
            }
          }
        }
        length -= 44;
      }
      return length;
    }
  };
  var SoundTrack = _SoundTrack;
  SoundTrack.aByte664 = 6;
  SoundTrack.tracks = Array(5e3).fill(null);
  SoundTrack.trackDelays = Array(5e3).fill(0);
  SoundTrack._buffer = null;
  SoundTrack.buffer = null;

  // osrs/cache/media/Widget.ts
  init_inject();

  // osrs/util/TextUtils.ts
  init_inject();
  var import_long2 = __toESM(require_long(), 1);
  var _TextUtils = class {
    static nameToLong(name) {
      let longName = new import_long2.default(0, 0);
      for (let i = 0; i < name.length && i < 12; i++) {
        {
          const ch = name.charAt(i);
          longName = longName.mul(37);
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ch) >= "A".charCodeAt(0) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ch) <= "Z".charCodeAt(0)) {
            longName = longName.add(1 + ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ch) - 65);
          } else if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ch) >= "a".charCodeAt(0) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ch) <= "z".charCodeAt(0)) {
            longName = longName.add(1 + ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ch) - 97);
          } else if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ch) >= "0".charCodeAt(0) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ch) <= "9".charCodeAt(0)) {
            longName = longName.add(27 + ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ch) - 48);
          }
        }
      }
      for (; longName.mod(37).isZero() && !longName.isZero(); longName = longName.div(37)) {
      }
      return longName;
    }
    static longToName(longName) {
      if (longName.lessThan(0) || longName.greaterThan(6582952005840035e3)) {
        return "invalid_name";
      }
      if (longName.div(37).isZero()) {
        return "invalid_name";
      }
      let length = 0;
      const name = Array(12).fill("");
      while (!longName.isZero()) {
        const tmp = new import_long2.default(longName.low, longName.high);
        longName = longName.div(37);
        name[11 - length++] = _TextUtils.VALID_CHARACTERS[tmp.sub(longName.mul(37)).toNumber()];
      }
      return name.join("");
    }
    static spriteToHash(sprite) {
      return rs_hash_string(sprite);
    }
    static decodeAddress(address) {
      return (address >> 24 & 255) + "." + (address >> 16 & 255) + "." + (address >> 8 & 255) + "." + (address & 255);
    }
    static formatName(name) {
      if (name.length > 0) {
        const formatedName = name.split("");
        for (let pos = 0; pos < formatedName.length; pos++) {
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(formatedName[pos]) == "_".charCodeAt(0)) {
            formatedName[pos] = " ";
            if (pos + 1 < formatedName.length && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(formatedName[pos + 1]) >= "a".charCodeAt(0) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(formatedName[pos + 1]) <= "z".charCodeAt(0)) {
              formatedName[pos + 1] = String.fromCharCode(
                ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(formatedName[pos + 1]) + 65 - 97
              );
            }
          }
        }
        if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(formatedName[0]) >= "a".charCodeAt(0) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(formatedName[0]) <= "z".charCodeAt(0)) {
          formatedName[0] = String.fromCharCode(
            ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(formatedName[0]) + 65 - 97
          );
        }
        return formatedName.join("");
      } else {
        return name;
      }
    }
    static censorPassword(password) {
      let censoredPassword = "";
      for (let index = 0; index < password.length; index++) {
        censoredPassword += "*";
      }
      return censoredPassword;
    }
  };
  var TextUtils = _TextUtils;
  TextUtils.VALID_CHARACTERS = [
    "_",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];

  // osrs/cache/media/Widget.ts
  var _Widget = class {
    constructor() {
      this.optionText = null;
      this.disabledImage = null;
      this.imageY = null;
      this.id = 0;
      this.itemDeletesDraged = false;
      this.anInt218 = 0;
      this.hiddenUntilHovered = false;
      this.alpha = 0;
      this.imageX = null;
      this.optionAttributes = 0;
      this.itemAmounts = null;
      this.unknownOne = 0;
      this.enabledHoveredColor = 0;
      this.anInt227 = 0;
      this.anInt228 = 0;
      this.isInventory = false;
      this.disabledText = null;
      this.anInt231 = 0;
      this.childrenX = null;
      this.unknownTwo = false;
      this.opcodes = null;
      this.anInt235 = 0;
      this.type = 0;
      this.typeFaces = null;
      this.height = 0;
      this.filled = false;
      this.disabledColor = 0;
      this.width = 0;
      this.contentType = 0;
      this.itemSpritePadsY = 0;
      this.enabledImage = null;
      this.typeFaceShadowed = false;
      this.parentId = 0;
      this.enabledText = null;
      this.zoom = 0;
      this.rotationX = 0;
      this.rotationY = 0;
      this.hoveredPopup = 0;
      this.conditionValues = null;
      this.children = null;
      this.anInt259 = 0;
      this.enabledColor = 0;
      this.disabledHoveredColor = 0;
      this.options = null;
      this.itemSpritePadsX = 0;
      this.images = null;
      this.enabledModelType = 0;
      this.enabledModelId = 0;
      this.tooltip = null;
      this.items = null;
      this.typeFaceCentered = false;
      this.conditionTypes = null;
      this.itemSwapable = false;
      this.childrenY = null;
      this.optionCircumfix = null;
      this.modelType = 0;
      this.modelId = 0;
      this.scrollLimit = 0;
      this.disabledAnimation = 0;
      this.enabledAnimation = 0;
      this.itemUsable = false;
      this.actionType = 0;
      if (this.optionText === void 0) {
        this.optionText = null;
      }
      if (this.disabledImage === void 0) {
        this.disabledImage = null;
      }
      if (this.imageY === void 0) {
        this.imageY = null;
      }
      if (this.id === void 0) {
        this.id = 0;
      }
      if (this.itemDeletesDraged === void 0) {
        this.itemDeletesDraged = false;
      }
      if (this.anInt218 === void 0) {
        this.anInt218 = 0;
      }
      if (this.hiddenUntilHovered === void 0) {
        this.hiddenUntilHovered = false;
      }
      if (this.alpha === void 0) {
        this.alpha = 0;
      }
      if (this.imageX === void 0) {
        this.imageX = null;
      }
      if (this.optionAttributes === void 0) {
        this.optionAttributes = 0;
      }
      if (this.itemAmounts === void 0) {
        this.itemAmounts = null;
      }
      if (this.unknownOne === void 0) {
        this.unknownOne = 0;
      }
      if (this.enabledHoveredColor === void 0) {
        this.enabledHoveredColor = 0;
      }
      if (this.anInt227 === void 0) {
        this.anInt227 = 0;
      }
      if (this.anInt228 === void 0) {
        this.anInt228 = 0;
      }
      if (this.isInventory === void 0) {
        this.isInventory = false;
      }
      if (this.disabledText === void 0) {
        this.disabledText = null;
      }
      if (this.anInt231 === void 0) {
        this.anInt231 = 0;
      }
      if (this.childrenX === void 0) {
        this.childrenX = null;
      }
      if (this.unknownTwo === void 0) {
        this.unknownTwo = false;
      }
      if (this.opcodes === void 0) {
        this.opcodes = null;
      }
      if (this.anInt235 === void 0) {
        this.anInt235 = 0;
      }
      if (this.type === void 0) {
        this.type = 0;
      }
      if (this.typeFaces === void 0) {
        this.typeFaces = null;
      }
      if (this.height === void 0) {
        this.height = 0;
      }
      if (this.filled === void 0) {
        this.filled = false;
      }
      if (this.disabledColor === void 0) {
        this.disabledColor = 0;
      }
      if (this.width === void 0) {
        this.width = 0;
      }
      if (this.contentType === void 0) {
        this.contentType = 0;
      }
      if (this.itemSpritePadsY === void 0) {
        this.itemSpritePadsY = 0;
      }
      if (this.enabledImage === void 0) {
        this.enabledImage = null;
      }
      if (this.typeFaceShadowed === void 0) {
        this.typeFaceShadowed = false;
      }
      if (this.parentId === void 0) {
        this.parentId = 0;
      }
      if (this.enabledText === void 0) {
        this.enabledText = null;
      }
      if (this.zoom === void 0) {
        this.zoom = 0;
      }
      if (this.rotationX === void 0) {
        this.rotationX = 0;
      }
      if (this.rotationY === void 0) {
        this.rotationY = 0;
      }
      if (this.hoveredPopup === void 0) {
        this.hoveredPopup = 0;
      }
      if (this.conditionValues === void 0) {
        this.conditionValues = null;
      }
      if (this.children === void 0) {
        this.children = null;
      }
      if (this.anInt259 === void 0) {
        this.anInt259 = 0;
      }
      if (this.enabledColor === void 0) {
        this.enabledColor = 0;
      }
      if (this.disabledHoveredColor === void 0) {
        this.disabledHoveredColor = 0;
      }
      if (this.options === void 0) {
        this.options = null;
      }
      if (this.itemSpritePadsX === void 0) {
        this.itemSpritePadsX = 0;
      }
      if (this.images === void 0) {
        this.images = null;
      }
      if (this.enabledModelType === void 0) {
        this.enabledModelType = 0;
      }
      if (this.enabledModelId === void 0) {
        this.enabledModelId = 0;
      }
      if (this.tooltip === void 0) {
        this.tooltip = null;
      }
      if (this.items === void 0) {
        this.items = null;
      }
      if (this.typeFaceCentered === void 0) {
        this.typeFaceCentered = false;
      }
      if (this.conditionTypes === void 0) {
        this.conditionTypes = null;
      }
      if (this.itemSwapable === void 0) {
        this.itemSwapable = false;
      }
      if (this.childrenY === void 0) {
        this.childrenY = null;
      }
      if (this.optionCircumfix === void 0) {
        this.optionCircumfix = null;
      }
      if (this.modelType === void 0) {
        this.modelType = 0;
      }
      if (this.modelId === void 0) {
        this.modelId = 0;
      }
      if (this.scrollLimit === void 0) {
        this.scrollLimit = 0;
      }
      if (this.disabledAnimation === void 0) {
        this.disabledAnimation = 0;
      }
      if (this.enabledAnimation === void 0) {
        this.enabledAnimation = 0;
      }
      if (this.itemUsable === void 0) {
        this.itemUsable = false;
      }
      if (this.actionType === void 0) {
        this.actionType = 0;
      }
    }
    static getImage(spriteId, spriteName) {
      const hash = TextUtils.spriteToHash(spriteName);
      const spriteHash = (hash << 8) + spriteId;
      let sprite = _Widget.spriteCacheModern.get(spriteHash);
      if (sprite != null) {
        return sprite;
      }
      if (_Widget.mediaArchive == null) {
        return null;
      }
      try {
        sprite = ImageRGB.fromArchive(_Widget.mediaArchive, spriteName, spriteId);
        _Widget.spriteCacheModern.set(spriteHash, sprite);
      } catch (_ex) {
        return null;
      }
      return sprite;
    }
    static forId(id) {
      if (_Widget.interfaces[id] == null) {
        const buf = new Buffer3(_Widget.data[id]);
        const j = buf.getUnsignedLEShort();
        _Widget.interfaces[id] = _Widget.parse(j, buf, id);
      }
      return _Widget.interfaces[id];
    }
    static parse(parentId, buffer, widgetIndex) {
      const widget = new _Widget();
      widget.id = widgetIndex;
      widget.parentId = parentId;
      widget.type = buffer.getUnsignedByte();
      widget.actionType = buffer.getUnsignedByte();
      widget.contentType = buffer.getUnsignedLEShort();
      widget.width = buffer.getUnsignedLEShort();
      widget.height = buffer.getUnsignedLEShort();
      widget.alpha = buffer.getUnsignedByte() | 0;
      widget.hoveredPopup = buffer.getUnsignedByte();
      if (widget.hoveredPopup !== 0) {
        widget.hoveredPopup = (widget.hoveredPopup - 1 << 8) + buffer.getUnsignedByte();
      } else {
        widget.hoveredPopup = -1;
      }
      if (widget.contentType === 600) {
        _Widget.anInt246 = parentId;
      }
      if (widget.contentType === 650) {
        _Widget.anInt255 = parentId;
      }
      if (widget.contentType === 655) {
        _Widget.anInt277 = parentId;
      }
      const conditionCount = buffer.getUnsignedByte();
      if (conditionCount > 0) {
        widget.conditionTypes = Array(conditionCount).fill(0);
        widget.conditionValues = Array(conditionCount).fill(0);
        for (let condition = 0; condition < conditionCount; condition++) {
          {
            widget.conditionTypes[condition] = buffer.getUnsignedByte();
            widget.conditionValues[condition] = buffer.getUnsignedLEShort();
          }
        }
      }
      const opcodeCount = buffer.getUnsignedByte();
      if (opcodeCount > 0) {
        widget.opcodes = Array(opcodeCount).fill(0);
        for (let opcode = 0; opcode < opcodeCount; opcode++) {
          {
            const subOpcodeCount = buffer.getUnsignedLEShort();
            widget.opcodes[opcode] = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(subOpcodeCount);
            for (let subOpcode = 0; subOpcode < subOpcodeCount; subOpcode++) {
              widget.opcodes[opcode][subOpcode] = buffer.getUnsignedLEShort();
            }
          }
        }
      }
      if (widget.type === 0) {
        widget.scrollLimit = buffer.getUnsignedLEShort();
        widget.hiddenUntilHovered = buffer.getUnsignedByte() === 1;
        const childrenCount = buffer.getUnsignedLEShort();
        widget.children = Array(childrenCount).fill(0);
        widget.childrenX = Array(childrenCount).fill(0);
        widget.childrenY = Array(childrenCount).fill(0);
        for (let child = 0; child < childrenCount; child++) {
          {
            widget.children[child] = buffer.getUnsignedLEShort();
            widget.childrenX[child] = buffer.getSignedShort();
            widget.childrenY[child] = buffer.getSignedShort();
          }
        }
      }
      if (widget.type === 1) {
        widget.unknownOne = buffer.getUnsignedLEShort();
        widget.unknownTwo = buffer.getUnsignedByte() === 1;
      }
      if (widget.type === 2) {
        widget.items = Array(widget.width * widget.height).fill(0);
        widget.itemAmounts = Array(widget.width * widget.height).fill(0);
        widget.itemSwapable = buffer.getUnsignedByte() === 1;
        widget.isInventory = buffer.getUnsignedByte() === 1;
        widget.itemUsable = buffer.getUnsignedByte() === 1;
        widget.itemDeletesDraged = buffer.getUnsignedByte() === 1;
        widget.itemSpritePadsX = buffer.getUnsignedByte();
        widget.itemSpritePadsY = buffer.getUnsignedByte();
        widget.imageX = Array(20).fill(0);
        widget.imageY = Array(20).fill(0);
        widget.images = Array(20).fill(null);
        for (let sprite = 0; sprite < 20; sprite++) {
          {
            const hasSprite = buffer.getUnsignedByte();
            if (hasSprite === 1) {
              widget.imageX[sprite] = buffer.getSignedShort();
              widget.imageY[sprite] = buffer.getSignedShort();
              const spriteName = buffer.getString();
              if (spriteName.length > 0) {
                const spriteId = spriteName.lastIndexOf(",");
                widget.images[sprite] = _Widget.getImage(parseInt(spriteName.substring(spriteId + 1)), spriteName.substring(0, spriteId));
              }
            }
          }
        }
        widget.options = [null, null, null, null, null];
        for (let optionId = 0; optionId < 5; optionId++) {
          {
            widget.options[optionId] = buffer.getString();
            if (widget.options[optionId].length === 0) {
              widget.options[optionId] = null;
            }
          }
        }
      }
      if (widget.type === 3) {
        widget.filled = buffer.getUnsignedByte() === 1;
      }
      if (widget.type === 4 || widget.type === 1) {
        widget.typeFaceCentered = buffer.getUnsignedByte() === 1;
        const typeFace = buffer.getUnsignedByte();
        if (_Widget.fonts != null) {
          widget.typeFaces = _Widget.fonts[typeFace];
        }
        widget.typeFaceShadowed = buffer.getUnsignedByte() === 1;
      }
      if (widget.type === 4) {
        widget.disabledText = buffer.getString();
        widget.enabledText = buffer.getString();
      }
      if (widget.type === 1 || widget.type === 3 || widget.type === 4) {
        widget.disabledColor = buffer.getInt();
      }
      if (widget.type === 3 || widget.type === 4) {
        widget.enabledColor = buffer.getInt();
        widget.disabledHoveredColor = buffer.getInt();
        widget.enabledHoveredColor = buffer.getInt();
      }
      if (widget.type === 5) {
        let spriteName = buffer.getString();
        if (spriteName.length > 0) {
          const spriteId = spriteName.lastIndexOf(",");
          widget.disabledImage = _Widget.getImage(parseInt(spriteName.substring(spriteId + 1)), spriteName.substring(0, spriteId));
        }
        spriteName = buffer.getString();
        if (spriteName.length > 0) {
          const spriteId = spriteName.lastIndexOf(",");
          widget.enabledImage = _Widget.getImage(parseInt(spriteName.substring(spriteId + 1)), spriteName.substring(0, spriteId));
        }
      }
      if (widget.type === 6) {
        widgetIndex = buffer.getUnsignedByte();
        if (widgetIndex !== 0) {
          widget.modelType = 1;
          widget.modelId = (widgetIndex - 1 << 8) + buffer.getUnsignedByte();
        }
        widgetIndex = buffer.getUnsignedByte();
        if (widgetIndex !== 0) {
          widget.enabledModelType = 1;
          widget.enabledModelId = (widgetIndex - 1 << 8) + buffer.getUnsignedByte();
        }
        widgetIndex = buffer.getUnsignedByte();
        if (widgetIndex !== 0) {
          widget.disabledAnimation = (widgetIndex - 1 << 8) + buffer.getUnsignedByte();
        } else {
          widget.disabledAnimation = -1;
        }
        widgetIndex = buffer.getUnsignedByte();
        if (widgetIndex !== 0) {
          widget.enabledAnimation = (widgetIndex - 1 << 8) + buffer.getUnsignedByte();
        } else {
          widget.enabledAnimation = -1;
        }
        widget.zoom = buffer.getUnsignedLEShort();
        widget.rotationX = buffer.getUnsignedLEShort();
        widget.rotationY = buffer.getUnsignedLEShort();
      }
      if (widget.type === 7) {
        widget.items = Array(widget.width * widget.height).fill(0);
        widget.itemAmounts = Array(widget.width * widget.height).fill(0);
        widget.typeFaceCentered = buffer.getUnsignedByte() === 1;
        const typeFaceCount = buffer.getUnsignedByte();
        if (_Widget.fonts != null) {
          widget.typeFaces = _Widget.fonts[typeFaceCount];
        }
        widget.typeFaceShadowed = buffer.getUnsignedByte() === 1;
        widget.disabledColor = buffer.getInt();
        widget.itemSpritePadsX = buffer.getSignedShort();
        widget.itemSpritePadsY = buffer.getSignedShort();
        widget.isInventory = buffer.getUnsignedByte() === 1;
        widget.options = [null, null, null, null, null];
        for (let optionId = 0; optionId < 5; optionId++) {
          {
            widget.options[optionId] = buffer.getString();
            if (widget.options[optionId].length === 0) {
              widget.options[optionId] = null;
            }
          }
        }
      }
      if (widget.type === 8) {
        widget.disabledText = buffer.getString();
      }
      if (widget.actionType === 2 || widget.type === 2) {
        widget.optionCircumfix = buffer.getString();
        widget.optionText = buffer.getString();
        widget.optionAttributes = buffer.getUnsignedLEShort();
      }
      if (widget.actionType === 1 || widget.actionType === 4 || widget.actionType === 5 || widget.actionType === 6) {
        widget.tooltip = buffer.getString();
        if (widget.tooltip.length === 0) {
          if (widget.actionType === 1) {
            widget.tooltip = "Ok";
          }
          if (widget.actionType === 4) {
            widget.tooltip = "Select";
          }
          if (widget.actionType === 5) {
            widget.tooltip = "Select";
          }
          if (widget.actionType === 6) {
            widget.tooltip = "Continue";
          }
        }
      }
      return widget;
    }
    static load(widgetArchive, fonts, mediaArchive) {
      const buffer = new Buffer3(widgetArchive.getFile("data"));
      _Widget.mediaArchive = mediaArchive;
      _Widget.fonts = fonts;
      let parentId = -1;
      const widgetCount = buffer.getUnsignedLEShort();
      _Widget.interfaces = Array(widgetCount).fill(null);
      _Widget.data = Array(widgetCount).fill(0);
      while (buffer.currentPosition < buffer.buffer.length) {
        {
          let widgetIndex = buffer.getUnsignedLEShort();
          if (widgetIndex === 65535) {
            parentId = buffer.getUnsignedLEShort();
            widgetIndex = buffer.getUnsignedLEShort();
          }
          const i1 = buffer.currentPosition;
          const widget = _Widget.parse(parentId, buffer, widgetIndex);
          const temp = _Widget.data[widget.id] = Array(buffer.currentPosition - i1 + 2).fill(0);
          for (let j1 = i1; j1 < buffer.currentPosition; j1++) {
            temp[j1 - i1 + 2] = buffer.buffer[j1];
          }
          temp[0] = parentId >> 8 | 0;
          temp[1] = parentId | 0;
        }
      }
      _Widget.mediaArchive = null;
    }
    static method200(i) {
      if (i === -1) {
        return;
      }
      for (let j = 0; j < _Widget.interfaces.length; j++) {
        if (_Widget.interfaces[j] != null && _Widget.interfaces[j].parentId === i && _Widget.interfaces[j].type !== 2) {
          _Widget.interfaces[j] = null;
        }
      }
    }
    static setModel(modelType, model, modelId) {
      _Widget.modelCache.removeAll();
      if (model != null && modelType !== 4) {
        _Widget.modelCache.put(model, (modelType << 16) + modelId);
      }
    }
    static reset() {
      _Widget.interfaces = null;
      _Widget.mediaArchive = null;
      _Widget.spriteCacheModern = /* @__PURE__ */ new Map();
      _Widget.fonts = null;
      _Widget.data = null;
    }
    swapItems(originalSlot, newSlot) {
      let originalItem = this.items[originalSlot];
      this.items[originalSlot] = this.items[newSlot];
      this.items[newSlot] = originalItem;
      originalItem = this.itemAmounts[originalSlot];
      this.itemAmounts[originalSlot] = this.itemAmounts[newSlot];
      this.itemAmounts[newSlot] = originalItem;
    }
    getModel(modelType, modelId) {
      let item = null;
      if (modelType === 4) {
        item = ItemDefinition.lookup(modelId);
        _Widget.anInt280 += item.ambience;
        _Widget.anInt243 += item.diffusion;
      }
      let model = _Widget.modelCache.get((modelType << 16) + modelId);
      if (model != null) {
        return model;
      }
      if (modelType === 1) {
        model = Model.getModel(modelId);
      }
      if (modelType === 2) {
        model = ActorDefinition.getDefinition(modelId).getHeadModel();
      }
      if (modelType === 3) {
        model = Game.localPlayer.getHeadModel();
      }
      if (modelType === 4) {
        model = item.asStack(50);
      }
      if (modelType === 5) {
        model = null;
      }
      if (model != null) {
        _Widget.modelCache.put(model, (modelType << 16) + modelId);
      }
      return model;
    }
    getAnimatedModel(frame1Id, frame2Id, modelEnabled) {
      let model;
      if (modelEnabled) {
        model = this.getModel(this.enabledModelType, this.enabledModelId);
      } else {
        model = this.getModel(this.modelType, this.modelId);
      }
      if (model == null) {
        return null;
      }
      if (frame2Id === -1 && frame1Id === -1 && model.triangleColorValues == null) {
        return model;
      }
      const animatedModel = new Model(true, model, ((lhs, rhs) => lhs && rhs)(Animation.exists(frame2Id), Animation.exists(frame1Id)));
      if (frame2Id !== -1 || frame1Id !== -1) {
        animatedModel.createBones();
      }
      if (frame2Id !== -1) {
        animatedModel.applyTransform(frame2Id);
      }
      if (frame1Id !== -1) {
        animatedModel.applyTransform(frame1Id);
      }
      animatedModel.applyLighting(64, 768, -50, -10, -50, true);
      return animatedModel;
    }
  };
  var Widget = _Widget;
  Widget.mediaArchive = null;
  Widget.interfaces = null;
  Widget.fonts = null;
  Widget.anInt243 = 0;
  Widget.anInt246 = -1;
  Widget.spriteCacheModern = /* @__PURE__ */ new Map();
  Widget.anInt255 = -1;
  Widget.modelCache = new Cache(30);
  Widget.anInt277 = -1;
  Widget.anInt280 = 0;
  Widget.data = null;

  // osrs/util/MouseCapturer.ts
  init_inject();
  var MouseCapturer = class {
    constructor(_client) {
      this.capturing = true;
      this.coordsY = Array(500).fill(0);
      this.objectLock = new Object();
      this.coordsX = Array(500).fill(0);
      if (this._client === void 0) {
        this._client = null;
      }
      if (this.client === void 0) {
        this.client = null;
      }
      if (this.coord === void 0) {
        this.coord = 0;
      }
      this.client = _client;
    }
    async run() {
      if (this.coord < 500) {
        this.coordsX[this.coord] = this.client.mouseX;
        this.coordsY[this.coord] = this.client.mouseY;
        this.coord++;
      }
      await sleep(50);
      return this.capturing;
    }
  };

  // osrs/cache/cfg/ChatCensor.ts
  init_inject();
  var _ChatCensor = class {
    static load(archive) {
      const fragmentsEnc = new Buffer3(archive.getFile("fragmentsenc.txt"));
      const badEnc = new Buffer3(archive.getFile("badenc.txt"));
      const domainEnc = new Buffer3(archive.getFile("domainenc.txt"));
      const topLevelDomainsBuffer = new Buffer3(archive.getFile("tldlist.txt"));
      _ChatCensor.loadDictionaries(fragmentsEnc, badEnc, domainEnc, topLevelDomainsBuffer);
    }
    static loadDictionaries(fragmentsEnc, badEnc, domainEnc, topLevelDomainsBuffer) {
      _ChatCensor.loadBadEnc(badEnc);
      _ChatCensor.loadDomainEnc(domainEnc);
      _ChatCensor.loadFragmentsEnc(fragmentsEnc);
      _ChatCensor.loadTopLevelDomains(topLevelDomainsBuffer);
    }
    static loadTopLevelDomains(buffer) {
      const length = buffer.getInt();
      _ChatCensor.topLevelDomains = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(length);
      _ChatCensor.topLevelDomainsType = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(length);
      for (let index = 0; index < length; index++) {
        {
          _ChatCensor.topLevelDomainsType[index] = buffer.getUnsignedByte();
          const topLevelDomain = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(null);
            }
            return a;
          })(buffer.getUnsignedByte());
          for (let character = 0; character < topLevelDomain.length; character++) {
            topLevelDomain[character] = String.fromCharCode(buffer.getUnsignedByte());
          }
          _ChatCensor.topLevelDomains[index] = topLevelDomain;
        }
      }
    }
    static loadBadEnc(buffer) {
      const length = buffer.getInt();
      _ChatCensor.badWords = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(length);
      _ChatCensor.badBytes = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(length);
      _ChatCensor.loadBadWords(buffer, _ChatCensor.badWords, _ChatCensor.badBytes);
    }
    static loadDomainEnc(buffer) {
      const length = buffer.getInt();
      _ChatCensor.domains = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(length);
      _ChatCensor.loadDomains(buffer, _ChatCensor.domains);
    }
    static loadFragmentsEnc(buffer) {
      _ChatCensor.fragments = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(buffer.getInt());
      for (let index = 0; index < _ChatCensor.fragments.length; index++) {
        _ChatCensor.fragments[index] = buffer.getUnsignedLEShort();
      }
    }
    static loadBadWords(buffer, badWords, badBytes) {
      for (let index = 0; index < badWords.length; index++) {
        {
          const badWord = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(null);
            }
            return a;
          })(buffer.getUnsignedByte());
          for (let k = 0; k < badWord.length; k++) {
            badWord[k] = String.fromCharCode(buffer.getUnsignedByte());
          }
          badWords[index] = badWord;
          const badByte = function(dims) {
            const allocate = function(dims2) {
              if (dims2.length == 0) {
                return 0;
              } else {
                const array = [];
                for (let i = 0; i < dims2[0]; i++) {
                  array.push(allocate(dims2.slice(1)));
                }
                return array;
              }
            };
            return allocate(dims);
          }([buffer.getUnsignedByte(), 2]);
          for (let l = 0; l < badByte.length; l++) {
            {
              badByte[l][0] = buffer.getUnsignedByte() | 0;
              badByte[l][1] = buffer.getUnsignedByte() | 0;
            }
          }
          if (badByte.length > 0) {
            badBytes[index] = badByte;
          }
        }
      }
    }
    static loadDomains(buffer, cs) {
      for (let index = 0; index < cs.length; index++) {
        {
          const domainEnc = ((s) => {
            const a = [];
            while (s-- > 0) {
              a.push(null);
            }
            return a;
          })(buffer.getUnsignedByte());
          for (let character = 0; character < domainEnc.length; character++) {
            domainEnc[character] = String.fromCharCode(buffer.getUnsignedByte());
          }
          cs[index] = domainEnc;
        }
      }
    }
    static formatLegalCharacters(characters) {
      let character = 0;
      for (let index = 0; index < characters.length; index++) {
        {
          if (_ChatCensor.isLegalCharacter(characters[index])) {
            characters[character] = characters[index];
          } else {
            characters[character] = " ";
          }
          if (character === 0 || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(characters[character]) != " ".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(characters[character - 1]) != " ".charCodeAt(0)) {
            character++;
          }
        }
      }
      for (let characterIndex = character; characterIndex < characters.length; characterIndex++) {
        characters[characterIndex] = " ";
      }
    }
    static isLegalCharacter(character) {
      return ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) >= " ".charCodeAt(0) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) <= "\x7F".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) == " ".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) == "\n".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) == "	".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) == "\xA3".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) == "\u20AC".charCodeAt(0);
    }
    static censorString(string) {
      return string;
    }
    static method384(i, ac, ac1) {
      for (let j = 0; j < ac1.length; j++) {
        if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[j]) != "*".charCodeAt(0) && _ChatCensor.method408(-217, ac1[j])) {
          ac[j] = ac1[j];
        }
      }
      if (i !== 0) {
        _ChatCensor.anInt728 = 271;
      }
    }
    static method385(i, ac) {
      let flag = true;
      for (let j = 0; j < ac.length; j++) {
        {
          const c2 = ac[j];
          if (_ChatCensor.method405(true, c2)) {
            if (flag) {
              if (_ChatCensor.method407(c2)) {
                flag = false;
              }
            } else if (_ChatCensor.method408(-217, c2)) {
              ac[j] = String.fromCharCode(((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) + 97 - 65);
            }
          } else {
            flag = true;
          }
        }
      }
      if (i === 1) {
      }
    }
    static method386(ac, i) {
      for (let j = 0; j < 2; j++) {
        {
          for (let k = _ChatCensor.badWords.length - 1; k >= 0; k--) {
            _ChatCensor.method395(_ChatCensor.badBytes[k], -939, _ChatCensor.badWords[k], ac);
          }
        }
      }
      if (i !== -48545) {
        _ChatCensor.aBoolean731 = !_ChatCensor.aBoolean731;
      }
    }
    static method387(i, ac) {
      const ac1 = ((o) => {
        if (o.clone != void 0) {
          return o.clone();
        } else {
          const clone = Object.create(o);
          for (const p in o) {
            if (o.hasOwnProperty(p)) {
              clone[p] = o[p];
            }
          }
          return clone;
        }
      })(ac);
      const ac2 = ["(", "a", ")"];
      _ChatCensor.method395(null, -939, ac2, ac1);
      if (i < 3 || i > 3) {
        _ChatCensor.anInt728 = 382;
      }
      const ac3 = ((o) => {
        if (o.clone != void 0) {
          return o.clone();
        } else {
          const clone = Object.create(o);
          for (const p in o) {
            if (o.hasOwnProperty(p)) {
              clone[p] = o[p];
            }
          }
          return clone;
        }
      })(ac);
      const ac4 = ["d", "o", "t"];
      _ChatCensor.method395(null, -939, ac4, ac3);
      for (let j = _ChatCensor.domains.length - 1; j >= 0; j--) {
        _ChatCensor.method388(ac, ac3, ac1, -65, _ChatCensor.domains[j]);
      }
    }
    static method388(ac, ac1, ac2, i, ac3) {
      if (i >= 0) {
        return;
      }
      if (ac3.length > ac.length) {
        return;
      }
      let j;
      for (let k = 0; k <= ac.length - ac3.length; k += j) {
        {
          let l = k;
          let i1 = 0;
          j = 1;
          while (l < ac.length) {
            {
              let j1 = 0;
              const c2 = ac[l];
              let c1 = "\0";
              if (l + 1 < ac.length) {
                c1 = ac[l + 1];
              }
              if (i1 < ac3.length && (j1 = _ChatCensor.method397(c2, 0, ac3[i1], c1)) > 0) {
                l += j1;
                i1++;
                continue;
              }
              if (i1 === 0) {
                break;
              }
              if ((j1 = _ChatCensor.method397(c2, 0, ac3[i1 - 1], c1)) > 0) {
                l += j1;
                if (i1 === 1) {
                  j++;
                }
                continue;
              }
              if (i1 >= ac3.length || !_ChatCensor.method403(c2, false)) {
                break;
              }
              l++;
            }
          }
          if (i1 >= ac3.length) {
            let flag1 = false;
            const k1 = _ChatCensor.method389(ac, ac2, -72 | 0, k);
            const l1 = _ChatCensor.method390(ac1, 0, l - 1, ac);
            if (k1 > 2 || l1 > 2) {
              flag1 = true;
            }
            if (flag1) {
              for (let i2 = k; i2 < l; i2++) {
                ac[i2] = "*";
              }
            }
          }
        }
      }
    }
    static method389(ac, ac1, byte0, i) {
      if (i === 0) {
        return 2;
      }
      for (let j = i - 1; j >= 0; j--) {
        {
          if (!_ChatCensor.method403(ac[j], false)) {
            break;
          }
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[j]) == "@".charCodeAt(0)) {
            return 3;
          }
        }
      }
      let k = 0;
      for (let l = i - 1; l >= 0; l--) {
        {
          if (!_ChatCensor.method403(ac1[l], false)) {
            break;
          }
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[l]) == "*".charCodeAt(0)) {
            k++;
          }
        }
      }
      if (byte0 !== -72) {
        return 3;
      }
      if (k >= 3) {
        return 4;
      }
      return !_ChatCensor.method403(ac[i - 1], false) ? 0 : 1;
    }
    static method390(ac, i, j, ac1) {
      if (j + 1 === ac1.length) {
        return 2;
      }
      for (let k = j + 1; k < ac1.length; k++) {
        {
          if (!_ChatCensor.method403(ac1[k], false)) {
            break;
          }
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[k]) == ".".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[k]) == ",".charCodeAt(0)) {
            return 3;
          }
        }
      }
      let l = 0;
      if (i !== 0) {
        return _ChatCensor.anInt733;
      }
      for (let i1 = j + 1; i1 < ac1.length; i1++) {
        {
          if (!_ChatCensor.method403(ac[i1], false)) {
            break;
          }
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[i1]) == "*".charCodeAt(0)) {
            l++;
          }
        }
      }
      if (l >= 3) {
        return 4;
      }
      return !_ChatCensor.method403(ac1[j + 1], false) ? 0 : 1;
    }
    static method391(ac, i) {
      const ac1 = ((o) => {
        if (o.clone != void 0) {
          return o.clone();
        } else {
          const clone = Object.create(o);
          for (const p in o) {
            if (o.hasOwnProperty(p)) {
              clone[p] = o[p];
            }
          }
          return clone;
        }
      })(ac);
      const ac2 = ["d", "o", "t"];
      _ChatCensor.method395(null, -939, ac2, ac1);
      const ac3 = ((o) => {
        if (o.clone != void 0) {
          return o.clone();
        } else {
          const clone = Object.create(o);
          for (const p in o) {
            if (o.hasOwnProperty(p)) {
              clone[p] = o[p];
            }
          }
          return clone;
        }
      })(ac);
      const ac4 = ["s", "l", "a", "s", "h"];
      if (i !== 0) {
        _ChatCensor.aBoolean732 = !_ChatCensor.aBoolean732;
      }
      _ChatCensor.method395(null, -939, ac4, ac3);
      for (let j = 0; j < _ChatCensor.topLevelDomains.length; j++) {
        _ChatCensor.method392(ac, 7 | 0, ac1, _ChatCensor.topLevelDomainsType[j], _ChatCensor.topLevelDomains[j], ac3);
      }
    }
    static method392(ac, byte0, ac1, i, ac2, ac3) {
      if (ac2.length > ac.length) {
        return;
      }
      let j;
      for (let k = 0; k <= ac.length - ac2.length; k += j) {
        {
          let l = k;
          let i1 = 0;
          j = 1;
          while (l < ac.length) {
            {
              let j1 = 0;
              const c2 = ac[l];
              let c1 = "\0";
              if (l + 1 < ac.length) {
                c1 = ac[l + 1];
              }
              if (i1 < ac2.length && (j1 = _ChatCensor.method397(c2, 0, ac2[i1], c1)) > 0) {
                l += j1;
                i1++;
                continue;
              }
              if (i1 === 0) {
                break;
              }
              if ((j1 = _ChatCensor.method397(c2, 0, ac2[i1 - 1], c1)) > 0) {
                l += j1;
                if (i1 === 1) {
                  j++;
                }
                continue;
              }
              if (i1 >= ac2.length || !_ChatCensor.method403(c2, false)) {
                break;
              }
              l++;
            }
          }
          if (i1 >= ac2.length) {
            let flag1 = false;
            const k1 = _ChatCensor.method393(ac1, k, ac, -113 | 0);
            const l1 = _ChatCensor.method394(ac3, l - 1, ac, 3);
            if (i === 1 && k1 > 0 && l1 > 0) {
              flag1 = true;
            }
            if (i === 2 && (k1 > 2 && l1 > 0 || k1 > 0 && l1 > 2)) {
              flag1 = true;
            }
            if (i === 3 && k1 > 0 && l1 > 2) {
              flag1 = true;
            }
            if (flag1) {
              let i2 = k;
              let j2 = l - 1;
              if (k1 > 2) {
                if (k1 === 4) {
                  let flag2 = false;
                  for (let l2 = i2 - 1; l2 >= 0; l2--) {
                    if (flag2) {
                      if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[l2]) != "*".charCodeAt(0)) {
                        break;
                      }
                      i2 = l2;
                    } else if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[l2]) == "*".charCodeAt(0)) {
                      i2 = l2;
                      flag2 = true;
                    }
                  }
                }
                let flag3 = false;
                for (let i3 = i2 - 1; i3 >= 0; i3--) {
                  if (flag3) {
                    if (_ChatCensor.method403(ac[i3], false)) {
                      break;
                    }
                    i2 = i3;
                  } else if (!_ChatCensor.method403(ac[i3], false)) {
                    flag3 = true;
                    i2 = i3;
                  }
                }
              }
              if (l1 > 2) {
                if (l1 === 4) {
                  let flag4 = false;
                  for (let j3 = j2 + 1; j3 < ac.length; j3++) {
                    if (flag4) {
                      if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac3[j3]) != "*".charCodeAt(0)) {
                        break;
                      }
                      j2 = j3;
                    } else if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac3[j3]) == "*".charCodeAt(0)) {
                      j2 = j3;
                      flag4 = true;
                    }
                  }
                }
                let flag5 = false;
                for (let k3 = j2 + 1; k3 < ac.length; k3++) {
                  if (flag5) {
                    if (_ChatCensor.method403(ac[k3], false)) {
                      break;
                    }
                    j2 = k3;
                  } else if (!_ChatCensor.method403(ac[k3], false)) {
                    flag5 = true;
                    j2 = k3;
                  }
                }
              }
              for (let k2 = i2; k2 <= j2; k2++) {
                ac[k2] = "*";
              }
            }
          }
        }
      }
      if (byte0 === 7) {
        byte0 = 0;
      }
    }
    static method393(ac, i, ac1, byte0) {
      if (byte0 !== _ChatCensor.aByte735) {
        for (let j = 1; j > 0; j++) {
        }
      }
      if (i === 0) {
        return 2;
      }
      for (let k = i - 1; k >= 0; k--) {
        {
          if (!_ChatCensor.method403(ac1[k], false)) {
            break;
          }
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[k]) == ",".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[k]) == ".".charCodeAt(0)) {
            return 3;
          }
        }
      }
      let l = 0;
      for (let i1 = i - 1; i1 >= 0; i1--) {
        {
          if (!_ChatCensor.method403(ac[i1], false)) {
            break;
          }
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[i1]) == "*".charCodeAt(0)) {
            l++;
          }
        }
      }
      if (l >= 3) {
        return 4;
      }
      return !_ChatCensor.method403(ac1[i - 1], false) ? 0 : 1;
    }
    static method394(ac, i, ac1, j) {
      if (j < _ChatCensor.anInt736 || j > _ChatCensor.anInt736) {
        for (let k = 1; k > 0; k++) {
        }
      }
      if (i + 1 === ac1.length) {
        return 2;
      }
      for (let l = i + 1; l < ac1.length; l++) {
        {
          if (!_ChatCensor.method403(ac1[l], false)) {
            break;
          }
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[l]) == "\\".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[l]) == "/".charCodeAt(0)) {
            return 3;
          }
        }
      }
      let i1 = 0;
      for (let j1 = i + 1; j1 < ac1.length; j1++) {
        {
          if (!_ChatCensor.method403(ac[j1], false)) {
            break;
          }
          if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[j1]) == "*".charCodeAt(0)) {
            i1++;
          }
        }
      }
      if (i1 >= 5) {
        return 4;
      }
      return !_ChatCensor.method403(ac1[i + 1], false) ? 0 : 1;
    }
    static method395(abyte0, i, ac, ac1) {
      while (i >= 0) {
        return;
      }
      if (ac.length > ac1.length) {
        return;
      }
      let j;
      for (let k = 0; k <= ac1.length - ac.length; k += j) {
        {
          let l = k;
          let i1 = 0;
          let j1 = 0;
          j = 1;
          let flag1 = false;
          let flag2 = false;
          let flag3 = false;
          while (l < ac1.length && (!flag2 || !flag3)) {
            {
              let k1 = 0;
              const c2 = ac1[l];
              let c22 = "\0";
              if (l + 1 < ac1.length) {
                c22 = ac1[l + 1];
              }
              if (i1 < ac.length && (k1 = _ChatCensor.method398(ac[i1], c2, c22, 7)) > 0) {
                if (k1 === 1 && _ChatCensor.method406(c2, false)) {
                  flag2 = true;
                }
                if (k1 === 2 && (_ChatCensor.method406(c2, false) || _ChatCensor.method406(c22, false))) {
                  flag2 = true;
                }
                l += k1;
                i1++;
                continue;
              }
              if (i1 === 0) {
                break;
              }
              if ((k1 = _ChatCensor.method398(ac[i1 - 1], c2, c22, 7)) > 0) {
                l += k1;
                if (i1 === 1) {
                  j++;
                }
                continue;
              }
              if (i1 >= ac.length || !_ChatCensor.method404(2, c2)) {
                break;
              }
              if (_ChatCensor.method403(c2, false) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) != "'".charCodeAt(0)) {
                flag1 = true;
              }
              if (_ChatCensor.method406(c2, false)) {
                flag3 = true;
              }
              l++;
              if ((++j1 * 100 / (l - k) | 0) > 90) {
                break;
              }
            }
          }
          if (i1 >= ac.length && (!flag2 || !flag3)) {
            let flag4 = true;
            if (!flag1) {
              let c1 = " ";
              if (k - 1 >= 0) {
                c1 = ac1[k - 1];
              }
              let c3 = " ";
              if (l < ac1.length) {
                c3 = ac1[l];
              }
              const byte0 = _ChatCensor.method399(c1, 7 | 0);
              const byte1 = _ChatCensor.method399(c3, 7 | 0);
              if (abyte0 != null && _ChatCensor.method396(byte1, abyte0, byte0, 4)) {
                flag4 = false;
              }
            } else {
              let flag5 = false;
              let flag6 = false;
              if (k - 1 < 0 || _ChatCensor.method403(ac1[k - 1], false) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[k - 1]) != "'".charCodeAt(0)) {
                flag5 = true;
              }
              if (l >= ac1.length || _ChatCensor.method403(ac1[l], false) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[l]) != "'".charCodeAt(0)) {
                flag6 = true;
              }
              if (!flag5 || !flag6) {
                let flag7 = false;
                let k2 = k - 2;
                if (flag5) {
                  k2 = k;
                }
                for (; !flag7 && k2 < l; k2++) {
                  if (k2 >= 0 && (!_ChatCensor.method403(ac1[k2], false) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[k2]) == "'".charCodeAt(0))) {
                    const ac2 = [null, null, null];
                    let j3;
                    for (j3 = 0; j3 < 3; j3++) {
                      {
                        if (k2 + j3 >= ac1.length || _ChatCensor.method403(ac1[k2 + j3], false) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[k2 + j3]) != "'".charCodeAt(0)) {
                          break;
                        }
                        ac2[j3] = ac1[k2 + j3];
                      }
                    }
                    let flag8 = true;
                    if (j3 === 0) {
                      flag8 = false;
                    }
                    if (j3 < 3 && k2 - 1 >= 0 && (!_ChatCensor.method403(ac1[k2 - 1], false) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac1[k2 - 1]) == "'".charCodeAt(0))) {
                      flag8 = false;
                    }
                    if (flag8 && !_ChatCensor.method409(ac2, 463)) {
                      flag7 = true;
                    }
                  }
                }
                if (!flag7) {
                  flag4 = false;
                }
              }
            }
            if (flag4) {
              let l1 = 0;
              let i2 = 0;
              let j2 = -1;
              for (let l2 = k; l2 < l; l2++) {
                if (_ChatCensor.method406(ac1[l2], false)) {
                  l1++;
                } else if (_ChatCensor.method405(true, ac1[l2])) {
                  i2++;
                  j2 = l2;
                }
              }
              if (j2 > -1) {
                l1 -= l - 1 - j2;
              }
              if (l1 <= i2) {
                for (let i3 = k; i3 < l; i3++) {
                  ac1[i3] = "*";
                }
              } else {
                j = 1;
              }
            }
          }
        }
      }
    }
    static method396(byte0, abyte0, byte1, i) {
      let j = 0;
      if (i < 4 || i > 4) {
        throw Error("NullPointerException");
      }
      if (abyte0[j][0] === byte1 && abyte0[j][1] === byte0) {
        return true;
      }
      let k = abyte0.length - 1;
      if (abyte0[k][0] === byte1 && abyte0[k][1] === byte0) {
        return true;
      }
      do {
        {
          const l = (j + k) / 2 | 0;
          if (abyte0[l][0] === byte1 && abyte0[l][1] === byte0) {
            return true;
          }
          if (byte1 < abyte0[l][0] || byte1 === abyte0[l][0] && byte0 < abyte0[l][1]) {
            k = l;
          } else {
            j = l;
          }
        }
      } while (j !== k && j + 1 !== k);
      return false;
    }
    static method397(c2, i, c1, c22) {
      if (i !== 0) {
        return _ChatCensor.anInt733;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2)) {
        return 1;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "o".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "0".charCodeAt(0)) {
        return 1;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "o".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "(".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) == ")".charCodeAt(0)) {
        return 2;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "c".charCodeAt(0) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "(".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "<".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "[".charCodeAt(0))) {
        return 1;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "e".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "\u20AC".charCodeAt(0)) {
        return 1;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "s".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "$".charCodeAt(0)) {
        return 1;
      }
      return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "l".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) != "i".charCodeAt(0) ? 0 : 1;
    }
    static method398(c2, c1, c22, i) {
      if (i !== 7) {
        return _ChatCensor.anInt728;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1)) {
        return 1;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "a".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "m".charCodeAt(0)) {
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "a".charCodeAt(0)) {
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "4".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "@".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "^".charCodeAt(0)) {
            return 1;
          }
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "/".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "\\".charCodeAt(0) ? 0 : 2;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "b".charCodeAt(0)) {
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "6".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "8".charCodeAt(0)) {
            return 1;
          }
          return (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "1".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "3".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "i".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "3".charCodeAt(0)) ? 0 : 2;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "c".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "(".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "<".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "{".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "[".charCodeAt(0) ? 0 : 1;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "d".charCodeAt(0)) {
          return (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "[".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != ")".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "i".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != ")".charCodeAt(0)) ? 0 : 2;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "e".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "3".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "\u20AC".charCodeAt(0) ? 0 : 1;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "f".charCodeAt(0)) {
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "p".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) == "h".charCodeAt(0)) {
            return 2;
          }
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "\xA3".charCodeAt(0) ? 0 : 1;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "g".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "9".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "6".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "q".charCodeAt(0) ? 0 : 1;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "h".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "#".charCodeAt(0) ? 0 : 1;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "i".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "y".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "l".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "j".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "1".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "!".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != ":".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != ";".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "|".charCodeAt(0) ? 0 : 1;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "j".charCodeAt(0)) {
          return 0;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "k".charCodeAt(0)) {
          return 0;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "l".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "1".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "|".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "i".charCodeAt(0) ? 0 : 1;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "m".charCodeAt(0)) {
          return 0;
        }
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "n".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "z".charCodeAt(0)) {
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "n".charCodeAt(0)) {
          return 0;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "o".charCodeAt(0)) {
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "0".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "*".charCodeAt(0)) {
            return 1;
          }
          return (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "(".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != ")".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "[".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "]".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "{".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "}".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "<".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != ">".charCodeAt(0)) ? 0 : 2;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "p".charCodeAt(0)) {
          return 0;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "q".charCodeAt(0)) {
          return 0;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "r".charCodeAt(0)) {
          return 0;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "s".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "5".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "z".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "$".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "2".charCodeAt(0) ? 0 : 1;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "t".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "7".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "+".charCodeAt(0) ? 0 : 1;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "u".charCodeAt(0)) {
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "v".charCodeAt(0)) {
            return 1;
          }
          return (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "\\".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "/".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "\\".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "|".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "|".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "/".charCodeAt(0)) ? 0 : 2;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "v".charCodeAt(0)) {
          return (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "\\".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "/".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "\\".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "|".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "|".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "/".charCodeAt(0)) ? 0 : 2;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "w".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "v".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "v".charCodeAt(0) ? 0 : 2;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "x".charCodeAt(0)) {
          return (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != ")".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "(".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "}".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "{".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "]".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "[".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != ">".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "<".charCodeAt(0)) ? 0 : 2;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "y".charCodeAt(0)) {
          return 0;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "z".charCodeAt(0)) {
          return 0;
        }
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "0".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "9".charCodeAt(0)) {
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "0".charCodeAt(0)) {
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "o".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) == "O".charCodeAt(0)) {
            return 1;
          }
          return (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "(".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != ")".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "{".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "}".charCodeAt(0)) && (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "[".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c22) != "]".charCodeAt(0)) ? 0 : 2;
        }
        if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "1".charCodeAt(0)) {
          return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "l".charCodeAt(0) ? 0 : 1;
        } else {
          return 0;
        }
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == ",".charCodeAt(0)) {
        return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != ".".charCodeAt(0) ? 0 : 1;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == ".".charCodeAt(0)) {
        return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != ",".charCodeAt(0) ? 0 : 1;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "!".charCodeAt(0)) {
        return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) != "i".charCodeAt(0) ? 0 : 1;
      } else {
        return 0;
      }
    }
    static method399(c2, byte0) {
      if (byte0 !== 7) {
        throw Error("NullPointerException");
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "a".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "z".charCodeAt(0)) {
        return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) - 97 + 1 | 0;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "'".charCodeAt(0)) {
        return 28;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "0".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "9".charCodeAt(0)) {
        return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) - 48 + 29 | 0;
      } else {
        return 27;
      }
    }
    static method400(i, ac) {
      let j = 0;
      let k = 0;
      let l = 0;
      if (i < 3 || i > 3) {
        return;
      }
      let i1 = 0;
      while ((j = _ChatCensor.method401(307, k, ac)) !== -1) {
        {
          let flag = false;
          for (let j1 = k; j1 >= 0 && j1 < j && !flag; j1++) {
            if (!_ChatCensor.method403(ac[j1], false) && !_ChatCensor.method404(2, ac[j1])) {
              flag = true;
            }
          }
          if (flag) {
            l = 0;
          }
          if (l === 0) {
            i1 = j;
          }
          k = _ChatCensor.method402(j, 618, ac);
          let k1 = 0;
          for (let l1 = j; l1 < k; l1++) {
            k1 = k1 * 10 + ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[l1]) - 48;
          }
          if (k1 > 255 || k - j > 8) {
            l = 0;
          } else {
            l++;
          }
          if (l === 4) {
            for (let i2 = i1; i2 < k; i2++) {
              ac[i2] = "*";
            }
            l = 0;
          }
        }
      }
    }
    static method401(i, j, ac) {
      for (let k = j; k < ac.length && k >= 0; k++) {
        if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[k]) >= "0".charCodeAt(0) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[k]) <= "9".charCodeAt(0)) {
          return k;
        }
      }
      if (i <= 0) {
        _ChatCensor.aBoolean731 = !_ChatCensor.aBoolean731;
      }
      return -1;
    }
    static method402(i, j, ac) {
      if (j <= 0) {
        for (let k = 1; k > 0; k++) {
        }
      }
      for (let l = i; l < ac.length && l >= 0; l++) {
        if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[l]) < "0".charCodeAt(0) || ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[l]) > "9".charCodeAt(0)) {
          return l;
        }
      }
      return ac.length;
    }
    static method403(c2, flag) {
      if (flag) {
        throw Error("NullPointerException");
      }
      return !_ChatCensor.method405(true, c2) && !_ChatCensor.method406(c2, false);
    }
    static method404(i, c2) {
      if (i !== 2) {
        _ChatCensor.aBoolean732 = !_ChatCensor.aBoolean732;
      }
      if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) < "a".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) > "z".charCodeAt(0)) {
        return true;
      }
      return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "v".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "x".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "j".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "q".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "z".charCodeAt(0);
    }
    static method405(flag, c2) {
      return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "a".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "z".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "A".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "Z".charCodeAt(0);
    }
    static method406(c2, flag) {
      if (flag) {
        throw Error("NullPointerException");
      }
      return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "0".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "9".charCodeAt(0);
    }
    static method407(c2) {
      return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "a".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "z".charCodeAt(0);
    }
    static method408(i, c2) {
      return ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "A".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "Z".charCodeAt(0);
    }
    static method409(ac, i) {
      let flag = true;
      for (let j = 0; j < ac.length; j++) {
        if (!_ChatCensor.method406(ac[j], false) && ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(ac[j]) != 0) {
          flag = false;
        }
      }
      i = 78 / i | 0;
      if (flag) {
        return true;
      }
      const k = _ChatCensor.method410(ac, 5 | 0);
      let l = 0;
      let i1 = _ChatCensor.fragments.length - 1;
      if (k === _ChatCensor.fragments[l] || k === _ChatCensor.fragments[i1]) {
        return true;
      }
      do {
        {
          const j1 = (l + i1) / 2 | 0;
          if (k === _ChatCensor.fragments[j1]) {
            return true;
          }
          if (k < _ChatCensor.fragments[j1]) {
            i1 = j1;
          } else {
            l = j1;
          }
        }
      } while (l !== i1 && l + 1 !== i1);
      return false;
    }
    static method410(ac, byte0) {
      if (ac.length > 6) {
        return 0;
      }
      let i = 0;
      if (byte0 === 5) {
        byte0 = 0;
      } else {
        return 3;
      }
      for (let j = 0; j < ac.length; j++) {
        {
          const c2 = ac[ac.length - j - 1];
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "a".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "z".charCodeAt(0)) {
            i = i * 38 + (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) - 97 + 1);
          } else if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "'".charCodeAt(0)) {
            i = i * 38 + 27;
          } else if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "0".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "9".charCodeAt(0)) {
            i = i * 38 + (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) - 48 + 28);
          } else if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) != 0) {
            return 0;
          }
        }
      }
      return i;
    }
  };
  var ChatCensor = _ChatCensor;
  ChatCensor.anInt728 = 3;
  ChatCensor.anInt729 = 0;
  ChatCensor.aBoolean731 = false;
  ChatCensor.aBoolean732 = false;
  ChatCensor.anInt733 = -48545;
  ChatCensor.anInt734 = 0;
  ChatCensor.aByte735 = -113;
  ChatCensor.anInt736 = 3;
  ChatCensor.aBoolean738 = false;
  ChatCensor.fragments = null;
  ChatCensor.badWords = null;
  ChatCensor.badBytes = null;
  ChatCensor.domains = null;
  ChatCensor.topLevelDomains = null;
  ChatCensor.topLevelDomainsType = null;
  ChatCensor.toCharArray = ["cook", "cook's", "cooks", "seeks", "sheet", "woop", "woops", "faq", "noob", "noobs"];

  // osrs/media/renderable/actor/Player.ts
  init_inject();

  // osrs/media/renderable/actor/Actor.ts
  init_inject();
  var Actor = class extends Renderable {
    constructor() {
      super();
      this.textCycle = 100;
      this.pathX = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.pathY = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.movementAnimation = -1;
      this.runningQueue = [false, false, false, false, false, false, false, false, false, false];
      this.aBoolean1592 = false;
      this.modelHeight = 200;
      this.endCycle = -1e3;
      this.anInt1600 = 32;
      this.boundaryDimension = 1;
      this.anInt1609 = -1;
      this.graphic = -1;
      this.walkAnimationId = -1;
      this.turnAroundAnimationId = -1;
      this.turnRightAnimationId = -1;
      this.turnLeftAnimationId = -1;
      this.emoteAnimation = -1;
      this.runAnimationId = -1;
      this.hitDamages = [0, 0, 0, 0];
      this.hitTypes = [0, 0, 0, 0];
      this.hitCycles = [0, 0, 0, 0];
      this.idleAnimation = -1;
      this.standTurnAnimationId = -1;
      if (this.forcedChat === void 0) {
        this.forcedChat = null;
      }
      if (this.textColour === void 0) {
        this.textColour = 0;
      }
      if (this.nextStepOrientation === void 0) {
        this.nextStepOrientation = 0;
      }
      if (this.pulseCycle === void 0) {
        this.pulseCycle = 0;
      }
      if (this.displayedMovementFrames === void 0) {
        this.displayedMovementFrames = 0;
      }
      if (this.anInt1590 === void 0) {
        this.anInt1590 = 0;
      }
      if (this.textEffect === void 0) {
        this.textEffect = 0;
      }
      if (this.anInt1596 === void 0) {
        this.anInt1596 = 0;
      }
      if (this.anInt1597 === void 0) {
        this.anInt1597 = 0;
      }
      if (this.anInt1598 === void 0) {
        this.anInt1598 = 0;
      }
      if (this.anInt1599 === void 0) {
        this.anInt1599 = 0;
      }
      if (this.anInt1602 === void 0) {
        this.anInt1602 = 0;
      }
      if (this.anInt1603 === void 0) {
        this.anInt1603 = 0;
      }
      if (this.anInt1604 === void 0) {
        this.anInt1604 = 0;
      }
      if (this.anInt1605 === void 0) {
        this.anInt1605 = 0;
      }
      if (this.anInt1606 === void 0) {
        this.anInt1606 = 0;
      }
      if (this.anInt1607 === void 0) {
        this.anInt1607 = 0;
      }
      if (this.anInt1608 === void 0) {
        this.anInt1608 = 0;
      }
      if (this.worldX === void 0) {
        this.worldX = 0;
      }
      if (this.worldY === void 0) {
        this.worldY = 0;
      }
      if (this.anInt1612 === void 0) {
        this.anInt1612 = 0;
      }
      if (this.anInt1613 === void 0) {
        this.anInt1613 = 0;
      }
      if (this.currentAnimation === void 0) {
        this.currentAnimation = 0;
      }
      if (this.anInt1616 === void 0) {
        this.anInt1616 = 0;
      }
      if (this.anInt1617 === void 0) {
        this.anInt1617 = 0;
      }
      if (this.spotAnimationDelay === void 0) {
        this.spotAnimationDelay = 0;
      }
      if (this.anInt1623 === void 0) {
        this.anInt1623 = 0;
      }
      if (this.displayedEmoteFrames === void 0) {
        this.displayedEmoteFrames = 0;
      }
      if (this.anInt1626 === void 0) {
        this.anInt1626 = 0;
      }
      if (this.animationDelay === void 0) {
        this.animationDelay = 0;
      }
      if (this.anInt1628 === void 0) {
        this.anInt1628 = 0;
      }
      if (this.pathLength === void 0) {
        this.pathLength = 0;
      }
    }
    resetPath() {
      this.pathLength = 0;
      this.anInt1613 = 0;
    }
    isVisible() {
      return false;
    }
    move(direction, running) {
      let x2 = this.pathX[0];
      let y = this.pathY[0];
      if (direction === 0) {
        x2--;
        y++;
      }
      if (direction === 1) {
        y++;
      }
      if (direction === 2) {
        x2++;
        y++;
      }
      if (direction === 3) {
        x2--;
      }
      if (direction === 4) {
        x2++;
      }
      if (direction === 5) {
        x2--;
        y--;
      }
      if (direction === 6) {
        y--;
      }
      if (direction === 7) {
        x2++;
        y--;
      }
      if (this.emoteAnimation !== -1 && AnimationSequence.animations[this.emoteAnimation].priority === 1) {
        this.emoteAnimation = -1;
      }
      if (this.pathLength < 9) {
        this.pathLength++;
      }
      for (let pos = this.pathLength; pos > 0; pos--) {
        {
          this.pathX[pos] = this.pathX[pos - 1];
          this.pathY[pos] = this.pathY[pos - 1];
          this.runningQueue[pos] = this.runningQueue[pos - 1];
        }
      }
      this.pathX[0] = x2;
      this.pathY[0] = y;
      this.runningQueue[0] = running;
    }
    updateHits(hitType, hitDamage, hitCycle) {
      for (let hit = 0; hit < 4; hit++) {
        if (this.hitCycles[hit] <= hitCycle) {
          this.hitDamages[hit] = hitDamage;
          this.hitTypes[hit] = hitType;
          this.hitCycles[hit] = hitCycle + 70;
          return;
        }
      }
    }
    setPosition(x2, y, discard) {
      if (this.emoteAnimation !== -1 && AnimationSequence.animations[this.emoteAnimation].priority === 1) {
        this.emoteAnimation = -1;
      }
      if (!discard) {
        const k = x2 - this.pathX[0];
        const i1 = y - this.pathY[0];
        if (k >= -8 && k <= 8 && i1 >= -8 && i1 <= 8) {
          if (this.pathLength < 9) {
            this.pathLength++;
          }
          for (let j1 = this.pathLength; j1 > 0; j1--) {
            {
              this.pathX[j1] = this.pathX[j1 - 1];
              this.pathY[j1] = this.pathY[j1 - 1];
              this.runningQueue[j1] = this.runningQueue[j1 - 1];
            }
          }
          this.pathX[0] = x2;
          this.pathY[0] = y;
          this.runningQueue[0] = false;
          return;
        }
      }
      this.pathLength = 0;
      this.anInt1613 = 0;
      this.anInt1623 = 0;
      this.pathX[0] = x2;
      this.pathY[0] = y;
      this.worldX = this.pathX[0] * 128 + this.boundaryDimension * 64;
      this.worldY = this.pathY[0] * 128 + this.boundaryDimension * 64;
    }
  };

  // osrs/media/renderable/actor/Player.ts
  var _Player = class extends Actor {
    constructor() {
      super();
      this.prayerIconId = -1;
      this.cachedModel = -1;
      this.appearance = Array(12).fill(0);
      this.skullIconId = -1;
      this.visible = false;
      this.appearanceColors = [0, 0, 0, 0, 0];
      this.aBoolean1763 = false;
      if (this.anInt1743 === void 0) {
        this.anInt1743 = 0;
      }
      if (this.anInt1744 === void 0) {
        this.anInt1744 = 0;
      }
      if (this.anInt1745 === void 0) {
        this.anInt1745 = 0;
      }
      if (this.playerModel === void 0) {
        this.playerModel = null;
      }
      if (this.anInt1750 === void 0) {
        this.anInt1750 = 0;
      }
      if (this.playerName === void 0) {
        this.playerName = null;
      }
      if (this.combatLevel === void 0) {
        this.combatLevel = 0;
      }
      if (this.appearanceHash === void 0) {
        this.appearanceHash = 0;
      }
      if (this.gender === void 0) {
        this.gender = 0;
      }
      if (this.npcDefinition === void 0) {
        this.npcDefinition = null;
      }
      if (this.anInt1759 === void 0) {
        this.anInt1759 = 0;
      }
      if (this.objectAppearanceStartTick === void 0) {
        this.objectAppearanceStartTick = 0;
      }
      if (this.objectAppearanceEndTick === void 0) {
        this.objectAppearanceEndTick = 0;
      }
      if (this.teamId === void 0) {
        this.teamId = 0;
      }
      if (this.anInt1768 === void 0) {
        this.anInt1768 = 0;
      }
      if (this.anInt1769 === void 0) {
        this.anInt1769 = 0;
      }
      if (this.anInt1770 === void 0) {
        this.anInt1770 = 0;
      }
      if (this.anInt1771 === void 0) {
        this.anInt1771 = 0;
      }
    }
    getHeadModel() {
      if (!this.visible) {
        return null;
      }
      if (this.npcDefinition != null) {
        return this.npcDefinition.getHeadModel();
      }
      let cached = false;
      for (let index = 0; index < 12; index++) {
        {
          const appearanceId = this.appearance[index];
          if (appearanceId >= 256 && appearanceId < 512 && !IdentityKit.cache[appearanceId - 256].isHeadModelCached()) {
            cached = true;
          }
          if (appearanceId >= 512 && !ItemDefinition.lookup(appearanceId - 512).headPieceReady(this.gender)) {
            cached = true;
          }
        }
      }
      if (cached) {
        return null;
      }
      const headModels = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(12);
      let headModelsOffset = 0;
      for (let modelIndex = 0; modelIndex < 12; modelIndex++) {
        {
          const appearanceId = this.appearance[modelIndex];
          if (appearanceId >= 256 && appearanceId < 512) {
            const subModel = IdentityKit.cache[appearanceId - 256].getHeadModel();
            if (subModel != null) {
              headModels[headModelsOffset++] = subModel;
            }
          }
          if (appearanceId >= 512) {
            const subModel = ItemDefinition.lookup(appearanceId - 512).asHeadPiece(this.gender);
            if (subModel != null) {
              headModels[headModelsOffset++] = subModel;
            }
          }
        }
      }
      const headModel = new Model(headModelsOffset, headModels);
      for (let index = 0; index < 5; index++) {
        if (this.appearanceColors[index] !== 0) {
          headModel.replaceColor(Game.playerColours[index][0], Game.playerColours[index][this.appearanceColors[index]]);
          if (index === 1) {
            headModel.replaceColor(Game.SKIN_COLOURS[0], Game.SKIN_COLOURS[this.appearanceColors[index]]);
          }
        }
      }
      return headModel;
    }
    getAnimatedModel() {
      if (this.npcDefinition != null) {
        let frame = -1;
        if (this.emoteAnimation >= 0 && this.animationDelay === 0) {
          frame = AnimationSequence.animations[this.emoteAnimation].getPrimaryFrame[this.displayedEmoteFrames];
        } else if (this.movementAnimation >= 0) {
          frame = AnimationSequence.animations[this.movementAnimation].getPrimaryFrame[this.displayedMovementFrames];
        }
        const model2 = this.npcDefinition.getChildModel(frame, -1, null);
        return model2;
      }
      let hash = this.appearanceHash;
      let primaryFrame = -1;
      let secondaryFrame = -1;
      let shieldModel = -1;
      let weaponModel = -1;
      if (this.emoteAnimation >= 0 && this.animationDelay === 0) {
        const emote = AnimationSequence.animations[this.emoteAnimation];
        primaryFrame = emote.getPrimaryFrame[this.displayedEmoteFrames];
        if (this.movementAnimation >= 0 && this.movementAnimation !== this.idleAnimation) {
          secondaryFrame = AnimationSequence.animations[this.movementAnimation].getPrimaryFrame[this.displayedMovementFrames];
        }
        if (emote.getPlayerShieldDelta >= 0) {
          shieldModel = emote.getPlayerShieldDelta;
          hash += shieldModel - this.appearance[5] << 40;
        }
        if (emote.getPlayerWeaponDelta >= 0) {
          weaponModel = emote.getPlayerWeaponDelta;
          hash += weaponModel - this.appearance[3] << 48;
        }
      } else if (this.movementAnimation >= 0) {
        primaryFrame = AnimationSequence.animations[this.movementAnimation].getPrimaryFrame[this.displayedMovementFrames];
      }
      let model = _Player.modelCache.get(hash);
      if (model == null) {
        let invalid = false;
        for (let bodyPart = 0; bodyPart < 12; bodyPart++) {
          {
            let appearanceModel = this.appearance[bodyPart];
            if (weaponModel >= 0 && bodyPart === 3) {
              appearanceModel = weaponModel;
            }
            if (shieldModel >= 0 && bodyPart === 5) {
              appearanceModel = shieldModel;
            }
            if (appearanceModel >= 256 && appearanceModel < 512 && !IdentityKit.cache[appearanceModel - 256].isBodyModelCached()) {
              invalid = true;
            }
            if (appearanceModel >= 512 && !ItemDefinition.lookup(appearanceModel - 512).equipmentReady(this.gender)) {
              invalid = true;
            }
          }
        }
        if (invalid) {
          if (this.cachedModel !== -1) {
            model = _Player.modelCache.get(this.cachedModel);
          }
          if (model == null) {
            return null;
          }
        }
      }
      if (model == null) {
        const models = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(null);
          }
          return a;
        })(12);
        let count = 0;
        for (let index = 0; index < 12; index++) {
          {
            let part = this.appearance[index];
            if (weaponModel >= 0 && index === 3) {
              part = weaponModel;
            }
            if (shieldModel >= 0 && index === 5) {
              part = shieldModel;
            }
            if (part >= 256 && part < 512) {
              const bodyModel = IdentityKit.cache[part - 256].getBodyModel();
              if (bodyModel != null) {
                models[count++] = bodyModel;
              }
            }
            if (part >= 512) {
              const equipment = ItemDefinition.lookup(part - 512).asEquipment(this.gender);
              if (equipment != null) {
                models[count++] = equipment;
              }
            }
          }
        }
        model = new Model(count, models);
        for (let part = 0; part < 5; part++) {
          if (this.appearanceColors[part] !== 0) {
            model.replaceColor(Game.playerColours[part][0], Game.playerColours[part][this.appearanceColors[part]]);
            if (part === 1) {
              model.replaceColor(Game.SKIN_COLOURS[0], Game.SKIN_COLOURS[this.appearanceColors[part]]);
            }
          }
        }
        model.createBones();
        model.applyLighting(64, 850, -30, -50, -30, true);
        _Player.modelCache.put(model, hash);
        this.cachedModel = hash;
      }
      if (this.aBoolean1763) {
        return model;
      }
      const empty = Model.EMPTY_MODEL;
      empty.replaceWithModel(model, ((lhs, rhs) => lhs && rhs)(Animation.exists(primaryFrame), Animation.exists(secondaryFrame)));
      if (primaryFrame !== -1 && secondaryFrame !== -1) {
        empty.mixAnimationFrames(secondaryFrame, 0, primaryFrame, AnimationSequence.animations[this.emoteAnimation].flowControl);
      } else if (primaryFrame !== -1) {
        empty.applyTransform(primaryFrame);
      }
      empty.calculateDiagonals();
      empty.triangleSkin = null;
      empty.vectorSkin = null;
      return empty;
    }
    isVisible() {
      return this.visible;
    }
    getRotatedModel() {
      if (!this.visible) {
        return null;
      }
      let appearanceModel = this.getAnimatedModel();
      if (appearanceModel == null) {
        return null;
      }
      this.modelHeight = appearanceModel.modelHeight;
      appearanceModel.oneSquareModel = true;
      if (this.aBoolean1763) {
        return appearanceModel;
      }
      if (this.graphic !== -1 && this.currentAnimation !== -1) {
        const spotAnimation = SpotAnimation.cache[this.graphic];
        const spotAnimationModel = spotAnimation.getModel();
        if (spotAnimationModel != null) {
          const spotAnimationModel2 = new Model(true, spotAnimationModel, Animation.exists(this.currentAnimation));
          spotAnimationModel2.translate(0, 0, -this.spotAnimationDelay);
          spotAnimationModel2.createBones();
          spotAnimationModel2.applyTransform(spotAnimation.sequences.getPrimaryFrame[this.currentAnimation]);
          spotAnimationModel2.triangleSkin = null;
          spotAnimationModel2.vectorSkin = null;
          if (spotAnimation.resizeXY !== 128 || spotAnimation.resizeZ !== 128) {
            spotAnimationModel2.scaleT(spotAnimation.resizeZ, spotAnimation.resizeXY, 9, spotAnimation.resizeXY);
          }
          spotAnimationModel2.applyLighting(
            64 + spotAnimation.modelLightFalloff,
            850 + spotAnimation.modelLightAmbient,
            -30,
            -50,
            -30,
            true
          );
          const models = [appearanceModel, spotAnimationModel2];
          appearanceModel = new Model(2, 0, models);
        }
      }
      if (this.playerModel != null) {
        if (Game.pulseCycle >= this.objectAppearanceEndTick) {
          this.playerModel = null;
        }
        if (Game.pulseCycle >= this.objectAppearanceStartTick && Game.pulseCycle < this.objectAppearanceEndTick) {
          const model = this.playerModel;
          model.translate(this.anInt1743 - this.worldX, this.anInt1745 - this.worldY, this.anInt1744 - this.anInt1750);
          if (this.nextStepOrientation === 512) {
            model.rotate90Degrees();
            model.rotate90Degrees();
            model.rotate90Degrees();
          } else if (this.nextStepOrientation === 1024) {
            model.rotate90Degrees();
            model.rotate90Degrees();
          } else if (this.nextStepOrientation === 1536) {
            model.rotate90Degrees();
          }
          const models = [appearanceModel, model];
          appearanceModel = new Model(2, 0, models);
          if (this.nextStepOrientation === 512) {
            model.rotate90Degrees();
          } else if (this.nextStepOrientation === 1024) {
            model.rotate90Degrees();
            model.rotate90Degrees();
          } else if (this.nextStepOrientation === 1536) {
            model.rotate90Degrees();
            model.rotate90Degrees();
            model.rotate90Degrees();
          }
          model.translate(this.worldX - this.anInt1743, this.worldY - this.anInt1745, this.anInt1750 - this.anInt1744);
        }
      }
      appearanceModel.oneSquareModel = true;
      return appearanceModel;
    }
    updateAppearance(buffer) {
      buffer.currentPosition = 0;
      this.gender = buffer.getUnsignedByte();
      this.skullIconId = buffer.getSignedByte();
      this.prayerIconId = buffer.getSignedByte();
      this.npcDefinition = null;
      this.teamId = 0;
      for (let index = 0; index < 12; index++) {
        {
          const upperByte = buffer.getUnsignedByte();
          if (upperByte === 0) {
            this.appearance[index] = 0;
            continue;
          }
          const lowerByte = buffer.getUnsignedByte();
          this.appearance[index] = (upperByte << 8) + lowerByte;
          if (index === 0 && this.appearance[0] === 65535) {
            this.npcDefinition = ActorDefinition.getDefinition(buffer.getUnsignedLEShort());
            break;
          }
          if (this.appearance[index] >= 512 && this.appearance[index] - 512 < ItemDefinition.count) {
            const itemTeam = ItemDefinition.lookup(this.appearance[index] - 512).team;
            if (itemTeam !== 0) {
              this.teamId = itemTeam;
            }
          }
        }
      }
      for (let l = 0; l < 5; l++) {
        {
          let j1 = buffer.getUnsignedByte();
          if (j1 < 0 || j1 >= Game.playerColours[l].length) {
            j1 = 0;
          }
          this.appearanceColors[l] = j1;
        }
      }
      this.idleAnimation = buffer.getUnsignedLEShort();
      if (this.idleAnimation === 65535) {
        this.idleAnimation = -1;
      }
      this.standTurnAnimationId = buffer.getUnsignedLEShort();
      if (this.standTurnAnimationId === 65535) {
        this.standTurnAnimationId = -1;
      }
      this.walkAnimationId = buffer.getUnsignedLEShort();
      if (this.walkAnimationId === 65535) {
        this.walkAnimationId = -1;
      }
      this.turnAroundAnimationId = buffer.getUnsignedLEShort();
      if (this.turnAroundAnimationId === 65535) {
        this.turnAroundAnimationId = -1;
      }
      this.turnRightAnimationId = buffer.getUnsignedLEShort();
      if (this.turnRightAnimationId === 65535) {
        this.turnRightAnimationId = -1;
      }
      this.turnLeftAnimationId = buffer.getUnsignedLEShort();
      if (this.turnLeftAnimationId === 65535) {
        this.turnLeftAnimationId = -1;
      }
      this.runAnimationId = buffer.getUnsignedLEShort();
      if (this.runAnimationId === 65535) {
        this.runAnimationId = -1;
      }
      this.playerName = TextUtils.formatName(TextUtils.longToName(buffer.getLong()));
      this.combatLevel = buffer.getUnsignedByte();
      this.anInt1759 = buffer.getUnsignedLEShort();
      this.visible = true;
      this.appearanceHash = 0;
      const k1 = this.appearance[5];
      const i2 = this.appearance[9];
      this.appearance[5] = i2;
      this.appearance[9] = k1;
      for (let j2 = 0; j2 < 12; j2++) {
        {
          this.appearanceHash <<= 4;
          if (this.appearance[j2] >= 256) {
            this.appearanceHash += this.appearance[j2] - 256;
          }
        }
      }
      if (this.appearance[0] >= 256) {
        this.appearanceHash += this.appearance[0] - 256 >> 4;
      }
      if (this.appearance[1] >= 256) {
        this.appearanceHash += this.appearance[1] - 256 >> 8;
      }
      this.appearance[5] = k1;
      this.appearance[9] = i2;
      for (let k2 = 0; k2 < 5; k2++) {
        {
          this.appearanceHash <<= 3;
          this.appearanceHash += this.appearanceColors[k2];
        }
      }
      this.appearanceHash <<= 1;
      this.appearanceHash += this.gender;
    }
  };
  var Player = _Player;
  Player.modelCache = new Cache(260);

  // osrs/media/renderable/actor/Npc.ts
  init_inject();
  var Npc = class extends Actor {
    constructor() {
      super();
      if (this.npcDefinition === void 0) {
        this.npcDefinition = null;
      }
    }
    getChildModel() {
      if (this.emoteAnimation >= 0 && this.animationDelay === 0) {
        const frameId = AnimationSequence.animations[this.emoteAnimation].getPrimaryFrame[this.displayedEmoteFrames];
        let frameId2 = -1;
        if (this.movementAnimation >= 0 && this.movementAnimation !== this.idleAnimation) {
          frameId2 = AnimationSequence.animations[this.movementAnimation].getPrimaryFrame[this.displayedMovementFrames];
        }
        return this.npcDefinition.getChildModel(frameId, frameId2, AnimationSequence.animations[this.emoteAnimation].flowControl);
      }
      let j = -1;
      if (this.movementAnimation >= 0) {
        j = AnimationSequence.animations[this.movementAnimation].getPrimaryFrame[this.displayedMovementFrames];
      }
      return this.npcDefinition.getChildModel(j, -1, null);
    }
    getRotatedModel() {
      if (this.npcDefinition == null) {
        return null;
      }
      let model = this.getChildModel();
      if (model == null) {
        return null;
      }
      this.modelHeight = model.modelHeight;
      if (this.graphic !== -1 && this.currentAnimation !== -1) {
        const spotanimation = SpotAnimation.cache[this.graphic];
        const model_4_ = spotanimation.getModel();
        if (model_4_ != null) {
          const animationId = spotanimation.sequences.getPrimaryFrame[this.currentAnimation];
          const animationModel = new Model(true, model_4_, Animation.exists(animationId));
          animationModel.translate(0, 0, -this.spotAnimationDelay);
          animationModel.createBones();
          animationModel.applyTransform(animationId);
          animationModel.triangleSkin = null;
          animationModel.vectorSkin = null;
          if (spotanimation.resizeXY !== 128 || spotanimation.resizeZ !== 128) {
            animationModel.scaleT(spotanimation.resizeZ, spotanimation.resizeXY, 9, spotanimation.resizeXY);
          }
          animationModel.applyLighting(64 + spotanimation.modelLightFalloff, 850 + spotanimation.modelLightAmbient, -30, -50, -30, true);
          const models = [model, animationModel];
          model = new Model(2, 0, models);
        }
      }
      if (this.npcDefinition.boundaryDimension === 1) {
        model.oneSquareModel = true;
      }
      return model;
    }
    isVisible() {
      return this.npcDefinition != null;
    }
  };

  // osrs/util/SignLink.ts
  init_inject();
  var _SignLink = class {
    static initialize(address) {
      console.log("SignLink.initialize");
      _SignLink.threadLiveId = Math.random() * 99999999 | 0;
      _SignLink.dnsRequest = null;
      _SignLink.saveRequest = null;
      _SignLink.urlRequest = null;
      _SignLink.inetAddress = address;
      Game.parallelExecutor.start(this);
    }
    static setVolume(value) {
      console.log("SignLink.setVolume");
    }
    static getUID(location) {
      console.log("SignLink.getUID");
      return 1;
    }
    static dnsLookup(host) {
      console.log("SignLink.dnsLookup");
      _SignLink.dns = host;
      _SignLink.dnsRequest = host;
    }
    static saveWave(data, length) {
      console.log("SignLink.saveWave");
      if (length > 2e6 || _SignLink.saveRequest != null) {
        return false;
      }
      _SignLink.wavePosition = (_SignLink.wavePosition + 1) % 5;
      _SignLink.saveLength = length;
      _SignLink.saveBuffer = data;
      _SignLink.midiPlay = true;
      _SignLink.saveRequest = "sound" + _SignLink.wavePosition + ".wav";
      return true;
    }
    static replayWave() {
      console.log("SignLink.replayWave");
      if (_SignLink.saveRequest != null) {
        return false;
      }
      _SignLink.saveBuffer = null;
      _SignLink.midiPlay = true;
      _SignLink.saveRequest = "sound" + _SignLink.wavePosition + ".wav";
      return true;
    }
    static saveMidi(data, length) {
      console.log("SignLink.saveMidi");
      if (length > 2e6 || _SignLink.saveRequest != null) {
        return;
      }
      _SignLink.midiPosition = (_SignLink.midiPosition + 1) % 5;
      _SignLink.saveLength = length;
      _SignLink.saveBuffer = data;
      _SignLink.play = true;
      _SignLink.saveRequest = "jingle" + _SignLink.midiPosition + ".mid";
    }
    static reportError(error) {
      console.log("SignLink.reportError");
      console.info("Error: " + error);
    }
    constructor() {
      if (this.curPosition === void 0) {
        this.curPosition = null;
      }
    }
    async run() {
      console.log("running");
      _SignLink.active = true;
    }
    playMidi(location) {
      console.log("SignLink.playMidi");
    }
  };
  var SignLink = _SignLink;
  SignLink.CLIENT_REVISION = 377;
  SignLink.uid = 0;
  SignLink.storeId = 32;
  SignLink.active = false;
  SignLink.threadLiveId = Math.random() * 99999999 | 0;
  SignLink.inetAddress = "";
  SignLink.socketRequest = 0;
  SignLink.socket = null;
  SignLink.threadRequestPriority = 1;
  SignLink.dnsRequest = null;
  SignLink.dns = null;
  SignLink.urlRequest = null;
  SignLink.saveLength = 0;
  SignLink.saveRequest = null;
  SignLink.saveBuffer = null;
  SignLink.play = false;
  SignLink.midiPosition = 0;
  SignLink.midi = null;
  SignLink.midiVolume = 0;
  SignLink.fadeMidi = 0;
  SignLink.midiPlay = false;
  SignLink.wavePosition = 0;
  SignLink.waveVolume = 0;
  SignLink.__reportError = true;
  SignLink.errorName = "";

  // osrs/net/BufferedConnection.ts
  init_inject();
  var BufferedConnection = class {
    constructor(gameStub, socket) {
      this.closed = false;
      this.writing = false;
      this.ioError = false;
      if (this.socket === void 0) {
        this.socket = null;
      }
      if (this.gameStub === void 0) {
        this.gameStub = null;
      }
      if (this.buffer === void 0) {
        this.buffer = null;
      }
      if (this.writerPosition === void 0) {
        this.writerPosition = 0;
      }
      if (this.bufferPosition === void 0) {
        this.bufferPosition = 0;
      }
      this.gameStub = gameStub;
      this.socket = socket;
    }
    close() {
      this.closed = true;
      try {
        if (this.socket != null) {
          this.socket.close();
        }
      } catch (_ex) {
        console.info("Error closing stream");
      }
      this.writing = false;
      this.buffer = null;
    }
    async read$() {
      if (this.closed) {
        return 0;
      } else {
        return await this.socket.read();
      }
    }
    getAvailable() {
      if (this.closed) {
        return 0;
      } else {
        return this.socket.available();
      }
    }
    async read$byte_A$int$int(src, offset, length) {
      if (!this.closed) {
        let byteRead;
        for (; length > 0; length -= byteRead) {
          {
            byteRead = await this.socket.read$byte_A$int$int(src, offset, length);
            if (byteRead <= 0) {
              throw Error("EOF");
            }
            offset += byteRead;
          }
        }
      }
    }
    write(length, offset, src) {
      if (this.closed) {
        return;
      }
      if (this.ioError) {
        this.ioError = false;
        throw Error("Error in writer thread");
      }
      this.socket.write$byte_A$int$int(src, offset, length);
      if (this.buffer == null) {
        this.buffer = Array(5e3).fill(0);
      }
    }
    printDebug() {
      console.info("dummy:" + this.closed);
      console.info("tcycl:" + this.writerPosition);
      console.info("tnum:" + this.bufferPosition);
      console.info("writer:" + this.writing);
      console.info("ioerror:" + this.ioError);
      try {
        console.info("available:" + this.getAvailable());
      } catch (_ex) {
      }
    }
  };

  // osrs/Configuration.ts
  init_inject();
  var Configuration = class {
  };
  Configuration.SERVER_ADDRESS = "127.0.0.1";
  Configuration.GAME_PORT = 43594;
  Configuration.JAGGRAB_PORT = 43595;
  Configuration.HTTP_PORT = 8080;
  Configuration.JAGGRAB_ENABLED = false;
  Configuration.RSA_ENABLED = true;
  Configuration.RSA_PUBLIC_KEY = "65537";
  Configuration.RSA_MODULUS = "119568088839203297999728368933573315070738693395974011872885408638642676871679245723887367232256427712869170521351089799352546294030059890127723509653145359924771433131004387212857375068629466435244653901851504845054452735390701003613803443469723435116497545687393297329052988014281948392136928774011011998343";

  // osrs/net/ISAACCipher.ts
  init_inject();
  var import_isaac_crypto = __toESM(require_src(), 1);
  var ISAACCipher = class {
    constructor(seed) {
      this.generator = new import_isaac_crypto.ISAACGenerator(seed);
    }
    nextInt() {
      return this.generator.getNextResult() | 0;
    }
  };

  // osrs/util/PacketConstants.ts
  init_inject();
  var PacketConstants = class {
  };
  PacketConstants.PACKET_SIZES = [
    0,
    0,
    4,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    2,
    0,
    0,
    -2,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    -1,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    -2,
    0,
    0,
    0,
    2,
    23,
    0,
    9,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    -2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    7,
    5,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    7,
    0,
    0,
    0,
    1,
    3,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    -2,
    -1,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    1,
    -1,
    2,
    2,
    0,
    0,
    4,
    0,
    0,
    0,
    6,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    15,
    3,
    -2,
    0,
    0,
    8,
    6,
    0,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    4,
    3,
    0,
    14,
    0,
    0,
    -2,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    4,
    2,
    2,
    0,
    4,
    0,
    0,
    0,
    -2,
    0,
    0,
    0,
    0,
    0,
    -2,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    5,
    0,
    1,
    1,
    4,
    0,
    2,
    0
  ];

  // osrs/sound/SoundPlayer.ts
  init_inject();
  var _SoundPlayer = class {
    static setVolume(level) {
      _SoundPlayer.volume = level;
    }
    static getVolume() {
      return _SoundPlayer.volume;
    }
    constructor(stream, level, delay) {
      if (this.stream === void 0) {
        this.stream = null;
      }
      if (this.info === void 0) {
        this.info = null;
      }
      if (this.sound === void 0) {
        this.sound = null;
      }
      if (this.soundStream === void 0) {
        this.soundStream = null;
      }
      if (this.player === void 0) {
        this.player = null;
      }
      if (this.delay === void 0) {
        this.delay = 0;
      }
      if (this.soundLevel === void 0) {
        this.soundLevel = 0;
      }
      if (level === 0 || _SoundPlayer.volume === 4 || level - _SoundPlayer.volume <= 0) {
        return;
      }
      this.soundStream = stream;
      this.soundLevel = level;
      this.delay = delay;
    }
    run() {
    }
    getDecibels(level) {
      switch (level) {
        case 1:
          return Math.fround(-80);
        case 2:
          return Math.fround(-70);
        case 3:
          return Math.fround(-60);
        case 4:
          return Math.fround(-50);
        case 5:
          return Math.fround(-40);
        case 6:
          return Math.fround(-30);
        case 7:
          return Math.fround(-20);
        case 8:
          return Math.fround(-10);
        case 9:
          return Math.fround(-0);
        case 10:
          return Math.fround(6);
        default:
          return Math.fround(0);
      }
    }
  };
  var SoundPlayer = _SoundPlayer;
  SoundPlayer.volume = 0;

  // osrs/media/renderable/Item.ts
  init_inject();
  var Item = class extends Renderable {
    constructor() {
      super();
      if (this.itemId === void 0) {
        this.itemId = 0;
      }
      if (this.itemCount === void 0) {
        this.itemCount = 0;
      }
    }
    getRotatedModel() {
      const itemDefinition = ItemDefinition.lookup(this.itemId);
      return itemDefinition.asGroundStack(this.itemCount);
    }
  };

  // osrs/scene/SpawnObjectNode.ts
  init_inject();
  var SpawnObjectNode = class extends Node {
    constructor() {
      super();
      this.anInt1390 = -1;
      if (this.anInt1384 === void 0) {
        this.anInt1384 = 0;
      }
      if (this.anInt1385 === void 0) {
        this.anInt1385 = 0;
      }
      if (this.anInt1386 === void 0) {
        this.anInt1386 = 0;
      }
      if (this.anInt1387 === void 0) {
        this.anInt1387 = 0;
      }
      if (this.anInt1388 === void 0) {
        this.anInt1388 = 0;
      }
      if (this.anInt1389 === void 0) {
        this.anInt1389 = 0;
      }
      if (this.anInt1391 === void 0) {
        this.anInt1391 = 0;
      }
      if (this.anInt1392 === void 0) {
        this.anInt1392 = 0;
      }
      if (this.anInt1393 === void 0) {
        this.anInt1393 = 0;
      }
      if (this.anInt1394 === void 0) {
        this.anInt1394 = 0;
      }
      if (this.anInt1395 === void 0) {
        this.anInt1395 = 0;
      }
    }
  };

  // osrs/media/renderable/Projectile.ts
  init_inject();
  var Projectile = class extends Renderable {
    constructor(sceneId, endHeight, startDistanceFromTarget, projectileY, i1, speed, startSlope, targetedEntityIndex, height, projectileX, delay) {
      super();
      if (this.animation === void 0) {
        this.animation = null;
      }
      if (this.sceneId === void 0) {
        this.sceneId = 0;
      }
      if (this.currentX === void 0) {
        this.currentX = 0;
      }
      if (this.currentY === void 0) {
        this.currentY = 0;
      }
      if (this.currentHeight === void 0) {
        this.currentHeight = 0;
      }
      if (this.startSlope === void 0) {
        this.startSlope = 0;
      }
      if (this.startDistanceFromTarget === void 0) {
        this.startDistanceFromTarget = 0;
      }
      if (this.targetedEntityId === void 0) {
        this.targetedEntityId = 0;
      }
      if (this.aBoolean1561 === void 0) {
        this.aBoolean1561 = false;
      }
      if (this.anInt1562 === void 0) {
        this.anInt1562 = 0;
      }
      if (this.anInt1563 === void 0) {
        this.anInt1563 = 0;
      }
      if (this.delay === void 0) {
        this.delay = 0;
      }
      if (this.endCycle === void 0) {
        this.endCycle = 0;
      }
      if (this.animationFrame === void 0) {
        this.animationFrame = 0;
      }
      if (this.duration === void 0) {
        this.duration = 0;
      }
      if (this.speedVectorX === void 0) {
        this.speedVectorX = 0;
      }
      if (this.speedVectorY === void 0) {
        this.speedVectorY = 0;
      }
      if (this.speedVectorScalar === void 0) {
        this.speedVectorScalar = 0;
      }
      if (this.speedVectorZ === void 0) {
        this.speedVectorZ = 0;
      }
      if (this.aBoolean1573 === void 0) {
        this.aBoolean1573 = false;
      }
      if (this.heightOffset === void 0) {
        this.heightOffset = 0;
      }
      if (this.moving === void 0) {
        this.moving = false;
      }
      if (this.startX === void 0) {
        this.startX = 0;
      }
      if (this.startY === void 0) {
        this.startY = 0;
      }
      if (this.startHeight === void 0) {
        this.startHeight = 0;
      }
      if (this.endHeight === void 0) {
        this.endHeight = 0;
      }
      this.aBoolean1561 = false;
      this.aBoolean1573 = true;
      this.animation = SpotAnimation.cache[i1];
      this.sceneId = sceneId;
      this.startX = projectileX;
      this.startY = projectileY;
      this.startHeight = height;
      this.delay = delay;
      this.endCycle = speed;
      this.startSlope = startSlope;
      this.startDistanceFromTarget = startDistanceFromTarget;
      this.targetedEntityId = targetedEntityIndex;
      this.endHeight = endHeight;
      this.moving = false;
    }
    trackTarget(targetX, targetY, k, loopCycle) {
      if (!this.moving) {
        const distanceX = targetX - this.startX;
        const distanceY = targetY - this.startY;
        const distanceScalar = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
        this.currentX = this.startX + distanceX * this.startDistanceFromTarget / distanceScalar;
        this.currentY = this.startY + distanceY * this.startDistanceFromTarget / distanceScalar;
        this.currentHeight = this.startHeight;
      }
      const cyclesRemaining = this.endCycle + 1 - loopCycle;
      this.speedVectorX = (targetX - this.currentX) / cyclesRemaining;
      this.speedVectorY = (targetY - this.currentY) / cyclesRemaining;
      this.speedVectorScalar = Math.sqrt(this.speedVectorX * this.speedVectorX + this.speedVectorY * this.speedVectorY);
      if (!this.moving) {
        this.speedVectorZ = -this.speedVectorScalar * Math.tan(this.startSlope * 0.02454369);
      }
      this.heightOffset = 2 * (k - this.currentHeight - this.speedVectorZ * cyclesRemaining) / (cyclesRemaining * cyclesRemaining);
    }
    move(time) {
      this.moving = true;
      this.currentX += this.speedVectorX * time;
      this.currentY += this.speedVectorY * time;
      this.currentHeight += this.speedVectorZ * time + 0.5 * this.heightOffset * time * time;
      this.speedVectorZ += this.heightOffset * time;
      this.anInt1562 = (Math.atan2(this.speedVectorX, this.speedVectorY) * 325.949 | 0) + 1024 & 2047;
      this.anInt1563 = (Math.atan2(this.speedVectorZ, this.speedVectorScalar) * 325.949 | 0) & 2047;
      if (this.animation.sequences != null) {
        for (this.duration += time; this.duration > this.animation.sequences.getFrameLength(this.animationFrame); ) {
          {
            this.duration -= this.animation.sequences.getFrameLength(this.animationFrame);
            this.animationFrame++;
            if (this.animationFrame >= this.animation.sequences.frameCount) {
              this.animationFrame = 0;
            }
          }
        }
      }
    }
    getRotatedModel() {
      const model = this.animation.getModel();
      if (model == null) {
        return null;
      }
      let frameId = -1;
      if (this.animation.sequences != null) {
        frameId = this.animation.sequences.getPrimaryFrame[this.animationFrame];
      }
      const projectileModel = new Model(true, model, Animation.exists(frameId));
      if (frameId !== -1) {
        projectileModel.createBones();
        projectileModel.applyTransform(frameId);
        projectileModel.triangleSkin = null;
        projectileModel.vectorSkin = null;
      }
      if (this.animation.resizeXY !== 128 || this.animation.resizeZ !== 128) {
        projectileModel.scaleT(this.animation.resizeZ, this.animation.resizeXY, 9, this.animation.resizeXY);
      }
      projectileModel.rotateX(this.anInt1563);
      projectileModel.applyLighting(64 + this.animation.modelLightFalloff, 850 + this.animation.modelLightAmbient, -30, -50, -30, true);
      return projectileModel;
    }
  };

  // osrs/media/renderable/GameAnimableObject.ts
  init_inject();
  var GameAnimableObject = class extends Renderable {
    constructor(plane, loopCycle, loopCycleOffset, animationIndex, z, y, x2) {
      super();
      this.transformCompleted = false;
      if (this.plane === void 0) {
        this.plane = 0;
      }
      if (this.x === void 0) {
        this.x = 0;
      }
      if (this.y === void 0) {
        this.y = 0;
      }
      if (this.z === void 0) {
        this.z = 0;
      }
      if (this.eclapsedFrames === void 0) {
        this.eclapsedFrames = 0;
      }
      if (this.duration === void 0) {
        this.duration = 0;
      }
      if (this.animation === void 0) {
        this.animation = null;
      }
      if (this.loopCycle === void 0) {
        this.loopCycle = 0;
      }
      this.animation = SpotAnimation.cache[animationIndex];
      this.plane = plane;
      this.x = x2;
      this.y = y;
      this.z = z;
      this.loopCycle = loopCycle + loopCycleOffset;
      this.transformCompleted = false;
    }
    nextFrame(frame) {
      this.duration += frame;
      while (this.duration > this.animation.sequences.getFrameLength(this.eclapsedFrames)) {
        {
          this.duration -= this.animation.sequences.getFrameLength(this.eclapsedFrames);
          this.eclapsedFrames++;
          if (this.eclapsedFrames >= this.animation.sequences.frameCount && (this.eclapsedFrames < 0 || this.eclapsedFrames >= this.animation.sequences.frameCount)) {
            this.eclapsedFrames = 0;
            this.transformCompleted = true;
          }
        }
      }
    }
    getRotatedModel() {
      const model = this.animation.getModel();
      if (model == null) {
        return null;
      }
      const frame = this.animation.sequences.getPrimaryFrame[this.eclapsedFrames];
      const animatedModel = new Model(true, model, Animation.exists(frame));
      if (!this.transformCompleted) {
        animatedModel.createBones();
        animatedModel.applyTransform(frame);
        animatedModel.triangleSkin = null;
        animatedModel.vectorSkin = null;
      }
      if (this.animation.resizeXY !== 128 || this.animation.resizeZ !== 128) {
        animatedModel.scaleT(this.animation.resizeZ, this.animation.resizeXY, 9, this.animation.resizeXY);
      }
      if (this.animation.rotation !== 0) {
        if (this.animation.rotation === 90) {
          animatedModel.rotate90Degrees();
        }
        if (this.animation.rotation === 180) {
          animatedModel.rotate90Degrees();
          animatedModel.rotate90Degrees();
        }
        if (this.animation.rotation === 270) {
          animatedModel.rotate90Degrees();
          animatedModel.rotate90Degrees();
          animatedModel.rotate90Degrees();
        }
      }
      animatedModel.applyLighting(64 + this.animation.modelLightFalloff, 850 + this.animation.modelLightAmbient, -30, -50, -30, true);
      return animatedModel;
    }
  };

  // osrs/util/SkillConstants.ts
  init_inject();
  var SkillConstants = class {
  };
  SkillConstants.SKILL_COUNT = 25;
  SkillConstants.SKILL_NAMES = [
    "attack",
    "defence",
    "strength",
    "hitpoints",
    "ranged",
    "prayer",
    "magic",
    "cooking",
    "woodcutting",
    "fletching",
    "fishing",
    "firemaking",
    "crafting",
    "smithing",
    "mining",
    "herblore",
    "agility",
    "thieving",
    "slayer",
    "farming",
    "runecraft",
    "-unused-",
    "-unused-",
    "-unused-",
    "-unused-"
  ];
  SkillConstants.SKILL_TOGGLES = [
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    false,
    false,
    false,
    false
  ];

  // osrs/util/ChatEncoder.ts
  init_inject();
  var _ChatEncoder = class {
    static get(length, buffer) {
      let count = 0;
      let validCharacterIndex = -1;
      for (let lengthCounter = 0; lengthCounter < length; lengthCounter++) {
        {
          const character = buffer.getUnsignedByte();
          let characterBit = character >> 4 & 15;
          if (validCharacterIndex === -1) {
            if (characterBit < 13) {
              _ChatEncoder.message[count++] = _ChatEncoder.VALID_CHARACTERS[characterBit];
            } else {
              validCharacterIndex = characterBit;
            }
          } else {
            _ChatEncoder.message[count++] = _ChatEncoder.VALID_CHARACTERS[(validCharacterIndex << 4) + characterBit - 195];
            validCharacterIndex = -1;
          }
          characterBit = character & 15;
          if (validCharacterIndex === -1) {
            if (characterBit < 13) {
              _ChatEncoder.message[count++] = _ChatEncoder.VALID_CHARACTERS[characterBit];
            } else {
              validCharacterIndex = characterBit;
            }
          } else {
            _ChatEncoder.message[count++] = _ChatEncoder.VALID_CHARACTERS[(validCharacterIndex << 4) + characterBit - 195];
            validCharacterIndex = -1;
          }
        }
      }
      let isSymbol = true;
      for (let messageIndex = 0; messageIndex < count; messageIndex++) {
        {
          const c2 = _ChatEncoder.message[messageIndex];
          if (isSymbol && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) >= "a".charCodeAt(0) && ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) <= "z".charCodeAt(0)) {
            _ChatEncoder.message[messageIndex] = String.fromCharCode(
              _ChatEncoder.message[messageIndex].charCodeAt(0) + "\uFFE0".charCodeAt(0)
            );
            isSymbol = false;
          }
          if (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == ".".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "!".charCodeAt(0) || ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) == "?".charCodeAt(0)) {
            isSymbol = true;
          }
        }
      }
      return ((str, index, len) => str.substring(index, index + len))(_ChatEncoder.message.join(""), 0, count);
    }
    static put(chatMessage, buffer) {
      if (chatMessage.length > 80) {
        chatMessage = chatMessage.substring(0, 80);
      }
      let chatMessageCharacter = -1;
      for (let index = 0; index < chatMessage.length; index++) {
        {
          const character = chatMessage.charAt(index);
          let validCharacterIndex = 0;
          for (let validIndex = 0; validIndex < _ChatEncoder.VALID_CHARACTERS.length; validIndex++) {
            {
              if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(character) != ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(_ChatEncoder.VALID_CHARACTERS[validIndex])) {
                continue;
              }
              validCharacterIndex = validIndex;
              break;
            }
          }
          if (validCharacterIndex > 12) {
            validCharacterIndex += 195;
          }
          if (chatMessageCharacter === -1) {
            if (validCharacterIndex < 13) {
              chatMessageCharacter = validCharacterIndex;
            } else {
              buffer.putByte(validCharacterIndex);
            }
          } else if (validCharacterIndex < 13) {
            buffer.putByte((chatMessageCharacter << 4) + validCharacterIndex);
            chatMessageCharacter = -1;
          } else {
            buffer.putByte((chatMessageCharacter << 4) + (validCharacterIndex >> 4));
            chatMessageCharacter = validCharacterIndex & 15;
          }
        }
      }
      if (chatMessageCharacter !== -1) {
        buffer.putByte(chatMessageCharacter << 4);
      }
    }
    static formatChatMessage(chatMessage) {
      _ChatEncoder.messageBuffer.currentPosition = 0;
      _ChatEncoder.put(chatMessage, _ChatEncoder.messageBuffer);
      const offset = _ChatEncoder.messageBuffer.currentPosition;
      _ChatEncoder.messageBuffer.currentPosition = 0;
      return _ChatEncoder.get(offset, _ChatEncoder.messageBuffer);
    }
  };
  var ChatEncoder = _ChatEncoder;
  ChatEncoder.message = Array(100).fill(null);
  ChatEncoder.messageBuffer = new Buffer3(Array(100).fill(0));
  ChatEncoder.VALID_CHARACTERS = [
    " ",
    "e",
    "t",
    "a",
    "o",
    "i",
    "h",
    "n",
    "s",
    "r",
    "d",
    "l",
    "u",
    "m",
    "w",
    "c",
    "y",
    "f",
    "g",
    "p",
    "b",
    "v",
    "k",
    "x",
    "j",
    "q",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    " ",
    "!",
    "?",
    ".",
    ",",
    ":",
    ";",
    "(",
    ")",
    "-",
    "&",
    "*",
    "\\",
    "'",
    "@",
    "#",
    "+",
    "=",
    "\xA3",
    "$",
    "%",
    '"',
    "[",
    "]"
  ];

  // osrs/Actions.ts
  init_inject();
  var Actions = class {
  };
  Actions.EXAMINE_ITEM = 1094;
  Actions.TOGGLE_SETTING_WIDGET = 890;
  Actions.ACCEPT_CHALLENGE = 695;
  Actions.ACCEPT_TRADE = 544;
  Actions.ADD_FRIEND = 762;
  Actions.ADD_IGNORE = 574;
  Actions.USABLE_WIDGET = 70;
  Actions.REMOVE_IGNORE = 859;
  Actions.CLICK_TO_CONTINUE = 575;
  Actions.CLOSE_WIDGETS = 639;
  Actions.REMOVE_FRIEND = 775;
  Actions.RESET_SETTING_WIDGET = 518;
  Actions.PRIVATE_MESSAGE = 984;

  // osrs/Game.ts
  var import_long3 = __toESM(require_long(), 1);

  // osrs/sound/MidiPlayer/MIDIPlayer.ts
  init_inject();

  // node_modules/@ryohey/wavelet/dist/index.js
  init_inject();
  var Logger = class {
    constructor() {
      __publicField(this, "enabled", true);
    }
    log(...args) {
      if (this.enabled) {
        console.log(...args);
      }
    }
    warn(...args) {
      if (this.enabled) {
        console.warn(...args);
      }
    }
    error(...args) {
      if (this.enabled) {
        console.error(...args);
      }
    }
  };
  var logger = new Logger();
  logger.enabled = false;
  function toCharCodes(str) {
    var bytes = [];
    for (var i = 0; i < str.length; i++) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  (function() {
    function Buffer5() {
      this.data = [];
      this.position = 0;
    }
    Object.defineProperty(Buffer5.prototype, "length", {
      get: function() {
        return this.data.length;
      },
      enumerable: false,
      configurable: true
    });
    Buffer5.prototype.writeByte = function(v) {
      this.data.push(v);
      this.position++;
    };
    Buffer5.prototype.writeStr = function(str) {
      this.writeBytes(toCharCodes(str));
    };
    Buffer5.prototype.writeInt32 = function(v) {
      this.writeByte(v >> 24 & 255);
      this.writeByte(v >> 16 & 255);
      this.writeByte(v >> 8 & 255);
      this.writeByte(v & 255);
    };
    Buffer5.prototype.writeInt16 = function(v) {
      this.writeByte(v >> 8 & 255);
      this.writeByte(v & 255);
    };
    Buffer5.prototype.writeBytes = function(arr) {
      var _this = this;
      arr.forEach(function(v) {
        return _this.writeByte(v);
      });
    };
    Buffer5.prototype.writeChunk = function(id, func) {
      this.writeStr(id);
      var chunkBuf = new Buffer5();
      func(chunkBuf);
      this.writeInt32(chunkBuf.length);
      this.writeBytes(chunkBuf.data);
    };
    Buffer5.prototype.toBytes = function() {
      return new Uint8Array(this.data);
    };
    return Buffer5;
  })();
  var EnvelopePhase;
  (function(EnvelopePhase2) {
    EnvelopePhase2[EnvelopePhase2["attack"] = 0] = "attack";
    EnvelopePhase2[EnvelopePhase2["decay"] = 1] = "decay";
    EnvelopePhase2[EnvelopePhase2["sustain"] = 2] = "sustain";
    EnvelopePhase2[EnvelopePhase2["release"] = 3] = "release";
    EnvelopePhase2[EnvelopePhase2["forceStop"] = 4] = "forceStop";
    EnvelopePhase2[EnvelopePhase2["stopped"] = 5] = "stopped";
  })(EnvelopePhase || (EnvelopePhase = {}));
  var bin = {};
  Object.defineProperty(bin, "__esModule", { value: true });
  var Stream = class {
    constructor(data, offset) {
      this.data = data;
      this.ip = offset;
    }
    readString(size) {
      const str = String.fromCharCode.apply(null, this.data.subarray(this.ip, this.ip += size));
      const nullLocation = str.indexOf("\0");
      if (nullLocation > 0) {
        return str.substr(0, nullLocation);
      }
      return str;
    }
    readWORD() {
      return this.data[this.ip++] | this.data[this.ip++] << 8;
    }
    readDWORD(bigEndian = false) {
      if (bigEndian) {
        return (this.data[this.ip++] << 24 | this.data[this.ip++] << 16 | this.data[this.ip++] << 8 | this.data[this.ip++]) >>> 0;
      } else {
        return (this.data[this.ip++] | this.data[this.ip++] << 8 | this.data[this.ip++] << 16 | this.data[this.ip++] << 24) >>> 0;
      }
    }
    readByte() {
      return this.data[this.ip++];
    }
    readAt(offset) {
      return this.data[this.ip + offset];
    }
    readUInt8() {
      return this.readByte();
    }
    readInt8() {
      return this.readByte() << 24 >> 24;
    }
    readUInt16() {
      return this.readWORD();
    }
    readInt16() {
      return this.readWORD() << 16 >> 16;
    }
    readUInt32() {
      return this.readDWORD();
    }
  };
  function parseChunk$1(input, ip, bigEndian) {
    const stream = new Stream(input, ip);
    const type = stream.readString(4);
    const size = stream.readDWORD(bigEndian);
    return new Chunk(type, size, stream.ip);
  }
  function parseRiff(input, index = 0, length, { padding = true, bigEndian = false } = {}) {
    const chunkList = [];
    const end = length + index;
    let ip = index;
    while (ip < end) {
      const chunk = parseChunk$1(input, ip, bigEndian);
      ip = chunk.offset + chunk.size;
      if (padding && (ip - index & 1) === 1) {
        ip++;
      }
      chunkList.push(chunk);
    }
    return chunkList;
  }
  var Chunk = class {
    constructor(type, size, offset) {
      this.type = type;
      this.size = size;
      this.offset = offset;
    }
  };
  var GeneratorEnumeratorTable = [
    "startAddrsOffset",
    "endAddrsOffset",
    "startloopAddrsOffset",
    "endloopAddrsOffset",
    "startAddrsCoarseOffset",
    "modLfoToPitch",
    "vibLfoToPitch",
    "modEnvToPitch",
    "initialFilterFc",
    "initialFilterQ",
    "modLfoToFilterFc",
    "modEnvToFilterFc",
    "endAddrsCoarseOffset",
    "modLfoToVolume",
    void 0,
    "chorusEffectsSend",
    "reverbEffectsSend",
    "pan",
    void 0,
    void 0,
    void 0,
    "delayModLFO",
    "freqModLFO",
    "delayVibLFO",
    "freqVibLFO",
    "delayModEnv",
    "attackModEnv",
    "holdModEnv",
    "decayModEnv",
    "sustainModEnv",
    "releaseModEnv",
    "keynumToModEnvHold",
    "keynumToModEnvDecay",
    "delayVolEnv",
    "attackVolEnv",
    "holdVolEnv",
    "decayVolEnv",
    "sustainVolEnv",
    "releaseVolEnv",
    "keynumToVolEnvHold",
    "keynumToVolEnvDecay",
    "instrument",
    void 0,
    "keyRange",
    "velRange",
    "startloopAddrsCoarseOffset",
    "keynum",
    "velocity",
    "initialAttenuation",
    void 0,
    "endloopAddrsCoarseOffset",
    "coarseTune",
    "fineTune",
    "sampleID",
    "sampleModes",
    void 0,
    "scaleTuning",
    "exclusiveClass",
    "overridingRootKey"
  ];
  var VersionTag = class {
    static parse(stream) {
      const v = new VersionTag();
      v.major = stream.readInt8();
      v.minor = stream.readInt8();
      return v;
    }
  };
  var Info = class {
    static parse(data, chunks) {
      function getChunk(type) {
        return chunks.find((c2) => c2.type === type);
      }
      function toStream(chunk) {
        return new Stream(data, chunk.offset);
      }
      function readString(type) {
        const chunk = getChunk(type);
        if (!chunk) {
          return null;
        }
        return toStream(chunk).readString(chunk.size);
      }
      function readVersionTag(type) {
        const chunk = getChunk(type);
        if (!chunk) {
          return null;
        }
        return VersionTag.parse(toStream(chunk));
      }
      const info = new Info();
      info.comment = readString("ICMT");
      info.copyright = readString("ICOP");
      info.creationDate = readString("ICRD");
      info.engineer = readString("IENG");
      info.name = readString("INAM");
      info.product = readString("IPRD");
      info.software = readString("ISFT");
      info.version = readVersionTag("ifil");
      info.soundEngine = readString("isng");
      info.romName = readString("irom");
      info.romVersion = readVersionTag("iver");
      return info;
    }
  };
  var PresetHeader = class {
    get isEnd() {
      return this.presetName === "EOP";
    }
    static parse(stream) {
      const p = new PresetHeader();
      p.presetName = stream.readString(20);
      p.preset = stream.readWORD();
      p.bank = stream.readWORD();
      p.presetBagIndex = stream.readWORD();
      p.library = stream.readDWORD();
      p.genre = stream.readDWORD();
      p.morphology = stream.readDWORD();
      return p;
    }
  };
  var PresetBag = class {
    static parse(stream) {
      const p = new PresetBag();
      p.presetGeneratorIndex = stream.readWORD();
      p.presetModulatorIndex = stream.readWORD();
      return p;
    }
  };
  var RangeValue = class {
    constructor(lo, hi) {
      this.lo = lo;
      this.hi = hi;
    }
    static parse(stream) {
      return new RangeValue(stream.readByte(), stream.readByte());
    }
  };
  var ModulatorList = class {
    get type() {
      return GeneratorEnumeratorTable[this.destinationOper];
    }
    get isEnd() {
      return this.sourceOper === 0 && this.destinationOper === 0 && this.value === 0 && this.amountSourceOper === 0 && this.transOper === 0;
    }
    static parse(stream) {
      const t = new ModulatorList();
      t.sourceOper = stream.readWORD();
      t.destinationOper = stream.readWORD();
      switch (t.type) {
        case "keyRange":
        case "velRange":
        case "keynum":
        case "velocity":
          t.value = RangeValue.parse(stream);
          break;
        default:
          t.value = stream.readInt16();
          break;
      }
      t.amountSourceOper = stream.readWORD();
      t.transOper = stream.readWORD();
      return t;
    }
  };
  var GeneratorList = class {
    get type() {
      return GeneratorEnumeratorTable[this.code];
    }
    get isEnd() {
      return this.code === 0 && this.value === 0;
    }
    static parse(stream) {
      const t = new GeneratorList();
      t.code = stream.readWORD();
      switch (t.type) {
        case "keynum":
        case "keyRange":
        case "velRange":
        case "velocity":
          t.value = RangeValue.parse(stream);
          break;
        default:
          t.value = stream.readInt16();
          break;
      }
      return t;
    }
  };
  var Instrument = class {
    get isEnd() {
      return this.instrumentName === "EOI";
    }
    static parse(stream) {
      const t = new Instrument();
      t.instrumentName = stream.readString(20);
      t.instrumentBagIndex = stream.readWORD();
      return t;
    }
  };
  var InstrumentBag = class {
    static parse(stream) {
      const t = new InstrumentBag();
      t.instrumentGeneratorIndex = stream.readWORD();
      t.instrumentModulatorIndex = stream.readWORD();
      return t;
    }
  };
  var SampleHeader = class {
    get isEnd() {
      return this.sampleName === "EOS";
    }
    static parse(stream) {
      const s = new SampleHeader();
      s.sampleName = stream.readString(20);
      s.start = stream.readDWORD();
      s.end = stream.readDWORD();
      s.loopStart = stream.readDWORD();
      s.loopEnd = stream.readDWORD();
      s.sampleRate = stream.readDWORD();
      s.originalPitch = stream.readByte();
      s.pitchCorrection = stream.readInt8();
      s.sampleLink = stream.readWORD();
      s.sampleType = stream.readWORD();
      s.loopStart -= s.start;
      s.loopEnd -= s.start;
      return s;
    }
  };
  function parse(input, option = {}) {
    const chunkList = parseRiff(input, 0, input.length, option);
    if (chunkList.length !== 1) {
      throw new Error("wrong chunk length");
    }
    const chunk = chunkList[0];
    if (chunk === null) {
      throw new Error("chunk not found");
    }
    function parseRiffChunk(chunk2, data) {
      const chunkList2 = getChunkList(chunk2, data, "RIFF", "sfbk");
      if (chunkList2.length !== 3) {
        throw new Error("invalid sfbk structure");
      }
      return Object.assign({
        info: parseInfoList(chunkList2[0], data),
        samplingData: parseSdtaList(chunkList2[1], data)
      }, parsePdtaList(chunkList2[2], data));
    }
    function parsePdtaList(chunk2, data) {
      const chunkList2 = getChunkList(chunk2, data, "LIST", "pdta");
      if (chunkList2.length !== 9) {
        throw new Error("invalid pdta chunk");
      }
      return {
        presetHeaders: parsePhdr(chunkList2[0], data),
        presetZone: parsePbag(chunkList2[1], data),
        presetModulators: parsePmod(chunkList2[2], data),
        presetGenerators: parsePgen(chunkList2[3], data),
        instruments: parseInst(chunkList2[4], data),
        instrumentZone: parseIbag(chunkList2[5], data),
        instrumentModulators: parseImod(chunkList2[6], data),
        instrumentGenerators: parseIgen(chunkList2[7], data),
        sampleHeaders: parseShdr(chunkList2[8], data)
      };
    }
    const result = parseRiffChunk(chunk, input);
    return Object.assign(Object.assign({}, result), { samples: loadSample(result.sampleHeaders, result.samplingData.offset, input) });
  }
  function getChunkList(chunk, data, expectedType, expectedSignature) {
    if (chunk.type !== expectedType) {
      throw new Error("invalid chunk type:" + chunk.type);
    }
    const stream = new Stream(data, chunk.offset);
    const signature = stream.readString(4);
    if (signature !== expectedSignature) {
      throw new Error("invalid signature:" + signature);
    }
    return parseRiff(data, stream.ip, chunk.size - 4);
  }
  function parseInfoList(chunk, data) {
    const chunkList = getChunkList(chunk, data, "LIST", "INFO");
    return Info.parse(data, chunkList);
  }
  function parseSdtaList(chunk, data) {
    const chunkList = getChunkList(chunk, data, "LIST", "sdta");
    if (chunkList.length !== 1) {
      throw new Error("TODO");
    }
    return chunkList[0];
  }
  function parseChunk(chunk, data, type, clazz, terminate) {
    const result = [];
    if (chunk.type !== type) {
      throw new Error("invalid chunk type:" + chunk.type);
    }
    const stream = new Stream(data, chunk.offset);
    const size = chunk.offset + chunk.size;
    while (stream.ip < size) {
      const obj = clazz.parse(stream);
      if (terminate && terminate(obj)) {
        break;
      }
      result.push(obj);
    }
    return result;
  }
  var parsePhdr = (chunk, data) => parseChunk(chunk, data, "phdr", PresetHeader, (p) => p.isEnd);
  var parsePbag = (chunk, data) => parseChunk(chunk, data, "pbag", PresetBag);
  var parseInst = (chunk, data) => parseChunk(chunk, data, "inst", Instrument, (i) => i.isEnd);
  var parseIbag = (chunk, data) => parseChunk(chunk, data, "ibag", InstrumentBag);
  var parsePmod = (chunk, data) => parseChunk(chunk, data, "pmod", ModulatorList, (m) => m.isEnd);
  var parseImod = (chunk, data) => parseChunk(chunk, data, "imod", ModulatorList, (m) => m.isEnd);
  var parsePgen = (chunk, data) => parseChunk(chunk, data, "pgen", GeneratorList, (g) => g.isEnd);
  var parseIgen = (chunk, data) => parseChunk(chunk, data, "igen", GeneratorList);
  var parseShdr = (chunk, data) => parseChunk(chunk, data, "shdr", SampleHeader, (s) => s.isEnd);
  function adjustSampleData(sample, sampleRate) {
    let multiply = 1;
    while (sampleRate < 22050) {
      const newSample = new Int16Array(sample.length * 2);
      for (let i = 0, j = 0, il = sample.length; i < il; ++i) {
        newSample[j++] = sample[i];
        newSample[j++] = sample[i];
      }
      sample = newSample;
      multiply *= 2;
      sampleRate *= 2;
    }
    return {
      sample,
      multiply
    };
  }
  function loadSample(sampleHeader, samplingDataOffset, data) {
    return sampleHeader.map((header) => {
      let sample = new Int16Array(new Uint8Array(data.subarray(samplingDataOffset + header.start * 2, samplingDataOffset + header.end * 2)).buffer);
      if (header.sampleRate > 0) {
        const adjust = adjustSampleData(sample, header.sampleRate);
        sample = adjust.sample;
        header.sampleRate *= adjust.multiply;
        header.loopStart *= adjust.multiply;
        header.loopEnd *= adjust.multiply;
      }
      return sample;
    });
  }
  function createGeneraterObject(generators) {
    const result = {};
    for (const gen of generators) {
      const type = gen.type;
      if (type !== void 0) {
        result[type] = gen.value;
      }
    }
    return result;
  }
  var defaultInstrumentZone = {
    keynum: void 0,
    instrument: void 0,
    velocity: void 0,
    exclusiveClass: void 0,
    keyRange: new RangeValue(0, 127),
    velRange: new RangeValue(0, 127),
    sampleID: void 0,
    delayVolEnv: -12e3,
    attackVolEnv: -12e3,
    decayVolEnv: -12e3,
    holdVolEnv: -12e3,
    sustainVolEnv: 0,
    releaseVolEnv: -12e3,
    delayModEnv: -12e3,
    attackModEnv: -12e3,
    decayModEnv: -12e3,
    holdModEnv: -12e3,
    sustainModEnv: 0,
    releaseModEnv: -12e3,
    modEnvToPitch: 0,
    modEnvToFilterFc: 0,
    modLfoToFilterFc: 0,
    modLfoToPitch: 0,
    modLfoToVolume: 0,
    vibLfoToPitch: 0,
    chorusEffectsSend: 0,
    reverbEffectsSend: 0,
    delayModLFO: 0,
    freqModLFO: 0,
    delayVibLFO: 0,
    keynumToModEnvDecay: 0,
    keynumToModEnvHold: 0,
    keynumToVolEnvDecay: 0,
    keynumToVolEnvHold: 0,
    coarseTune: 0,
    fineTune: 0,
    scaleTuning: 100,
    freqVibLFO: 0,
    startAddrsOffset: 0,
    startAddrsCoarseOffset: 0,
    endAddrsOffset: 0,
    endAddrsCoarseOffset: 0,
    startloopAddrsOffset: 0,
    startloopAddrsCoarseOffset: 0,
    initialAttenuation: 0,
    endloopAddrsOffset: 0,
    endloopAddrsCoarseOffset: 0,
    overridingRootKey: void 0,
    initialFilterQ: 1,
    initialFilterFc: 13500,
    sampleModes: 0,
    pan: void 0
  };
  function arrayRange(start, end) {
    return Array.from({ length: end - start }, (_, k) => k + start);
  }
  function getInstrumentZone(parsed, instrumentZoneIndex) {
    const instrumentBag = parsed.instrumentZone[instrumentZoneIndex];
    const nextInstrumentBag = parsed.instrumentZone[instrumentZoneIndex + 1];
    const generatorIndex = instrumentBag.instrumentGeneratorIndex;
    const nextGeneratorIndex = nextInstrumentBag ? nextInstrumentBag.instrumentGeneratorIndex : parsed.instrumentGenerators.length;
    return parsed.instrumentGenerators.slice(generatorIndex, nextGeneratorIndex);
  }
  function getInstrumentZoneIndexes(parsed, instrumentID) {
    const instrument = parsed.instruments[instrumentID];
    const nextInstrument = parsed.instruments[instrumentID + 1];
    return arrayRange(instrument.instrumentBagIndex, nextInstrument ? nextInstrument.instrumentBagIndex : parsed.instrumentZone.length);
  }
  function getInstrumentGenerators(parsed, instrumentID) {
    return getInstrumentZoneIndexes(parsed, instrumentID).map((i) => getInstrumentZone(parsed, i));
  }
  function getPresetGenerators(parsed, presetHeaderIndex) {
    let presetGenerators;
    const presetHeader = parsed.presetHeaders[presetHeaderIndex];
    const presetBag = parsed.presetZone[presetHeader.presetBagIndex];
    const nextPresetHeaderIndex = presetHeaderIndex + 1;
    if (nextPresetHeaderIndex < parsed.presetHeaders.length) {
      const nextPresetHeader = parsed.presetHeaders[nextPresetHeaderIndex];
      const nextPresetBag = parsed.presetZone[nextPresetHeader.presetBagIndex];
      presetGenerators = parsed.presetGenerators.slice(presetBag.presetGeneratorIndex, nextPresetBag.presetGeneratorIndex);
    } else {
      presetGenerators = parsed.presetGenerators.slice(presetBag.presetGeneratorIndex, parsed.presetGenerators.length);
    }
    return presetGenerators;
  }
  var SoundFont = class {
    constructor(parsed) {
      this.parsed = parsed;
    }
    getPresetZone(presetHeaderIndex) {
      return getPresetGenerators(this.parsed, presetHeaderIndex);
    }
    getInstrumentZone(instrumentZoneIndex) {
      return createGeneraterObject(getInstrumentZone(this.parsed, instrumentZoneIndex));
    }
    getInstrumentZoneIndexes(instrumentID) {
      return getInstrumentZoneIndexes(this.parsed, instrumentID);
    }
    getInstrumentKey(bankNumber, instrumentNumber, key, velocity = 100) {
      const presetHeaderIndex = this.parsed.presetHeaders.findIndex((p) => p.preset === instrumentNumber && p.bank === bankNumber);
      if (presetHeaderIndex < 0) {
        console.warn("preset not found: bank=%s instrument=%s", bankNumber, instrumentNumber);
        return null;
      }
      const presetGenerators = getPresetGenerators(this.parsed, presetHeaderIndex);
      const lastPresetGenertor = presetGenerators[presetGenerators.length - 1];
      if (lastPresetGenertor.type !== "instrument" || isNaN(Number(lastPresetGenertor.value))) {
        throw new Error("Invalid SoundFont: invalid preset generator: expect instrument");
      }
      const instrumentID = lastPresetGenertor.value;
      const instrumentZones = getInstrumentGenerators(this.parsed, instrumentID).map(createGeneraterObject);
      let globalInstrumentZone;
      const firstInstrumentZone = instrumentZones[0];
      if (firstInstrumentZone.sampleID === void 0) {
        globalInstrumentZone = instrumentZones[0];
      }
      const instrumentZone = instrumentZones.find((i) => {
        if (i === globalInstrumentZone) {
          return false;
        }
        let isInKeyRange = false;
        if (i.keyRange) {
          isInKeyRange = key >= i.keyRange.lo && key <= i.keyRange.hi;
        }
        let isInVelRange = true;
        if (i.velRange) {
          isInVelRange = velocity >= i.velRange.lo && velocity <= i.velRange.hi;
        }
        return isInKeyRange && isInVelRange;
      });
      if (!instrumentZone) {
        console.warn("instrument not found: bank=%s instrument=%s", bankNumber, instrumentNumber);
        return null;
      }
      if (instrumentZone.sampleID === void 0) {
        throw new Error("Invalid SoundFont: sampleID not found");
      }
      const gen = Object.assign(Object.assign(Object.assign({}, defaultInstrumentZone), removeUndefined$1(globalInstrumentZone || {})), removeUndefined$1(instrumentZone));
      const sample = this.parsed.samples[gen.sampleID];
      const sampleHeader = this.parsed.sampleHeaders[gen.sampleID];
      const tune = gen.coarseTune + gen.fineTune / 100;
      const basePitch = tune + sampleHeader.pitchCorrection / 100 - (gen.overridingRootKey || sampleHeader.originalPitch);
      const scaleTuning = gen.scaleTuning / 100;
      return {
        sample,
        sampleRate: sampleHeader.sampleRate,
        sampleName: sampleHeader.sampleName,
        sampleModes: gen.sampleModes,
        playbackRate: (key2) => Math.pow(Math.pow(2, 1 / 12), (key2 + basePitch) * scaleTuning),
        modEnvToPitch: gen.modEnvToPitch / 100,
        scaleTuning,
        start: gen.startAddrsCoarseOffset * 32768 + gen.startAddrsOffset,
        end: gen.endAddrsCoarseOffset * 32768 + gen.endAddrsOffset,
        loopStart: sampleHeader.loopStart + gen.startloopAddrsCoarseOffset * 32768 + gen.startloopAddrsOffset,
        loopEnd: sampleHeader.loopEnd + gen.endloopAddrsCoarseOffset * 32768 + gen.endloopAddrsOffset,
        volDelay: convertTime$1(gen.delayVolEnv),
        volAttack: convertTime$1(gen.attackVolEnv),
        volHold: convertTime$1(gen.holdVolEnv),
        volDecay: convertTime$1(gen.decayVolEnv),
        volSustain: gen.sustainVolEnv / 1e3,
        volRelease: convertTime$1(gen.releaseVolEnv),
        modDelay: convertTime$1(gen.delayModEnv),
        modAttack: convertTime$1(gen.attackModEnv),
        modHold: convertTime$1(gen.holdModEnv),
        modDecay: convertTime$1(gen.decayModEnv),
        modSustain: gen.sustainModEnv / 1e3,
        modRelease: convertTime$1(gen.releaseModEnv),
        keyRange: gen.keyRange,
        velRange: gen.velRange,
        initialFilterFc: gen.initialFilterFc,
        modEnvToFilterFc: gen.modEnvToFilterFc,
        initialFilterQ: gen.initialFilterQ,
        initialAttenuation: gen.initialAttenuation,
        freqVibLFO: gen.freqVibLFO ? convertTime$1(gen.freqVibLFO) * 8.176 : void 0,
        pan: gen.pan
      };
    }
    getPresetNames() {
      const bank = {};
      this.parsed.presetHeaders.forEach((preset) => {
        if (!bank[preset.bank]) {
          bank[preset.bank] = {};
        }
        bank[preset.bank][preset.preset] = preset.presetName;
      });
      return bank;
    }
  };
  function convertTime$1(value) {
    return Math.pow(2, value / 1200);
  }
  function removeUndefined$1(obj) {
    const result = {};
    for (let key in obj) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  bin.SoundFont = SoundFont;
  bin.convertTime = convertTime$1;
  var createGeneraterObject_1 = bin.createGeneraterObject = createGeneraterObject;
  var defaultInstrumentZone_1 = bin.defaultInstrumentZone = defaultInstrumentZone;
  var getInstrumentGenerators_1 = bin.getInstrumentGenerators = getInstrumentGenerators;
  bin.getInstrumentZone = getInstrumentZone;
  bin.getInstrumentZoneIndexes = getInstrumentZoneIndexes;
  var getPresetGenerators_1 = bin.getPresetGenerators = getPresetGenerators;
  var parse_1 = bin.parse = parse;
  var sampleToSynthEvent = (sample) => ({
    type: "loadSample",
    sample,
    bank: sample.bank,
    instrument: sample.instrument,
    keyRange: sample.keyRange,
    velRange: sample.velRange
  });
  var getSamplesFromSoundFont = (data, ctx) => {
    const parsed = parse_1(data);
    const result = [];
    for (let i = 0; i < parsed.presetHeaders.length; i++) {
      const presetHeader = parsed.presetHeaders[i];
      const presetGenerators = getPresetGenerators_1(parsed, i);
      for (const lastPresetGenertor of presetGenerators.filter((gen) => gen.type === "instrument")) {
        const presetZone = createGeneraterObject_1(presetGenerators);
        const instrumentID = lastPresetGenertor.value;
        const instrumentZones = getInstrumentGenerators_1(parsed, instrumentID).map(createGeneraterObject_1);
        let globalInstrumentZone;
        const firstInstrumentZone = instrumentZones[0];
        if (firstInstrumentZone.sampleID === void 0) {
          globalInstrumentZone = instrumentZones[0];
        }
        for (const zone of instrumentZones.filter((zone2) => zone2.sampleID !== void 0)) {
          const sample = parsed.samples[zone.sampleID];
          const sampleHeader = parsed.sampleHeaders[zone.sampleID];
          const gen = {
            ...defaultInstrumentZone_1,
            ...removeUndefined(globalInstrumentZone ?? {}),
            ...removeUndefined(zone)
          };
          for (const key of Object.keys(gen)) {
            if (key in presetZone && typeof gen[key] === "number" && typeof presetZone[key] === "number") {
              gen[key] += presetZone[key];
            }
          }
          const tune = gen.coarseTune + gen.fineTune / 100;
          const basePitch = tune + sampleHeader.pitchCorrection / 100 - (gen.overridingRootKey ?? sampleHeader.originalPitch);
          const sampleStart = gen.startAddrsCoarseOffset * 32768 + gen.startAddrsOffset;
          const sampleEnd = gen.endAddrsCoarseOffset * 32768 + gen.endAddrsOffset;
          const loopStart = sampleHeader.loopStart + gen.startloopAddrsCoarseOffset * 32768 + gen.startloopAddrsOffset;
          const loopEnd = sampleHeader.loopEnd + gen.endloopAddrsCoarseOffset * 32768 + gen.endloopAddrsOffset;
          const sample2 = sample.subarray(0, sample.length + sampleEnd);
          const audioBuffer = ctx.createBuffer(1, sample2.length, sampleHeader.sampleRate);
          const audioData = audioBuffer.getChannelData(0);
          sample2.forEach((v, i2) => {
            audioData[i2] = v / 32767;
          });
          const amplitudeEnvelope = {
            attackTime: timeCentToSec(gen.attackVolEnv),
            decayTime: timeCentToSec(gen.decayVolEnv) / 4,
            sustainLevel: 1 - gen.sustainVolEnv / 1e3,
            releaseTime: timeCentToSec(gen.releaseVolEnv) / 4
          };
          result.push({
            buffer: audioData.buffer,
            pitch: -basePitch,
            name: sampleHeader.sampleName,
            sampleStart,
            sampleEnd: sampleEnd === 0 ? audioData.length : sampleEnd,
            loop: gen.sampleModes === 1 && loopEnd > 0 ? {
              start: loopStart,
              end: loopEnd
            } : null,
            instrument: presetHeader.preset,
            bank: presetHeader.bank,
            keyRange: [gen.keyRange.lo, gen.keyRange.hi],
            velRange: [gen.velRange.lo, gen.velRange.hi],
            sampleRate: sampleHeader.sampleRate,
            amplitudeEnvelope,
            scaleTuning: gen.scaleTuning / 100,
            pan: (gen.pan ?? 0) / 500,
            exclusiveClass: gen.exclusiveClass,
            volume: 1 - gen.initialAttenuation / 1e3
          });
        }
      }
    }
    return result.map(sampleToSynthEvent);
  };
  function convertTime(value) {
    return Math.pow(2, value / 1200);
  }
  function timeCentToSec(value) {
    if (value <= -32768) {
      return 0;
    }
    if (value < -12e3) {
      value = -12e3;
    }
    if (value > 8e3) {
      value = 8e3;
    }
    return convertTime(value);
  }
  function removeUndefined(obj) {
    const result = {};
    for (let key in obj) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    }
    return result;
  }

  // node_modules/midifile-ts/dist/index.js
  init_inject();
  var MIDIChannelEvents = {
    noteOff: 8,
    noteOn: 9,
    noteAftertouch: 10,
    controller: 11,
    programChange: 12,
    channelAftertouch: 13,
    pitchBend: 14
  };
  var MIDIControlEvents = {
    MSB_BANK: 0,
    MSB_MODWHEEL: 1,
    MSB_BREATH: 2,
    MSB_FOOT: 4,
    MSB_PORTAMENTO_TIME: 5,
    MSB_DATA_ENTRY: 6,
    MSB_MAIN_VOLUME: 7,
    MSB_BALANCE: 8,
    MSB_PAN: 10,
    MSB_EXPRESSION: 11,
    MSB_EFFECT1: 12,
    MSB_EFFECT2: 13,
    MSB_GENERAL_PURPOSE1: 16,
    MSB_GENERAL_PURPOSE2: 17,
    MSB_GENERAL_PURPOSE3: 18,
    MSB_GENERAL_PURPOSE4: 19,
    LSB_BANK: 32,
    LSB_MODWHEEL: 33,
    LSB_BREATH: 34,
    LSB_FOOT: 36,
    LSB_PORTAMENTO_TIME: 37,
    LSB_DATA_ENTRY: 38,
    LSB_MAIN_VOLUME: 39,
    LSB_BALANCE: 40,
    LSB_PAN: 42,
    LSB_EXPRESSION: 43,
    LSB_EFFECT1: 44,
    LSB_EFFECT2: 45,
    LSB_GENERAL_PURPOSE1: 48,
    LSB_GENERAL_PURPOSE2: 49,
    LSB_GENERAL_PURPOSE3: 50,
    LSB_GENERAL_PURPOSE4: 51,
    SUSTAIN: 64,
    PORTAMENTO: 65,
    SOSTENUTO: 66,
    SUSTENUTO: 66,
    SOFT_PEDAL: 67,
    LEGATO_FOOTSWITCH: 68,
    HOLD2: 69,
    SC1_SOUND_VARIATION: 70,
    SC2_TIMBRE: 71,
    SC3_RELEASE_TIME: 72,
    SC4_ATTACK_TIME: 73,
    SC5_BRIGHTNESS: 74,
    SC6: 75,
    SC7: 76,
    SC8: 77,
    SC9: 78,
    SC10: 79,
    GENERAL_PURPOSE5: 80,
    GENERAL_PURPOSE6: 81,
    GENERAL_PURPOSE7: 82,
    GENERAL_PURPOSE8: 83,
    PORTAMENTO_CONTROL: 84,
    E1_REVERB_DEPTH: 91,
    E2_TREMOLO_DEPTH: 92,
    E3_CHORUS_DEPTH: 93,
    E4_DETUNE_DEPTH: 94,
    E5_PHASER_DEPTH: 95,
    DATA_INCREMENT: 96,
    DATA_DECREMENT: 97,
    NONREG_PARM_NUM_LSB: 98,
    NONREG_PARM_NUM_MSB: 99,
    REGIST_PARM_NUM_LSB: 100,
    REGIST_PARM_NUM_MSB: 101,
    ALL_SOUNDS_OFF: 120,
    RESET_CONTROLLERS: 121,
    LOCAL_CONTROL_SWITCH: 122,
    ALL_NOTES_OFF: 123,
    OMNI_OFF: 124,
    OMNI_ON: 125,
    MONO1: 126,
    MONO2: 127
  };
  var MIDIMetaEvents = {
    sequenceNumber: 0,
    text: 1,
    copyrightNotice: 2,
    trackName: 3,
    instrumentName: 4,
    lyrics: 5,
    marker: 6,
    cuePoint: 7,
    midiChannelPrefix: 32,
    portPrefix: 33,
    endOfTrack: 47,
    setTempo: 81,
    smpteOffset: 84,
    timeSignature: 88,
    keySignature: 89,
    sequencerSpecific: 127
  };
  function deserialize(stream, lastEventTypeByte, setLastEventTypeByte) {
    if (lastEventTypeByte === void 0) {
      lastEventTypeByte = 0;
    }
    var deltaTime = stream.readVarInt();
    return deserializeSingleEvent(stream, deltaTime, lastEventTypeByte, setLastEventTypeByte);
  }
  function deserializeSingleEvent(stream, deltaTime, lastEventTypeByte, setLastEventTypeByte) {
    if (deltaTime === void 0) {
      deltaTime = 0;
    }
    if (lastEventTypeByte === void 0) {
      lastEventTypeByte = 0;
    }
    var eventTypeByte = stream.readInt8();
    if ((eventTypeByte & 240) === 240) {
      if (eventTypeByte === 255) {
        var type = "meta";
        var subtypeByte = stream.readInt8();
        var length = stream.readVarInt();
        switch (subtypeByte) {
          case MIDIMetaEvents.sequenceNumber:
            if (length !== 2)
              throw new Error("Expected length for sequenceNumber event is 2, got " + length);
            return {
              deltaTime,
              type,
              subtype: "sequenceNumber",
              number: stream.readInt16()
            };
          case MIDIMetaEvents.text:
            return {
              deltaTime,
              type,
              subtype: "text",
              text: stream.readStr(length)
            };
          case MIDIMetaEvents.copyrightNotice:
            return {
              deltaTime,
              type,
              subtype: "copyrightNotice",
              text: stream.readStr(length)
            };
          case MIDIMetaEvents.trackName:
            return {
              deltaTime,
              type,
              subtype: "trackName",
              text: stream.readStr(length)
            };
          case MIDIMetaEvents.instrumentName:
            return {
              deltaTime,
              type,
              subtype: "instrumentName",
              text: stream.readStr(length)
            };
          case MIDIMetaEvents.lyrics:
            return {
              deltaTime,
              type,
              subtype: "lyrics",
              text: stream.readStr(length)
            };
          case MIDIMetaEvents.marker:
            return {
              deltaTime,
              type,
              subtype: "marker",
              text: stream.readStr(length)
            };
          case MIDIMetaEvents.cuePoint:
            return {
              deltaTime,
              type,
              subtype: "cuePoint",
              text: stream.readStr(length)
            };
          case MIDIMetaEvents.midiChannelPrefix:
            if (length !== 1)
              throw new Error("Expected length for midiChannelPrefix event is 1, got " + length);
            return {
              deltaTime,
              type,
              subtype: "midiChannelPrefix",
              value: stream.readInt8()
            };
          case MIDIMetaEvents.portPrefix:
            if (length !== 1)
              throw new Error("Expected length for midiChannelPrefix event is 1, got " + length);
            return {
              deltaTime,
              type,
              subtype: "portPrefix",
              port: stream.readInt8()
            };
          case MIDIMetaEvents.endOfTrack:
            if (length !== 0)
              throw new Error("Expected length for endOfTrack event is 0, got " + length);
            return {
              deltaTime,
              type,
              subtype: "endOfTrack"
            };
          case MIDIMetaEvents.setTempo:
            if (length !== 3)
              throw new Error("Expected length for setTempo event is 3, got " + length);
            return {
              deltaTime,
              type,
              subtype: "setTempo",
              microsecondsPerBeat: (stream.readInt8() << 16) + (stream.readInt8() << 8) + stream.readInt8()
            };
          case MIDIMetaEvents.smpteOffset: {
            if (length !== 5)
              throw new Error("Expected length for smpteOffset event is 5, got " + length);
            var hourByte = stream.readInt8();
            var table = {
              0: 24,
              32: 25,
              64: 29,
              96: 30
            };
            return {
              deltaTime,
              type,
              subtype: "smpteOffset",
              frameRate: table[hourByte & 96],
              hour: hourByte & 31,
              min: stream.readInt8(),
              sec: stream.readInt8(),
              frame: stream.readInt8(),
              subframe: stream.readInt8()
            };
          }
          case MIDIMetaEvents.timeSignature:
            if (length !== 4)
              throw new Error("Expected length for timeSignature event is 4, got " + length);
            return {
              deltaTime,
              type,
              subtype: "timeSignature",
              numerator: stream.readInt8(),
              denominator: Math.pow(2, stream.readInt8()),
              metronome: stream.readInt8(),
              thirtyseconds: stream.readInt8()
            };
          case MIDIMetaEvents.keySignature:
            if (length !== 2)
              throw new Error("Expected length for keySignature event is 2, got " + length);
            return {
              deltaTime,
              type,
              subtype: "keySignature",
              key: stream.readInt8(true),
              scale: stream.readInt8()
            };
          case MIDIMetaEvents.sequencerSpecific:
            return {
              deltaTime,
              type,
              subtype: "sequencerSpecific",
              data: stream.read(length)
            };
          default:
            return {
              deltaTime,
              type,
              subtype: "unknown",
              data: stream.read(length)
            };
        }
      } else if (eventTypeByte === 240) {
        var length = stream.readVarInt();
        return {
          deltaTime,
          type: "sysEx",
          data: stream.read(length)
        };
      } else if (eventTypeByte === 247) {
        var length = stream.readVarInt();
        return {
          deltaTime,
          type: "dividedSysEx",
          data: stream.read(length)
        };
      } else {
        throw new Error("Unrecognised MIDI event type byte: " + eventTypeByte);
      }
    } else {
      var param1 = void 0;
      if ((eventTypeByte & 128) === 0) {
        param1 = eventTypeByte;
        eventTypeByte = lastEventTypeByte;
      } else {
        param1 = stream.readInt8();
        setLastEventTypeByte === null || setLastEventTypeByte === void 0 ? void 0 : setLastEventTypeByte(eventTypeByte);
      }
      var eventType = eventTypeByte >> 4;
      var channel = eventTypeByte & 15;
      var type = "channel";
      switch (eventType) {
        case MIDIChannelEvents.noteOff:
          return {
            deltaTime,
            type,
            channel,
            subtype: "noteOff",
            noteNumber: param1,
            velocity: stream.readInt8()
          };
        case MIDIChannelEvents.noteOn: {
          var velocity = stream.readInt8();
          return {
            deltaTime,
            type,
            channel,
            subtype: velocity === 0 ? "noteOff" : "noteOn",
            noteNumber: param1,
            velocity
          };
        }
        case MIDIChannelEvents.noteAftertouch:
          return {
            deltaTime,
            type,
            channel,
            subtype: "noteAftertouch",
            noteNumber: param1,
            amount: stream.readInt8()
          };
        case MIDIChannelEvents.controller:
          return {
            deltaTime,
            type,
            channel,
            subtype: "controller",
            controllerType: param1,
            value: stream.readInt8()
          };
        case MIDIChannelEvents.programChange:
          return {
            deltaTime,
            type,
            channel,
            subtype: "programChange",
            value: param1
          };
        case MIDIChannelEvents.channelAftertouch:
          return {
            deltaTime,
            type,
            channel,
            subtype: "channelAftertouch",
            amount: param1
          };
        case MIDIChannelEvents.pitchBend:
          return {
            deltaTime,
            type,
            channel,
            subtype: "pitchBend",
            value: param1 + (stream.readInt8() << 7)
          };
        default:
          return {
            deltaTime,
            type,
            channel,
            subtype: "unknown",
            data: stream.readInt8()
          };
      }
    }
  }
  var Stream2 = function() {
    function Stream3(buf) {
      this.position = 0;
      if (buf instanceof DataView) {
        this.buf = buf;
      } else if (buf instanceof ArrayBuffer) {
        this.buf = new DataView(buf);
      } else if (buf instanceof Array) {
        this.buf = new DataView(new Uint8Array(buf).buffer);
      } else if (buf instanceof Uint8Array) {
        this.buf = new DataView(buf.buffer);
      } else {
        throw new Error("not supported type: " + typeof buf);
      }
    }
    Stream3.prototype.readByte = function() {
      return this.buf.getUint8(this.position++);
    };
    Stream3.prototype.readStr = function(length) {
      return this.read(length).map(function(e) {
        return String.fromCharCode(e);
      }).join("");
    };
    Stream3.prototype.read = function(length) {
      var result = [];
      for (var index = 0; index < length; index++) {
        result.push(this.readByte());
      }
      return result;
    };
    Stream3.prototype.readInt32 = function() {
      var result = this.buf.getInt32(this.position, false);
      this.position += 4;
      return result;
    };
    Stream3.prototype.readInt16 = function() {
      var result = this.buf.getInt16(this.position, false);
      this.position += 2;
      return result;
    };
    Stream3.prototype.readInt8 = function(signed) {
      if (signed === void 0) {
        signed = false;
      }
      if (signed) {
        return this.buf.getInt8(this.position++);
      } else {
        return this.readByte();
      }
    };
    Stream3.prototype.eof = function() {
      return this.position >= this.buf.byteLength;
    };
    Stream3.prototype.readVarInt = function() {
      var result = 0;
      for (; ; ) {
        var b = this.readInt8();
        if (b & 128) {
          result += b & 127;
          result <<= 7;
        } else {
          return result + b;
        }
      }
    };
    return Stream3;
  }();
  function read(data) {
    function readChunk(stream2) {
      var id = stream2.readStr(4);
      var length = stream2.readInt32();
      return {
        id,
        length,
        data: stream2.read(length)
      };
    }
    var stream = new Stream2(data);
    var headerChunk = readChunk(stream);
    if (headerChunk.id !== "MThd" || headerChunk.length !== 6) {
      throw new Error("Bad .mid file - header not found");
    }
    var headerStream = new Stream2(headerChunk.data);
    var formatType = headerStream.readInt16();
    var trackCount = headerStream.readInt16();
    var timeDivision = headerStream.readInt16();
    var ticksPerBeat;
    if (timeDivision & 32768) {
      throw new Error("Expressing time division in SMTPE frames is not supported yet");
    } else {
      ticksPerBeat = timeDivision;
    }
    var header = {
      formatType,
      trackCount,
      ticksPerBeat
    };
    var lastEventTypeByte;
    function readEvent(stream2) {
      return deserialize(stream2, lastEventTypeByte, function(byte) {
        return lastEventTypeByte = byte;
      });
    }
    var tracks = [];
    for (var i = 0; i < header.trackCount; i++) {
      tracks[i] = [];
      var trackChunk = readChunk(stream);
      if (trackChunk.id !== "MTrk") {
        throw new Error("Unexpected chunk - expected MTrk, got " + trackChunk.id);
      }
      var trackStream = new Stream2(trackChunk.data);
      while (!trackStream.eof()) {
        var event = readEvent(trackStream);
        tracks[i].push(event);
      }
    }
    return {
      header,
      tracks
    };
  }
  function toCharCodes2(str) {
    var bytes = [];
    for (var i = 0; i < str.length; i++) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  var Buffer4 = function() {
    function Buffer5() {
      this.data = [];
      this.position = 0;
    }
    Object.defineProperty(Buffer5.prototype, "length", {
      get: function() {
        return this.data.length;
      },
      enumerable: false,
      configurable: true
    });
    Buffer5.prototype.writeByte = function(v) {
      this.data.push(v);
      this.position++;
    };
    Buffer5.prototype.writeStr = function(str) {
      this.writeBytes(toCharCodes2(str));
    };
    Buffer5.prototype.writeInt32 = function(v) {
      this.writeByte(v >> 24 & 255);
      this.writeByte(v >> 16 & 255);
      this.writeByte(v >> 8 & 255);
      this.writeByte(v & 255);
    };
    Buffer5.prototype.writeInt16 = function(v) {
      this.writeByte(v >> 8 & 255);
      this.writeByte(v & 255);
    };
    Buffer5.prototype.writeBytes = function(arr) {
      var _this = this;
      arr.forEach(function(v) {
        return _this.writeByte(v);
      });
    };
    Buffer5.prototype.writeChunk = function(id, func) {
      this.writeStr(id);
      var chunkBuf = new Buffer5();
      func(chunkBuf);
      this.writeInt32(chunkBuf.length);
      this.writeBytes(chunkBuf.data);
    };
    Buffer5.prototype.toBytes = function() {
      return new Uint8Array(this.data);
    };
    return Buffer5;
  }();

  // osrs/sound/MidiPlayer/EventScheduler.ts
  init_inject();
  var EventScheduler = class {
    constructor(events = [], tick = 0, timebase = 480, lookAheadTime = 100) {
      this.lookAheadTime = 100;
      this.timebase = 480;
      this._currentTick = 0;
      this._scheduledTick = 0;
      this._prevTime = void 0;
      this._events = events;
      this._currentTick = tick;
      this._scheduledTick = tick;
      this.timebase = timebase;
      this.lookAheadTime = lookAheadTime;
    }
    get currentTick() {
      return this._currentTick;
    }
    millisecToTick(ms, bpm) {
      return ms / 1e3 * bpm / 60 * this.timebase;
    }
    tickToMillisec(tick, bpm) {
      return tick / (this.timebase / 60) / bpm * 1e3;
    }
    seek(tick) {
      this._currentTick = this._scheduledTick = Math.max(0, tick);
    }
    readNextEvents(bpm, timestamp) {
      if (this._prevTime === void 0) {
        this._prevTime = timestamp;
      }
      const delta = timestamp - this._prevTime;
      const nowTick = Math.floor(
        this._currentTick + Math.max(0, this.millisecToTick(delta, bpm))
      );
      const lookAheadTick = Math.floor(
        this.millisecToTick(this.lookAheadTime, bpm)
      );
      const startTick = this._scheduledTick;
      const endTick = nowTick + lookAheadTick;
      this._prevTime = timestamp;
      this._currentTick = nowTick;
      this._scheduledTick = endTick;
      return this._events.filter((e) => e && e.tick >= startTick && e.tick < endTick).map((e) => {
        const waitTick = e.tick - nowTick;
        const delayedTime = timestamp + Math.max(0, this.tickToMillisec(waitTick, bpm));
        return {
          event: e,
          timestamp: delayedTime
        };
      });
    }
  };

  // osrs/sound/MidiPlayer/processor/ProcessorLoader.ts
  init_inject();

  // osrs/sound/MidiPlayer/processor/processor.file.js
  var processor_file_default = 'class Logger {\n    enabled = true;\n    log(...args) {\n        if (this.enabled) {\n            console.log(...args);\n        }\n    }\n    warn(...args) {\n        if (this.enabled) {\n            console.warn(...args);\n        }\n    }\n    error(...args) {\n        if (this.enabled) {\n            console.error(...args);\n        }\n    }\n}\nconst logger = new Logger();\nlogger.enabled = false;\n\nclass SampleTable {\n    samples = {};\n    addSample(sample, bank, instrument, keyRange, velRange) {\n        for (let i = keyRange[0]; i <= keyRange[1]; i++) {\n            if (this.samples[bank] === undefined) {\n                this.samples[bank] = {};\n            }\n            if (this.samples[bank][instrument] === undefined) {\n                this.samples[bank][instrument] = {};\n            }\n            if (this.samples[bank][instrument][i] === undefined) {\n                this.samples[bank][instrument][i] = [];\n            }\n            this.samples[bank][instrument][i].push({ ...sample, velRange });\n        }\n    }\n    getSamples(bank, instrument, pitch, velocity) {\n        const samples = this.samples?.[bank]?.[instrument]?.[pitch];\n        return (samples?.filter((s) => velocity >= s.velRange[0] && velocity <= s.velRange[1]) ?? []);\n    }\n}\n\nvar MIDIControlEvents = {\n    MSB_BANK: 0x00,\n    MSB_MODWHEEL: 0x01,\n    MSB_BREATH: 0x02,\n    MSB_FOOT: 0x04,\n    MSB_PORTAMENTO_TIME: 0x05,\n    MSB_DATA_ENTRY: 0x06,\n    MSB_MAIN_VOLUME: 0x07,\n    MSB_BALANCE: 0x08,\n    MSB_PAN: 0x0a,\n    MSB_EXPRESSION: 0x0b,\n    MSB_EFFECT1: 0x0c,\n    MSB_EFFECT2: 0x0d,\n    MSB_GENERAL_PURPOSE1: 0x10,\n    MSB_GENERAL_PURPOSE2: 0x11,\n    MSB_GENERAL_PURPOSE3: 0x12,\n    MSB_GENERAL_PURPOSE4: 0x13,\n    LSB_BANK: 0x20,\n    LSB_MODWHEEL: 0x21,\n    LSB_BREATH: 0x22,\n    LSB_FOOT: 0x24,\n    LSB_PORTAMENTO_TIME: 0x25,\n    LSB_DATA_ENTRY: 0x26,\n    LSB_MAIN_VOLUME: 0x27,\n    LSB_BALANCE: 0x28,\n    LSB_PAN: 0x2a,\n    LSB_EXPRESSION: 0x2b,\n    LSB_EFFECT1: 0x2c,\n    LSB_EFFECT2: 0x2d,\n    LSB_GENERAL_PURPOSE1: 0x30,\n    LSB_GENERAL_PURPOSE2: 0x31,\n    LSB_GENERAL_PURPOSE3: 0x32,\n    LSB_GENERAL_PURPOSE4: 0x33,\n    SUSTAIN: 0x40,\n    PORTAMENTO: 0x41,\n    SOSTENUTO: 0x42,\n    SUSTENUTO: 0x42,\n    SOFT_PEDAL: 0x43,\n    LEGATO_FOOTSWITCH: 0x44,\n    HOLD2: 0x45,\n    SC1_SOUND_VARIATION: 0x46,\n    SC2_TIMBRE: 0x47,\n    SC3_RELEASE_TIME: 0x48,\n    SC4_ATTACK_TIME: 0x49,\n    SC5_BRIGHTNESS: 0x4a,\n    SC6: 0x4b,\n    SC7: 0x4c,\n    SC8: 0x4d,\n    SC9: 0x4e,\n    SC10: 0x4f,\n    GENERAL_PURPOSE5: 0x50,\n    GENERAL_PURPOSE6: 0x51,\n    GENERAL_PURPOSE7: 0x52,\n    GENERAL_PURPOSE8: 0x53,\n    PORTAMENTO_CONTROL: 0x54,\n    E1_REVERB_DEPTH: 0x5b,\n    E2_TREMOLO_DEPTH: 0x5c,\n    E3_CHORUS_DEPTH: 0x5d,\n    E4_DETUNE_DEPTH: 0x5e,\n    E5_PHASER_DEPTH: 0x5f,\n    DATA_INCREMENT: 0x60,\n    DATA_DECREMENT: 0x61,\n    NONREG_PARM_NUM_LSB: 0x62,\n    NONREG_PARM_NUM_MSB: 0x63,\n    REGIST_PARM_NUM_LSB: 0x64,\n    REGIST_PARM_NUM_MSB: 0x65,\n    ALL_SOUNDS_OFF: 0x78,\n    RESET_CONTROLLERS: 0x79,\n    LOCAL_CONTROL_SWITCH: 0x7a,\n    ALL_NOTES_OFF: 0x7b,\n    OMNI_OFF: 0x7c,\n    OMNI_ON: 0x7d,\n    MONO1: 0x7e,\n    MONO2: 0x7f,\n};\n\nfunction toCharCodes(str) {\n    var bytes = [];\n    for (var i = 0; i < str.length; i++) {\n        bytes.push(str.charCodeAt(i));\n    }\n    return bytes;\n}\n\n/** @class */ ((function () {\n    function Buffer() {\n        this.data = [];\n        this.position = 0;\n    }\n    Object.defineProperty(Buffer.prototype, "length", {\n        get: function () {\n            return this.data.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Buffer.prototype.writeByte = function (v) {\n        this.data.push(v);\n        this.position++;\n    };\n    Buffer.prototype.writeStr = function (str) {\n        this.writeBytes(toCharCodes(str));\n    };\n    Buffer.prototype.writeInt32 = function (v) {\n        this.writeByte((v >> 24) & 0xff);\n        this.writeByte((v >> 16) & 0xff);\n        this.writeByte((v >> 8) & 0xff);\n        this.writeByte(v & 0xff);\n    };\n    Buffer.prototype.writeInt16 = function (v) {\n        this.writeByte((v >> 8) & 0xff);\n        this.writeByte(v & 0xff);\n    };\n    Buffer.prototype.writeBytes = function (arr) {\n        var _this = this;\n        arr.forEach(function (v) { return _this.writeByte(v); });\n    };\n    Buffer.prototype.writeChunk = function (id, func) {\n        this.writeStr(id);\n        var chunkBuf = new Buffer();\n        func(chunkBuf);\n        this.writeInt32(chunkBuf.length);\n        this.writeBytes(chunkBuf.data);\n    };\n    Buffer.prototype.toBytes = function () {\n        return new Uint8Array(this.data);\n    };\n    return Buffer;\n})());\n\n// https://gist.github.com/fmal/763d9c953c5a5f8b8f9099dbc58da55e\nfunction insertSorted(arr, item, prop) {\n    let low = 0;\n    let high = arr.length;\n    let mid;\n    while (low < high) {\n        mid = (low + high) >>> 1; // like (num / 2) but faster\n        if (arr[mid][prop] < item[prop]) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    arr.splice(low, 0, item);\n}\n\nclass SynthEventHandler {\n    processor;\n    scheduledEvents = [];\n    currentEvents = [];\n    rpnEvents = {};\n    bankSelectMSB = {};\n    constructor(processor) {\n        this.processor = processor;\n    }\n    get currentFrame() {\n        return this.processor.currentFrame;\n    }\n    addEvent(e) {\n        logger.log(e);\n        if ("delayTime" in e) {\n            // handle in process\n            insertSorted(this.scheduledEvents, {\n                ...e,\n                scheduledFrame: this.currentFrame + e.delayTime,\n            }, "scheduledFrame");\n        }\n        else {\n            this.handleImmediateEvent(e);\n        }\n    }\n    processScheduledEvents() {\n        if (this.scheduledEvents.length === 0) {\n            return;\n        }\n        while (true) {\n            const e = this.scheduledEvents[0];\n            if (e === undefined || e.scheduledFrame > this.currentFrame) {\n                // scheduledEvents are sorted by scheduledFrame,\n                // so we can break early instead of iterating through all scheduledEvents,\n                break;\n            }\n            this.scheduledEvents.shift();\n            this.currentEvents.push(e);\n        }\n        while (true) {\n            const e = this.currentEvents.pop();\n            if (e === undefined) {\n                break;\n            }\n            this.handleDelayableEvent(e.midi);\n        }\n    }\n    handleImmediateEvent(e) {\n        switch (e.type) {\n            case "loadSample":\n                this.processor.loadSample(e.sample, e.bank, e.instrument, e.keyRange, e.velRange);\n                break;\n        }\n    }\n    handleDelayableEvent(e) {\n        logger.log("handle delayable event", e);\n        switch (e.type) {\n            case "channel": {\n                switch (e.subtype) {\n                    case "noteOn":\n                        this.processor.noteOn(e.channel, e.noteNumber, e.velocity);\n                        break;\n                    case "noteOff":\n                        this.processor.noteOff(e.channel, e.noteNumber);\n                        break;\n                    case "pitchBend":\n                        this.processor.pitchBend(e.channel, e.value);\n                        break;\n                    case "programChange":\n                        this.processor.programChange(e.channel, e.value);\n                        break;\n                    case "controller": {\n                        switch (e.controllerType) {\n                            case MIDIControlEvents.NONREG_PARM_NUM_MSB:\n                            case MIDIControlEvents.NONREG_PARM_NUM_LSB: // NRPN LSB\n                                // Delete the rpn for do not send NRPN data events\n                                delete this.rpnEvents[e.channel];\n                                break;\n                            case MIDIControlEvents.REGIST_PARM_NUM_MSB: {\n                                if (e.value === 127) {\n                                    delete this.rpnEvents[e.channel];\n                                }\n                                else {\n                                    this.rpnEvents[e.channel] = {\n                                        ...this.rpnEvents[e.channel],\n                                        rpnMSB: e,\n                                    };\n                                }\n                                break;\n                            }\n                            case MIDIControlEvents.REGIST_PARM_NUM_LSB: {\n                                if (e.value === 127) {\n                                    delete this.rpnEvents[e.channel];\n                                }\n                                else {\n                                    this.rpnEvents[e.channel] = {\n                                        ...this.rpnEvents[e.channel],\n                                        rpnLSB: e,\n                                    };\n                                }\n                                break;\n                            }\n                            case MIDIControlEvents.MSB_DATA_ENTRY: {\n                                const rpn = {\n                                    ...this.rpnEvents[e.channel],\n                                    dataMSB: e,\n                                };\n                                this.rpnEvents[e.channel] = rpn;\n                                // In case of pitch bend sensitivity,\n                                // send without waiting for Data LSB event\n                                if (rpn.rpnLSB?.value === 0) {\n                                    this.processor.setPitchBendSensitivity(e.channel, rpn.dataMSB.value);\n                                }\n                                break;\n                            }\n                            case MIDIControlEvents.LSB_DATA_ENTRY: {\n                                this.rpnEvents[e.channel] = {\n                                    ...this.rpnEvents[e.channel],\n                                    dataLSB: e,\n                                };\n                                // TODO: Send other RPN events\n                                break;\n                            }\n                            case MIDIControlEvents.MSB_MAIN_VOLUME:\n                                this.processor.setMainVolume(e.channel, e.value);\n                                break;\n                            case MIDIControlEvents.MSB_EXPRESSION:\n                                this.processor.expression(e.channel, e.value);\n                                break;\n                            case MIDIControlEvents.ALL_SOUNDS_OFF:\n                                this.removeScheduledEvents(e.channel);\n                                this.processor.allSoundsOff(e.channel);\n                                break;\n                            case MIDIControlEvents.ALL_NOTES_OFF:\n                                this.processor.allNotesOff(e.channel);\n                                break;\n                            case MIDIControlEvents.SUSTAIN:\n                                this.processor.hold(e.channel, e.value);\n                                break;\n                            case MIDIControlEvents.MSB_PAN:\n                                this.processor.setPan(e.channel, e.value);\n                                break;\n                            case MIDIControlEvents.MSB_MODWHEEL:\n                                this.processor.modulation(e.channel, e.value);\n                                break;\n                            case MIDIControlEvents.MSB_BANK:\n                                this.bankSelectMSB[e.channel] = e.value;\n                                break;\n                            case MIDIControlEvents.LSB_BANK: {\n                                const msb = this.bankSelectMSB[e.channel];\n                                if (msb !== undefined) {\n                                    const bank = (msb << 7) + e.value;\n                                    this.processor.bankSelect(e.channel, bank);\n                                }\n                                break;\n                            }\n                            case MIDIControlEvents.RESET_CONTROLLERS:\n                                this.processor.resetChannel(e.channel);\n                                break;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    removeScheduledEvents(channel) {\n        this.scheduledEvents = this.scheduledEvents.filter((e) => e.midi.channel !== channel);\n        this.currentEvents = this.currentEvents.filter((e) => e.midi.channel !== channel);\n    }\n}\n\nvar EnvelopePhase;\n(function (EnvelopePhase) {\n    EnvelopePhase[EnvelopePhase["attack"] = 0] = "attack";\n    EnvelopePhase[EnvelopePhase["decay"] = 1] = "decay";\n    EnvelopePhase[EnvelopePhase["sustain"] = 2] = "sustain";\n    EnvelopePhase[EnvelopePhase["release"] = 3] = "release";\n    EnvelopePhase[EnvelopePhase["forceStop"] = 4] = "forceStop";\n    EnvelopePhase[EnvelopePhase["stopped"] = 5] = "stopped";\n})(EnvelopePhase || (EnvelopePhase = {}));\nconst forceStopReleaseTime = 0.1;\nclass AmplitudeEnvelope {\n    parameter;\n    phase = EnvelopePhase.attack;\n    lastAmplitude = 0;\n    sampleRate;\n    constructor(parameter, sampleRate) {\n        this.parameter = parameter;\n        this.sampleRate = sampleRate;\n    }\n    noteOn() {\n        this.phase = EnvelopePhase.attack;\n    }\n    noteOff() {\n        if (this.phase !== EnvelopePhase.forceStop) {\n            this.phase = EnvelopePhase.release;\n        }\n    }\n    // Rapidly decrease the volume. This method ignores release time parameter\n    forceStop() {\n        this.phase = EnvelopePhase.forceStop;\n    }\n    getAmplitude(bufferSize) {\n        const { attackTime, decayTime, sustainLevel, releaseTime } = this.parameter;\n        const { sampleRate } = this;\n        // Attack\n        switch (this.phase) {\n            case EnvelopePhase.attack: {\n                const amplificationPerFrame = (1 / (attackTime * sampleRate)) * bufferSize;\n                const value = this.lastAmplitude + amplificationPerFrame;\n                if (value >= 1) {\n                    this.phase = EnvelopePhase.decay;\n                    this.lastAmplitude = 1;\n                    return 1;\n                }\n                this.lastAmplitude = value;\n                return value;\n            }\n            case EnvelopePhase.decay: {\n                const attenuationPerFrame = (1 / (decayTime * sampleRate)) * bufferSize;\n                const value = this.lastAmplitude - attenuationPerFrame;\n                if (value <= sustainLevel) {\n                    if (sustainLevel <= 0) {\n                        this.phase = EnvelopePhase.stopped;\n                        this.lastAmplitude = 0;\n                        return 0;\n                    }\n                    else {\n                        this.phase = EnvelopePhase.sustain;\n                        this.lastAmplitude = sustainLevel;\n                        return sustainLevel;\n                    }\n                }\n                this.lastAmplitude = value;\n                return value;\n            }\n            case EnvelopePhase.sustain: {\n                return sustainLevel;\n            }\n            case EnvelopePhase.release: {\n                const attenuationPerFrame = (1 / (releaseTime * sampleRate)) * bufferSize;\n                const value = this.lastAmplitude - attenuationPerFrame;\n                if (value <= 0) {\n                    this.phase = EnvelopePhase.stopped;\n                    this.lastAmplitude = 0;\n                    return 0;\n                }\n                this.lastAmplitude = value;\n                return value;\n            }\n            case EnvelopePhase.forceStop: {\n                const attenuationPerFrame = (1 / (forceStopReleaseTime * sampleRate)) * bufferSize;\n                const value = this.lastAmplitude - attenuationPerFrame;\n                if (value <= 0) {\n                    this.phase = EnvelopePhase.stopped;\n                    this.lastAmplitude = 0;\n                    return 0;\n                }\n                this.lastAmplitude = value;\n                return value;\n            }\n            case EnvelopePhase.stopped: {\n                return 0;\n            }\n        }\n    }\n    get isPlaying() {\n        return this.phase !== EnvelopePhase.stopped;\n    }\n}\n\nclass LFO {\n    // Hz\n    frequency = 5;\n    phase = 0;\n    sampleRate;\n    constructor(sampleRate) {\n        this.sampleRate = sampleRate;\n    }\n    getValue(bufferSize) {\n        const phase = this.phase;\n        this.phase +=\n            ((Math.PI * 2 * this.frequency) / this.sampleRate) * bufferSize;\n        return Math.sin(phase);\n    }\n}\n\nclass WavetableOscillator {\n    sample;\n    sampleIndex = 0;\n    _isPlaying = false;\n    _isNoteOff = false;\n    baseSpeed = 1;\n    envelope;\n    pitchLFO;\n    sampleRate;\n    speed = 1;\n    // 0 to 1\n    velocity = 1;\n    // 0 to 1\n    volume = 1;\n    modulation = 0;\n    // cent\n    modulationDepthRange = 50;\n    // -1 to 1\n    pan = 0;\n    // This oscillator should be note off when hold pedal off\n    isHold = false;\n    constructor(sample, sampleRate) {\n        this.sample = sample;\n        this.sampleRate = sampleRate;\n        this.envelope = new AmplitudeEnvelope(sample.amplitudeEnvelope, sampleRate);\n        this.pitchLFO = new LFO(sampleRate);\n    }\n    noteOn(pitch, velocity) {\n        this.velocity = velocity;\n        this._isPlaying = true;\n        this.sampleIndex = this.sample.sampleStart;\n        this.baseSpeed = Math.pow(2, ((pitch - this.sample.pitch) / 12) * this.sample.scaleTuning);\n        this.pitchLFO.frequency = 5;\n        this.envelope.noteOn();\n    }\n    noteOff() {\n        this.envelope.noteOff();\n        this._isNoteOff = true;\n    }\n    forceStop() {\n        this.envelope.forceStop();\n    }\n    process(outputs) {\n        if (!this._isPlaying) {\n            return;\n        }\n        const speed = (this.baseSpeed * this.speed * this.sample.sampleRate) / this.sampleRate;\n        const volume = this.velocity * this.volume * this.sample.volume;\n        // zero to pi/2\n        const panTheta = ((Math.min(1, Math.max(-1, this.pan + this.sample.pan)) + 1) * Math.PI) /\n            4;\n        const leftPanVolume = Math.cos(panTheta);\n        const rightPanVolume = Math.sin(panTheta);\n        const gain = this.envelope.getAmplitude(outputs[0].length);\n        const leftGain = gain * volume * leftPanVolume;\n        const rightGain = gain * volume * rightPanVolume;\n        const pitchLFOValue = this.pitchLFO.getValue(outputs[0].length);\n        const pitchModulation = pitchLFOValue * this.modulation * (this.modulationDepthRange / 1200);\n        const modulatedSpeed = speed * (1 + pitchModulation);\n        for (let i = 0; i < outputs[0].length; ++i) {\n            const index = Math.floor(this.sampleIndex);\n            const advancedIndex = this.sampleIndex + modulatedSpeed;\n            let loopIndex = null;\n            if (this.sample.loop !== null && advancedIndex >= this.sample.loop.end) {\n                loopIndex =\n                    this.sample.loop.start + (advancedIndex - Math.floor(advancedIndex));\n            }\n            const nextIndex = loopIndex !== null\n                ? Math.floor(loopIndex)\n                : Math.min(index + 1, this.sample.sampleEnd - 1);\n            // linear interpolation\n            const current = this.sample.buffer[index];\n            const next = this.sample.buffer[nextIndex];\n            const level = current + (next - current) * (this.sampleIndex - index);\n            outputs[0][i] += level * leftGain;\n            outputs[1][i] += level * rightGain;\n            this.sampleIndex = loopIndex ?? advancedIndex;\n            if (this.sampleIndex >= this.sample.sampleEnd) {\n                this._isPlaying = false;\n                break;\n            }\n        }\n    }\n    get isPlaying() {\n        return this._isPlaying && this.envelope.isPlaying;\n    }\n    get isNoteOff() {\n        return this._isNoteOff;\n    }\n    get exclusiveClass() {\n        return this.sample.exclusiveClass;\n    }\n}\n\nconst initialChannelState = () => ({\n    volume: 1,\n    bank: 0,\n    instrument: 0,\n    pitchBend: 0,\n    pitchBendSensitivity: 2,\n    oscillators: {},\n    expression: 1,\n    pan: 0,\n    modulation: 0,\n    hold: false,\n});\nconst RHYTHM_CHANNEL = 9;\nconst RHYTHM_BANK = 128;\nclass SynthProcessorCore {\n    sampleTable = new SampleTable();\n    channels = {};\n    eventHandler;\n    sampleRate;\n    getCurrentFrame;\n    constructor(sampleRate, getCurrentFrame) {\n        this.eventHandler = new SynthEventHandler(this);\n        this.sampleRate = sampleRate;\n        this.getCurrentFrame = getCurrentFrame;\n    }\n    get currentFrame() {\n        return this.getCurrentFrame();\n    }\n    getSamples(channel, pitch, velocity) {\n        const state = this.getChannelState(channel);\n        // Play drums for CH.10\n        const bank = channel === RHYTHM_CHANNEL ? RHYTHM_BANK : state.bank;\n        return this.sampleTable.getSamples(bank, state.instrument, pitch, velocity);\n    }\n    loadSample(sample, bank, instrument, keyRange, velRange) {\n        const _sample = {\n            ...sample,\n            buffer: new Float32Array(sample.buffer),\n        };\n        this.sampleTable.addSample(_sample, bank, instrument, keyRange, velRange);\n    }\n    addEvent(e) {\n        this.eventHandler.addEvent(e);\n    }\n    noteOn(channel, pitch, velocity) {\n        const state = this.getChannelState(channel);\n        const samples = this.getSamples(channel, pitch, velocity);\n        if (samples.length === 0) {\n            logger.warn(`There is no sample for noteNumber ${pitch} in instrument ${state.instrument} in bank ${state.bank}`);\n            return;\n        }\n        for (const sample of samples) {\n            const oscillator = new WavetableOscillator(sample, this.sampleRate);\n            const volume = velocity / 0x80;\n            oscillator.noteOn(pitch, volume);\n            if (state.oscillators[pitch] === undefined) {\n                state.oscillators[pitch] = [];\n            }\n            if (sample.exclusiveClass !== undefined) {\n                for (const key in state.oscillators) {\n                    for (const osc of state.oscillators[key]) {\n                        if (osc.exclusiveClass === sample.exclusiveClass) {\n                            osc.forceStop();\n                        }\n                    }\n                }\n            }\n            state.oscillators[pitch].push(oscillator);\n        }\n    }\n    noteOff(channel, pitch) {\n        const state = this.getChannelState(channel);\n        if (state.oscillators[pitch] === undefined) {\n            return;\n        }\n        for (const osc of state.oscillators[pitch]) {\n            if (!osc.isNoteOff) {\n                if (state.hold) {\n                    osc.isHold = true;\n                }\n                else {\n                    osc.noteOff();\n                }\n            }\n        }\n    }\n    pitchBend(channel, value) {\n        const state = this.getChannelState(channel);\n        state.pitchBend = (value / 0x2000 - 1) * state.pitchBendSensitivity;\n    }\n    programChange(channel, value) {\n        const state = this.getChannelState(channel);\n        state.instrument = value;\n    }\n    setPitchBendSensitivity(channel, value) {\n        const state = this.getChannelState(channel);\n        state.pitchBendSensitivity = value;\n    }\n    setMainVolume(channel, value) {\n        const state = this.getChannelState(channel);\n        state.volume = value / 0x80;\n    }\n    expression(channel, value) {\n        const state = this.getChannelState(channel);\n        state.expression = value / 0x80;\n    }\n    allSoundsOff(channel) {\n        const state = this.getChannelState(channel);\n        for (const key in state.oscillators) {\n            for (const osc of state.oscillators[key]) {\n                osc.forceStop();\n            }\n        }\n    }\n    allNotesOff(channel) {\n        const state = this.getChannelState(channel);\n        for (const key in state.oscillators) {\n            for (const osc of state.oscillators[key]) {\n                osc.noteOff();\n            }\n        }\n    }\n    hold(channel, value) {\n        const hold = value >= 64;\n        const state = this.getChannelState(channel);\n        state.hold = hold;\n        if (hold) {\n            return;\n        }\n        for (const key in state.oscillators) {\n            for (const osc of state.oscillators[key]) {\n                if (osc.isHold) {\n                    osc.noteOff();\n                }\n            }\n        }\n    }\n    setPan(channel, value) {\n        const state = this.getChannelState(channel);\n        state.pan = (value / 127 - 0.5) * 2;\n    }\n    bankSelect(channel, value) {\n        const state = this.getChannelState(channel);\n        state.bank = value;\n    }\n    modulation(channel, value) {\n        const state = this.getChannelState(channel);\n        state.modulation = value / 0x80;\n    }\n    resetChannel(channel) {\n        delete this.channels[channel];\n    }\n    getChannelState(channel) {\n        const state = this.channels[channel];\n        if (state !== undefined) {\n            return state;\n        }\n        const newState = initialChannelState();\n        this.channels[channel] = newState;\n        return newState;\n    }\n    process(outputs) {\n        this.eventHandler.processScheduledEvents();\n        for (const channel in this.channels) {\n            const state = this.channels[channel];\n            for (let key in state.oscillators) {\n                state.oscillators[key] = state.oscillators[key].filter((oscillator) => {\n                    oscillator.speed = Math.pow(2, state.pitchBend / 12);\n                    oscillator.volume = state.volume * state.expression;\n                    oscillator.pan = state.pan;\n                    oscillator.modulation = state.modulation;\n                    oscillator.process([outputs[0], outputs[1]]);\n                    if (!oscillator.isPlaying) {\n                        return false;\n                    }\n                    return true;\n                });\n            }\n        }\n        // master volume\n        const masterVolume = 0.3;\n        for (let i = 0; i < outputs[0].length; ++i) {\n            outputs[0][i] *= masterVolume;\n            outputs[1][i] *= masterVolume;\n        }\n    }\n}\n\n\n\nclass EventScheduler {\n    // \u5148\u8AAD\u307F\u6642\u9593 (ms)\n    // Leading time (MS)\n    lookAheadTime = 100\n\n    // 1/4 \u62CD\u5B50\u3054\u3068\u306E tick \u6570\n    // 1/4 TICK number for each beat\n    timebase = 480\n\n    _currentTick = 0;\n    _scheduledTick = 0;\n    _prevTime = undefined;\n    _events;\n\n    constructor(events = [], tick = 0, timebase = 480, lookAheadTime = 100) {\n        this._events = events\n        this._currentTick = tick\n        this._scheduledTick = tick\n        this.timebase = timebase\n        this.lookAheadTime = lookAheadTime\n    }\n\n    get currentTick() {\n        return this._currentTick\n    }\n\n    millisecToTick(ms, bpm) {\n        return (((ms / 1000) * bpm) / 60) * this.timebase\n    }\n\n    tickToMillisec(tick, bpm) {\n        return (tick / (this.timebase / 60) / bpm) * 1000\n    }\n\n    seek(tick) {\n        this._currentTick = this._scheduledTick = Math.max(0, tick)\n    }\n\n    readNextEvents(bpm, timestamp) {\n        if (this._prevTime === undefined) {\n            this._prevTime = timestamp\n        }\n        const delta = timestamp - this._prevTime\n        const nowTick = Math.floor(\n            this._currentTick + Math.max(0, this.millisecToTick(delta, bpm))\n        )\n\n        // \u5148\u8AAD\u307F\u6642\u9593\n        // Leading time\n        const lookAheadTick = Math.floor(\n            this.millisecToTick(this.lookAheadTime, bpm)\n        )\n\n        // \u524D\u56DE\u30B9\u30B1\u30B8\u30E5\u30FC\u30EB\u6E08\u307F\u306E\u6642\u70B9\u304B\u3089\u3001\n        // From the previous scheduled point,\n        // \u5148\u8AAD\u307F\u6642\u9593\u307E\u3067\u3092\u51E6\u7406\u306E\u5BFE\u8C61\u3068\u3059\u308B\n        // Target of processing up to read time\n        const startTick = this._scheduledTick\n        const endTick = nowTick + lookAheadTick\n\n        this._prevTime = timestamp\n        this._currentTick = nowTick\n        this._scheduledTick = endTick\n\n        return this._events\n            .filter((e) => e && e.tick >= startTick && e.tick < endTick)\n            .map((e) => {\n                const waitTick = e.tick - nowTick\n                const delayedTime =\n                    timestamp + Math.max(0, this.tickToMillisec(waitTick, bpm))\n                return {\n                    event: e,\n                    timestamp: delayedTime\n                }\n            })\n    }\n}\n\nclass SynthProcessor extends AudioWorkletProcessor {\n    synth = new SynthProcessorCore(sampleRate, () => currentFrame);\n    scheduler;\n\n    prevTime = 0;\n\n    isPlaying = false;\n    playPrevTime = 0;\n\n    tempo = 120;\n    sampleRate = 48000;\n    endOfSong = 0;\n\n    constructor() {\n        super();\n\n        this.port.onmessage = (e) => {\n            if (e.data.type == "loadMidi") {\n                this.scheduler = new EventScheduler(e.data.events, e.data.tick, e.data.timebase, e.data.lookAheadTime);\n                this.endOfSong = e.data.endOfSong;\n            }\n            else if (e.data.type == "midiAction") {\n                if (e.data.action == "resume") {\n                    this.isPlaying = true;\n                }\n                else if (e.data.action == "pause") {\n                    this.isPlaying = false;\n                }\n            }\n            else {\n                this.synth.addEvent(e.data);\n            }\n        };\n    }\n\n    handleEvent(e, delayTime) {\n        switch (e.type) {\n            case "channel":\n                return {\n                    type: "midi",\n                        midi: e,\n                        delayTime,\n                };\n            case "meta":\n                switch (e.subtype) {\n                    case "setTempo":\n                        this.tempo = (60 * 1000000) / e.microsecondsPerBeat;\n                        break\n                    default:\n                        // console.warn(`not supported meta event`, e);\n                        break\n                }\n        }\n        return null;\n    }\n\n    playTimer() {\n        if (this.isPlaying && this.playPrevTime + 0.1 <= currentTime) {\n            const now = currentTime * 1000;\n            const events = this.scheduler.readNextEvents(this.tempo, now)\n            \n            // console.log("running", now, this.sampleRate, this.tempo, events.length);\n    \n            // channel \u30A4\u30D9\u30F3\u30C8\u3092 MIDI Output \u306B\u9001\u4FE1\n            // Send Channel Event to MIDI OUTPUT\n            events.forEach(({ event, timestamp }) => {\n                const delayTime = ((timestamp - now) / 1000) * this.sampleRate;\n                const synthEvent = this.handleEvent(event, delayTime);\n                if (synthEvent !== null) {\n                    this.synth.addEvent(synthEvent);\n                }\n            })\n    \n            if (this.scheduler.currentTick >= this.endOfSong) {\n                this.isPlaying = false;\n            }\n\n            this.playPrevTime = currentTime;\n        }\n    }\n\n    process(_inputs, outputs) {\n        this.playTimer();\n\n        this.synth.process(outputs[0]);\n        return true;\n    }\n}\n\nregisterProcessor("synth-processor", SynthProcessor);';

  // osrs/sound/MidiPlayer/processor/ProcessorLoader.ts
  var ProcessorLoader = class {
    static async Load() {
      const blob = new Blob([processor_file_default], { type: "application/javascript" });
      const reader = new FileReader();
      reader.readAsDataURL(blob);
      return await new Promise((result) => {
        reader.onloadend = function() {
          result(reader.result.toString());
        };
      });
    }
  };

  // osrs/sound/MidiPlayer/MIDIPlayer.ts
  function addTick(events, track) {
    let tick = 0;
    return events.map((e) => {
      tick += e.deltaTime;
      return {
        ...e,
        tick,
        track
      };
    });
  }
  var isEndOfTrackEvent = (e) => "subtype" in e && e.subtype === "endOfTrack";
  var TIMER_INTERVAL = 100;
  var LOOK_AHEAD_TIME = 50;
  var MIDIPlayer = class {
    constructor() {
      this.setup();
      document.addEventListener("click", () => {
        this.context.resume();
      });
      document.addEventListener("touchstart", () => {
        this.context.resume();
      });
    }
    async setup() {
      this.context = new AudioContext();
      this.sampleRate = this.context.sampleRate;
      try {
        await this.context.audioWorklet.addModule(await ProcessorLoader.Load());
      } catch (e) {
        console.error(e);
        throw Error("Failed to add AudioWorklet module");
      }
      this.synth = new AudioWorkletNode(this.context, "synth-processor", {
        numberOfInputs: 0,
        outputChannelCount: [2]
      });
      this.synth.connect(this.context.destination);
      this.output = (e, transfer) => {
        this.synth.port.postMessage(e, transfer ?? []);
      };
    }
    loadSoundFont(soundFontBuffer) {
      const parsed = getSamplesFromSoundFont(new Uint8Array(soundFontBuffer), this.context);
      for (const sample of parsed) {
        this.output(sample, [sample.sample.buffer]);
      }
    }
    loadMidi(midiBuffer) {
      const midi = read(midiBuffer);
      this.midi = midi;
      this.tickedEvents = midi.tracks.flatMap(addTick).sort((a, b) => a.tick - b.tick);
      this.scheduler = new EventScheduler(this.tickedEvents, 0, this.midi.header.ticksPerBeat, TIMER_INTERVAL + LOOK_AHEAD_TIME);
      this.endOfSong = Math.max(...this.tickedEvents.filter(isEndOfTrackEvent).map((e) => e.tick));
      this.resetControllers();
      this.output({
        type: "loadMidi",
        events: this.tickedEvents,
        tick: 0,
        timebase: this.midi.header.ticksPerBeat,
        lookAheadTime: TIMER_INTERVAL + LOOK_AHEAD_TIME,
        endOfSong: this.endOfSong
      });
    }
    resume() {
      this.output({
        type: "midiAction",
        action: "resume"
      });
    }
    pause() {
      this.output({
        type: "midiAction",
        action: "pause"
      });
      this.allSoundsOff();
    }
    stop() {
      this.pause();
      this.resetControllers();
      this.scheduler.seek(0);
    }
    seek(position) {
      this.allSoundsOff();
      this.scheduler.seek(position * this.endOfSong);
    }
    setVolume(volume) {
      for (let i = 0; i < 16; i++) {
        this.output({
          type: "midi",
          midi: {
            type: "channel",
            subtype: "controller",
            controllerType: MIDIControlEvents.MSB_MAIN_VOLUME,
            channel: i,
            value: volume
          },
          delayTime: 0
        });
      }
    }
    allSoundsOff() {
      for (let i = 0; i < 16; i++) {
        this.output({
          type: "midi",
          midi: {
            type: "channel",
            subtype: "controller",
            controllerType: MIDIControlEvents.ALL_SOUNDS_OFF,
            channel: i,
            value: 0
          },
          delayTime: 0
        });
      }
    }
    resetControllers() {
      for (let i = 0; i < 16; i++) {
        this.output({
          type: "midi",
          midi: {
            type: "channel",
            subtype: "controller",
            controllerType: MIDIControlEvents.RESET_CONTROLLERS,
            channel: i,
            value: 0
          },
          delayTime: 0
        });
      }
    }
  };

  // osrs/Game.ts
  function init_SKILL_EXPERIENCE() {
    const bitfield = Array(99).fill(0);
    let value = 0;
    for (let level = 0; level < 99; level++) {
      const realLevel = level + 1;
      const expDiff = realLevel + 300 * Math.pow(2, realLevel / 7) | 0;
      value += expDiff;
      bitfield[level] = value / 4 | 0;
    }
    return bitfield;
  }
  function init_BITFIELD_MAX_VALUE() {
    const bitfield = Array(32).fill(0);
    let value = 2;
    for (let k = 0; k < 32; k++) {
      {
        bitfield[k] = value - 1;
        value += value;
      }
    }
    return bitfield;
  }
  var _Game = class extends GameShell {
    constructor(canvas) {
      super(canvas);
      this.stores = [];
      this.archiveHashes = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.titleArchive = null;
      this.fontSmall = null;
      this.fontNormal = null;
      this.fontBold = null;
      this.fontFancy = null;
      this.flameLeftBackground = null;
      this.flameRightBackground = null;
      this.aClass18_1198 = null;
      this.aClass18_1199 = null;
      this.aClass18_1200 = null;
      this.aClass18_1203 = null;
      this.aClass18_1204 = null;
      this.aClass18_1205 = null;
      this.aClass18_1206 = null;
      this.chatboxProducingGraphicsBuffer = null;
      this.aClass18_1157 = null;
      this.aClass18_1156 = null;
      this.aClass18_1158 = null;
      this.aClass18_1108 = null;
      this.aClass18_1109 = null;
      this.aBoolean1046 = false;
      this.titleboxImage = null;
      this.titleboxButtonImage = null;
      this.anImageRGB1226 = null;
      this.anImageRGB1227 = null;
      this.startedRenderingFlames = false;
      this.shouldRenderFlames = false;
      this.packetSize = 0;
      this.isRenderingFlames = false;
      this.flameCycle = 0;
      this.anInt1238 = 0;
      this.anIntArray1166 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(256);
      this.outBuffer = Buffer3.allocate(1);
      this.anInt1047 = 0;
      this.anInt1048 = 0;
      this.anInt1322 = 0;
      this.aString1027 = null;
      this.renderDelay = 0;
      this.currentSceneTileFlags = null;
      this.anIntArrayArrayArray891 = null;
      this.currentScene = null;
      this.currentCollisionMap = Array(4).fill(null);
      this.minimapImage = null;
      this.loggedIn = false;
      this.onDemandRequester = null;
      this.opcode = 0;
      this.redrawTabArea = false;
      this.backDialogueId = -1;
      this.nextSong = 0;
      this.dialogueId = -1;
      this.redrawChatbox = false;
      this.loadingStage = 0;
      this.aByteArrayArray838 = null;
      this.anIntArray857 = null;
      this.anIntArray858 = null;
      this.aByteArrayArray1232 = null;
      this.songChanging = true;
      this.musicEnabled = true;
      this.widgetSettings = Array(2e3).fill(0);
      this.inventoryBackgroundImage = null;
      this.chatboxBackgroundImage = null;
      this.minimapBackgroundImage = null;
      this.anIndexedImage1052 = null;
      this.anIndexedImage1053 = null;
      this.anIndexedImage1054 = null;
      this.tabIcon = Array(13).fill(null);
      this.minimapCompass = null;
      this.minimapEdge = null;
      this.mapscenes = Array(100).fill(null);
      this.worldMapHintIcons = Array(100).fill(null);
      this.hitmarks = Array(20).fill(null);
      this.headiconsPks = Array(32).fill(null);
      this.headiconsPrayers = Array(32).fill(null);
      this.headiconsHints = Array(32).fill(null);
      this.aClass50_Sub1_Sub1_Sub1_1037 = null;
      this.aClass50_Sub1_Sub1_Sub1_1086 = null;
      this.mapFlagMarker = null;
      this.mapdotItem = null;
      this.mapdotActor = null;
      this.mapdotPlayer = null;
      this.mapdotFriend = null;
      this.mapdotTeammate = null;
      this.cursorCross = Array(8).fill(null);
      this.scrollbarUp = null;
      this.scrollbarDown = null;
      this.aClass50_Sub1_Sub1_Sub3_880 = null;
      this.aClass50_Sub1_Sub1_Sub3_881 = null;
      this.aClass50_Sub1_Sub1_Sub3_882 = null;
      this.aClass50_Sub1_Sub1_Sub3_883 = null;
      this.aClass50_Sub1_Sub1_Sub3_884 = null;
      this.aClass50_Sub1_Sub1_Sub3_983 = null;
      this.aClass50_Sub1_Sub1_Sub3_984 = null;
      this.aClass50_Sub1_Sub1_Sub3_985 = null;
      this.aClass50_Sub1_Sub1_Sub3_986 = null;
      this.aClass50_Sub1_Sub1_Sub3_987 = null;
      this.moderatorIcon = Array(2).fill(null);
      this.anIntArray1180 = Array(33).fill(0);
      this.anIntArray1286 = Array(33).fill(0);
      this.anIntArray1019 = Array(151).fill(0);
      this.anIntArray920 = Array(151).fill(0);
      this.anIntArray1003 = null;
      this.chatboxLineOffsets = null;
      this.anIntArray1001 = null;
      this.anIntArray1002 = null;
      this.mouseCapturer = null;
      this.aClass18_906 = null;
      this.aClass18_907 = null;
      this.aClass18_908 = null;
      this.aClass18_909 = null;
      this.aClass18_910 = null;
      this.aClass18_911 = null;
      this.aClass18_912 = null;
      this.aClass18_913 = null;
      this.aClass18_914 = null;
      this.startUpError = false;
      this.aBoolean1016 = false;
      this.aBoolean1097 = false;
      this.buffer = Buffer3.allocate(1);
      this.username = "Wildy" + Math.floor(Math.random() * 1e3);
      this.password = "Testing";
      this.loginScreenState = 0;
      this.anInt977 = 0;
      this.statusLineOne = "";
      this.statusLineTwo = "";
      this.anInt850 = 0;
      this.anInt1094 = 0;
      this.gameConnection = null;
      this.tempBuffer = Buffer3.allocate(1);
      this.incomingRandom = null;
      this.playerRights = 0;
      this.aLong902 = 0;
      this.duplicateClickCount = 0;
      this.aBoolean1275 = true;
      this.lastOpcode = 0;
      this.secondLastOpcode = 0;
      this.thirdLastOpcode = 0;
      this.timeoutCounter = 0;
      this.systemUpdateTime = 0;
      this.anInt873 = 0;
      this.anInt1197 = 0;
      this.menuActionRow = 0;
      this.menuOpen = false;
      this.chatMessages = Array(100).fill(null);
      this.itemSelected = 0;
      this.widgetSelected = 0;
      this.currentSound = 0;
      this.anInt1009 = 0;
      this.anInt1255 = 0;
      this.anInt916 = 0;
      this.anInt1233 = 0;
      this.cameraHorizontal = 0;
      this.minimapState = 0;
      this.anInt1276 = -1;
      this.destinationX = 0;
      this.destinationY = 0;
      this.localPlayerCount = 0;
      this.anInt1133 = 0;
      this.anInt968 = 2048;
      this.players = Array(this.anInt968).fill(null);
      this.cachedAppearances = Array(this.anInt968).fill(null);
      this.npcs = Array(16384).fill(null);
      this.thisPlayerId = 2047;
      this.aClass6_1282 = new LinkedList();
      this.aClass6_1210 = new LinkedList();
      this.groundItems = array3d(4, 104, 104, null);
      this.aClass6_1261 = new LinkedList();
      this.friendListStatus = 0;
      this.friendsCount = 0;
      this.openInterfaceId = -1;
      this.anInt1053 = -1;
      this.anInt960 = -1;
      this.anInt1089 = -1;
      this.anInt1279 = -1;
      this.aBoolean1239 = false;
      this.anInt1285 = 3;
      this.inputType = 0;
      this.messagePromptRaised = false;
      this.clickToContinueString = null;
      this.anInt1319 = 0;
      this.anInt1213 = -1;
      this.characterEditChangeGenger = true;
      this.characterEditColors = Array(5).fill(0);
      this.aStringArray1069 = Array(5).fill(null);
      this.aBooleanArray1070 = Array(5).fill(false);
      this.aLong1229 = 0;
      this.aBoolean1277 = false;
      this.characterEditIdentityKits = Array(7).fill(0);
      this.aClass18_1110 = null;
      this.useJaggrab = Configuration.JAGGRAB_ENABLED;
      this.jaggrabSocket = null;
      this.sound = Array(50).fill(0);
      this.soundType = Array(50).fill(0);
      this.soundDelay = Array(50).fill(0);
      this.aBoolean1301 = true;
      this.anIntArray1005 = Array(2e3).fill(0);
      this.previousSong = 0;
      this.anInt1300 = 0;
      this.anInt998 = 0;
      this.anInt1223 = 0;
      this.anInt955 = 0;
      this.anInt1011 = 0;
      this.anInt1012 = 0;
      this.anInt1264 = 0;
      this.aBoolean1265 = false;
      this.anInt1251 = 128;
      this.plane = 0;
      this.aBoolean953 = false;
      this.coordinates = null;
      this.nextTopLeftTileX = 0;
      this.nextTopRightTileY = 0;
      this.aBoolean1163 = false;
      this.aBoolean1209 = false;
      this.chunkX = 0;
      this.chunkY = 0;
      this.constructedMapPalette = array3d(4, 13, 13, 0);
      this.anInt1072 = 20411;
      this.aBoolean1067 = false;
      this.minimapHintCount = 0;
      this.minimapHint = Array(1e3).fill(null);
      this.minimapHintX = Array(1e3).fill(0);
      this.minimapHintY = Array(1e3).fill(0);
      this.aBoolean950 = false;
      this.inputInputMessage = "";
      this.publicChatMode = 0;
      this.privateChatMode = 0;
      this.tradeMode = 0;
      this.aBoolean1212 = false;
      this.anInt1226 = 0;
      this.anInt847 = 0;
      this.anInt848 = 0;
      this.anInt844 = 0;
      this.anInt845 = 0;
      this.anInt846 = 0;
      this.anInt1151 = 0;
      this.oriented = false;
      this.anInt993 = 0;
      this.anInt994 = 0;
      this.anInt995 = 0;
      this.anInt996 = 0;
      this.anInt997 = 0;
      this.cameraX = 0;
      this.cameraZ = 0;
      this.cameraY = 0;
      this.cameraPitch = 0;
      this.cameraYaw = 0;
      this.aBooleanArray927 = Array(5).fill(false);
      this.anIntArray1105 = Array(5).fill(0);
      this.anIntArray852 = Array(5).fill(0);
      this.anIntArray991 = Array(5).fill(0);
      this.quakeTimes = Array(5).fill(0);
      this.friends = Array(200).fill(new import_long3.default(0, 0));
      this.friendWorlds = Array(200).fill(0);
      this.friendUsernames = Array(200).fill(null);
      this.anIntArray1032 = [0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3];
      this.placementX = 0;
      this.placementY = 0;
      this.thisPlayerServerId = -1;
      this.anIntArray843 = Array(SkillConstants.SKILL_COUNT).fill(0);
      this.anIntArray1029 = Array(SkillConstants.SKILL_COUNT).fill(0);
      this.anIntArray1054 = Array(SkillConstants.SKILL_COUNT).fill(0);
      this.topLeftTileX = 0;
      this.topLeftTileY = 0;
      this.anInt1324 = 0;
      this.anInt874 = 0;
      this.anInt875 = 0;
      this.anInt876 = 0;
      this.anInt877 = 0;
      this.anInt878 = 0;
      this.aBoolean1038 = true;
      this.ignoresCount = 0;
      this.ignores = Array(100).fill(new import_long3.default(0, 0));
      this.anIntArray1081 = [1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
      this.playerMembers = 0;
      this.removePlayerCount = 0;
      this.updatedPlayerCount = 0;
      this.removePlayers = Array(1e3).fill(0);
      this.anIntArray1134 = Array(16384).fill(0);
      this.aByte1317 = -58;
      this.anInt1281 = -939;
      this.updatedPlayers = Array(this.anInt968).fill(0);
      this.anInt1140 = -110;
      this.playerList = Array(this.anInt968).fill(0);
      this.chatTypes = Array(100).fill(0);
      this.chatPlayerNames = Array(100).fill(null);
      this.inTutorialIsland = false;
      this.chatBuffer = new Buffer3(Array(5e3).fill(0));
      this.anInt1083 = 0;
      this.anInt1075 = 0;
      this.anInt1208 = 0;
      this.anInt1170 = 0;
      this.anInt1273 = 0;
      this.anInt1215 = 0;
      this.anInt992 = 0;
      this.lastAddress = 0;
      this.anInt1034 = 0;
      this.anInt1030 = 0;
      this.anIntArray1258 = Array(100).fill(0);
      this.anInt1152 = 0;
      this.anInt1328 = 409;
      this.aByte1143 = -80;
      this.aByte1066 = 1;
      this.anInt1175 = -89;
      this.anInt1055 = 2;
      this.soundVolume = Array(50).fill(0);
      this.aLong1172 = 0;
      this.anInt1257 = 0;
      this.anInt1272 = -1;
      this.anInt935 = -1;
      this.anInt1222 = 0;
      this.anInt928 = -100;
      this.tickDelta = 0;
      this.crossType = 0;
      this.crossIndex = 0;
      this.atInventoryInterfaceType = 0;
      this.atInventoryLoopCycle = 0;
      this.activeInterfaceType = 0;
      this.anInt1269 = 0;
      this.anInt1114 = 0;
      this.anInt1115 = 0;
      this.aBoolean1155 = false;
      this.lastActiveInvInterface = 0;
      this.modifiedWidgetId = 0;
      this.mouseInvInterfaceIndex = 0;
      this.selectedInventorySlot = 0;
      this.aByte1161 = 97;
      this.anInt1020 = 0;
      this.anInt1021 = 0;
      this.anInt1044 = 0;
      this.anInt1284 = 0;
      this.anInt1129 = 0;
      this.anInt893 = 0;
      this.anInt1118 = 0;
      this.anInt853 = 0;
      this.anInt854 = 2;
      this.anInt1010 = 2;
      this.anInt1256 = 1;
      this.anInt1045 = 0;
      this.anInt917 = 2;
      this.anInt1234 = 1;
      this.anInt872 = 0;
      this.menuActionTexts = Array(500).fill(null);
      this.menuActionTypes = Array(500).fill(0);
      this.anInt1004 = 0;
      this.anInt915 = 0;
      this.anInt1315 = 0;
      this.anInt1302 = 0;
      this.anInt1178 = 300;
      this.anInt1280 = 0;
      this.anInt1106 = 0;
      this.firstMenuOperand = Array(500).fill(0);
      this.secondMenuOperand = Array(500).fill(0);
      this.selectedMenuActions = Array(500).fill(0);
      this.aBoolean1127 = false;
      this.anInt1303 = 0;
      this.anInt1148 = 0;
      this.anInt1147 = 0;
      this.aString1150 = null;
      this.selectedWidgetName = null;
      this.anInt1173 = 0;
      this.anIntArrayArray885 = array2d(104, 104, 0);
      this.cost = array2d(104, 104, 0);
      this.anIntArray1123 = Array(4e3).fill(0);
      this.anIntArray1124 = Array(4e3).fill(0);
      this.anInt1126 = 0;
      this.aBoolean1014 = false;
      this.anInt851 = 0;
      this.anInt1304 = 0;
      this.menuClickX = 0;
      this.menuClickY = 0;
      this.anInt1307 = 0;
      this.anInt1308 = 0;
      this.anInt1330 = 0;
      this.anInt1331 = 0;
      this.anInt1149 = 0;
      this.anInt1172 = 0;
      this.reportedName = "";
      this.reportMutePlayer = false;
      this.reportAbuseInterfaceID = -1;
      this.chatMessage = "";
      this.friendsListAction = 0;
      this.aLong1141 = new import_long3.default(0, 0);
      this.chatboxInputMessage = "";
      this.anInt1154 = -916;
      this.anInt1262 = 0;
      this.anInt1263 = 0;
      this.anInt1186 = 0;
      this.anInt1187 = 0;
      this.anInt1289 = 0;
      this.chatboxInput = "";
      this.anInt1236 = 326;
      this.anInt1107 = 78;
      this.aClass13_1249 = new Widget();
      this.anInt862 = 0;
      this.anInt865 = 0;
      this.aClass50_Sub1_Sub1_Sub1_1102 = null;
      this.aClass50_Sub1_Sub1_Sub1_1103 = null;
      this.anInt931 = 2301979;
      this.anInt1080 = 5063219;
      this.anInt1135 = 7759444;
      this.anInt921 = 8;
      this.anInt1287 = 3353893;
      this.anInt1138 = 0;
      this.anIntArrayArray886 = array2d(104, 104, 0);
      this.anInt939 = 0;
      this.screenX = -1;
      this.screenY = -1;
      this.anInt940 = 50;
      this.anIntArray944 = Array(this.anInt940).fill(0);
      this.anIntArray943 = Array(this.anInt940).fill(0);
      this.anIntArray941 = Array(this.anInt940).fill(0);
      this.anIntArray942 = Array(this.anInt940).fill(0);
      this.anIntArray945 = Array(this.anInt940).fill(0);
      this.anIntArray946 = Array(this.anInt940).fill(0);
      this.anIntArray947 = Array(this.anInt940).fill(0);
      this.aStringArray948 = Array(this.anInt940).fill(null);
      this.anIntArray842 = [16776960, 16711680, 65280, 65535, 16711935, 16777215];
      this.anInt1056 = 3;
      this.anIntArray1290 = [17, 24, 34, 40];
      this.aByteArray1245 = Array(16384).fill(0);
      this.aByte956 = 1;
      this.aString861 = "";
      this.aStringArray863 = Array(100).fill(null);
      this.aBoolean959 = true;
      this.anIntArray864 = Array(100).fill(0);
      this.anInt1119 = -30658;
      window.Game = this;
    }
    static getCombatLevelColour(user, opponent) {
      const difference = user - opponent;
      if (difference < -9) {
        return "@red@";
      }
      if (difference < -6) {
        return "@or3@";
      }
      if (difference < -3) {
        return "@or2@";
      }
      if (difference < 0) {
        return "@or1@";
      }
      if (difference > 9) {
        return "@gre@";
      }
      if (difference > 6) {
        return "@gr3@";
      }
      if (difference > 3) {
        return "@gr2@";
      }
      if (difference > 0) {
        return "@gr1@";
      } else {
        return "@yel@";
      }
    }
    static getShortenedAmountText(coins) {
      if (coins < 1e5) {
        return new String(coins).toString();
      }
      if (coins < 1e7) {
        return (coins / 1e3 | 0) + "K";
      } else {
        return (coins / 1e6 | 0) + "M";
      }
    }
    static setHighMemory() {
      Scene.lowMemory = false;
      Rasterizer3D.lowMemory = false;
      _Game.lowMemory = false;
      Region.lowMemory = false;
      GameObjectDefinition.lowMemory = false;
    }
    static setLowMemory() {
      Scene.lowMemory = true;
      Rasterizer3D.lowMemory = true;
      _Game.lowMemory = true;
      Region.lowMemory = true;
      GameObjectDefinition.lowMemory = true;
    }
    static getFullAmountText(amount) {
      let string = new String(amount).toString();
      for (let index = string.length - 3; index > 0; index -= 3) {
        string = string.substring(0, index) + "," + string.substring(index);
      }
      if (string.length > 8) {
        string = "@gre@" + string.substring(0, string.length - 8) + " million @whi@(" + string + ")";
      } else if (string.length > 4) {
        string = "@cya@" + string.substring(0, string.length - 4) + "K @whi@(" + string + ")";
      }
      return " " + string;
    }
    async doLogic() {
      if (this.aBoolean1016 || this.startUpError || this.aBoolean1097) {
        return;
      }
      _Game.pulseCycle++;
      if (!this.loggedIn) {
        await this.method149(-724);
      } else {
        await this.processGame();
      }
      this.processOnDemandQueue(false);
    }
    async repaintGame() {
      if (this.aBoolean1016 || this.startUpError || this.aBoolean1097) {
        this.drawError();
        return;
      }
      _Game.anInt1309++;
      if (!this.loggedIn) {
        await this.drawLoginScreen(false);
      } else {
        this.drawGame();
      }
      this.anInt1094 = 0;
    }
    drawGame() {
      if (this.anInt1053 !== -1 && (this.loadingStage === 2 || this.imageProducer != null)) {
        if (this.loadingStage === 2) {
          this.method88(this.tickDelta, this.anInt1053, 5 | 0);
          if (this.anInt960 !== -1) {
            this.method88(this.tickDelta, this.anInt960, 5 | 0);
          }
          this.tickDelta = 0;
          this.method147(this.anInt1140);
          this.imageProducer.createRasterizer();
          Rasterizer3D.lineOffsets = this.anIntArray1003;
          Rasterizer.resetPixels();
          this.aBoolean1046 = true;
          const class13 = Widget.forId(this.anInt1053);
          if (class13.width === 512 && class13.height === 334 && class13.type === 0) {
            class13.width = 765;
            class13.height = 503;
          }
          this.method142(0, 0, class13, 0, 8);
          if (this.anInt960 !== -1) {
            const class13_1 = Widget.forId(this.anInt960);
            if (class13_1.width === 512 && class13_1.height === 334 && class13_1.type === 0) {
              class13_1.width = 765;
              class13_1.height = 503;
            }
            this.method142(0, 0, class13_1, 0, 8);
          }
          if (!this.menuOpen) {
            this.processRightClick(-521);
            this.drawMenuTooltip();
          } else {
            this.method128(false);
          }
        }
        this.imageProducer.drawGraphics(0, 0, this.gameGraphics);
        return;
      }
      if (this.aBoolean1046) {
        this.method122();
        this.aBoolean1046 = false;
        this.aClass18_906.drawGraphics(0, 4, this.gameGraphics);
        this.aClass18_907.drawGraphics(0, 357, this.gameGraphics);
        this.aClass18_908.drawGraphics(722, 4, this.gameGraphics);
        this.aClass18_909.drawGraphics(743, 205, this.gameGraphics);
        this.aClass18_910.drawGraphics(0, 0, this.gameGraphics);
        this.aClass18_911.drawGraphics(516, 4, this.gameGraphics);
        this.aClass18_912.drawGraphics(516, 205, this.gameGraphics);
        this.aClass18_913.drawGraphics(496, 357, this.gameGraphics);
        this.aClass18_914.drawGraphics(0, 338, this.gameGraphics);
        this.redrawTabArea = true;
        this.redrawChatbox = true;
        this.aBoolean950 = true;
        this.aBoolean1212 = true;
        if (this.loadingStage !== 2) {
          this.aClass18_1158.drawGraphics(4, 4, this.gameGraphics);
          this.aClass18_1157.drawGraphics(550, 4, this.gameGraphics);
        }
        _Game.anInt1237++;
        if (_Game.anInt1237 > 85) {
          _Game.anInt1237 = 0;
          this.outBuffer.putOpcode(168);
        }
      }
      if (this.loadingStage === 2) {
        this.drawGameView();
      }
      if (this.menuOpen && this.anInt1304 === 1) {
        this.redrawTabArea = true;
      }
      if (this.anInt1089 !== -1) {
        const flag = this.method88(this.tickDelta, this.anInt1089, 5 | 0);
        if (flag) {
          this.redrawTabArea = true;
        }
      }
      if (this.atInventoryInterfaceType === 2) {
        this.redrawTabArea = true;
      }
      if (this.activeInterfaceType === 2) {
        this.redrawTabArea = true;
      }
      if (this.redrawTabArea) {
        this.redrawTabs();
        this.redrawTabArea = false;
      }
      if (this.backDialogueId === -1 && this.inputType === 0) {
        this.aClass13_1249.anInt231 = this.anInt1107 - this.anInt851 - 77;
        if (this.mouseX > 448 && this.mouseX < 560 && this.mouseY > 332) {
          this.method42(this.anInt1107, 0, this.aClass13_1249, 102 | 0, this.mouseY - 357, -1, this.mouseX - 17, 77, 463);
        }
        let j = this.anInt1107 - 77 - this.aClass13_1249.anInt231;
        if (j < 0) {
          j = 0;
        }
        if (j > this.anInt1107 - 77) {
          j = this.anInt1107 - 77;
        }
        if (this.anInt851 !== j) {
          this.anInt851 = j;
          this.redrawChatbox = true;
        }
      }
      if (this.backDialogueId === -1 && this.inputType === 3) {
        const k = this.anInt862 * 14 + 7;
        this.aClass13_1249.anInt231 = this.anInt865;
        if (this.mouseX > 448 && this.mouseX < 560 && this.mouseY > 332) {
          this.method42(k, 0, this.aClass13_1249, 102 | 0, this.mouseY - 357, -1, this.mouseX - 17, 77, 463);
        }
        let i1 = this.aClass13_1249.anInt231;
        if (i1 < 0) {
          i1 = 0;
        }
        if (i1 > k - 77) {
          i1 = k - 77;
        }
        if (this.anInt865 !== i1) {
          this.anInt865 = i1;
          this.redrawChatbox = true;
        }
      }
      if (this.backDialogueId !== -1) {
        const flag1 = this.method88(this.tickDelta, this.backDialogueId, 5 | 0);
        if (flag1) {
          this.redrawChatbox = true;
        }
      }
      if (this.atInventoryInterfaceType === 3) {
        this.redrawChatbox = true;
      }
      if (this.activeInterfaceType === 3) {
        this.redrawChatbox = true;
      }
      if (this.clickToContinueString != null) {
        this.redrawChatbox = true;
      }
      if (this.menuOpen && this.anInt1304 === 2) {
        this.redrawChatbox = true;
      }
      if (this.redrawChatbox) {
        this.renderChatbox();
        this.redrawChatbox = false;
      }
      if (this.loadingStage === 2) {
        this.renderMinimap();
        this.aClass18_1157.drawGraphics(550, 4, this.gameGraphics);
      }
      if (this.anInt1213 !== -1) {
        this.aBoolean950 = true;
      }
      if (this.aBoolean950) {
        if (this.anInt1213 !== -1 && this.anInt1213 === this.anInt1285) {
          this.anInt1213 = -1;
          this.outBuffer.putOpcode(119);
          this.outBuffer.putByte(this.anInt1285);
        }
        this.aBoolean950 = false;
        this.aClass18_1110.createRasterizer();
        this.anIndexedImage1054.drawImage(0, 0);
        if (this.anInt1089 === -1) {
          if (this.anIntArray1081[this.anInt1285] !== -1) {
            if (this.anInt1285 === 0) {
              this.aClass50_Sub1_Sub1_Sub3_880.drawImage(22, 10);
            }
            if (this.anInt1285 === 1) {
              this.aClass50_Sub1_Sub1_Sub3_881.drawImage(54, 8);
            }
            if (this.anInt1285 === 2) {
              this.aClass50_Sub1_Sub1_Sub3_881.drawImage(82, 8);
            }
            if (this.anInt1285 === 3) {
              this.aClass50_Sub1_Sub1_Sub3_882.drawImage(110, 8);
            }
            if (this.anInt1285 === 4) {
              this.aClass50_Sub1_Sub1_Sub3_884.drawImage(153, 8);
            }
            if (this.anInt1285 === 5) {
              this.aClass50_Sub1_Sub1_Sub3_884.drawImage(181, 8);
            }
            if (this.anInt1285 === 6) {
              this.aClass50_Sub1_Sub1_Sub3_883.drawImage(209, 9);
            }
          }
          if (this.anIntArray1081[0] !== -1 && (this.anInt1213 !== 0 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[0].drawImage(29, 13);
          }
          if (this.anIntArray1081[1] !== -1 && (this.anInt1213 !== 1 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[1].drawImage(53, 11);
          }
          if (this.anIntArray1081[2] !== -1 && (this.anInt1213 !== 2 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[2].drawImage(82, 11);
          }
          if (this.anIntArray1081[3] !== -1 && (this.anInt1213 !== 3 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[3].drawImage(115, 12);
          }
          if (this.anIntArray1081[4] !== -1 && (this.anInt1213 !== 4 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[4].drawImage(153, 13);
          }
          if (this.anIntArray1081[5] !== -1 && (this.anInt1213 !== 5 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[5].drawImage(180, 11);
          }
          if (this.anIntArray1081[6] !== -1 && (this.anInt1213 !== 6 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[6].drawImage(208, 13);
          }
        }
        this.aClass18_1110.drawGraphics(516, 160, this.gameGraphics);
        this.aClass18_1109.createRasterizer();
        this.anIndexedImage1053.drawImage(0, 0);
        if (this.anInt1089 === -1) {
          if (this.anIntArray1081[this.anInt1285] !== -1) {
            if (this.anInt1285 === 7) {
              this.aClass50_Sub1_Sub1_Sub3_983.drawImage(42, 0);
            }
            if (this.anInt1285 === 8) {
              this.aClass50_Sub1_Sub1_Sub3_984.drawImage(74, 0);
            }
            if (this.anInt1285 === 9) {
              this.aClass50_Sub1_Sub1_Sub3_984.drawImage(102, 0);
            }
            if (this.anInt1285 === 10) {
              this.aClass50_Sub1_Sub1_Sub3_985.drawImage(130, 1);
            }
            if (this.anInt1285 === 11) {
              this.aClass50_Sub1_Sub1_Sub3_987.drawImage(173, 0);
            }
            if (this.anInt1285 === 12) {
              this.aClass50_Sub1_Sub1_Sub3_987.drawImage(201, 0);
            }
            if (this.anInt1285 === 13) {
              this.aClass50_Sub1_Sub1_Sub3_986.drawImage(229, 0);
            }
          }
          if (this.anIntArray1081[8] !== -1 && (this.anInt1213 !== 8 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[7].drawImage(74, 2);
          }
          if (this.anIntArray1081[9] !== -1 && (this.anInt1213 !== 9 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[8].drawImage(102, 3);
          }
          if (this.anIntArray1081[10] !== -1 && (this.anInt1213 !== 10 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[9].drawImage(137, 4);
          }
          if (this.anIntArray1081[11] !== -1 && (this.anInt1213 !== 11 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[10].drawImage(174, 2);
          }
          if (this.anIntArray1081[12] !== -1 && (this.anInt1213 !== 12 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[11].drawImage(201, 2);
          }
          if (this.anIntArray1081[13] !== -1 && (this.anInt1213 !== 13 || _Game.pulseCycle % 20 < 10)) {
            this.tabIcon[12].drawImage(226, 2);
          }
        }
        this.aClass18_1109.drawGraphics(496, 466, this.gameGraphics);
        this.aClass18_1158.createRasterizer();
        Rasterizer3D.lineOffsets = this.anIntArray1002;
      }
      if (this.aBoolean1212) {
        this.aBoolean1212 = false;
        this.aClass18_1108.createRasterizer();
        this.anIndexedImage1052.drawImage(0, 0);
        this.fontNormal.drawStringCenter("Public chat", 55, 28, 16777215, true);
        if (this.publicChatMode === 0) {
          this.fontNormal.drawStringCenter("On", 55, 41, 65280, true);
        }
        if (this.publicChatMode === 1) {
          this.fontNormal.drawStringCenter("Friends", 55, 41, 16776960, true);
        }
        if (this.publicChatMode === 2) {
          this.fontNormal.drawStringCenter("Off", 55, 41, 16711680, true);
        }
        if (this.publicChatMode === 3) {
          this.fontNormal.drawStringCenter("Hide", 55, 41, 65535, true);
        }
        this.fontNormal.drawStringCenter("Private chat", 184, 28, 16777215, true);
        if (this.privateChatMode === 0) {
          this.fontNormal.drawStringCenter("On", 184, 41, 65280, true);
        }
        if (this.privateChatMode === 1) {
          this.fontNormal.drawStringCenter("Friends", 184, 41, 16776960, true);
        }
        if (this.privateChatMode === 2) {
          this.fontNormal.drawStringCenter("Off", 184, 41, 16711680, true);
        }
        this.fontNormal.drawStringCenter("Trade/compete", 324, 28, 16777215, true);
        if (this.tradeMode === 0) {
          this.fontNormal.drawStringCenter("On", 324, 41, 65280, true);
        }
        if (this.tradeMode === 1) {
          this.fontNormal.drawStringCenter("Friends", 324, 41, 16776960, true);
        }
        if (this.tradeMode === 2) {
          this.fontNormal.drawStringCenter("Off", 324, 41, 16711680, true);
        }
        this.fontNormal.drawStringCenter("Report abuse", 458, 33, 16777215, true);
        this.aClass18_1108.drawGraphics(0, 453, this.gameGraphics);
        this.aClass18_1158.createRasterizer();
        Rasterizer3D.lineOffsets = this.anIntArray1002;
      }
      this.tickDelta = 0;
    }
    renderMinimap() {
      this.aClass18_1157.createRasterizer();
      if (this.minimapState === 2) {
        const mmBackgroundPixels = this.minimapBackgroundImage.pixels;
        const rasterPixels = Rasterizer.pixels;
        const pixelCount = mmBackgroundPixels.length;
        for (let i = 0; i < pixelCount; i++) {
          if (mmBackgroundPixels[i] === 0) {
            rasterPixels[i] = 0;
          }
        }
        this.minimapCompass.shapeImageToPixels$int$int$int$int$int_A$int$int$int$int_A$int(
          0,
          33,
          25,
          33,
          this.anIntArray1286,
          0,
          this.cameraHorizontal,
          256,
          this.anIntArray1180,
          25
        );
        this.aClass18_1158.createRasterizer();
        Rasterizer3D.lineOffsets = this.anIntArray1002;
        return;
      }
      const angle = this.cameraHorizontal + this.anInt916 & 2047;
      const centerX = 48 + (_Game.localPlayer.worldX / 32 | 0);
      const centerY = 464 - (_Game.localPlayer.worldY / 32 | 0);
      this.minimapImage.shapeImageToPixels$int$int$int$int$int_A$int$int$int$int_A$int(
        5,
        151,
        centerX,
        146,
        this.anIntArray920,
        25,
        angle,
        256 + this.anInt1233,
        this.anIntArray1019,
        centerY
      );
      this.minimapCompass.shapeImageToPixels$int$int$int$int$int_A$int$int$int$int_A$int(
        0,
        33,
        25,
        33,
        this.anIntArray1286,
        0,
        this.cameraHorizontal,
        256,
        this.anIntArray1180,
        25
      );
      for (let i = 0; i < this.minimapHintCount; i++) {
        {
          const hintX = this.minimapHintX[i] * 4 + 2 - (_Game.localPlayer.worldX / 32 | 0);
          const hintY = this.minimapHintY[i] * 4 + 2 - (_Game.localPlayer.worldY / 32 | 0);
          this.drawOnMinimap(this.minimapHint[i], hintX, hintY);
        }
      }
      for (let x2 = 0; x2 < 104; x2++) {
        {
          for (let y = 0; y < 104; y++) {
            {
              const itemList = this.groundItems[this.plane][x2][y];
              if (itemList != null) {
                const itemX = x2 * 4 + 2 - (_Game.localPlayer.worldX / 32 | 0);
                const itemY = y * 4 + 2 - (_Game.localPlayer.worldY / 32 | 0);
                this.drawOnMinimap(this.mapdotItem, itemX, itemY);
              }
            }
          }
        }
      }
      for (let i = 0; i < this.anInt1133; i++) {
        {
          const npc = this.npcs[this.anIntArray1134[i]];
          if (npc != null && npc.isVisible()) {
            let definition = npc.npcDefinition;
            if (definition.childrenIds != null) {
              definition = definition.getChildDefinition();
            }
            if (definition != null && definition.minimapVisible && definition.clickable) {
              const npcX = (npc.worldX / 32 | 0) - (_Game.localPlayer.worldX / 32 | 0);
              const npcY = (npc.worldY / 32 | 0) - (_Game.localPlayer.worldY / 32 | 0);
              this.drawOnMinimap(this.mapdotActor, npcX, npcY);
            }
          }
        }
      }
      for (let i = 0; i < this.localPlayerCount; i++) {
        {
          const player2 = this.players[this.playerList[i]];
          if (player2 != null && player2.isVisible()) {
            const playerX = (player2.worldX / 32 | 0) - (_Game.localPlayer.worldX / 32 | 0);
            const playerY = (player2.worldY / 32 | 0) - (_Game.localPlayer.worldY / 32 | 0);
            const name = TextUtils.nameToLong(player2.playerName);
            let isFriend = false;
            let isTeammate = false;
            for (let x2 = 0; x2 < this.friendsCount; x2++) {
              {
                if (!name.eq(this.friends[x2]) || this.friendWorlds[x2] === 0) {
                  continue;
                }
                isFriend = true;
                break;
              }
            }
            if (_Game.localPlayer.teamId !== 0 && player2.teamId !== 0 && _Game.localPlayer.teamId === player2.teamId) {
              isTeammate = true;
            }
            if (isFriend) {
              this.drawOnMinimap(this.mapdotFriend, playerX, playerY);
            } else if (isTeammate) {
              this.drawOnMinimap(this.mapdotTeammate, playerX, playerY);
            } else {
              this.drawOnMinimap(this.mapdotPlayer, playerX, playerY);
            }
          }
        }
      }
      if (this.anInt1197 !== 0 && _Game.pulseCycle % 20 < 10) {
        if (this.anInt1197 === 1 && this.anInt1226 >= 0 && this.anInt1226 < this.npcs.length) {
          const npc = this.npcs[this.anInt1226];
          if (npc != null) {
            const npcX = (npc.worldX / 32 | 0) - (_Game.localPlayer.worldX / 32 | 0);
            const npcY = (npc.worldY / 32 | 0) - (_Game.localPlayer.worldY / 32 | 0);
            this.drawMinimap(this.aClass50_Sub1_Sub1_Sub1_1037, npcX, npcY);
          }
        }
        if (this.anInt1197 === 2) {
          const hintX = (this.anInt844 - this.nextTopLeftTileX) * 4 + 2 - (_Game.localPlayer.worldX / 32 | 0);
          const hintY = (this.anInt845 - this.nextTopRightTileY) * 4 + 2 - (_Game.localPlayer.worldY / 32 | 0);
          this.drawMinimap(this.aClass50_Sub1_Sub1_Sub1_1037, hintX, hintY);
        }
        if (this.anInt1197 === 10 && this.anInt1151 >= 0 && this.anInt1151 < this.players.length) {
          const player2 = this.players[this.anInt1151];
          if (player2 != null) {
            const playerX = (player2.worldX / 32 | 0) - (_Game.localPlayer.worldX / 32 | 0);
            const playerY = (player2.worldY / 32 | 0) - (_Game.localPlayer.worldY / 32 | 0);
            this.drawMinimap(this.aClass50_Sub1_Sub1_Sub1_1037, playerX, playerY);
          }
        }
      }
      if (this.destinationX !== 0) {
        const flagX = this.destinationX * 4 + 2 - (_Game.localPlayer.worldX / 32 | 0);
        const flagY = this.destinationY * 4 + 2 - (_Game.localPlayer.worldY / 32 | 0);
        this.drawOnMinimap(this.mapFlagMarker, flagX, flagY);
      }
      Rasterizer.drawFilledRectangle(97, 78, 3, 3, 16777215);
      this.aClass18_1158.createRasterizer();
      Rasterizer3D.lineOffsets = this.anIntArray1002;
    }
    drawMinimap(sprite, x2, y) {
      const r2 = x2 * x2 + y * y;
      if (r2 > 4225 && r2 < 9e4) {
        const theta = this.cameraHorizontal + this.anInt916 & 2047;
        let sin = Model.SINE[theta];
        let cos = Model.COSINE[theta];
        sin = sin * 256 / (this.anInt1233 + 256) | 0;
        cos = cos * 256 / (this.anInt1233 + 256) | 0;
        const l1 = y * sin + x2 * cos >> 16;
        const i2 = y * cos - x2 * sin >> 16;
        const d = Math.atan2(l1, i2);
        const j2 = Math.sin(d) * 63 | 0;
        const k2 = Math.cos(d) * 57 | 0;
        this.minimapEdge.method466(256, 15, 94 + j2 + 4 - 10, 15, 20, this.anInt1119, 20, d, 83 - k2 - 20);
        return;
      } else {
        this.drawOnMinimap(sprite, x2, y);
        return;
      }
    }
    drawOnMinimap(sprite, x2, y) {
      if (sprite == null) {
        return;
      }
      const k = this.cameraHorizontal + this.anInt916 & 2047;
      const l = x2 * x2 + y * y;
      if (l > 6400) {
        return;
      }
      let i1 = Model.SINE[k];
      let j1 = Model.COSINE[k];
      i1 = i1 * 256 / (this.anInt1233 + 256) | 0;
      j1 = j1 * 256 / (this.anInt1233 + 256) | 0;
      const k1 = y * i1 + x2 * j1 >> 16;
      const l1 = y * j1 - x2 * i1 >> 16;
      if (l > 2500) {
        sprite.method467(
          this.minimapBackgroundImage,
          83 - l1 - (sprite.maxHeight / 2 | 0) - 4,
          -49993,
          94 + k1 - (sprite.maxWidth / 2 | 0) + 4
        );
        return;
      } else {
        sprite.drawImage(83 - l1 - (sprite.maxHeight / 2 | 0) - 4, 94 + k1 - (sprite.maxWidth / 2 | 0) + 4);
        return;
      }
    }
    renderChatbox() {
      this.chatboxProducingGraphicsBuffer.createRasterizer();
      Rasterizer3D.lineOffsets = this.chatboxLineOffsets;
      this.chatboxBackgroundImage.drawImage(0, 0);
      if (this.messagePromptRaised) {
        console.log("this.messagePromptRaised");
        this.fontBold.drawStringLeft(this.chatboxInputMessage, 239, 40, 0);
        this.fontBold.drawStringLeft(this.chatMessage + "*", 239, 60, 128);
      } else if (this.inputType === 1) {
        this.fontBold.drawStringLeft("Enter amount:", 239, 40, 0);
        this.fontBold.drawStringLeft(this.inputInputMessage + "*", 239, 60, 128);
      } else if (this.inputType === 2) {
        this.fontBold.drawStringLeft("Enter name:", 239, 40, 0);
        this.fontBold.drawStringLeft(this.inputInputMessage + "*", 239, 60, 128);
      } else if (this.inputType === 3) {
        if (!((o1, o2) => {
          if (o1 && o1.equals) {
            return o1.equals(o2);
          } else {
            return o1 === o2;
          }
        })(this.inputInputMessage, this.aString861)) {
          this.method14(this.inputInputMessage, 2);
          this.aString861 = this.inputInputMessage;
        }
        const typeFace = this.fontNormal;
        Rasterizer.setCoordinates(0, 0, 77, 463);
        for (let i = 0; i < this.anInt862; i++) {
          {
            const y = 18 + i * 14 - this.anInt865;
            if (y > 0 && y < 110) {
              typeFace.drawStringLeft(this.aStringArray863[i], 239, y, 0);
            }
          }
        }
        Rasterizer.resetCoordinates();
        if (this.anInt862 > 5) {
          this.method56(true, this.anInt865, 463, 77, this.anInt862 * 14 + 7, 0);
        }
        if (this.inputInputMessage.length === 0) {
          this.fontBold.drawStringLeft("Enter object name", 239, 40, 255);
        } else if (this.anInt862 === 0) {
          this.fontBold.drawStringLeft("No matching objects found, please shorten search", 239, 40, 0);
        }
        typeFace.drawStringLeft(this.inputInputMessage + "*", 239, 90, 0);
        Rasterizer.drawHorizontalLine(0, 77, 479, 0);
      } else if (this.clickToContinueString != null) {
        this.fontBold.drawStringLeft(this.clickToContinueString, 239, 40, 0);
        this.fontBold.drawStringLeft("Click to continue", 239, 60, 128);
      } else if (this.backDialogueId !== -1) {
        this.method142(0, 0, Widget.forId(this.backDialogueId), 0, 8);
      } else if (this.dialogueId !== -1) {
        this.method142(0, 0, Widget.forId(this.dialogueId), 0, 8);
      } else {
        const typeFace = this.fontNormal;
        let line = 0;
        Rasterizer.setCoordinates(0, 0, 77, 463);
        for (let i = 0; i < 100; i++) {
          {
            if (this.chatMessages[i] != null) {
              let name2 = this.chatPlayerNames[i];
              const type = this.chatTypes[i];
              const y = 70 - line * 14 + this.anInt851;
              let privilege = 0;
              if (name2 != null && ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name2, "@cr1@")) {
                name2 = name2.substring(5);
                privilege = 1;
              }
              if (name2 != null && ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name2, "@cr2@")) {
                name2 = name2.substring(5);
                privilege = 2;
              }
              if (type === 0) {
                if (y > 0 && y < 110) {
                  typeFace.drawString(this.chatMessages[i], 4, y, 0);
                }
                line++;
              }
              if ((type === 1 || type === 2) && (type === 1 || this.publicChatMode === 0 || this.publicChatMode === 1 && this.method148(13292, name2))) {
                if (y > 0 && y < 110) {
                  let x2 = 4;
                  if (privilege === 1) {
                    this.moderatorIcon[0].drawImage(x2, y - 12);
                    x2 += 14;
                  }
                  if (privilege === 2) {
                    this.moderatorIcon[1].drawImage(x2, y - 12);
                    x2 += 14;
                  }
                  typeFace.drawString(name2 + ":", x2, y, 0);
                  x2 += typeFace.getStringEffectWidth(name2) + 8;
                  typeFace.drawString(this.chatMessages[i], x2, y, 255);
                }
                line++;
              }
              if ((type === 3 || type === 7) && this.anInt1223 === 0 && (type === 7 || this.privateChatMode === 0 || this.privateChatMode === 1 && this.method148(13292, name2))) {
                if (y > 0 && y < 110) {
                  let x2 = 4;
                  typeFace.drawString("From", x2, y, 0);
                  x2 += typeFace.getStringEffectWidth("From ");
                  if (privilege === 1) {
                    this.moderatorIcon[0].drawImage(x2, y - 12);
                    x2 += 14;
                  }
                  if (privilege === 2) {
                    this.moderatorIcon[1].drawImage(x2, y - 12);
                    x2 += 14;
                  }
                  typeFace.drawString(name2 + ":", x2, y, 0);
                  x2 += typeFace.getStringEffectWidth(name2) + 8;
                  typeFace.drawString(this.chatMessages[i], x2, y, 8388608);
                }
                line++;
              }
              if (type === 4 && (this.tradeMode === 0 || this.tradeMode === 1 && this.method148(13292, name2))) {
                if (y > 0 && y < 110) {
                  typeFace.drawString(name2 + " " + this.chatMessages[i], 4, y, 8388736);
                }
                line++;
              }
              if (type === 5 && this.anInt1223 === 0 && this.privateChatMode < 2) {
                if (y > 0 && y < 110) {
                  typeFace.drawString(this.chatMessages[i], 4, y, 8388608);
                }
                line++;
              }
              if (type === 6 && this.anInt1223 === 0 && this.privateChatMode < 2) {
                if (y > 0 && y < 110) {
                  typeFace.drawString("To " + name2 + ":", 4, y, 0);
                  typeFace.drawString(this.chatMessages[i], 12 + typeFace.getStringEffectWidth("To " + name2), y, 8388608);
                }
                line++;
              }
              if (type === 8 && (this.tradeMode === 0 || this.tradeMode === 1 && this.method148(13292, name2))) {
                if (y > 0 && y < 110) {
                  typeFace.drawString(name2 + " " + this.chatMessages[i], 4, y, 8270336);
                }
                line++;
              }
            }
          }
        }
        Rasterizer.resetCoordinates();
        this.anInt1107 = line * 14 + 7;
        if (this.anInt1107 < 78) {
          this.anInt1107 = 78;
        }
        this.method56(true, this.anInt1107 - this.anInt851 - 77, 463, 77, this.anInt1107, 0);
        let name;
        if (_Game.localPlayer != null && _Game.localPlayer.playerName != null) {
          name = _Game.localPlayer.playerName;
        } else {
          name = TextUtils.formatName(this.username);
        }
        typeFace.drawString(name + ":", 4, 90, 0);
        typeFace.drawString(this.chatboxInput + "*", 6 + typeFace.getStringEffectWidth(name + ": "), 90, 255);
        Rasterizer.drawHorizontalLine(0, 77, 479, 0);
      }
      if (this.menuOpen && this.anInt1304 === 2) {
        this.method128(false);
      }
      this.chatboxProducingGraphicsBuffer.drawGraphics(17, 357, this.gameGraphics);
      this.aClass18_1158.createRasterizer();
      Rasterizer3D.lineOffsets = this.anIntArray1002;
    }
    method14(s, i) {
      if (s == null || s.length === 0) {
        this.anInt862 = 0;
        return;
      }
      let s1 = s;
      const as = ((s2) => {
        const a = [];
        while (s2-- > 0) {
          a.push(null);
        }
        return a;
      })(100);
      let j = 0;
      do {
        {
          const k = s1.indexOf(" ");
          if (k === -1) {
            break;
          }
          const s2 = s1.substring(0, k).trim();
          if (s2.length > 0) {
            as[j++] = s2.toLowerCase();
          }
          s1 = s1.substring(k + 1);
        }
      } while (true);
      s1 = s1.trim();
      if (s1.length > 0) {
        as[j++] = s1.toLowerCase();
      }
      this.anInt862 = 0;
      if (i !== 2) {
        this.aBoolean959 = !this.aBoolean959;
      }
      label0:
        for (let l = 0; l < ItemDefinition.count; l++) {
          {
            const class16 = ItemDefinition.lookup(l);
            if (class16.notedTemplateId !== -1 || class16.name == null) {
              continue;
            }
            const s3 = class16.name.toLowerCase();
            for (let i1 = 0; i1 < j; i1++) {
              if (s3.indexOf(as[i1]) === -1) {
                continue label0;
              }
            }
            this.aStringArray863[this.anInt862] = s3;
            this.anIntArray864[this.anInt862] = l;
            this.anInt862++;
            if (this.anInt862 >= this.aStringArray863.length) {
              return;
            }
          }
        }
    }
    redrawTabs() {
      this.aClass18_1156.createRasterizer();
      Rasterizer3D.lineOffsets = this.anIntArray1001;
      this.inventoryBackgroundImage.drawImage(0, 0);
      if (this.anInt1089 !== -1) {
        this.method142(0, 0, Widget.forId(this.anInt1089), 0, 8);
      } else if (this.anIntArray1081[this.anInt1285] !== -1) {
        this.method142(0, 0, Widget.forId(this.anIntArray1081[this.anInt1285]), 0, 8);
      }
      if (this.menuOpen && this.anInt1304 === 1) {
        this.method128(false);
      }
      this.aClass18_1156.drawGraphics(553, 205, this.gameGraphics);
      this.aClass18_1158.createRasterizer();
      Rasterizer3D.lineOffsets = this.anIntArray1002;
    }
    drawGameView() {
      this.anInt1138++;
      this.processPlayerAdditions(true);
      this.method57(true);
      this.processPlayerAdditions(false);
      this.method57(false);
      this.method51(false);
      this.method76(-992);
      if (!this.oriented) {
        let j = this.anInt1251;
        if ((this.anInt1289 / 256 | 0) > j) {
          j = this.anInt1289 / 256 | 0;
        }
        if (this.aBooleanArray927[4] && this.anIntArray852[4] + 128 > j) {
          j = this.anIntArray852[4] + 128;
        }
        const l = this.cameraHorizontal + this.anInt1255 & 2047;
        this.setCameraPosition(
          this.anInt1262,
          this.anInt1263,
          this.getTileHeight(_Game.localPlayer.worldY, _Game.localPlayer.worldX, 9 | 0, this.plane) - 50,
          j,
          l
        );
      }
      let k;
      if (!this.oriented) {
        k = this.method117(1 | 0);
      } else {
        k = this.method118(-276);
      }
      const i1 = this.cameraX;
      const j1 = this.cameraZ;
      const k1 = this.cameraY;
      const l1 = this.cameraPitch;
      const i2 = this.cameraYaw;
      for (let j2 = 0; j2 < 5; j2++) {
        if (this.aBooleanArray927[j2]) {
          const k2 = Math.random() * (this.anIntArray1105[j2] * 2 + 1) - this.anIntArray1105[j2] + Math.sin(this.quakeTimes[j2] * (this.anIntArray991[j2] / 100)) * this.anIntArray852[j2] | 0;
          if (j2 === 0) {
            this.cameraX += k2;
          }
          if (j2 === 1) {
            this.cameraZ += k2;
          }
          if (j2 === 2) {
            this.cameraY += k2;
          }
          if (j2 === 3) {
            this.cameraYaw = this.cameraYaw + k2 & 2047;
          }
          if (j2 === 4) {
            this.cameraPitch += k2;
            if (this.cameraPitch < 128) {
              this.cameraPitch = 128;
            }
            if (this.cameraPitch > 383) {
              this.cameraPitch = 383;
            }
          }
        }
      }
      const l2 = Rasterizer3D.anInt1547;
      Model.aBoolean1705 = true;
      Model.anInt1708 = 0;
      Model.anInt1706 = this.mouseX - 4;
      Model.anInt1707 = this.mouseY - 4;
      Rasterizer.resetPixels();
      this.currentScene.method280(this.cameraX, k, 0, this.cameraZ, this.cameraY, this.cameraYaw, this.cameraPitch);
      this.currentScene.method255();
      this.method121(false);
      this.method127(true);
      this.method65(l2);
      this.renderGameView();
      this.aClass18_1158.drawGraphics(4, 4, this.gameGraphics);
      this.cameraX = i1;
      this.cameraZ = j1;
      this.cameraY = k1;
      this.cameraPitch = l1;
      this.cameraYaw = i2;
    }
    renderGameView() {
      this.renderSplitPrivateMessages();
      if (this.crossType === 1) {
        this.cursorCross[this.crossIndex / 100 | 0].drawImage(this.anInt1021 - 8 - 4, this.anInt1020 - 8 - 4);
      }
      if (this.crossType === 2) {
        this.cursorCross[4 + (this.crossIndex / 100 | 0)].drawImage(this.anInt1021 - 8 - 4, this.anInt1020 - 8 - 4);
      }
      if (this.anInt1279 !== -1) {
        this.method88(this.tickDelta, this.anInt1279, 5 | 0);
        this.method142(0, 0, Widget.forId(this.anInt1279), 0, 8);
      }
      if (this.openInterfaceId !== -1) {
        this.method88(this.tickDelta, this.openInterfaceId, 5 | 0);
        this.method142(0, 0, Widget.forId(this.openInterfaceId), 0, 8);
      }
      this.setTutorialIslandFlag();
      if (!this.menuOpen) {
        this.processRightClick(-521);
        this.drawMenuTooltip();
      } else if (this.anInt1304 === 0) {
        this.method128(false);
      }
      if (this.anInt1319 === 1) {
        this.aClass50_Sub1_Sub1_Sub1_1086.drawImage(296, 472);
      }
      if (_Game.fps) {
        let y = 20;
        let colour = 16776960;
        if (this.fps < 30 && _Game.lowMemory) {
          colour = 16711680;
        }
        if (this.fps < 20 && !_Game.lowMemory) {
          colour = 16711680;
        }
        this.fontNormal.drawStringRight("Fps:" + this.fps, 507, y, colour);
        y += 15;
        const memoryUsed = 1337;
        colour = 16776960;
        if (memoryUsed > 33554432 && _Game.lowMemory) {
          colour = 16711680;
        }
        if (memoryUsed > 67108864 && !_Game.lowMemory) {
          colour = 16711680;
        }
        this.fontNormal.drawStringRight("Mem:" + memoryUsed + "k", 507, y, colour);
      }
      if (this.systemUpdateTime !== 0) {
        let seconds = this.systemUpdateTime / 50 | 0;
        const minutes = seconds / 60 | 0;
        seconds %= 60;
        if (seconds < 10) {
          this.fontNormal.drawString("System update in: " + minutes + ":0" + seconds, 4, 329, 16776960);
        } else {
          this.fontNormal.drawString("System update in: " + minutes + ":" + seconds, 4, 329, 16776960);
        }
        _Game.anInt895++;
        if (_Game.anInt895 > 112) {
          _Game.anInt895 = 0;
          this.outBuffer.putOpcode(197);
          this.outBuffer.putInt(0);
        }
      }
    }
    method128(flag) {
      if (flag) {
        this.outBuffer.putByte(23);
      }
      const i = this.menuClickX;
      const j = this.menuClickY;
      const k = this.anInt1307;
      const l = this.anInt1308;
      const i1 = 6116423;
      Rasterizer.drawFilledRectangle(i, j, k, l, i1);
      Rasterizer.drawFilledRectangle(i + 1, j + 1, k - 2, 16, 0);
      Rasterizer.drawUnfilledRectangle(i + 1, j + 18, k - 2, l - 19, 0);
      this.fontBold.drawString("Choose Option", i + 3, j + 14, i1);
      let j1 = this.mouseX;
      let k1 = this.mouseY;
      if (this.anInt1304 === 0) {
        j1 -= 4;
        k1 -= 4;
      }
      if (this.anInt1304 === 1) {
        j1 -= 553;
        k1 -= 205;
      }
      if (this.anInt1304 === 2) {
        j1 -= 17;
        k1 -= 357;
      }
      for (let l1 = 0; l1 < this.menuActionRow; l1++) {
        {
          const i2 = j + 31 + (this.menuActionRow - 1 - l1) * 15;
          let j2 = 16777215;
          if (j1 > i && j1 < i + k && k1 > i2 - 13 && k1 < i2 + 3) {
            j2 = 16776960;
          }
          this.fontBold.drawShadowedString(this.menuActionTexts[l1], i + 3, i2, true, j2);
        }
      }
    }
    setTutorialIslandFlag() {
      const x2 = (_Game.localPlayer.worldX >> 7) + this.nextTopLeftTileX;
      const y = (_Game.localPlayer.worldY >> 7) + this.nextTopRightTileY;
      this.inTutorialIsland = false;
      if (x2 >= 3053 && x2 <= 3156 && y >= 3056 && y <= 3136) {
        this.inTutorialIsland = true;
      }
      if (x2 >= 3072 && x2 <= 3118 && y >= 9492 && y <= 9535) {
        this.inTutorialIsland = true;
      }
      if (this.inTutorialIsland && x2 >= 3139 && x2 <= 3199 && y >= 3008 && y <= 3062) {
        this.inTutorialIsland = false;
      }
    }
    renderSplitPrivateMessages() {
      if (this.anInt1223 === 0) {
        return;
      }
      const typeFace = this.fontNormal;
      let line = 0;
      if (this.systemUpdateTime !== 0) {
        line = 1;
      }
      for (let i = 0; i < 100; i++) {
        {
          if (this.chatMessages[i] != null) {
            const type = this.chatTypes[i];
            let name = this.chatPlayerNames[i];
            let privilege = 0;
            if (name != null && ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(
              name,
              "@cr1@"
            )) {
              name = name.substring(5);
              privilege = 1;
            }
            if (name != null && ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(
              name,
              "@cr2@"
            )) {
              name = name.substring(5);
              privilege = 2;
            }
            if ((type === 3 || type === 7) && (type === 7 || this.privateChatMode === 0 || this.privateChatMode === 1 && this.method148(13292, name))) {
              const y = 329 - line * 13;
              let x2 = 4;
              typeFace.drawString("From", x2, y, 0);
              typeFace.drawString("From", x2, y - 1, 65535);
              x2 += typeFace.getStringEffectWidth("From ");
              if (privilege === 1) {
                this.moderatorIcon[0].drawImage(x2, y - 12);
                x2 += 14;
              }
              if (privilege === 2) {
                this.moderatorIcon[1].drawImage(x2, y - 12);
                x2 += 14;
              }
              typeFace.drawString(name + ": " + this.chatMessages[i], x2, y, 0);
              typeFace.drawString(name + ": " + this.chatMessages[i], x2, y - 1, 65535);
              if (++line >= 5) {
                return;
              }
            }
            if (type === 5 && this.privateChatMode < 2) {
              const y = 329 - line * 13;
              typeFace.drawString(this.chatMessages[i], 4, y, 0);
              typeFace.drawString(this.chatMessages[i], 4, y - 1, 65535);
              if (++line >= 5) {
                return;
              }
            }
            if (type === 6 && this.privateChatMode < 2) {
              const y = 329 - line * 13;
              typeFace.drawString("To " + name + ": " + this.chatMessages[i], 4, y, 0);
              typeFace.drawString("To " + name + ": " + this.chatMessages[i], 4, y - 1, 65535);
              if (++line >= 5) {
                return;
              }
            }
          }
        }
      }
    }
    method118(i) {
      const j = this.getTileHeight(this.cameraY, this.cameraX, 9 | 0, this.plane);
      while (i >= 0) {
        this.opcode = this.buffer.getUnsignedByte();
      }
      if (j - this.cameraZ < 800 && (this.currentSceneTileFlags[this.plane][this.cameraX >> 7][this.cameraY >> 7] & 4) !== 0) {
        return this.plane;
      } else {
        return 3;
      }
    }
    method117(byte0) {
      let i = 3;
      if (byte0 === this.aByte956) {
        byte0 = 0;
      } else {
        this.startUp();
      }
      if (this.cameraPitch < 310) {
        _Game.anInt978++;
        if (_Game.anInt978 > 1457) {
          _Game.anInt978 = 0;
          this.outBuffer.putOpcode(244);
          this.outBuffer.putByte(0);
          const j = this.outBuffer.currentPosition;
          this.outBuffer.putByte(219);
          this.outBuffer.putShort(37745);
          this.outBuffer.putByte(61);
          this.outBuffer.putShort(43756);
          this.outBuffer.putShort(Math.random() * 65536 | 0);
          this.outBuffer.putByte(Math.random() * 256 | 0);
          this.outBuffer.putShort(51171);
          if ((Math.random() * 2 | 0) === 0) {
            this.outBuffer.putShort(15808);
          }
          this.outBuffer.putByte(97);
          this.outBuffer.putByte(Math.random() * 256 | 0);
          this.outBuffer.putLength(this.outBuffer.currentPosition - j);
        }
        let k = this.cameraX >> 7;
        let l = this.cameraY >> 7;
        const i1 = _Game.localPlayer.worldX >> 7;
        const j1 = _Game.localPlayer.worldY >> 7;
        if ((this.currentSceneTileFlags[this.plane][k][l] & 4) !== 0) {
          i = this.plane;
        }
        let k1;
        if (i1 > k) {
          k1 = i1 - k;
        } else {
          k1 = k - i1;
        }
        let l1;
        if (j1 > l) {
          l1 = j1 - l;
        } else {
          l1 = l - j1;
        }
        if (k1 > l1) {
          const i2 = l1 * 65536 / k1 | 0;
          let k2 = 32768;
          while (k !== i1) {
            {
              if (k < i1) {
                k++;
              } else if (k > i1) {
                k--;
              }
              if ((this.currentSceneTileFlags[this.plane][k][l] & 4) !== 0) {
                i = this.plane;
              }
              k2 += i2;
              if (k2 >= 65536) {
                k2 -= 65536;
                if (l < j1) {
                  l++;
                } else if (l > j1) {
                  l--;
                }
                if ((this.currentSceneTileFlags[this.plane][k][l] & 4) !== 0) {
                  i = this.plane;
                }
              }
            }
          }
        } else {
          const j2 = k1 * 65536 / l1 | 0;
          let l2 = 32768;
          while (l !== j1) {
            {
              if (l < j1) {
                l++;
              } else if (l > j1) {
                l--;
              }
              if ((this.currentSceneTileFlags[this.plane][k][l] & 4) !== 0) {
                i = this.plane;
              }
              l2 += j2;
              if (l2 >= 65536) {
                l2 -= 65536;
                if (k < i1) {
                  k++;
                } else if (k > i1) {
                  k--;
                }
                if ((this.currentSceneTileFlags[this.plane][k][l] & 4) !== 0) {
                  i = this.plane;
                }
              }
            }
          }
        }
      }
      if ((this.currentSceneTileFlags[this.plane][_Game.localPlayer.worldX >> 7][_Game.localPlayer.worldY >> 7] & 4) !== 0) {
        i = this.plane;
      }
      return i;
    }
    setCameraPosition(x2, y, z, pitch, yaw) {
      const pitchDifference = 2048 - pitch & 2047;
      const yawDifference = 2048 - yaw & 2047;
      let xOffset = 0;
      let zOffset = 0;
      let yOffset = 600 + pitch * 3;
      if (pitchDifference !== 0) {
        const sine = Model.SINE[pitchDifference];
        const cosine = Model.COSINE[pitchDifference];
        const temp = zOffset * cosine - yOffset * sine >> 16;
        yOffset = zOffset * sine + yOffset * cosine >> 16;
        zOffset = temp;
      }
      if (yawDifference !== 0) {
        const sine = Model.SINE[yawDifference];
        const cosine = Model.COSINE[yawDifference];
        const temp = yOffset * sine + xOffset * cosine >> 16;
        yOffset = yOffset * cosine - xOffset * sine >> 16;
        xOffset = temp;
      }
      this.cameraX = x2 - xOffset;
      this.cameraZ = z - zOffset;
      this.cameraY = y - yOffset;
      this.cameraPitch = pitch;
      this.cameraYaw = yaw;
    }
    method76(i) {
      while (i >= 0) {
        this.groundItems = null;
      }
      for (let gameAnimableObject = this.aClass6_1210.first(); gameAnimableObject != null; gameAnimableObject = this.aClass6_1210.next()) {
        if (gameAnimableObject.plane !== this.plane || gameAnimableObject.transformCompleted) {
          gameAnimableObject.remove();
        } else if (_Game.pulseCycle >= gameAnimableObject.loopCycle) {
          gameAnimableObject.nextFrame(this.tickDelta);
          if (gameAnimableObject.transformCompleted) {
            gameAnimableObject.remove();
          } else {
            this.currentScene.addEntity(
              -1,
              gameAnimableObject,
              gameAnimableObject.x,
              gameAnimableObject.z,
              false,
              0,
              gameAnimableObject.plane,
              60,
              gameAnimableObject.y,
              0
            );
          }
        }
      }
    }
    method65(i) {
      if (!_Game.lowMemory) {
        for (let k = 0; k < this.anIntArray1290.length; k++) {
          {
            const l = this.anIntArray1290[k];
            if (Rasterizer3D.anIntArray1546[l] >= i) {
              const class50_sub1_sub1_sub3 = Rasterizer3D.aClass50_Sub1_Sub1_Sub3Array1540[l];
              const i1 = class50_sub1_sub1_sub3.width * class50_sub1_sub1_sub3.height - 1;
              const j1 = class50_sub1_sub1_sub3.width * this.tickDelta * 2;
              const abyte0 = class50_sub1_sub1_sub3.pixels;
              const abyte1 = this.aByteArray1245;
              for (let k1 = 0; k1 <= i1; k1++) {
                abyte1[k1] = abyte0[k1 - j1 & i1];
              }
              class50_sub1_sub1_sub3.pixels = abyte1;
              this.aByteArray1245 = abyte0;
              Rasterizer3D.method499(l, 9);
            }
          }
        }
      }
    }
    method127(flag) {
      if (!flag) {
        this.anInt1056 = this.incomingRandom.nextInt();
      }
      if (this.anInt1197 !== 2) {
        return;
      }
      this.worldToScreen(
        (this.anInt844 - this.nextTopLeftTileX << 7) + this.anInt847,
        this.anInt846 * 2,
        (this.anInt845 - this.nextTopRightTileY << 7) + this.anInt848
      );
      if (this.screenX > -1 && _Game.pulseCycle % 20 < 10) {
        this.headiconsHints[0].drawImage(this.screenY - 28, this.screenX - 12);
      }
    }
    method51(flag) {
      let class50_sub1_sub4_sub2 = this.aClass6_1282.first();
      if (flag) {
        this.anInt1328 = 153;
      }
      for (; class50_sub1_sub4_sub2 != null; class50_sub1_sub4_sub2 = this.aClass6_1282.next()) {
        if (class50_sub1_sub4_sub2.sceneId !== this.plane || _Game.pulseCycle > class50_sub1_sub4_sub2.endCycle) {
          class50_sub1_sub4_sub2.remove();
        } else if (_Game.pulseCycle >= class50_sub1_sub4_sub2.delay) {
          if (class50_sub1_sub4_sub2.targetedEntityId > 0) {
            const class50_sub1_sub4_sub3_sub1 = this.npcs[class50_sub1_sub4_sub2.targetedEntityId - 1];
            if (class50_sub1_sub4_sub3_sub1 != null && class50_sub1_sub4_sub3_sub1.worldX >= 0 && class50_sub1_sub4_sub3_sub1.worldX < 13312 && class50_sub1_sub4_sub3_sub1.worldY >= 0 && class50_sub1_sub4_sub3_sub1.worldY < 13312) {
              class50_sub1_sub4_sub2.trackTarget(
                class50_sub1_sub4_sub3_sub1.worldX,
                class50_sub1_sub4_sub3_sub1.worldY,
                this.getTileHeight(
                  class50_sub1_sub4_sub3_sub1.worldY,
                  class50_sub1_sub4_sub3_sub1.worldX,
                  9 | 0,
                  class50_sub1_sub4_sub2.sceneId
                ) - class50_sub1_sub4_sub2.endHeight,
                _Game.pulseCycle
              );
            }
          }
          if (class50_sub1_sub4_sub2.targetedEntityId < 0) {
            const i = -class50_sub1_sub4_sub2.targetedEntityId - 1;
            let class50_sub1_sub4_sub3_sub2;
            if (i === this.thisPlayerServerId) {
              class50_sub1_sub4_sub3_sub2 = _Game.localPlayer;
            } else {
              class50_sub1_sub4_sub3_sub2 = this.players[i];
            }
            if (class50_sub1_sub4_sub3_sub2 != null && class50_sub1_sub4_sub3_sub2.worldX >= 0 && class50_sub1_sub4_sub3_sub2.worldX < 13312 && class50_sub1_sub4_sub3_sub2.worldY >= 0 && class50_sub1_sub4_sub3_sub2.worldY < 13312) {
              class50_sub1_sub4_sub2.trackTarget(
                class50_sub1_sub4_sub3_sub2.worldX,
                class50_sub1_sub4_sub3_sub2.worldY,
                this.getTileHeight(
                  class50_sub1_sub4_sub3_sub2.worldY,
                  class50_sub1_sub4_sub3_sub2.worldX,
                  9 | 0,
                  class50_sub1_sub4_sub2.sceneId
                ) - class50_sub1_sub4_sub2.endHeight,
                _Game.pulseCycle
              );
            }
          }
          class50_sub1_sub4_sub2.move(this.tickDelta);
          this.currentScene.addEntity(
            -1,
            class50_sub1_sub4_sub2,
            class50_sub1_sub4_sub2.currentX | 0,
            class50_sub1_sub4_sub2.currentHeight | 0,
            false,
            0,
            this.plane,
            60,
            class50_sub1_sub4_sub2.currentY | 0,
            class50_sub1_sub4_sub2.anInt1562
          );
        }
      }
      _Game.anInt1168++;
      if (_Game.anInt1168 > 51) {
        _Game.anInt1168 = 0;
        this.outBuffer.putOpcode(248);
      }
    }
    method57(flag) {
      for (let j = 0; j < this.anInt1133; j++) {
        {
          const class50_sub1_sub4_sub3_sub1 = this.npcs[this.anIntArray1134[j]];
          let k = 536870912 + (this.anIntArray1134[j] << 14);
          if (class50_sub1_sub4_sub3_sub1 == null || !class50_sub1_sub4_sub3_sub1.isVisible() || class50_sub1_sub4_sub3_sub1.npcDefinition.visible !== flag || !class50_sub1_sub4_sub3_sub1.npcDefinition.method360()) {
            continue;
          }
          const l = class50_sub1_sub4_sub3_sub1.worldX >> 7;
          const i1 = class50_sub1_sub4_sub3_sub1.worldY >> 7;
          if (l < 0 || l >= 104 || i1 < 0 || i1 >= 104) {
            continue;
          }
          if (class50_sub1_sub4_sub3_sub1.boundaryDimension === 1 && (class50_sub1_sub4_sub3_sub1.worldX & 127) === 64 && (class50_sub1_sub4_sub3_sub1.worldY & 127) === 64) {
            if (this.anIntArrayArray886[l][i1] === this.anInt1138) {
              continue;
            }
            this.anIntArrayArray886[l][i1] = this.anInt1138;
          }
          if (!class50_sub1_sub4_sub3_sub1.npcDefinition.clickable) {
            k += 2147483648;
          }
          this.currentScene.addEntity(
            k,
            class50_sub1_sub4_sub3_sub1,
            class50_sub1_sub4_sub3_sub1.worldX,
            this.getTileHeight(class50_sub1_sub4_sub3_sub1.worldY, class50_sub1_sub4_sub3_sub1.worldX, 9 | 0, this.plane),
            class50_sub1_sub4_sub3_sub1.aBoolean1592,
            0,
            this.plane,
            (class50_sub1_sub4_sub3_sub1.boundaryDimension - 1) * 64 + 60,
            class50_sub1_sub4_sub3_sub1.worldY,
            class50_sub1_sub4_sub3_sub1.anInt1612
          );
        }
      }
    }
    method121(flag) {
      this.anInt939 = 0;
      for (let i = -1; i < this.localPlayerCount + this.anInt1133; i++) {
        {
          let obj;
          if (i === -1) {
            obj = _Game.localPlayer;
          } else if (i < this.localPlayerCount) {
            obj = this.players[this.playerList[i]];
          } else {
            obj = this.npcs[this.anIntArray1134[i - this.localPlayerCount]];
          }
          if (obj == null || !obj.isVisible()) {
            continue;
          }
          if (obj != null && obj instanceof Npc) {
            let class37 = obj.npcDefinition;
            if (class37.childrenIds != null) {
              class37 = class37.getChildDefinition();
            }
            if (class37 == null) {
              continue;
            }
          }
          if (i < this.localPlayerCount) {
            let k = 30;
            const player2 = obj;
            if (player2.skullIconId !== -1 || player2.prayerIconId !== -1) {
              this.actorWorldToScreen(obj, obj.modelHeight + 15);
              if (this.screenX > -1) {
                if (player2.skullIconId !== -1) {
                  this.headiconsPks[player2.skullIconId].drawImage(
                    this.screenY - k,
                    this.screenX - 12
                  );
                  k += 25;
                }
                if (player2.prayerIconId !== -1) {
                  this.headiconsPrayers[player2.prayerIconId].drawImage(
                    this.screenY - k,
                    this.screenX - 12
                  );
                  k += 25;
                }
              }
            }
            if (i >= 0 && this.anInt1197 === 10 && this.anInt1151 === this.playerList[i]) {
              this.actorWorldToScreen(obj, obj.modelHeight + 15);
              if (this.screenX > -1) {
                this.headiconsHints[1].drawImage(this.screenY - k, this.screenX - 12);
              }
            }
          } else {
            const actorDef = obj.npcDefinition;
            if (actorDef.headIcon >= 0 && actorDef.headIcon < this.headiconsPrayers.length) {
              this.actorWorldToScreen(obj, obj.modelHeight + 15);
              if (this.screenX > -1) {
                this.headiconsPrayers[actorDef.headIcon].drawImage(this.screenY - 30, this.screenX - 12);
              }
            }
            if (this.anInt1197 === 1 && this.anInt1226 === this.anIntArray1134[i - this.localPlayerCount] && _Game.pulseCycle % 20 < 10) {
              this.actorWorldToScreen(obj, obj.modelHeight + 15);
              if (this.screenX > -1) {
                this.headiconsHints[0].drawImage(this.screenY - 28, this.screenX - 12);
              }
            }
          }
          if (obj.forcedChat != null && (i >= this.localPlayerCount || this.publicChatMode === 0 || this.publicChatMode === 3 || this.publicChatMode === 1 && this.method148(13292, obj.playerName))) {
            this.actorWorldToScreen(obj, obj.modelHeight);
            if (this.screenX > -1 && this.anInt939 < this.anInt940) {
              this.anIntArray944[this.anInt939] = this.fontBold.getStringWidth(obj.forcedChat) / 2 | 0;
              this.anIntArray943[this.anInt939] = this.fontBold.characterDefaultHeight;
              this.anIntArray941[this.anInt939] = this.screenX;
              this.anIntArray942[this.anInt939] = this.screenY;
              this.anIntArray945[this.anInt939] = obj.textColour;
              this.anIntArray946[this.anInt939] = obj.textEffect;
              this.anIntArray947[this.anInt939] = obj.textCycle;
              this.aStringArray948[this.anInt939++] = obj.forcedChat;
              if (this.anInt998 === 0 && obj.textEffect >= 1 && obj.textEffect <= 3) {
                this.anIntArray943[this.anInt939] += 10;
                this.anIntArray942[this.anInt939] += 5;
              }
              if (this.anInt998 === 0 && obj.textEffect === 4) {
                this.anIntArray944[this.anInt939] = 60;
              }
              if (this.anInt998 === 0 && obj.textEffect === 5) {
                this.anIntArray943[this.anInt939] += 5;
              }
            }
          }
          if (obj.endCycle > _Game.pulseCycle) {
            this.actorWorldToScreen(obj, obj.modelHeight + 15);
            if (this.screenX > -1) {
              let l = obj.anInt1596 * 30 / obj.anInt1597 | 0;
              if (l > 30) {
                l = 30;
              }
              Rasterizer.drawFilledRectangle(this.screenX - 15, this.screenY - 3, l, 5, 65280);
              Rasterizer.drawFilledRectangle(this.screenX - 15 + l, this.screenY - 3, 30 - l, 5, 16711680);
            }
          }
          for (let i1 = 0; i1 < 4; i1++) {
            if (obj.hitCycles[i1] > _Game.pulseCycle) {
              this.actorWorldToScreen(obj, obj.modelHeight / 2 | 0);
              if (this.screenX > -1) {
                if (i1 === 1) {
                  this.screenY -= 20;
                }
                if (i1 === 2) {
                  this.screenX -= 15;
                  this.screenY -= 10;
                }
                if (i1 === 3) {
                  this.screenX += 15;
                  this.screenY -= 10;
                }
                this.hitmarks[obj.hitTypes[i1]].drawImage(
                  this.screenY - 12,
                  this.screenX - 12
                );
                this.fontSmall.drawStringLeft(
                  new String(obj.hitDamages[i1]).toString(),
                  this.screenX,
                  this.screenY + 4,
                  0
                );
                this.fontSmall.drawStringLeft(
                  new String(obj.hitDamages[i1]).toString(),
                  this.screenX - 1,
                  this.screenY + 3,
                  16777215
                );
              }
            }
          }
        }
      }
      for (let j = 0; j < this.anInt939; j++) {
        {
          const j1 = this.anIntArray941[j];
          let k1 = this.anIntArray942[j];
          const l1 = this.anIntArray944[j];
          const i2 = this.anIntArray943[j];
          let flag1 = true;
          while (flag1) {
            {
              flag1 = false;
              for (let j2 = 0; j2 < j; j2++) {
                if (k1 + 2 > this.anIntArray942[j2] - this.anIntArray943[j2] && k1 - i2 < this.anIntArray942[j2] + 2 && j1 - l1 < this.anIntArray941[j2] + this.anIntArray944[j2] && j1 + l1 > this.anIntArray941[j2] - this.anIntArray944[j2] && this.anIntArray942[j2] - this.anIntArray943[j2] < k1) {
                  k1 = this.anIntArray942[j2] - this.anIntArray943[j2];
                  flag1 = true;
                }
              }
            }
          }
          this.screenX = this.anIntArray941[j];
          this.screenY = this.anIntArray942[j] = k1;
          const s = this.aStringArray948[j];
          if (this.anInt998 === 0) {
            let k2 = 16776960;
            if (this.anIntArray945[j] < 6) {
              k2 = this.anIntArray842[this.anIntArray945[j]];
            }
            if (this.anIntArray945[j] === 6) {
              k2 = this.anInt1138 % 20 >= 10 ? 16776960 : 16711680;
            }
            if (this.anIntArray945[j] === 7) {
              k2 = this.anInt1138 % 20 >= 10 ? 65535 : 255;
            }
            if (this.anIntArray945[j] === 8) {
              k2 = this.anInt1138 % 20 >= 10 ? 8454016 : 45056;
            }
            if (this.anIntArray945[j] === 9) {
              const l2 = 150 - this.anIntArray947[j];
              if (l2 < 50) {
                k2 = 16711680 + 1280 * l2;
              } else if (l2 < 100) {
                k2 = 16776960 - 327680 * (l2 - 50);
              } else if (l2 < 150) {
                k2 = 65280 + 5 * (l2 - 100);
              }
            }
            if (this.anIntArray945[j] === 10) {
              const i3 = 150 - this.anIntArray947[j];
              if (i3 < 50) {
                k2 = 16711680 + 5 * i3;
              } else if (i3 < 100) {
                k2 = 16711935 - 327680 * (i3 - 50);
              } else if (i3 < 150) {
                k2 = 255 + 327680 * (i3 - 100) - 5 * (i3 - 100);
              }
            }
            if (this.anIntArray945[j] === 11) {
              const j3 = 150 - this.anIntArray947[j];
              if (j3 < 50) {
                k2 = 16777215 - 327685 * j3;
              } else if (j3 < 100) {
                k2 = 65280 + 327685 * (j3 - 50);
              } else if (j3 < 150) {
                k2 = 16777215 - 327680 * (j3 - 100);
              }
            }
            if (this.anIntArray946[j] === 0) {
              this.fontBold.drawStringLeft(s, this.screenX, this.screenY + 1, 0);
              this.fontBold.drawStringLeft(s, this.screenX, this.screenY, k2);
            }
            if (this.anIntArray946[j] === 1) {
              this.fontBold.drawCenteredStringWaveY(s, this.screenX, this.screenY + 1, this.anInt1138, 0);
              this.fontBold.drawCenteredStringWaveY(s, this.screenX, this.screenY, this.anInt1138, k2);
            }
            if (this.anIntArray946[j] === 2) {
              this.fontBold.drawCeneteredStringWaveXY(s, this.screenX, this.screenY + 1, this.anInt1138, 0);
              this.fontBold.drawCeneteredStringWaveXY(s, this.screenX, this.screenY, this.anInt1138, k2);
            }
            if (this.anIntArray946[j] === 3) {
              this.fontBold.drawCenteredStringWaveXYMove(
                s,
                this.screenX,
                this.screenY + 1,
                this.anInt1138,
                150 - this.anIntArray947[j],
                0
              );
              this.fontBold.drawCenteredStringWaveXYMove(
                s,
                this.screenX,
                this.screenY,
                this.anInt1138,
                150 - this.anIntArray947[j],
                k2
              );
            }
            if (this.anIntArray946[j] === 4) {
              const k3 = this.fontBold.getStringWidth(s);
              const i4 = (150 - this.anIntArray947[j]) * (k3 + 100) / 150 | 0;
              Rasterizer.setCoordinates(0, this.screenX - 50, 334, this.screenX + 50);
              this.fontBold.drawString(s, this.screenX + 50 - i4, this.screenY + 1, 0);
              this.fontBold.drawString(s, this.screenX + 50 - i4, this.screenY, k2);
              Rasterizer.resetCoordinates();
            }
            if (this.anIntArray946[j] === 5) {
              const l3 = 150 - this.anIntArray947[j];
              let j4 = 0;
              if (l3 < 25) {
                j4 = l3 - 25;
              } else if (l3 > 125) {
                j4 = l3 - 125;
              }
              Rasterizer.setCoordinates(this.screenY - this.fontBold.characterDefaultHeight - 1, 0, this.screenY + 5, 512);
              this.fontBold.drawStringLeft(s, this.screenX, this.screenY + 1 + j4, 0);
              this.fontBold.drawStringLeft(s, this.screenX, this.screenY + j4, k2);
              Rasterizer.resetCoordinates();
            }
          } else {
            this.fontBold.drawStringLeft(s, this.screenX, this.screenY + 1, 0);
            this.fontBold.drawStringLeft(s, this.screenX, this.screenY, 16776960);
          }
        }
      }
      if (flag) {
        this.opcode = -1;
      }
    }
    actorWorldToScreen(actor, modelHeight) {
      this.worldToScreen(actor.worldX, modelHeight, actor.worldY);
    }
    worldToScreen(worldX, worldZ, worldY) {
      if (worldX < 128 || worldY < 128 || worldX > 13056 || worldY > 13056) {
        this.screenX = -1;
        this.screenY = -1;
        return;
      }
      let i1 = this.getTileHeight(worldY, worldX, 9, this.plane) - worldZ;
      worldX -= this.cameraX;
      i1 -= this.cameraZ;
      worldY -= this.cameraY;
      const j1 = Model.SINE[this.cameraPitch];
      const k1 = Model.COSINE[this.cameraPitch];
      const l1 = Model.SINE[this.cameraYaw];
      const i2 = Model.COSINE[this.cameraYaw];
      let j2 = worldY * l1 + worldX * i2 >> 16;
      worldY = worldY * i2 - worldX * l1 >> 16;
      worldX = j2;
      j2 = i1 * k1 - worldY * j1 >> 16;
      worldY = i1 * j1 + worldY * k1 >> 16;
      i1 = j2;
      if (worldY >= 50) {
        this.screenX = Rasterizer3D.centerX + ((worldX << 9) / worldY | 0);
        this.screenY = Rasterizer3D.centerY + ((i1 << 9) / worldY | 0);
        return;
      } else {
        this.screenX = -1;
        this.screenY = -1;
        return;
      }
    }
    processPlayerAdditions(priority) {
      if (_Game.localPlayer.worldX >> 7 === this.destinationX && _Game.localPlayer.worldY >> 7 === this.destinationY) {
        this.destinationX = 0;
      }
      let count = this.localPlayerCount;
      if (priority) {
        count = 1;
      }
      for (let index = 0; index < count; index++) {
        {
          let player2;
          let key;
          if (priority) {
            player2 = _Game.localPlayer;
            key = this.thisPlayerId << 14;
          } else {
            player2 = this.players[this.playerList[index]];
            key = this.playerList[index] << 14;
          }
          if (player2 == null || !player2.isVisible()) {
            continue;
          }
          player2.aBoolean1763 = false;
          if ((_Game.lowMemory && this.localPlayerCount > 50 || this.localPlayerCount > 200) && !priority && player2.movementAnimation === player2.idleAnimation) {
            player2.aBoolean1763 = true;
          }
          const viewportX = player2.worldX >> 7;
          const viewportY = player2.worldY >> 7;
          if (viewportX < 0 || viewportX >= 104 || viewportY < 0 || viewportY >= 104) {
            continue;
          }
          if (player2.playerModel != null && _Game.pulseCycle >= player2.objectAppearanceStartTick && _Game.pulseCycle < player2.objectAppearanceEndTick) {
            player2.aBoolean1763 = false;
            player2.anInt1750 = this.getTileHeight(player2.worldY, player2.worldX, 9 | 0, this.plane);
            this.currentScene.addRenderable(
              player2.anInt1750,
              player2.anInt1769,
              60,
              7,
              player2,
              player2.anInt1768,
              player2.worldY,
              player2.anInt1771,
              player2.worldX,
              player2.anInt1612,
              player2.anInt1770,
              this.plane,
              key
            );
            continue;
          }
          if ((player2.worldX & 127) === 64 && (player2.worldY & 127) === 64) {
            if (this.anIntArrayArray886[viewportX][viewportY] === this.anInt1138) {
              continue;
            }
            this.anIntArrayArray886[viewportX][viewportY] = this.anInt1138;
          }
          player2.anInt1750 = this.getTileHeight(player2.worldY, player2.worldX, 9 | 0, this.plane);
          this.currentScene.addEntity(
            key,
            player2,
            player2.worldX,
            player2.anInt1750,
            player2.aBoolean1592,
            0,
            this.plane,
            60,
            player2.worldY,
            player2.anInt1612
          );
        }
      }
    }
    drawMenuTooltip() {
      if (this.menuActionRow < 2 && this.itemSelected === 0 && this.widgetSelected === 0) {
        return;
      }
      let str;
      if (this.itemSelected === 1 && this.menuActionRow < 2) {
        str = "Use " + this.aString1150 + " with...";
      } else if (this.widgetSelected === 1 && this.menuActionRow < 2) {
        str = this.selectedWidgetName + "...";
      } else {
        str = this.menuActionTexts[this.menuActionRow - 1];
      }
      if (this.menuActionRow > 2) {
        str = str + "@whi@ / " + (this.menuActionRow - 2) + " more options";
      }
      this.fontBold.drawShadowedSeededAlphaString(str, 4, 15, 16777215, _Game.pulseCycle / 1e3 | 0);
    }
    method142(i, j, class13, k, l) {
      if (class13.type !== 0 || class13.children == null) {
        return;
      }
      if (class13.hiddenUntilHovered && this.anInt1302 !== class13.id && this.anInt1280 !== class13.id && this.anInt1106 !== class13.id) {
        return;
      }
      const i1 = Rasterizer.topX;
      const j1 = Rasterizer.topY;
      const k1 = Rasterizer.bottomX;
      const l1 = Rasterizer.bottomY;
      Rasterizer.setCoordinates(i, j, i + class13.height, j + class13.width);
      const i2 = class13.children.length;
      if (l !== 8) {
        this.opcode = -1;
      }
      for (let j2 = 0; j2 < i2; j2++) {
        {
          let k2 = class13.childrenX[j2] + j;
          let l2 = class13.childrenY[j2] + i - k;
          const child = Widget.forId(class13.children[j2]);
          k2 += child.anInt228;
          l2 += child.anInt259;
          if (child.contentType > 0) {
            this.method103(2 | 0, child);
          }
          if (child.type === 0) {
            if (child.anInt231 > child.scrollLimit - child.height) {
              child.anInt231 = child.scrollLimit - child.height;
            }
            if (child.anInt231 < 0) {
              child.anInt231 = 0;
            }
            this.method142(l2, k2, child, child.anInt231, 8);
            if (child.scrollLimit > child.height) {
              this.method56(true, child.anInt231, k2 + child.width, child.height, child.scrollLimit, l2);
            }
          } else if (child.type !== 1) {
            if (child.type === 2) {
              let i3 = 0;
              for (let i4 = 0; i4 < child.height; i4++) {
                {
                  for (let j5 = 0; j5 < child.width; j5++) {
                    {
                      let i6 = k2 + j5 * (32 + child.itemSpritePadsX);
                      let l6 = l2 + i4 * (32 + child.itemSpritePadsY);
                      if (i3 < 20) {
                        i6 += child.imageX[i3];
                        l6 += child.imageY[i3];
                      }
                      if (child.items[i3] > 0) {
                        let i7 = 0;
                        let j8 = 0;
                        const l10 = child.items[i3] - 1;
                        if (i6 > Rasterizer.topX - 32 && i6 < Rasterizer.bottomX && l6 > Rasterizer.topY - 32 && l6 < Rasterizer.bottomY || this.activeInterfaceType !== 0 && this.selectedInventorySlot === i3) {
                          let k11 = 0;
                          if (this.itemSelected === 1 && this.anInt1147 === i3 && this.anInt1148 === child.id) {
                            k11 = 16777215;
                          }
                          const class50_sub1_sub1_sub1_2 = ItemDefinition.sprite(
                            l10,
                            child.itemAmounts[i3],
                            k11
                          );
                          if (class50_sub1_sub1_sub1_2 != null) {
                            if (this.activeInterfaceType !== 0 && this.selectedInventorySlot === i3 && this.modifiedWidgetId === child.id) {
                              i7 = this.mouseX - this.anInt1114;
                              j8 = this.mouseY - this.anInt1115;
                              if (i7 < 5 && i7 > -5) {
                                i7 = 0;
                              }
                              if (j8 < 5 && j8 > -5) {
                                j8 = 0;
                              }
                              if (this.anInt1269 < 5) {
                                i7 = 0;
                                j8 = 0;
                              }
                              class50_sub1_sub1_sub1_2.drawImageAlpha(i6 + i7, l6 + j8, 128);
                              if (l6 + j8 < Rasterizer.topY && class13.anInt231 > 0) {
                                let i12 = this.tickDelta * (Rasterizer.topY - l6 - j8) / 3 | 0;
                                if (i12 > this.tickDelta * 10) {
                                  i12 = this.tickDelta * 10;
                                }
                                if (i12 > class13.anInt231) {
                                  i12 = class13.anInt231;
                                }
                                class13.anInt231 -= i12;
                                this.anInt1115 += i12;
                              }
                              if (l6 + j8 + 32 > Rasterizer.bottomY && class13.anInt231 < class13.scrollLimit - class13.height) {
                                let j12 = this.tickDelta * (l6 + j8 + 32 - Rasterizer.bottomY) / 3 | 0;
                                if (j12 > this.tickDelta * 10) {
                                  j12 = this.tickDelta * 10;
                                }
                                if (j12 > class13.scrollLimit - class13.height - class13.anInt231) {
                                  j12 = class13.scrollLimit - class13.height - class13.anInt231;
                                }
                                class13.anInt231 += j12;
                                this.anInt1115 -= j12;
                              }
                            } else if (this.atInventoryInterfaceType !== 0 && this.anInt1331 === i3 && this.anInt1330 === child.id) {
                              class50_sub1_sub1_sub1_2.drawImageAlpha(i6, l6, 128);
                            } else {
                              class50_sub1_sub1_sub1_2.drawImage(l6, i6);
                            }
                            if (class50_sub1_sub1_sub1_2.maxWidth === 33 || child.itemAmounts[i3] !== 1) {
                              const k12 = child.itemAmounts[i3];
                              this.fontSmall.drawString(
                                _Game.getShortenedAmountText(k12),
                                i6 + 1 + i7,
                                l6 + 10 + j8,
                                0
                              );
                              this.fontSmall.drawString(
                                _Game.getShortenedAmountText(k12),
                                i6 + i7,
                                l6 + 9 + j8,
                                16776960
                              );
                            }
                          }
                        }
                      } else if (child.images != null && i3 < 20) {
                        const class50_sub1_sub1_sub1_1 = child.images[i3];
                        if (class50_sub1_sub1_sub1_1 != null) {
                          class50_sub1_sub1_sub1_1.drawImage(l6, i6);
                        }
                      }
                      i3++;
                    }
                  }
                }
              }
            } else if (child.type === 3) {
              let flag = false;
              if (this.anInt1106 === child.id || this.anInt1280 === child.id || this.anInt1302 === child.id) {
                flag = true;
              }
              let j3;
              if (this.method95(child, -693)) {
                j3 = child.enabledColor;
                if (flag && child.enabledHoveredColor !== 0) {
                  j3 = child.enabledHoveredColor;
                }
              } else {
                j3 = child.disabledColor;
                if (flag && child.disabledHoveredColor !== 0) {
                  j3 = child.disabledHoveredColor;
                }
              }
              if (child.alpha === 0) {
                if (child.filled) {
                  Rasterizer.drawFilledRectangle(k2, l2, child.width, child.height, j3);
                } else {
                  Rasterizer.drawUnfilledRectangle(k2, l2, child.width, child.height, j3);
                }
              } else if (child.filled) {
                Rasterizer.drawFilledRectangleAlhpa(k2, l2, child.width, child.height, j3, 256 - (child.alpha & 255));
              } else {
                Rasterizer.drawUnfilledRectangleAlpha(k2, l2, child.width, child.height, j3, 256 - (child.alpha & 255));
              }
            } else if (child.type === 4) {
              const class50_sub1_sub1_sub2 = child.typeFaces;
              let s = child.disabledText;
              let flag1 = false;
              if (this.anInt1106 === child.id || this.anInt1280 === child.id || this.anInt1302 === child.id) {
                flag1 = true;
              }
              let j4;
              if (this.method95(child, -693)) {
                j4 = child.enabledColor;
                if (flag1 && child.enabledHoveredColor !== 0) {
                  j4 = child.enabledHoveredColor;
                }
                if (child.enabledText.length > 0) {
                  s = child.enabledText;
                }
              } else {
                j4 = child.disabledColor;
                if (flag1 && child.disabledHoveredColor !== 0) {
                  j4 = child.disabledHoveredColor;
                }
              }
              if (child.actionType === 6 && this.aBoolean1239) {
                s = "Please wait...";
                j4 = child.disabledColor;
              }
              if (Rasterizer.width === 479) {
                if (j4 === 16776960) {
                  j4 = 255;
                }
                if (j4 === 49152) {
                  j4 = 16777215;
                }
              }
              for (let j7 = l2 + class50_sub1_sub1_sub2.characterDefaultHeight; s.length > 0; j7 += class50_sub1_sub1_sub2.characterDefaultHeight) {
                {
                  if (s.indexOf("%") !== -1) {
                    do {
                      {
                        const k8 = s.indexOf("%1");
                        if (k8 === -1) {
                          break;
                        }
                        s = s.substring(0, k8) + this.method89(this.method129(3, 0, child), 8) + s.substring(k8 + 2);
                      }
                    } while (true);
                    do {
                      {
                        const l8 = s.indexOf("%2");
                        if (l8 === -1) {
                          break;
                        }
                        s = s.substring(0, l8) + this.method89(this.method129(3, 1, child), 8) + s.substring(l8 + 2);
                      }
                    } while (true);
                    do {
                      {
                        const i9 = s.indexOf("%3");
                        if (i9 === -1) {
                          break;
                        }
                        s = s.substring(0, i9) + this.method89(this.method129(3, 2, child), 8) + s.substring(i9 + 2);
                      }
                    } while (true);
                    do {
                      {
                        const j9 = s.indexOf("%4");
                        if (j9 === -1) {
                          break;
                        }
                        s = s.substring(0, j9) + this.method89(this.method129(3, 3, child), 8) + s.substring(j9 + 2);
                      }
                    } while (true);
                    do {
                      {
                        const k9 = s.indexOf("%5");
                        if (k9 === -1) {
                          break;
                        }
                        s = s.substring(0, k9) + this.method89(this.method129(3, 4, child), 8) + s.substring(k9 + 2);
                      }
                    } while (true);
                  }
                  const l9 = s.indexOf("\\n");
                  let s3;
                  if (l9 !== -1) {
                    s3 = s.substring(0, l9);
                    s = s.substring(l9 + 2);
                  } else {
                    s3 = s;
                    s = "";
                  }
                  if (child.typeFaceCentered) {
                    class50_sub1_sub1_sub2.drawStringCenter(
                      s3,
                      k2 + (child.width / 2 | 0),
                      j7,
                      j4,
                      child.typeFaceShadowed
                    );
                  } else {
                    class50_sub1_sub1_sub2.drawShadowedString(s3, k2, j7, child.typeFaceShadowed, j4);
                  }
                }
              }
            } else if (child.type === 5) {
              let class50_sub1_sub1_sub1;
              if (this.method95(child, -693)) {
                class50_sub1_sub1_sub1 = child.enabledImage;
              } else {
                class50_sub1_sub1_sub1 = child.disabledImage;
              }
              switch (child.id) {
                case 1164:
                case 1167:
                case 1170:
                case 1174:
                case 1540:
                case 1541:
                case 7455:
                  class50_sub1_sub1_sub1 = child.enabledImage;
                  break;
                default:
                  break;
              }
              if (class50_sub1_sub1_sub1 != null) {
                class50_sub1_sub1_sub1.drawImage(l2, k2);
              }
            } else if (child.type === 6) {
              const k3 = Rasterizer3D.centerX;
              const k4 = Rasterizer3D.centerY;
              Rasterizer3D.centerX = k2 + (child.width / 2 | 0);
              Rasterizer3D.centerY = l2 + (child.height / 2 | 0);
              const k5 = Rasterizer3D.SINE[child.rotationX] * child.zoom >> 16;
              const j6 = Rasterizer3D.COSINE[child.rotationX] * child.zoom >> 16;
              const flag2 = this.method95(child, -693);
              let k7;
              if (flag2) {
                k7 = child.enabledAnimation;
              } else {
                k7 = child.disabledAnimation;
              }
              let class50_sub1_sub4_sub4;
              if (k7 === -1) {
                class50_sub1_sub4_sub4 = child.getAnimatedModel(-1, -1, flag2);
              } else {
                const class14 = AnimationSequence.animations[k7];
                class50_sub1_sub4_sub4 = child.getAnimatedModel(
                  class14.frame1Ids[child.anInt235],
                  class14.getPrimaryFrame[child.anInt235],
                  flag2
                );
              }
              if (class50_sub1_sub4_sub4 != null) {
                class50_sub1_sub4_sub4.render(0, child.rotationY, 0, child.rotationX, 0, k5, j6);
              }
              Rasterizer3D.centerX = k3;
              Rasterizer3D.centerY = k4;
            } else {
              if (child.type === 7) {
                const class50_sub1_sub1_sub2_1 = child.typeFaces;
                let l4 = 0;
                for (let l5 = 0; l5 < child.height; l5++) {
                  {
                    for (let k6 = 0; k6 < child.width; k6++) {
                      {
                        if (child.items[l4] > 0) {
                          const class16 = ItemDefinition.lookup(child.items[l4] - 1);
                          let s6 = new String(class16.name).toString();
                          if (class16.stackable || child.itemAmounts[l4] !== 1) {
                            s6 = s6 + " x" + _Game.getFullAmountText(child.itemAmounts[l4]);
                          }
                          const i10 = k2 + k6 * (115 + child.itemSpritePadsX);
                          const i11 = l2 + l5 * (12 + child.itemSpritePadsY);
                          if (child.typeFaceCentered) {
                            class50_sub1_sub1_sub2_1.drawStringCenter(
                              s6,
                              i10 + (child.width / 2 | 0),
                              i11,
                              child.disabledColor,
                              child.typeFaceShadowed
                            );
                          } else {
                            class50_sub1_sub1_sub2_1.drawShadowedString(
                              s6,
                              i10,
                              i11,
                              child.typeFaceShadowed,
                              child.disabledColor
                            );
                          }
                        }
                        l4++;
                      }
                    }
                  }
                }
              }
              if (child.type === 8 && (this.anInt1284 === child.id || this.anInt1044 === child.id || this.anInt1129 === child.id) && this.anInt893 === 100) {
                let l3 = 0;
                let i5 = 0;
                const class50_sub1_sub1_sub2_2 = this.fontNormal;
                for (let s1 = child.disabledText; s1.length > 0; ) {
                  {
                    const l7 = s1.indexOf("\\n");
                    let s4;
                    if (l7 !== -1) {
                      s4 = s1.substring(0, l7);
                      s1 = s1.substring(l7 + 2);
                    } else {
                      s4 = s1;
                      s1 = "";
                    }
                    const j10 = class50_sub1_sub1_sub2_2.getStringEffectWidth(s4);
                    if (j10 > l3) {
                      l3 = j10;
                    }
                    i5 += class50_sub1_sub1_sub2_2.characterDefaultHeight + 1;
                  }
                }
                l3 += 6;
                i5 += 7;
                let i8 = k2 + child.width - 5 - l3;
                let k10 = l2 + child.height + 5;
                if (i8 < k2 + 5) {
                  i8 = k2 + 5;
                }
                if (i8 + l3 > j + class13.width) {
                  i8 = j + class13.width - l3;
                }
                if (k10 + i5 > i + class13.height) {
                  k10 = i + class13.height - i5;
                }
                Rasterizer.drawFilledRectangle(i8, k10, l3, i5, 16777120);
                Rasterizer.drawUnfilledRectangle(i8, k10, l3, i5, 0);
                let s2 = child.disabledText;
                for (let j11 = k10 + class50_sub1_sub1_sub2_2.characterDefaultHeight + 2; s2.length > 0; j11 += class50_sub1_sub1_sub2_2.characterDefaultHeight + 1) {
                  {
                    const l11 = s2.indexOf("\\n");
                    let s5;
                    if (l11 !== -1) {
                      s5 = s2.substring(0, l11);
                      s2 = s2.substring(l11 + 2);
                    } else {
                      s5 = s2;
                      s2 = "";
                    }
                    class50_sub1_sub1_sub2_2.drawShadowedString(s5, i8 + 3, j11, false, 0);
                  }
                }
              }
            }
          }
        }
      }
      Rasterizer.setCoordinates(j1, i1, l1, k1);
    }
    method89(i, j) {
      if (j < 8 || j > 8) {
        throw Error("NullPointerException");
      }
      if (i < 999999999) {
        return new String(i).toString();
      } else {
        return "*";
      }
    }
    method56(flag, i, j, k, l, i1) {
      this.scrollbarUp.drawImage(j, i1);
      this.scrollbarDown.drawImage(j, i1 + k - 16);
      Rasterizer.drawFilledRectangle(j, i1 + 16, 16, k - 32, this.anInt931);
      let j1 = (k - 32) * k / l | 0;
      if (j1 < 8) {
        j1 = 8;
      }
      const k1 = (k - 32 - j1) * i / (l - k) | 0;
      Rasterizer.drawFilledRectangle(j, i1 + 16 + k1, 16, j1, this.anInt1080);
      Rasterizer.drawVerticalLine(j, i1 + 16 + k1, j1, this.anInt1135);
      Rasterizer.drawVerticalLine(j + 1, i1 + 16 + k1, j1, this.anInt1135);
      if (!flag) {
        this.anInt921 = -136;
      }
      Rasterizer.drawHorizontalLine(j, i1 + 16 + k1, 16, this.anInt1135);
      Rasterizer.drawHorizontalLine(j, i1 + 17 + k1, 16, this.anInt1135);
      Rasterizer.drawVerticalLine(j + 15, i1 + 16 + k1, j1, this.anInt1287);
      Rasterizer.drawVerticalLine(j + 14, i1 + 17 + k1, j1 - 1, this.anInt1287);
      Rasterizer.drawHorizontalLine(j, i1 + 15 + k1 + j1, 16, this.anInt1287);
      Rasterizer.drawHorizontalLine(j + 1, i1 + 14 + k1 + j1, 15, this.anInt1287);
    }
    method103(byte0, class13) {
      if (byte0 === 2) {
        byte0 = 0;
      } else {
        this.anInt1004 = -82;
      }
      let i = class13.contentType;
      if (i >= 1 && i <= 100 || i >= 701 && i <= 800) {
        if (i === 1 && this.friendListStatus === 0) {
          class13.disabledText = "Loading friend list";
          class13.actionType = 0;
          return;
        }
        if (i === 1 && this.friendListStatus === 1) {
          class13.disabledText = "Connecting to friendserver";
          class13.actionType = 0;
          return;
        }
        if (i === 2 && this.friendListStatus !== 2) {
          class13.disabledText = "Please wait...";
          class13.actionType = 0;
          return;
        }
        let j = this.friendsCount;
        if (this.friendListStatus !== 2) {
          j = 0;
        }
        if (i > 700) {
          i -= 601;
        } else {
          i--;
        }
        if (i >= j) {
          class13.disabledText = "";
          class13.actionType = 0;
          return;
        } else {
          class13.disabledText = this.friendUsernames[i];
          class13.actionType = 1;
          return;
        }
      }
      if (i >= 101 && i <= 200 || i >= 801 && i <= 900) {
        let k = this.friendsCount;
        if (this.friendListStatus !== 2) {
          k = 0;
        }
        if (i > 800) {
          i -= 701;
        } else {
          i -= 101;
        }
        if (i >= k) {
          class13.disabledText = "";
          class13.actionType = 0;
          return;
        }
        if (this.friendWorlds[i] === 0) {
          class13.disabledText = "@red@Offline";
        } else if (this.friendWorlds[i] < 200) {
          if (this.friendWorlds[i] === _Game.world) {
            class13.disabledText = "@gre@World" + (this.friendWorlds[i] - 9);
          } else {
            class13.disabledText = "@yel@World" + (this.friendWorlds[i] - 9);
          }
        } else if (this.friendWorlds[i] === _Game.world) {
          class13.disabledText = "@gre@Classic" + (this.friendWorlds[i] - 219);
        } else {
          class13.disabledText = "@yel@Classic" + (this.friendWorlds[i] - 219);
        }
        class13.actionType = 1;
        return;
      }
      if (i === 203) {
        let l = this.friendsCount;
        if (this.friendListStatus !== 2) {
          l = 0;
        }
        class13.scrollLimit = l * 15 + 20;
        if (class13.scrollLimit <= class13.height) {
          class13.scrollLimit = class13.height + 1;
        }
        return;
      }
      if (i >= 401 && i <= 500) {
        if ((i -= 401) === 0 && this.friendListStatus === 0) {
          class13.disabledText = "Loading ignore list";
          class13.actionType = 0;
          return;
        }
        if (i === 1 && this.friendListStatus === 0) {
          class13.disabledText = "Please wait...";
          class13.actionType = 0;
          return;
        }
        let i1 = this.ignoresCount;
        if (this.friendListStatus === 0) {
          i1 = 0;
        }
        if (i >= i1) {
          class13.disabledText = "";
          class13.actionType = 0;
          return;
        } else {
          class13.disabledText = TextUtils.formatName(TextUtils.longToName(this.ignores[i]));
          class13.actionType = 1;
          return;
        }
      }
      if (i === 503) {
        class13.scrollLimit = this.ignoresCount * 15 + 20;
        if (class13.scrollLimit <= class13.height) {
          class13.scrollLimit = class13.height + 1;
        }
        return;
      }
      if (i === 327) {
        class13.rotationX = 150;
        class13.rotationY = (Math.sin(_Game.pulseCycle / 40) * 256 | 0) & 2047;
        if (this.aBoolean1277) {
          for (let j1 = 0; j1 < 7; j1++) {
            {
              const i2 = this.characterEditIdentityKits[j1];
              if (i2 >= 0 && !IdentityKit.cache[i2].isBodyModelCached()) {
                return;
              }
            }
          }
          this.aBoolean1277 = false;
          const aclass50_sub1_sub4_sub4 = [null, null, null, null, null, null, null];
          let j2 = 0;
          for (let k2 = 0; k2 < 7; k2++) {
            {
              const l2 = this.characterEditIdentityKits[k2];
              if (l2 >= 0) {
                aclass50_sub1_sub4_sub4[j2++] = IdentityKit.cache[l2].getBodyModel();
              }
            }
          }
          const class50_sub1_sub4_sub4 = new Model(j2, aclass50_sub1_sub4_sub4);
          for (let i3 = 0; i3 < 5; i3++) {
            if (this.characterEditColors[i3] !== 0) {
              class50_sub1_sub4_sub4.replaceColor(
                _Game.playerColours[i3][0],
                _Game.playerColours[i3][this.characterEditColors[i3]]
              );
              if (i3 === 1) {
                class50_sub1_sub4_sub4.replaceColor(_Game.SKIN_COLOURS[0], _Game.SKIN_COLOURS[this.characterEditColors[i3]]);
              }
            }
          }
          class50_sub1_sub4_sub4.createBones();
          class50_sub1_sub4_sub4.applyTransform(AnimationSequence.animations[_Game.localPlayer.idleAnimation].getPrimaryFrame[0]);
          class50_sub1_sub4_sub4.applyLighting(64, 850, -30, -50, -30, true);
          class13.modelType = 5;
          class13.modelId = 0;
          Widget.setModel(5, class50_sub1_sub4_sub4, 0);
        }
        return;
      }
      if (i === 324) {
        if (this.aClass50_Sub1_Sub1_Sub1_1102 == null) {
          this.aClass50_Sub1_Sub1_Sub1_1102 = class13.disabledImage;
          this.aClass50_Sub1_Sub1_Sub1_1103 = class13.enabledImage;
        }
        if (this.characterEditChangeGenger) {
          class13.disabledImage = this.aClass50_Sub1_Sub1_Sub1_1103;
          return;
        } else {
          class13.disabledImage = this.aClass50_Sub1_Sub1_Sub1_1102;
          return;
        }
      }
      if (i === 325) {
        if (this.aClass50_Sub1_Sub1_Sub1_1102 == null) {
          this.aClass50_Sub1_Sub1_Sub1_1102 = class13.disabledImage;
          this.aClass50_Sub1_Sub1_Sub1_1103 = class13.enabledImage;
        }
        if (this.characterEditChangeGenger) {
          class13.disabledImage = this.aClass50_Sub1_Sub1_Sub1_1102;
          return;
        } else {
          class13.disabledImage = this.aClass50_Sub1_Sub1_Sub1_1103;
          return;
        }
      }
      if (i === 600) {
        class13.disabledText = this.reportedName;
        if (_Game.pulseCycle % 20 < 10) {
          class13.disabledText += "|";
          return;
        } else {
          class13.disabledText += " ";
          return;
        }
      }
      if (i === 620) {
        if (this.playerRights >= 1) {
          if (this.reportMutePlayer) {
            class13.disabledColor = 16711680;
            class13.disabledText = "Moderator option: Mute player for 48 hours: <ON>";
          } else {
            class13.disabledColor = 16777215;
            class13.disabledText = "Moderator option: Mute player for 48 hours: <OFF>";
          }
        } else {
          class13.disabledText = "";
        }
      }
      if (i === 660) {
        const k1 = this.anInt1170 - this.anInt1215;
        let s1;
        if (k1 <= 0) {
          s1 = "earlier today";
        } else if (k1 === 1) {
          s1 = "yesterday";
        } else {
          s1 = k1 + " days ago";
        }
        class13.disabledText = "You last logged in @red@" + s1 + "@bla@ from: @red@" + SignLink.dns;
      }
      if (i === 661) {
        if (this.anInt1034 === 0) {
          class13.disabledText = "\\nYou have not yet set any recovery questions.\\nIt is @lre@strongly@yel@ recommended that you do so.\\n\\nIf you don't you will be @lre@unable to recover your\\n@lre@password@yel@ if you forget it, or it is stolen.";
        } else if (this.anInt1034 <= this.anInt1170) {
          class13.disabledText = "\\n\\nRecovery Questions Last Set:\\n@gre@" + this.getDate(this.anInt1034);
        } else {
          const l1 = this.anInt1170 + 14 - this.anInt1034;
          let s2;
          if (l1 <= 0) {
            s2 = "Earlier today";
          } else if (l1 === 1) {
            s2 = "Yesterday";
          } else {
            s2 = l1 + " days ago";
          }
          class13.disabledText = s2 + " you requested@lre@ new recovery\\n@lre@questions.@yel@ The requested change will occur\\non: @lre@" + this.getDate(this.anInt1034) + "\\n\\nIf you do not remember making this request\\ncancel it immediately, and change your password.";
        }
      }
      if (i === 662) {
        let s;
        if (this.anInt1273 === 0) {
          s = "@yel@0 unread messages";
        } else if (this.anInt1273 === 1) {
          s = "@gre@1 unread message";
        } else {
          s = "@gre@" + this.anInt1273 + " unread messages";
        }
        class13.disabledText = "You have " + s + "\\nin your message centre.";
      }
      if (i === 663) {
        if (this.anInt1083 <= 0 || this.anInt1083 > this.anInt1170 + 10) {
          class13.disabledText = "Last password change:\\n@gre@Never changed";
        } else {
          class13.disabledText = "Last password change:\\n@gre@" + this.getDate(this.anInt1083);
        }
      }
      if (i === 665) {
        if (this.anInt992 > 2 && !_Game.memberServer) {
          class13.disabledText = "This is a non-members\\nworld. To enjoy your\\nmembers benefits we\\nrecommend you play on a\\nmembers world instead.";
        } else if (this.anInt992 > 2) {
          class13.disabledText = "\\n\\nYou have @gre@" + this.anInt992 + "@yel@ days of\\nmember credit remaining.";
        } else if (this.anInt992 > 0) {
          class13.disabledText = "You have @gre@" + this.anInt992 + "@yel@ days of\\nmember credit remaining.\\n\\n@lre@Credit low! Renew now\\n@lre@to avoid losing members.";
        } else {
          class13.disabledText = "You are not a member.\\n\\nChoose to subscribe and\\nyou'll get loads of extra\\nbenefits and features.";
        }
      }
      if (i === 667) {
        if (this.anInt992 > 2 && !_Game.memberServer) {
          class13.disabledText = "To switch to a members-only world:\\n1) Logout and return to the world selection page.\\n2) Choose one of the members world with a gold star next to it's name.\\n\\nIf you prefer you can continue to use this world,\\nbut members only features will be unavailable here.";
        } else if (this.anInt992 > 0) {
          class13.disabledText = "To extend or cancel a subscription:\\n1) Logout and return to the frontpage of this website.\\n2)Choose the relevant option from the 'membership' section.\\n\\nNote: If you are a credit card subscriber a top-up payment will\\nautomatically be taken when 3 days credit remain.\\n(unless you cancel your subscription, which can be done at any time.)";
        } else {
          class13.disabledText = "To initializeApplication a subscripton:\\n1) Logout and return to the frontpage of this website.\\n2) Choose 'Start a new subscription'";
        }
      }
      if (i === 668) {
        if (this.anInt1034 > this.anInt1170) {
          class13.disabledText = "To cancel this request:\\n1) Logout and return to the frontpage of this website.\\n2) Choose 'Cancel recovery questions'.";
          return;
        }
        class13.disabledText = "To change your recovery questions:\\n1) Logout and return to the frontpage of this website.\\n2) Choose 'Set new recovery questions'.";
      }
    }
    getDate(time) {
      if (time > this.anInt1170 + 10) {
        return "Unknown";
      } else {
        const date = new Date((((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(time) + 11745) * 864e5);
        const day = date.getDay();
        const month = date.getMonth();
        const year = date.getFullYear();
        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        return day + "-" + monthNames[month] + "-" + year;
      }
    }
    method147(i) {
      if (this.imageProducer != null) {
        return;
      }
      this.method141();
      this.aClass18_1198 = null;
      this.aClass18_1199 = null;
      this.aClass18_1200 = null;
      if (i >= 0) {
        this.anInt1004 = -4;
      }
      this.flameLeftBackground = null;
      this.flameRightBackground = null;
      this.aClass18_1203 = null;
      this.aClass18_1204 = null;
      this.aClass18_1205 = null;
      this.aClass18_1206 = null;
      this.chatboxProducingGraphicsBuffer = null;
      this.aClass18_1157 = null;
      this.aClass18_1156 = null;
      this.aClass18_1158 = null;
      this.aClass18_1108 = null;
      this.aClass18_1109 = null;
      this.aClass18_1110 = null;
      this.imageProducer = new ProducingGraphicsBuffer(765, 503);
      this.aBoolean1046 = true;
    }
    method88(i, j, byte0) {
      let flag = false;
      const class13 = Widget.forId(j);
      for (let k = 0; k < class13.children.length; k++) {
        {
          if (class13.children[k] === -1) {
            break;
          }
          const class13_1 = Widget.forId(class13.children[k]);
          if (class13_1.type === 0) {
            flag = this.method88(i, class13_1.id, 5 | 0) || flag;
          }
          if (class13_1.type === 6 && (class13_1.disabledAnimation !== -1 || class13_1.enabledAnimation !== -1)) {
            const flag1 = this.method95(class13_1, -693);
            let i1;
            if (flag1) {
              i1 = class13_1.enabledAnimation;
            } else {
              i1 = class13_1.disabledAnimation;
            }
            if (i1 !== -1) {
              const class14 = AnimationSequence.animations[i1];
              for (class13_1.anInt227 += i; class13_1.anInt227 > class14.getFrameLength(class13_1.anInt235); ) {
                {
                  class13_1.anInt227 -= class14.getFrameLength(class13_1.anInt235);
                  class13_1.anInt235++;
                  if (class13_1.anInt235 >= class14.frameCount) {
                    class13_1.anInt235 -= class14.frameStep;
                    if (class13_1.anInt235 < 0 || class13_1.anInt235 >= class14.frameCount) {
                      class13_1.anInt235 = 0;
                    }
                  }
                  flag = true;
                }
              }
            }
          }
          if (class13_1.type === 6 && class13_1.anInt218 !== 0) {
            let l = class13_1.anInt218 >> 16;
            let j1 = class13_1.anInt218 << 16 >> 16;
            l *= i;
            j1 *= i;
            class13_1.rotationX = class13_1.rotationX + l & 2047;
            class13_1.rotationY = class13_1.rotationY + j1 & 2047;
            flag = true;
          }
        }
      }
      if (byte0 === 5) {
        byte0 = 0;
      } else {
        this.anInt1236 = -424;
      }
      return flag;
    }
    method95(class13, i) {
      if (i >= 0) {
        this.anInt1175 = 276;
      }
      if (class13.conditionTypes == null) {
        return false;
      }
      for (let j = 0; j < class13.conditionTypes.length; j++) {
        {
          const k = this.method129(3, j, class13);
          const l = class13.conditionValues[j];
          if (class13.conditionTypes[j] === 2) {
            if (k >= l) {
              return false;
            }
          } else if (class13.conditionTypes[j] === 3) {
            if (k <= l) {
              return false;
            }
          } else if (class13.conditionTypes[j] === 4) {
            if (k === l) {
              return false;
            }
          } else if (k !== l) {
            return false;
          }
        }
      }
      return true;
    }
    method129(i, j, class13) {
      if (i !== 3) {
        return this.anInt1222;
      }
      if (class13.opcodes == null || j >= class13.opcodes.length) {
        return -2;
      }
      try {
        const ai = class13.opcodes[j];
        let k = 0;
        let l = 0;
        let i1 = 0;
        do {
          {
            const j1 = ai[l++];
            let k1 = 0;
            let byte0 = 0;
            if (j1 === 0) {
              return k;
            }
            if (j1 === 1) {
              k1 = this.anIntArray1029[ai[l++]];
            }
            if (j1 === 2) {
              k1 = this.anIntArray1054[ai[l++]];
            }
            if (j1 === 3) {
              k1 = this.anIntArray843[ai[l++]];
            }
            if (j1 === 4) {
              const class13_1 = Widget.forId(ai[l++]);
              const k2 = ai[l++];
              if (k2 >= 0 && k2 < ItemDefinition.count && (!ItemDefinition.lookup(k2).members || _Game.memberServer)) {
                for (let j3 = 0; j3 < class13_1.items.length; j3++) {
                  if (class13_1.items[j3] === k2 + 1) {
                    k1 += class13_1.itemAmounts[j3];
                  }
                }
              }
            }
            if (j1 === 5) {
              k1 = this.widgetSettings[ai[l++]];
            }
            if (j1 === 6) {
              k1 = _Game.SKILL_EXPERIENCE[this.anIntArray1054[ai[l++]] - 1];
            }
            if (j1 === 7) {
              k1 = this.widgetSettings[ai[l++]] * 100 / 46875 | 0;
            }
            if (j1 === 8) {
              k1 = _Game.localPlayer.combatLevel;
            }
            if (j1 === 9) {
              for (let l1 = 0; l1 < SkillConstants.SKILL_COUNT; l1++) {
                if (SkillConstants.SKILL_TOGGLES[l1]) {
                  k1 += this.anIntArray1054[l1];
                }
              }
            }
            if (j1 === 10) {
              const class13_2 = Widget.forId(ai[l++]);
              const l2 = ai[l++] + 1;
              if (l2 >= 0 && l2 < ItemDefinition.count && (!ItemDefinition.lookup(l2).members || _Game.memberServer)) {
                for (let k3 = 0; k3 < class13_2.items.length; k3++) {
                  {
                    if (class13_2.items[k3] !== l2) {
                      continue;
                    }
                    k1 = 999999999;
                    break;
                  }
                }
              }
            }
            if (j1 === 11) {
              k1 = this.anInt1324;
            }
            if (j1 === 12) {
              k1 = this.anInt1030;
            }
            if (j1 === 13) {
              const i2 = this.widgetSettings[ai[l++]];
              const i3 = ai[l++];
              k1 = (i2 & 1 << i3) === 0 ? 0 : 1;
            }
            if (j1 === 14) {
              const j2 = ai[l++];
              const class49 = Varbit.cache[j2];
              const l3 = class49.configId;
              const i4 = class49.leastSignificantBit;
              const j4 = class49.mostSignificantBit;
              const k4 = _Game.BITFIELD_MAX_VALUE[j4 - i4];
              k1 = this.widgetSettings[l3] >> i4 & k4;
            }
            if (j1 === 15) {
              byte0 = 1;
            }
            if (j1 === 16) {
              byte0 = 2;
            }
            if (j1 === 17) {
              byte0 = 3;
            }
            if (j1 === 18) {
              k1 = (_Game.localPlayer.worldX >> 7) + this.nextTopLeftTileX;
            }
            if (j1 === 19) {
              k1 = (_Game.localPlayer.worldY >> 7) + this.nextTopRightTileY;
            }
            if (j1 === 20) {
              k1 = ai[l++];
            }
            if (byte0 === 0) {
              if (i1 === 0) {
                k += k1;
              }
              if (i1 === 1) {
                k -= k1;
              }
              if (i1 === 2 && k1 !== 0) {
                k = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(k / k1);
              }
              if (i1 === 3) {
                k *= k1;
              }
              i1 = 0;
            } else {
              i1 = byte0;
            }
          }
        } while (true);
      } catch (_ex) {
        return -1;
      }
    }
    async drawLoginScreen(flag) {
      await this.resetTitleScreen();
      this.aClass18_1200.createRasterizer();
      this.titleboxImage.drawImage(0, 0);
      const c2 = "\u0168";
      const c1 = "\xC8";
      if (this.loginScreenState === 0) {
        let j = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) + 80;
        this.fontSmall.drawStringCenter(
          this.onDemandRequester.message,
          ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
          j,
          7711145,
          true
        );
        j = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) - 20;
        this.fontBold.drawStringCenter(
          "Welcome to RuneScape",
          ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
          j,
          16776960,
          true
        );
        j += 30;
        let i1 = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) - 80;
        const l1 = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) + 20;
        this.titleboxButtonImage.drawImage(i1 - 73, l1 - 20);
        this.fontBold.drawStringCenter("New User", i1, l1 + 5, 16777215, true);
        i1 = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) + 80;
        this.titleboxButtonImage.drawImage(i1 - 73, l1 - 20);
        this.fontBold.drawStringCenter("Existing User", i1, l1 + 5, 16777215, true);
      }
      if (this.loginScreenState === 2) {
        let k = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) - 40;
        if (this.statusLineOne.length > 0) {
          this.fontBold.drawStringCenter(
            this.statusLineOne,
            ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
            k - 15,
            16776960,
            true
          );
          this.fontBold.drawStringCenter(
            this.statusLineTwo,
            ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
            k,
            16776960,
            true
          );
          k += 30;
        } else {
          this.fontBold.drawStringCenter(
            this.statusLineTwo,
            ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
            k - 7,
            16776960,
            true
          );
          k += 30;
        }
        this.fontBold.drawShadowedString(
          "Username: " + this.username + (((lhs, rhs) => lhs && rhs)(this.anInt977 === 0, _Game.pulseCycle % 40 < 20) ? "@yel@|" : ""),
          (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) - 90,
          k,
          true,
          16777215
        );
        k += 15;
        this.fontBold.drawShadowedString(
          "Password: " + TextUtils.censorPassword(this.password) + (((lhs, rhs) => lhs && rhs)(this.anInt977 === 1, _Game.pulseCycle % 40 < 20) ? "@yel@|" : ""),
          (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) - 88,
          k,
          true,
          16777215
        );
        k += 15;
        if (!flag) {
          let j1 = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) - 80;
          const i2 = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) + 50;
          this.titleboxButtonImage.drawImage(j1 - 73, i2 - 20);
          this.fontBold.drawStringCenter("Login", j1, i2 + 5, 16777215, true);
          j1 = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) + 80;
          this.titleboxButtonImage.drawImage(j1 - 73, i2 - 20);
          this.fontBold.drawStringCenter("Cancel", j1, i2 + 5, 16777215, true);
        }
      }
      if (this.loginScreenState === 3) {
        this.fontBold.drawStringCenter(
          "Create a free account",
          ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
          (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) - 60,
          16776960,
          true
        );
        let l = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) - 35;
        this.fontBold.drawStringCenter(
          "To create a new account you need to",
          ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
          l,
          16777215,
          true
        );
        l += 15;
        this.fontBold.drawStringCenter(
          "go back to the main RuneScape webpage",
          ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
          l,
          16777215,
          true
        );
        l += 15;
        this.fontBold.drawStringCenter(
          "and choose the 'create account'",
          ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
          l,
          16777215,
          true
        );
        l += 15;
        this.fontBold.drawStringCenter(
          "button near the top of that page.",
          ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
          l,
          16777215,
          true
        );
        l += 15;
        const k1 = ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0;
        const j2 = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) + 50;
        this.titleboxButtonImage.drawImage(k1 - 73, j2 - 20);
        this.fontBold.drawStringCenter("Cancel", k1, j2 + 5, 16777215, true);
      }
      this.aClass18_1200.drawGraphics(202, 171, this.gameGraphics);
      if (this.aBoolean1046) {
        this.aBoolean1046 = false;
        this.aClass18_1198.drawGraphics(128, 0, this.gameGraphics);
        this.aClass18_1199.drawGraphics(202, 371, this.gameGraphics);
        this.aClass18_1203.drawGraphics(0, 265, this.gameGraphics);
        this.aClass18_1204.drawGraphics(562, 265, this.gameGraphics);
        this.aClass18_1205.drawGraphics(128, 171, this.gameGraphics);
        this.aClass18_1206.drawGraphics(562, 171, this.gameGraphics);
      }
    }
    drawError() {
      const g = this.gameGraphics;
      g.setColor(Color.black);
      g.fillRect(0, 0, 765, 503);
      this.setFrameRate(1);
      if (this.startUpError) {
        this.startedRenderingFlames = false;
        g.setFont(new Font("Helvetica", 1, 16));
        g.setColor(Color.yellow);
        let j = 35;
        g.drawString("Sorry, an error has occured whilst loading RuneScape", 30, j);
        j += 50;
        g.setColor(Color.white);
        g.drawString("To fix this try the following (in order):", 30, j);
        j += 50;
        g.setColor(Color.white);
        g.setFont(new Font("Helvetica", 1, 12));
        g.drawString("1: Try closing ALL open web-browser windows, and reloading", 30, j);
        j += 30;
        g.drawString("2: Try clearing your web-browsers cache from tools->internet options", 30, j);
        j += 30;
        g.drawString("3: Try using a different game-world", 30, j);
        j += 30;
        g.drawString("4: Try rebooting your computer", 30, j);
        j += 30;
        g.drawString("5: Try selecting a different version of Java from the play-game menu", 30, j);
      }
      if (this.aBoolean1097) {
        this.startedRenderingFlames = false;
        g.setFont(new Font("Helvetica", 1, 20));
        g.setColor(Color.white);
        g.drawString("Error - unable to load game!", 50, 50);
        g.drawString("To play RuneScape make sure you play from", 50, 100);
        g.drawString("http://www.runescape.com", 50, 150);
      }
      if (this.aBoolean1016) {
        this.startedRenderingFlames = false;
        g.setColor(Color.yellow);
        let k = 35;
        g.drawString("Error a copy of RuneScape already appears to be loaded", 30, k);
        k += 50;
        g.setColor(Color.white);
        g.drawString("To fix this try the following (in order):", 30, k);
        k += 50;
        g.setColor(Color.white);
        g.setFont(new Font("Helvetica", 1, 12));
        g.drawString("1: Try closing ALL open web-browser windows, and reloading", 30, k);
        k += 30;
        g.drawString("2: Try rebooting your computer, and reloading", 30, k);
        k += 30;
      }
    }
    async method149(i) {
      while (i >= 0) {
        this.opcode = this.buffer.getUnsignedByte();
      }
      if (this.loginScreenState === 0) {
        let j = (this.width / 2 | 0) - 80;
        let i1 = (this.height / 2 | 0) + 20;
        i1 += 20;
        if (this.clickType === 1 && this.clickX >= j - 75 && this.clickX <= j + 75 && this.clickY >= i1 - 20 && this.clickY <= i1 + 20) {
          this.loginScreenState = 3;
          this.anInt977 = 0;
        }
        j = (this.width / 2 | 0) + 80;
        if (this.clickType === 1 && this.clickX >= j - 75 && this.clickX <= j + 75 && this.clickY >= i1 - 20 && this.clickY <= i1 + 20) {
          this.statusLineOne = "";
          this.statusLineTwo = "Enter your username & password.";
          this.loginScreenState = 2;
          this.anInt977 = 0;
          return;
        }
      } else {
        if (this.loginScreenState === 2) {
          let k = (this.height / 2 | 0) - 40;
          k += 30;
          k += 25;
          if (this.clickType === 1 && this.clickY >= k - 15 && this.clickY < k) {
            this.anInt977 = 0;
          }
          k += 15;
          if (this.clickType === 1 && this.clickY >= k - 15 && this.clickY < k) {
            this.anInt977 = 1;
          }
          k += 15;
          let j1 = (this.width / 2 | 0) - 80;
          let l1 = (this.height / 2 | 0) + 50;
          l1 += 20;
          if (this.clickType === 1 && this.clickX >= j1 - 75 && this.clickX <= j1 + 75 && this.clickY >= l1 - 20 && this.clickY <= l1 + 20) {
            this.anInt850 = 0;
            await this.login(this.username, this.password, false);
            if (this.loggedIn) {
              return;
            }
          }
          j1 = (this.width / 2 | 0) + 80;
          if (this.clickType === 1 && this.clickX >= j1 - 75 && this.clickX <= j1 + 75 && this.clickY >= l1 - 20 && this.clickY <= l1 + 20) {
            this.loginScreenState = 0;
            this.username = "";
            this.password = "";
          }
          do {
            {
              const i2 = this.readCharacter();
              if (i2 === -1) {
                break;
              }
              let flag = false;
              for (let j2 = 0; j2 < _Game.VALID_CHARACTERS.length; j2++) {
                {
                  if (i2 != ((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(_Game.VALID_CHARACTERS.charAt(j2))) {
                    continue;
                  }
                  flag = true;
                  break;
                }
              }
              if (this.anInt977 === 0) {
                if (i2 === 8 && this.username.length > 0) {
                  this.username = this.username.substring(0, this.username.length - 1);
                }
                if (i2 === 9 || i2 === 10 || i2 === 13) {
                  this.anInt977 = 1;
                }
                if (flag) {
                  this.username += String.fromCharCode(i2);
                }
                if (this.username.length > 12) {
                  this.username = this.username.substring(0, 12);
                }
              } else if (this.anInt977 === 1) {
                if (i2 === 8 && this.password.length > 0) {
                  this.password = this.password.substring(0, this.password.length - 1);
                }
                if (i2 === 9 || i2 === 10 || i2 === 13) {
                  this.anInt977 = 0;
                }
                if (flag) {
                  this.password += String.fromCharCode(i2);
                }
                if (this.password.length > 20) {
                  this.password = this.password.substring(0, 20);
                }
              }
            }
          } while (true);
          return;
        }
        if (this.loginScreenState === 3) {
          const l = this.width / 2 | 0;
          let k1 = (this.height / 2 | 0) + 50;
          k1 += 20;
          if (this.clickType === 1 && this.clickX >= l - 75 && this.clickX <= l + 75 && this.clickY >= k1 - 20 && this.clickY <= k1 + 20) {
            this.loginScreenState = 0;
          }
        }
      }
    }
    async login(username, password, reconnecting) {
      SignLink.errorName = username;
      try {
        if (!reconnecting) {
          this.statusLineOne = "";
          this.statusLineTwo = "Connecting to server...";
          await this.drawLoginScreen(true);
        }
        this.gameConnection = new BufferedConnection(this, await this.openSocket(Configuration.GAME_PORT + _Game.portOffset));
        const base37name = TextUtils.nameToLong(username);
        const hash = base37name.shiftRight(16).toNumber() & 31 | 0;
        this.outBuffer.currentPosition = 0;
        this.outBuffer.putByte(14);
        this.outBuffer.putByte(hash);
        this.gameConnection.write(2, 0, this.outBuffer.buffer);
        for (let j = 0; j < 8; j++) {
          await this.gameConnection.read$();
        }
        let responseCode = await this.gameConnection.read$();
        const initialResponseCode = responseCode;
        if (responseCode === 0) {
          await this.gameConnection.read$byte_A$int$int(this.buffer.buffer, 0, 8);
          this.buffer.currentPosition = 0;
          const seed = [0, 0, 0, 0];
          seed[0] = Math.random() * 99999999 | 0;
          seed[1] = Math.random() * 99999999 | 0;
          seed[2] = this.buffer.getInt();
          seed[3] = this.buffer.getInt();
          this.outBuffer.currentPosition = 0;
          this.outBuffer.putByte(10);
          this.outBuffer.putInt(seed[0]);
          this.outBuffer.putInt(seed[1]);
          this.outBuffer.putInt(seed[2]);
          this.outBuffer.putInt(seed[3]);
          this.outBuffer.putInt(SignLink.uid);
          this.outBuffer.putString(username);
          this.outBuffer.putString(password);
          if (Configuration.RSA_ENABLED) {
            this.outBuffer.encrypt(Configuration.RSA_MODULUS, Configuration.RSA_PUBLIC_KEY);
          }
          this.tempBuffer.currentPosition = 0;
          if (reconnecting) {
            this.tempBuffer.putByte(18);
          } else {
            this.tempBuffer.putByte(16);
          }
          this.tempBuffer.putByte(this.outBuffer.currentPosition + 36 + 1 + 1 + 2);
          this.tempBuffer.putByte(255);
          this.tempBuffer.putShort(SignLink.CLIENT_REVISION);
          this.tempBuffer.putByte(_Game.lowMemory ? 1 : 0);
          for (let i = 0; i < 9; i++) {
            this.tempBuffer.putInt(this.archiveHashes[i]);
          }
          this.tempBuffer.putBytes(this.outBuffer.buffer, 0, this.outBuffer.currentPosition);
          this.outBuffer.random = new ISAACCipher(seed);
          for (let i = 0; i < 4; i++) {
            seed[i] += 50;
          }
          this.incomingRandom = new ISAACCipher(seed);
          this.gameConnection.write(this.tempBuffer.currentPosition, 0, this.tempBuffer.buffer);
          responseCode = await this.gameConnection.read$();
        }
        if (responseCode === 1) {
          try {
            await sleep(500);
          } catch (ignored) {
          }
          this.login(username, password, reconnecting);
          return;
        }
        if (responseCode === 2) {
          this.playerRights = await this.gameConnection.read$();
          _Game.accountFlagged = await this.gameConnection.read$() === 1;
          this.aLong902 = 0;
          this.duplicateClickCount = 0;
          this.mouseCapturer.coord = 0;
          this.awtFocus = true;
          this.aBoolean1275 = true;
          this.loggedIn = true;
          this.outBuffer.currentPosition = 0;
          this.buffer.currentPosition = 0;
          this.opcode = -1;
          this.lastOpcode = -1;
          this.secondLastOpcode = -1;
          this.thirdLastOpcode = -1;
          this.packetSize = 0;
          this.timeoutCounter = 0;
          this.systemUpdateTime = 0;
          this.anInt873 = 0;
          this.anInt1197 = 0;
          this.menuActionRow = 0;
          this.menuOpen = false;
          this.idleTime = 0;
          for (let j1 = 0; j1 < 100; j1++) {
            this.chatMessages[j1] = null;
          }
          this.itemSelected = 0;
          this.widgetSelected = 0;
          this.loadingStage = 0;
          this.currentSound = 0;
          this.anInt850 = (Math.random() * 100 | 0) - 50;
          this.anInt1009 = (Math.random() * 110 | 0) - 55;
          this.anInt1255 = (Math.random() * 80 | 0) - 40;
          this.anInt916 = (Math.random() * 120 | 0) - 60;
          this.anInt1233 = (Math.random() * 30 | 0) - 20;
          this.cameraHorizontal = (Math.random() * 20 | 0) - 10 & 2047;
          this.minimapState = 0;
          this.anInt1276 = -1;
          this.destinationX = 0;
          this.destinationY = 0;
          this.localPlayerCount = 0;
          this.anInt1133 = 0;
          for (let i2 = 0; i2 < this.anInt968; i2++) {
            {
              this.players[i2] = null;
              this.cachedAppearances[i2] = null;
            }
          }
          for (let k2 = 0; k2 < 16384; k2++) {
            this.npcs[k2] = null;
          }
          _Game.localPlayer = this.players[this.thisPlayerId] = new Player();
          this.aClass6_1282.getNodeCount();
          this.aClass6_1210.getNodeCount();
          for (let l2 = 0; l2 < 4; l2++) {
            {
              for (let i3 = 0; i3 < 104; i3++) {
                {
                  for (let k3 = 0; k3 < 104; k3++) {
                    this.groundItems[l2][i3][k3] = null;
                  }
                }
              }
            }
          }
          this.aClass6_1261 = new LinkedList();
          this.friendListStatus = 0;
          this.friendsCount = 0;
          this.method44(_Game.aBoolean1190, this.dialogueId);
          this.dialogueId = -1;
          this.method44(_Game.aBoolean1190, this.backDialogueId);
          this.backDialogueId = -1;
          this.method44(_Game.aBoolean1190, this.openInterfaceId);
          this.openInterfaceId = -1;
          this.method44(_Game.aBoolean1190, this.anInt1053);
          this.anInt1053 = -1;
          this.method44(_Game.aBoolean1190, this.anInt960);
          this.anInt960 = -1;
          this.method44(_Game.aBoolean1190, this.anInt1089);
          this.anInt1089 = -1;
          this.method44(_Game.aBoolean1190, this.anInt1279);
          this.anInt1279 = -1;
          this.aBoolean1239 = false;
          this.anInt1285 = 3;
          this.inputType = 0;
          this.menuOpen = false;
          this.messagePromptRaised = false;
          this.clickToContinueString = null;
          this.anInt1319 = 0;
          this.anInt1213 = -1;
          this.characterEditChangeGenger = true;
          this.method25();
          for (let j3 = 0; j3 < 5; j3++) {
            this.characterEditColors[j3] = 0;
          }
          for (let l3 = 0; l3 < 5; l3++) {
            {
              this.aStringArray1069[l3] = null;
              this.aBooleanArray1070[l3] = false;
            }
          }
          _Game.anInt1100 = 0;
          _Game.anInt1165 = 0;
          _Game.anInt1235 = 0;
          _Game.anInt1052 = 0;
          _Game.anInt1139 = 0;
          _Game.anInt841 = 0;
          _Game.anInt1230 = 0;
          _Game.anInt1013 = 0;
          _Game.anInt1049 = 0;
          _Game.anInt1162 = 0;
          await this.method122();
          return;
        }
        if (responseCode === 3) {
          this.statusLineOne = "";
          this.statusLineTwo = "Invalid username or password.";
          return;
        }
        if (responseCode === 4) {
          this.statusLineOne = "Your account has been disabled.";
          this.statusLineTwo = "Please check your message-centre for details.";
          return;
        }
        if (responseCode === 5) {
          this.statusLineOne = "Your account is already logged in.";
          this.statusLineTwo = "Try again in 60 secs...";
          return;
        }
        if (responseCode === 6) {
          this.statusLineOne = "RuneScape has been updated!";
          this.statusLineTwo = "Please reload this page.";
          return;
        }
        if (responseCode === 7) {
          this.statusLineOne = "This world is full.";
          this.statusLineTwo = "Please use a different world.";
          return;
        }
        if (responseCode === 8) {
          this.statusLineOne = "Unable to connect.";
          this.statusLineTwo = "Login server offline.";
          return;
        }
        if (responseCode === 9) {
          this.statusLineOne = "Login limit exceeded.";
          this.statusLineTwo = "Too many connections from your address.";
          return;
        }
        if (responseCode === 10) {
          this.statusLineOne = "Unable to connect.";
          this.statusLineTwo = "Bad session id.";
          return;
        }
        if (responseCode === 12) {
          this.statusLineOne = "You need a members account to login to this world.";
          this.statusLineTwo = "Please subscribe, or use a different world.";
          return;
        }
        if (responseCode === 13) {
          this.statusLineOne = "Could not complete login.";
          this.statusLineTwo = "Please try using a different world.";
          return;
        }
        if (responseCode === 14) {
          this.statusLineOne = "The server is being updated.";
          this.statusLineTwo = "Please wait 1 minute and try again.";
          return;
        }
        if (responseCode === 15) {
          this.loggedIn = true;
          this.outBuffer.currentPosition = 0;
          this.buffer.currentPosition = 0;
          this.opcode = -1;
          this.lastOpcode = -1;
          this.secondLastOpcode = -1;
          this.thirdLastOpcode = -1;
          this.packetSize = 0;
          this.timeoutCounter = 0;
          this.systemUpdateTime = 0;
          this.menuActionRow = 0;
          this.menuOpen = false;
          this.aLong1229 = new Date().getTime();
          return;
        }
        if (responseCode === 16) {
          this.statusLineOne = "Login attempts exceeded.";
          this.statusLineTwo = "Please wait 1 minute and try again.";
          return;
        }
        if (responseCode === 17) {
          this.statusLineOne = "You are standing in a members-only area.";
          this.statusLineTwo = "To play on this world move to a free area first";
          return;
        }
        if (responseCode === 18) {
          this.statusLineOne = "Account locked as we suspect it has been stolen.";
          this.statusLineTwo = "Press 'recover a locked account' on front page.";
          return;
        }
        if (responseCode === 20) {
          this.statusLineOne = "Invalid loginserver requested";
          this.statusLineTwo = "Please try using a different world.";
          return;
        }
        if (responseCode === 21) {
          let time = await this.gameConnection.read$();
          for (time += 3; time >= 0; time--) {
            {
              this.statusLineOne = "You have only just left another world";
              this.statusLineTwo = "Your profile will be transferred in: " + time;
              await this.drawLoginScreen(true);
              try {
                await sleep(1200);
              } catch (ignored) {
              }
            }
          }
          this.login(username, password, reconnecting);
          return;
        }
        if (responseCode === 22) {
          this.statusLineOne = "Malformed login packet.";
          this.statusLineTwo = "Please try again.";
          return;
        }
        if (responseCode === 23) {
          this.statusLineOne = "No reply from loginserver.";
          this.statusLineTwo = "Please try again.";
          return;
        }
        if (responseCode === 24) {
          this.statusLineOne = "Error loading your profile.";
          this.statusLineTwo = "Please contact customer support.";
          return;
        }
        if (responseCode === 25) {
          this.statusLineOne = "Unexpected loginserver response.";
          this.statusLineTwo = "Please try using a different world.";
          return;
        }
        if (responseCode === 26) {
          this.statusLineOne = "This computers address has been blocked";
          this.statusLineTwo = "as it was used to break our rules";
          return;
        }
        if (responseCode === -1) {
          if (initialResponseCode === 0) {
            if (this.anInt850 < 2) {
              try {
                await sleep(2e3);
              } catch (ignored) {
              }
              this.anInt850++;
              this.login(username, password, reconnecting);
              return;
            } else {
              this.statusLineOne = "No response from loginserver";
              this.statusLineTwo = "Please wait 1 minute and try again.";
              return;
            }
          } else {
            this.statusLineOne = "No response from server";
            this.statusLineTwo = "Please try using a different world.";
            return;
          }
        } else {
          console.info("response:" + responseCode);
          this.statusLineOne = "Unexpected server response";
          this.statusLineTwo = "Please try using a different world.";
          return;
        }
      } catch (ex) {
        this.statusLineOne = "";
      }
      this.statusLineTwo = "Error connecting to server.";
    }
    async processGame() {
      if (this.systemUpdateTime > 1) {
        this.systemUpdateTime--;
      }
      if (this.anInt873 > 0) {
        this.anInt873--;
      }
      for (let i = 0; i < 5; i++) {
        if (!await this.parseIncomingPacket()) {
          break;
        }
      }
      if (!this.loggedIn) {
        return;
      }
      {
        if (_Game.accountFlagged) {
          if (this.clickType !== 0 || this.mouseCapturer.coord >= 40) {
            this.outBuffer.putOpcode(171);
            this.outBuffer.putByte(0);
            const i2 = this.outBuffer.currentPosition;
            let i3 = 0;
            for (let i4 = 0; i4 < this.mouseCapturer.coord; i4++) {
              {
                if (i2 - this.outBuffer.currentPosition >= 240) {
                  break;
                }
                i3++;
                let k4 = this.mouseCapturer.coordsY[i4];
                if (k4 < 0) {
                  k4 = 0;
                } else if (k4 > 502) {
                  k4 = 502;
                }
                let j5 = this.mouseCapturer.coordsX[i4];
                if (j5 < 0) {
                  j5 = 0;
                } else if (j5 > 764) {
                  j5 = 764;
                }
                let l5 = k4 * 765 + j5;
                if (this.mouseCapturer.coordsY[i4] === -1 && this.mouseCapturer.coordsX[i4] === -1) {
                  j5 = -1;
                  k4 = -1;
                  l5 = 524287;
                }
                if (j5 === this.anInt1011 && k4 === this.anInt1012) {
                  if (this.duplicateClickCount < 2047) {
                    this.duplicateClickCount++;
                  }
                } else {
                  let i6 = j5 - this.anInt1011;
                  this.anInt1011 = j5;
                  let j6 = k4 - this.anInt1012;
                  this.anInt1012 = k4;
                  if (this.duplicateClickCount < 8 && i6 >= -32 && i6 <= 31 && j6 >= -32 && j6 <= 31) {
                    i6 += 32;
                    j6 += 32;
                    this.outBuffer.putShort((this.duplicateClickCount << 12) + (i6 << 6) + j6);
                    this.duplicateClickCount = 0;
                  } else if (this.duplicateClickCount < 8) {
                    this.outBuffer.putTriByte(8388608 + (this.duplicateClickCount << 19) + l5);
                    this.duplicateClickCount = 0;
                  } else {
                    this.outBuffer.putInt(-1073741824 + (this.duplicateClickCount << 19) + l5);
                    this.duplicateClickCount = 0;
                  }
                }
              }
            }
            this.outBuffer.putLength(this.outBuffer.currentPosition - i2);
            if (i3 >= this.mouseCapturer.coord) {
              this.mouseCapturer.coord = 0;
            } else {
              this.mouseCapturer.coord -= i3;
              for (let l4 = 0; l4 < this.mouseCapturer.coord; l4++) {
                {
                  this.mouseCapturer.coordsX[l4] = this.mouseCapturer.coordsX[l4 + i3];
                  this.mouseCapturer.coordsY[l4] = this.mouseCapturer.coordsY[l4 + i3];
                }
              }
            }
          }
        } else {
          this.mouseCapturer.coord = 0;
        }
      }
      if (this.clickType !== 0) {
        let l = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))((this.clickTime - this.aLong902) / 50);
        if (l > 4095) {
          l = 4095;
        }
        this.aLong902 = this.clickTime;
        let j2 = this.clickY;
        if (j2 < 0) {
          j2 = 0;
        } else if (j2 > 502) {
          j2 = 502;
        }
        let j3 = this.clickX;
        if (j3 < 0) {
          j3 = 0;
        } else if (j3 > 764) {
          j3 = 764;
        }
        const j4 = j2 * 765 + j3;
        let i5 = 0;
        if (this.clickType === 2) {
          i5 = 1;
        }
        const k5 = l | 0;
        this.outBuffer.putOpcode(19);
        this.outBuffer.putInt((k5 << 20) + (i5 << 19) + j4);
      }
      if (this.anInt1264 > 0) {
        this.anInt1264--;
      }
      if (this.keyStatus[1] === 1 || this.keyStatus[2] === 1 || this.keyStatus[3] === 1 || this.keyStatus[4] === 1) {
        this.aBoolean1265 = true;
      }
      if (this.aBoolean1265 && this.anInt1264 <= 0) {
        this.anInt1264 = 20;
        this.aBoolean1265 = false;
        this.outBuffer.putOpcode(140);
        this.outBuffer.putLEShortDup(this.anInt1251);
        this.outBuffer.putLEShortDup(this.cameraHorizontal);
      }
      if (this.awtFocus && !this.aBoolean1275) {
        this.aBoolean1275 = true;
        this.outBuffer.putOpcode(187);
        this.outBuffer.putByte(1);
      }
      if (!this.awtFocus && this.aBoolean1275) {
        this.aBoolean1275 = false;
        this.outBuffer.putOpcode(187);
        this.outBuffer.putByte(0);
      }
      this.method143(-40 | 0);
      this.method36(16220);
      this.method152();
      this.timeoutCounter++;
      if (this.timeoutCounter > 750) {
        this.dropClient();
      }
      this.method100(0);
      this.method67(-37214);
      this.processActorOverheadText();
      this.tickDelta++;
      if (this.crossType !== 0) {
        this.crossIndex += 20;
        if (this.crossIndex >= 400) {
          this.crossType = 0;
        }
      }
      if (this.atInventoryInterfaceType !== 0) {
        this.atInventoryLoopCycle++;
        if (this.atInventoryLoopCycle >= 15) {
          if (this.atInventoryInterfaceType === 2) {
            this.redrawTabArea = true;
          }
          if (this.atInventoryInterfaceType === 3) {
            this.redrawChatbox = true;
          }
          this.atInventoryInterfaceType = 0;
        }
      }
      if (this.activeInterfaceType !== 0) {
        this.anInt1269++;
        if (this.mouseX > this.anInt1114 + 5 || this.mouseX < this.anInt1114 - 5 || this.mouseY > this.anInt1115 + 5 || this.mouseY < this.anInt1115 - 5) {
          this.aBoolean1155 = true;
        }
        if (this.mouseButtonPressed === 0) {
          if (this.activeInterfaceType === 2) {
            this.redrawTabArea = true;
          }
          if (this.activeInterfaceType === 3) {
            this.redrawChatbox = true;
          }
          this.activeInterfaceType = 0;
          if (this.aBoolean1155 && this.anInt1269 >= 5) {
            this.lastActiveInvInterface = -1;
            this.processRightClick(-521);
            if (this.lastActiveInvInterface === this.modifiedWidgetId && this.mouseInvInterfaceIndex !== this.selectedInventorySlot) {
              const childInterface = Widget.forId(this.modifiedWidgetId);
              let i1 = 0;
              if (this.anInt955 === 1 && childInterface.contentType === 206) {
                i1 = 1;
              }
              if (childInterface.items[this.mouseInvInterfaceIndex] <= 0) {
                i1 = 0;
              }
              if (childInterface.itemDeletesDraged) {
                const k2 = this.selectedInventorySlot;
                const k3 = this.mouseInvInterfaceIndex;
                childInterface.items[k3] = childInterface.items[k2];
                childInterface.itemAmounts[k3] = childInterface.itemAmounts[k2];
                childInterface.items[k2] = -1;
                childInterface.itemAmounts[k2] = 0;
              } else if (i1 === 1) {
                let l2 = this.selectedInventorySlot;
                for (const l3 = this.mouseInvInterfaceIndex; l2 !== l3; ) {
                  if (l2 > l3) {
                    childInterface.swapItems(l2, l2 - 1);
                    l2--;
                  } else if (l2 < l3) {
                    childInterface.swapItems(l2, l2 + 1);
                    l2++;
                  }
                }
              } else {
                childInterface.swapItems(this.selectedInventorySlot, this.mouseInvInterfaceIndex);
              }
              this.outBuffer.putOpcode(123);
              this.outBuffer.putLEShortAdded(this.mouseInvInterfaceIndex);
              this.outBuffer.putByteAdded(i1);
              this.outBuffer.putShortAdded(this.modifiedWidgetId);
              this.outBuffer.putLEShortDup(this.selectedInventorySlot);
            }
          } else if ((this.anInt1300 === 1 || this.menuHasAddFriend(this.menuActionRow - 1, this.aByte1161)) && this.menuActionRow > 2) {
            this.determineMenuSize();
          } else if (this.menuActionRow > 0) {
            this.processMenuActions(this.menuActionRow - 1);
          }
          this.atInventoryLoopCycle = 10;
          this.clickType = 0;
        }
      }
      if (Scene.clickedTileX !== -1) {
        const dstX = Scene.clickedTileX;
        const dstY = Scene.anInt486;
        const flag = this.walk(
          true,
          false,
          dstY,
          _Game.localPlayer.pathY[0],
          0,
          0,
          0,
          0,
          dstX,
          0,
          0,
          _Game.localPlayer.pathX[0]
        );
        Scene.clickedTileX = -1;
        if (flag) {
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 1;
          this.crossIndex = 0;
        }
      }
      if (this.clickType === 1 && this.clickToContinueString != null) {
        this.clickToContinueString = null;
        this.redrawChatbox = true;
        this.clickType = 0;
      }
      this.processMenuClick();
      if (this.anInt1053 === -1) {
        this.method146(4 | 0);
        this.method21(false);
        this.method39(true);
      }
      if (this.mouseButtonPressed === 1 || this.clickType === 1) {
        this.anInt1094++;
      }
      if (this.anInt1284 !== 0 || this.anInt1044 !== 0 || this.anInt1129 !== 0) {
        if (this.anInt893 < 100) {
          this.anInt893++;
          if (this.anInt893 === 100) {
            if (this.anInt1284 !== 0) {
              this.redrawChatbox = true;
            }
            if (this.anInt1044 !== 0) {
              this.redrawTabArea = true;
            }
          }
        }
      } else if (this.anInt893 > 0) {
        this.anInt893--;
      }
      if (this.loadingStage === 2) {
        this.checkForGameUsages(409);
      }
      if (this.loadingStage === 2 && this.oriented) {
        this.calculateCameraPosition();
      }
      for (let k = 0; k < 5; k++) {
        this.quakeTimes[k]++;
      }
      this.manageTextInputs();
      this.idleTime++;
      if (this.idleTime > 4500) {
        this.anInt873 = 250;
        this.idleTime -= 500;
        this.outBuffer.putOpcode(202);
      }
      this.anInt1118++;
      if (this.anInt1118 > 500) {
        this.anInt1118 = 0;
        const k1 = Math.random() * 8 | 0;
        if ((k1 & 1) === 1) {
          this.anInt853 += this.anInt854;
        }
        if ((k1 & 2) === 2) {
          this.anInt1009 += this.anInt1010;
        }
        if ((k1 & 4) === 4) {
          this.anInt1255 += this.anInt1256;
        }
      }
      if (this.anInt853 < -50) {
        this.anInt854 = 2;
      }
      if (this.anInt853 > 50) {
        this.anInt854 = -2;
      }
      if (this.anInt1009 < -55) {
        this.anInt1010 = 2;
      }
      if (this.anInt1009 > 55) {
        this.anInt1010 = -2;
      }
      if (this.anInt1255 < -40) {
        this.anInt1256 = 1;
      }
      if (this.anInt1255 > 40) {
        this.anInt1256 = -1;
      }
      this.anInt1045++;
      if (this.anInt1045 > 500) {
        this.anInt1045 = 0;
        const l1 = Math.random() * 8 | 0;
        if ((l1 & 1) === 1) {
          this.anInt916 += this.anInt917;
        }
        if ((l1 & 2) === 2) {
          this.anInt1233 += this.anInt1234;
        }
      }
      if (this.anInt916 < -60) {
        this.anInt917 = 2;
      }
      if (this.anInt916 > 60) {
        this.anInt917 = -2;
      }
      if (this.anInt1233 < -20) {
        this.anInt1234 = 1;
      }
      if (this.anInt1233 > 10) {
        this.anInt1234 = -1;
      }
      this.anInt872++;
      if (this.anInt872 > 50) {
        this.outBuffer.putOpcode(40);
      }
      try {
        if (this.gameConnection != null && this.outBuffer.currentPosition > 0) {
          this.gameConnection.write(this.outBuffer.currentPosition, 0, this.outBuffer.buffer);
          this.outBuffer.currentPosition = 0;
          this.anInt872 = 0;
          return;
        }
      } catch (__e) {
        if (__e != null && __e instanceof Error) {
          const exception = __e;
          this.logout();
        }
      }
    }
    method138() {
      console.info("============");
      console.info("flame-cycle:" + this.flameCycle);
      if (this.onDemandRequester != null) {
        console.info("Od-cycle:" + this.onDemandRequester.cycle);
      }
      console.info("loop-cycle:" + _Game.pulseCycle);
      console.info("draw-cycle:" + _Game.anInt1309);
      console.info("ptype:" + this.opcode);
      console.info("psize:" + this.packetSize);
      if (this.gameConnection != null) {
        this.gameConnection.printDebug();
      }
      this.dumpRequested = true;
    }
    manageTextInputs() {
      while (true) {
        {
          const key = this.readCharacter();
          if (key === -1) {
            break;
          }
          if (this.openInterfaceId !== -1 && this.openInterfaceId === this.reportAbuseInterfaceID) {
            if (key === 8 && this.reportedName.length > 0) {
              this.reportedName = this.reportedName.substring(0, this.reportedName.length - 1);
            }
            if ((key >= 97 && key <= 122 || key >= 65 && key <= 90 || key >= 48 && key <= 57 || key === 32) && this.reportedName.length < 12) {
              this.reportedName += String.fromCharCode(key);
            }
          } else if (this.messagePromptRaised) {
            if (key >= 32 && key <= 122 && this.chatMessage.length < 80) {
              this.chatMessage += String.fromCharCode(key);
              this.redrawChatbox = true;
            }
            if (key === 8 && this.chatMessage.length > 0) {
              this.chatMessage = this.chatMessage.substring(0, this.chatMessage.length - 1);
              this.redrawChatbox = true;
            }
            if (key === 13 || key === 10) {
              this.messagePromptRaised = false;
              this.redrawChatbox = true;
              if (this.friendsListAction === 1) {
                const l = TextUtils.nameToLong(this.chatMessage);
                this.addFriend(l);
              }
              if (this.friendsListAction === 2 && this.friendsCount > 0) {
                const l1 = TextUtils.nameToLong(this.chatMessage);
                this.removeFriend(l1);
              }
              if (this.friendsListAction === 3 && this.chatMessage.length > 0) {
                this.outBuffer.putOpcode(227);
                this.outBuffer.putByte(0);
                const j = this.outBuffer.currentPosition;
                this.outBuffer.putLong(this.aLong1141);
                ChatEncoder.put(this.chatMessage, this.outBuffer);
                this.outBuffer.putLength(this.outBuffer.currentPosition - j);
                this.chatMessage = ChatEncoder.formatChatMessage(this.chatMessage);
                this.addChatMessage(TextUtils.formatName(TextUtils.longToName(this.aLong1141)), this.chatMessage, 6);
                if (this.privateChatMode === 2) {
                  this.privateChatMode = 1;
                  this.aBoolean1212 = true;
                  this.outBuffer.putOpcode(176);
                  this.outBuffer.putByte(this.publicChatMode);
                  this.outBuffer.putByte(this.privateChatMode);
                  this.outBuffer.putByte(this.tradeMode);
                }
              }
              if (this.friendsListAction === 4 && this.ignoresCount < 100) {
                const l2 = TextUtils.nameToLong(this.chatMessage);
                this.addIgnore(this.anInt1154, l2);
              }
              if (this.friendsListAction === 5 && this.ignoresCount > 0) {
                const l3 = TextUtils.nameToLong(this.chatMessage);
                this.removeIgnore(l3);
              }
            }
          } else if (this.inputType === 1) {
            if (key >= 48 && key <= 57 && this.inputInputMessage.length < 10) {
              this.inputInputMessage += String.fromCharCode(key);
              this.redrawChatbox = true;
            }
            if (key === 8 && this.inputInputMessage.length > 0) {
              this.inputInputMessage = this.inputInputMessage.substring(0, this.inputInputMessage.length - 1);
              this.redrawChatbox = true;
            }
            if (key === 13 || key === 10) {
              if (this.inputInputMessage.length > 0) {
                let k = 0;
                try {
                  k = parseInt(this.inputInputMessage);
                } catch (_ex) {
                }
                this.outBuffer.putOpcode(75);
                this.outBuffer.putInt(k);
              }
              this.inputType = 0;
              this.redrawChatbox = true;
            }
          } else if (this.inputType === 2) {
            if (key >= 32 && key <= 122 && this.inputInputMessage.length < 12) {
              this.inputInputMessage += String.fromCharCode(key);
              this.redrawChatbox = true;
            }
            if (key === 8 && this.inputInputMessage.length > 0) {
              this.inputInputMessage = this.inputInputMessage.substring(0, this.inputInputMessage.length - 1);
              this.redrawChatbox = true;
            }
            if (key === 13 || key === 10) {
              if (this.inputInputMessage.length > 0) {
                this.outBuffer.putOpcode(206);
                this.outBuffer.putLong(TextUtils.nameToLong(this.inputInputMessage));
              }
              this.inputType = 0;
              this.redrawChatbox = true;
            }
          } else if (this.inputType === 3) {
            if (key >= 32 && key <= 122 && this.inputInputMessage.length < 40) {
              this.inputInputMessage += String.fromCharCode(key);
              this.redrawChatbox = true;
            }
            if (key === 8 && this.inputInputMessage.length > 0) {
              this.inputInputMessage = this.inputInputMessage.substring(0, this.inputInputMessage.length - 1);
              this.redrawChatbox = true;
            }
          } else if (this.backDialogueId === -1 && this.anInt1053 === -1) {
            if (key >= 32 && key <= 122 && this.chatboxInput.length < 80) {
              this.chatboxInput += String.fromCharCode(key);
              this.redrawChatbox = true;
            }
            if (key === 8 && this.chatboxInput.length > 0) {
              this.chatboxInput = this.chatboxInput.substring(0, this.chatboxInput.length - 1);
              this.redrawChatbox = true;
            }
            if ((key === 13 || key === 10) && this.chatboxInput.length > 0) {
              if (this.playerRights === 2) {
                if (((o1, o2) => {
                  if (o1 && o1.equals) {
                    return o1.equals(o2);
                  } else {
                    return o1 === o2;
                  }
                })(this.chatboxInput, "::clientdrop")) {
                  this.dropClient();
                }
                if (((o1, o2) => {
                  if (o1 && o1.equals) {
                    return o1.equals(o2);
                  } else {
                    return o1 === o2;
                  }
                })(this.chatboxInput, "::lag")) {
                  this.method138();
                }
                if (((o1, o2) => {
                  if (o1 && o1.equals) {
                    return o1.equals(o2);
                  } else {
                    return o1 === o2;
                  }
                })(this.chatboxInput, "::prefetchmusic")) {
                  for (let i_417_ = 0; i_417_ < this.onDemandRequester.fileCount(2); i_417_++) {
                    this.onDemandRequester.setPriority(1 | 0, 2, i_417_);
                  }
                }
                if (((o1, o2) => {
                  if (o1 && o1.equals) {
                    return o1.equals(o2);
                  } else {
                    return o1 === o2;
                  }
                })(this.chatboxInput, "::fpson")) {
                  _Game.fps = true;
                }
                if (((o1, o2) => {
                  if (o1 && o1.equals) {
                    return o1.equals(o2);
                  } else {
                    return o1 === o2;
                  }
                })(this.chatboxInput, "::fpsoff")) {
                  _Game.fps = false;
                }
                if (((o1, o2) => {
                  if (o1 && o1.equals) {
                    return o1.equals(o2);
                  } else {
                    return o1 === o2;
                  }
                })(this.chatboxInput, "::noclip")) {
                  for (let j1 = 0; j1 < 4; j1++) {
                    {
                      for (let k1 = 1; k1 < 103; k1++) {
                        {
                          for (let j2 = 1; j2 < 103; j2++) {
                            this.currentCollisionMap[j1].adjacency[k1][j2] = 0;
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(this.chatboxInput, "::")) {
                this.outBuffer.putOpcode(56);
                this.outBuffer.putByte(this.chatboxInput.length - 1);
                this.outBuffer.putString(this.chatboxInput.substring(2));
              } else {
                let s = this.chatboxInput.toLowerCase();
                let colourCode = 0;
                if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "yellow:")) {
                  colourCode = 0;
                  this.chatboxInput = this.chatboxInput.substring(7);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "red:")) {
                  colourCode = 1;
                  this.chatboxInput = this.chatboxInput.substring(4);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "green:")) {
                  colourCode = 2;
                  this.chatboxInput = this.chatboxInput.substring(6);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "cyan:")) {
                  colourCode = 3;
                  this.chatboxInput = this.chatboxInput.substring(5);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "purple:")) {
                  colourCode = 4;
                  this.chatboxInput = this.chatboxInput.substring(7);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "white:")) {
                  colourCode = 5;
                  this.chatboxInput = this.chatboxInput.substring(6);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "flash1:")) {
                  colourCode = 6;
                  this.chatboxInput = this.chatboxInput.substring(7);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "flash2:")) {
                  colourCode = 7;
                  this.chatboxInput = this.chatboxInput.substring(7);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "flash3:")) {
                  colourCode = 8;
                  this.chatboxInput = this.chatboxInput.substring(7);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "glow1:")) {
                  colourCode = 9;
                  this.chatboxInput = this.chatboxInput.substring(6);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "glow2:")) {
                  colourCode = 10;
                  this.chatboxInput = this.chatboxInput.substring(6);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "glow3:")) {
                  colourCode = 11;
                  this.chatboxInput = this.chatboxInput.substring(6);
                }
                s = this.chatboxInput.toLowerCase();
                let effectCode = 0;
                if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "wave:")) {
                  effectCode = 1;
                  this.chatboxInput = this.chatboxInput.substring(5);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "wave2:")) {
                  effectCode = 2;
                  this.chatboxInput = this.chatboxInput.substring(6);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "shake:")) {
                  effectCode = 3;
                  this.chatboxInput = this.chatboxInput.substring(6);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "scroll:")) {
                  effectCode = 4;
                  this.chatboxInput = this.chatboxInput.substring(7);
                } else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "slide:")) {
                  effectCode = 5;
                  this.chatboxInput = this.chatboxInput.substring(6);
                }
                this.outBuffer.putOpcode(49);
                this.outBuffer.putByte(0);
                const bufPos = this.outBuffer.currentPosition;
                this.outBuffer.putByteNegated(colourCode);
                this.outBuffer.putByteAdded(effectCode);
                this.chatBuffer.currentPosition = 0;
                ChatEncoder.put(this.chatboxInput, this.chatBuffer);
                this.outBuffer.putBytes(this.chatBuffer.buffer, 0, this.chatBuffer.currentPosition);
                this.outBuffer.putLength(this.outBuffer.currentPosition - bufPos);
                this.chatboxInput = ChatEncoder.formatChatMessage(this.chatboxInput);
                this.chatboxInput = ChatCensor.censorString(this.chatboxInput);
                _Game.localPlayer.forcedChat = this.chatboxInput;
                _Game.localPlayer.textColour = colourCode;
                _Game.localPlayer.textEffect = effectCode;
                _Game.localPlayer.textCycle = 150;
                if (this.playerRights === 2) {
                  this.addChatMessage("@cr2@" + _Game.localPlayer.playerName, _Game.localPlayer.forcedChat, 2);
                } else if (this.playerRights === 1) {
                  this.addChatMessage("@cr1@" + _Game.localPlayer.playerName, _Game.localPlayer.forcedChat, 2);
                } else {
                  this.addChatMessage(_Game.localPlayer.playerName, _Game.localPlayer.forcedChat, 2);
                }
                if (this.publicChatMode === 2) {
                  this.publicChatMode = 3;
                  this.aBoolean1212 = true;
                  this.outBuffer.putOpcode(176);
                  this.outBuffer.putByte(this.publicChatMode);
                  this.outBuffer.putByte(this.privateChatMode);
                  this.outBuffer.putByte(this.tradeMode);
                }
              }
              this.chatboxInput = "";
              this.redrawChatbox = true;
            }
          }
        }
      }
    }
    calculateCameraPosition() {
      let i = this.anInt874 * 128 + 64;
      let j = this.anInt875 * 128 + 64;
      let k = this.getTileHeight(j, i, 9 | 0, this.plane) - this.anInt876;
      if (this.cameraX < i) {
        this.cameraX += this.anInt877 + ((i - this.cameraX) * this.anInt878 / 1e3 | 0);
        if (this.cameraX > i) {
          this.cameraX = i;
        }
      }
      if (this.cameraX > i) {
        this.cameraX -= this.anInt877 + ((this.cameraX - i) * this.anInt878 / 1e3 | 0);
        if (this.cameraX < i) {
          this.cameraX = i;
        }
      }
      if (this.cameraZ < k) {
        this.cameraZ += this.anInt877 + ((k - this.cameraZ) * this.anInt878 / 1e3 | 0);
        if (this.cameraZ > k) {
          this.cameraZ = k;
        }
      }
      if (this.cameraZ > k) {
        this.cameraZ -= this.anInt877 + ((this.cameraZ - k) * this.anInt878 / 1e3 | 0);
        if (this.cameraZ < k) {
          this.cameraZ = k;
        }
      }
      if (this.cameraY < j) {
        this.cameraY += this.anInt877 + ((j - this.cameraY) * this.anInt878 / 1e3 | 0);
        if (this.cameraY > j) {
          this.cameraY = j;
        }
      }
      if (this.cameraY > j) {
        this.cameraY -= this.anInt877 + ((this.cameraY - j) * this.anInt878 / 1e3 | 0);
        if (this.cameraY < j) {
          this.cameraY = j;
        }
      }
      i = this.anInt993 * 128 + 64;
      j = this.anInt994 * 128 + 64;
      k = this.getTileHeight(j, i, 9 | 0, this.plane) - this.anInt995;
      const l = i - this.cameraX;
      const i1 = k - this.cameraZ;
      const j1 = j - this.cameraY;
      const k1 = Math.sqrt(l * l + j1 * j1) | 0;
      let l1 = (Math.atan2(i1, k1) * 325.949 | 0) & 2047;
      const j2 = (Math.atan2(l, j1) * -325.949 | 0) & 2047;
      if (l1 < 128) {
        l1 = 128;
      }
      if (l1 > 383) {
        l1 = 383;
      }
      if (this.cameraPitch < l1) {
        this.cameraPitch += this.anInt996 + ((l1 - this.cameraPitch) * this.anInt997 / 1e3 | 0);
        if (this.cameraPitch > l1) {
          this.cameraPitch = l1;
        }
      }
      if (this.cameraPitch > l1) {
        this.cameraPitch -= this.anInt996 + ((this.cameraPitch - l1) * this.anInt997 / 1e3 | 0);
        if (this.cameraPitch < l1) {
          this.cameraPitch = l1;
        }
      }
      let k2 = j2 - this.cameraYaw;
      if (k2 > 1024) {
        k2 -= 2048;
      }
      if (k2 < -1024) {
        k2 += 2048;
      }
      if (k2 > 0) {
        this.cameraYaw += this.anInt996 + (k2 * this.anInt997 / 1e3 | 0);
        this.cameraYaw &= 2047;
      }
      if (k2 < 0) {
        this.cameraYaw -= this.anInt996 + (-k2 * this.anInt997 / 1e3 | 0);
        this.cameraYaw &= 2047;
      }
      let l2 = j2 - this.cameraYaw;
      if (l2 > 1024) {
        l2 -= 2048;
      }
      if (l2 < -1024) {
        l2 += 2048;
      }
      if (l2 < 0 && k2 > 0 || l2 > 0 && k2 < 0) {
        this.cameraYaw = j2;
      }
    }
    checkForGameUsages(i) {
      i = 61 / i | 0;
      try {
        const j = _Game.localPlayer.worldX + this.anInt853;
        const k = _Game.localPlayer.worldY + this.anInt1009;
        if (this.anInt1262 - j < -500 || this.anInt1262 - j > 500 || this.anInt1263 - k < -500 || this.anInt1263 - k > 500) {
          this.anInt1262 = j;
          this.anInt1263 = k;
        }
        if (this.anInt1262 !== j) {
          this.anInt1262 += (j - this.anInt1262) / 16 | 0;
        }
        if (this.anInt1263 !== k) {
          this.anInt1263 += (k - this.anInt1263) / 16 | 0;
        }
        if (this.keyStatus[1] === 1) {
          this.anInt1186 += (-24 - this.anInt1186) / 2 | 0;
        } else if (this.keyStatus[2] === 1) {
          this.anInt1186 += (24 - this.anInt1186) / 2 | 0;
        } else {
          this.anInt1186 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.anInt1186 / 2);
        }
        if (this.keyStatus[3] === 1) {
          this.anInt1187 += (12 - this.anInt1187) / 2 | 0;
        } else if (this.keyStatus[4] === 1) {
          this.anInt1187 += (-12 - this.anInt1187) / 2 | 0;
        } else {
          this.anInt1187 = ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.anInt1187 / 2);
        }
        this.cameraHorizontal = this.cameraHorizontal + (this.anInt1186 / 2 | 0) & 2047;
        this.anInt1251 += this.anInt1187 / 2 | 0;
        if (this.anInt1251 < 128) {
          this.anInt1251 = 128;
        }
        if (this.anInt1251 > 383) {
          this.anInt1251 = 383;
        }
        const l = this.anInt1262 >> 7;
        const i1 = this.anInt1263 >> 7;
        const j1 = this.getTileHeight(this.anInt1263, this.anInt1262, 9 | 0, this.plane);
        let k1 = 0;
        if (l > 3 && i1 > 3 && l < 100 && i1 < 100) {
          for (let l1 = l - 4; l1 <= l + 4; l1++) {
            {
              for (let j2 = i1 - 4; j2 <= i1 + 4; j2++) {
                {
                  let k2 = this.plane;
                  if (k2 < 3 && (this.currentSceneTileFlags[1][l1][j2] & 2) === 2) {
                    k2++;
                  }
                  const l2 = j1 - this.anIntArrayArrayArray891[k2][l1][j2];
                  if (l2 > k1) {
                    k1 = l2;
                  }
                }
              }
            }
          }
        }
        let i2 = k1 * 192;
        if (i2 > 98048) {
          i2 = 98048;
        }
        if (i2 < 32768) {
          i2 = 32768;
        }
        if (i2 > this.anInt1289) {
          this.anInt1289 += (i2 - this.anInt1289) / 24 | 0;
          return;
        }
        if (i2 < this.anInt1289) {
          this.anInt1289 += (i2 - this.anInt1289) / 80 | 0;
          return;
        }
      } catch (_ex) {
        SignLink.reportError(
          "glfc_ex " + _Game.localPlayer.worldX + "," + _Game.localPlayer.worldY + "," + this.anInt1262 + "," + this.anInt1263 + "," + this.chunkX + "," + this.chunkY + "," + this.nextTopLeftTileX + "," + this.nextTopRightTileY
        );
        throw Error("eek");
      }
    }
    method39(flag) {
      if (!flag) {
        this.groundItems = null;
      }
      if (this.clickType === 1) {
        if (this.clickX >= 6 && this.clickX <= 106 && this.clickY >= 467 && this.clickY <= 499) {
          this.publicChatMode = (this.publicChatMode + 1) % 4;
          this.aBoolean1212 = true;
          this.redrawChatbox = true;
          this.outBuffer.putOpcode(176);
          this.outBuffer.putByte(this.publicChatMode);
          this.outBuffer.putByte(this.privateChatMode);
          this.outBuffer.putByte(this.tradeMode);
        }
        if (this.clickX >= 135 && this.clickX <= 235 && this.clickY >= 467 && this.clickY <= 499) {
          this.privateChatMode = (this.privateChatMode + 1) % 3;
          this.aBoolean1212 = true;
          this.redrawChatbox = true;
          this.outBuffer.putOpcode(176);
          this.outBuffer.putByte(this.publicChatMode);
          this.outBuffer.putByte(this.privateChatMode);
          this.outBuffer.putByte(this.tradeMode);
        }
        if (this.clickX >= 273 && this.clickX <= 373 && this.clickY >= 467 && this.clickY <= 499) {
          this.tradeMode = (this.tradeMode + 1) % 3;
          this.aBoolean1212 = true;
          this.redrawChatbox = true;
          this.outBuffer.putOpcode(176);
          this.outBuffer.putByte(this.publicChatMode);
          this.outBuffer.putByte(this.privateChatMode);
          this.outBuffer.putByte(this.tradeMode);
        }
        if (this.clickX >= 412 && this.clickX <= 512 && this.clickY >= 467 && this.clickY <= 499) {
          if (this.openInterfaceId === -1) {
            this.closeWidgets();
            this.reportedName = "";
            this.reportMutePlayer = false;
            this.reportAbuseInterfaceID = this.openInterfaceId = Widget.anInt246;
          } else {
            this.addChatMessage("", "Please close the interface you have open before using 'report abuse'", 0);
          }
          _Game.anInt1160++;
          if (_Game.anInt1160 > 161) {
            _Game.anInt1160 = 0;
            this.outBuffer.putOpcode(22);
            this.outBuffer.putShort(38304);
          }
        }
      }
    }
    method21(flag) {
      if (flag) {
        return;
      }
      if (this.clickType === 1) {
        if (this.clickX >= 539 && this.clickX <= 573 && this.clickY >= 169 && this.clickY < 205 && this.anIntArray1081[0] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 0;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 569 && this.clickX <= 599 && this.clickY >= 168 && this.clickY < 205 && this.anIntArray1081[1] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 1;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 597 && this.clickX <= 627 && this.clickY >= 168 && this.clickY < 205 && this.anIntArray1081[2] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 2;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 625 && this.clickX <= 669 && this.clickY >= 168 && this.clickY < 203 && this.anIntArray1081[3] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 3;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 666 && this.clickX <= 696 && this.clickY >= 168 && this.clickY < 205 && this.anIntArray1081[4] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 4;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 694 && this.clickX <= 724 && this.clickY >= 168 && this.clickY < 205 && this.anIntArray1081[5] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 5;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 722 && this.clickX <= 756 && this.clickY >= 169 && this.clickY < 205 && this.anIntArray1081[6] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 6;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 540 && this.clickX <= 574 && this.clickY >= 466 && this.clickY < 502 && this.anIntArray1081[7] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 7;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 572 && this.clickX <= 602 && this.clickY >= 466 && this.clickY < 503 && this.anIntArray1081[8] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 8;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 599 && this.clickX <= 629 && this.clickY >= 466 && this.clickY < 503 && this.anIntArray1081[9] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 9;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 627 && this.clickX <= 671 && this.clickY >= 467 && this.clickY < 502 && this.anIntArray1081[10] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 10;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 669 && this.clickX <= 699 && this.clickY >= 466 && this.clickY < 503 && this.anIntArray1081[11] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 11;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 696 && this.clickX <= 726 && this.clickY >= 466 && this.clickY < 503 && this.anIntArray1081[12] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 12;
          this.aBoolean950 = true;
        }
        if (this.clickX >= 724 && this.clickX <= 758 && this.clickY >= 466 && this.clickY < 502 && this.anIntArray1081[13] !== -1) {
          this.redrawTabArea = true;
          this.anInt1285 = 13;
          this.aBoolean950 = true;
        }
      }
    }
    method146(byte0) {
      if (byte0 !== 4) {
        return;
      }
      if (this.minimapState !== 0) {
        return;
      }
      if (this.clickType === 1) {
        let i = this.clickX - 25 - 550;
        let j = this.clickY - 5 - 4;
        if (i >= 0 && j >= 0 && i < 146 && j < 151) {
          i -= 73;
          j -= 75;
          const k = this.cameraHorizontal + this.anInt916 & 2047;
          let l = Rasterizer3D.SINE[k];
          let i1 = Rasterizer3D.COSINE[k];
          l = l * (this.anInt1233 + 256) >> 8;
          i1 = i1 * (this.anInt1233 + 256) >> 8;
          const j1 = j * l + i * i1 >> 11;
          const k1 = j * i1 - i * l >> 11;
          const l1 = _Game.localPlayer.worldX + j1 >> 7;
          const i2 = _Game.localPlayer.worldY - k1 >> 7;
          const flag = this.walk(
            true,
            false,
            i2,
            _Game.localPlayer.pathY[0],
            0,
            0,
            1,
            0,
            l1,
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          if (flag) {
            this.outBuffer.putByte(i);
            this.outBuffer.putByte(j);
            this.outBuffer.putShort(this.cameraHorizontal);
            this.outBuffer.putByte(57);
            this.outBuffer.putByte(this.anInt916);
            this.outBuffer.putByte(this.anInt1233);
            this.outBuffer.putByte(89);
            this.outBuffer.putShort(_Game.localPlayer.worldX);
            this.outBuffer.putShort(_Game.localPlayer.worldY);
            this.outBuffer.putByte(this.anInt1126);
            this.outBuffer.putByte(63);
          }
        }
      }
    }
    processMenuClick() {
      if (this.activeInterfaceType !== 0) {
        return;
      }
      let meta = this.clickType;
      if (this.widgetSelected === 1 && this.clickX >= 516 && this.clickY >= 160 && this.clickX <= 765 && this.clickY <= 205) {
        meta = 0;
      }
      if (this.menuOpen) {
        if (meta !== 1) {
          let x2 = this.mouseX;
          let y = this.mouseY;
          if (this.anInt1304 === 0) {
            x2 -= 4;
            y -= 4;
          }
          if (this.anInt1304 === 1) {
            x2 -= 553;
            y -= 205;
          }
          if (this.anInt1304 === 2) {
            x2 -= 17;
            y -= 357;
          }
          if (x2 < this.menuClickX - 10 || x2 > this.menuClickX + this.anInt1307 + 10 || y < this.menuClickY - 10 || y > this.menuClickY + this.anInt1308 + 10) {
            this.menuOpen = false;
            if (this.anInt1304 === 1) {
              this.redrawTabArea = true;
            }
            if (this.anInt1304 === 2) {
              this.redrawChatbox = true;
            }
          }
        }
        if (meta === 1) {
          const menuX = this.menuClickX;
          const menuY = this.menuClickY;
          const dx = this.anInt1307;
          let x2 = this.clickX;
          let y = this.clickY;
          if (this.anInt1304 === 0) {
            x2 -= 4;
            y -= 4;
          }
          if (this.anInt1304 === 1) {
            x2 -= 553;
            y -= 205;
          }
          if (this.anInt1304 === 2) {
            x2 -= 17;
            y -= 357;
          }
          let id = -1;
          for (let row = 0; row < this.menuActionRow; row++) {
            {
              const k3 = menuY + 31 + (this.menuActionRow - 1 - row) * 15;
              if (x2 > menuX && x2 < menuX + dx && y > k3 - 13 && y < k3 + 3) {
                id = row;
              }
            }
          }
          if (id !== -1) {
            this.processMenuActions(id);
          }
          this.menuOpen = false;
          if (this.anInt1304 === 1) {
            this.redrawTabArea = true;
          }
          if (this.anInt1304 === 2) {
            this.redrawChatbox = true;
            return;
          }
        }
      } else {
        if (meta === 1 && this.menuActionRow > 0) {
          const action = this.menuActionTypes[this.menuActionRow - 1];
          if (action === 9 || action === 225 || action === 444 || action === 564 || action === 894 || action === 961 || action === 399 || action === 324 || action === 227 || action === 891 || action === 52 || action === Actions.EXAMINE_ITEM) {
            const item = this.firstMenuOperand[this.menuActionRow - 1];
            const id = this.secondMenuOperand[this.menuActionRow - 1];
            const widget = Widget.forId(id);
            if (widget.itemSwapable || widget.itemDeletesDraged) {
              this.aBoolean1155 = false;
              this.anInt1269 = 0;
              this.modifiedWidgetId = id;
              this.selectedInventorySlot = item;
              this.activeInterfaceType = 2;
              this.anInt1114 = this.clickX;
              this.anInt1115 = this.clickY;
              if (Widget.forId(id).parentId === this.openInterfaceId) {
                this.activeInterfaceType = 1;
              }
              if (Widget.forId(id).parentId === this.backDialogueId) {
                this.activeInterfaceType = 3;
              }
              return;
            }
          }
        }
        if (meta === 1 && (this.anInt1300 === 1 || this.menuHasAddFriend(this.menuActionRow - 1, this.aByte1161)) && this.menuActionRow > 2) {
          meta = 2;
        }
        if (meta === 1 && this.menuActionRow > 0) {
          this.processMenuActions(this.menuActionRow - 1);
        }
        if (meta === 2 && this.menuActionRow > 0) {
          this.determineMenuSize();
        }
      }
    }
    determineMenuSize() {
      let width = this.fontBold.getStringEffectWidth("Choose Option");
      for (let i = 0; i < this.menuActionRow; i++) {
        {
          const rowWidth = this.fontBold.getStringEffectWidth(this.menuActionTexts[i]);
          if (rowWidth > width) {
            width = rowWidth;
          }
        }
      }
      width += 8;
      const height = 15 * this.menuActionRow + 21;
      if (this.clickX > 4 && this.clickY > 4 && this.clickX < 516 && this.clickY < 338) {
        let x2 = this.clickX - 4 - (width / 2 | 0);
        if (x2 + width > 512) {
          x2 = 512 - width;
        }
        if (x2 < 0) {
          x2 = 0;
        }
        let y = this.clickY - 4;
        if (y + height > 334) {
          y = 334 - height;
        }
        if (y < 0) {
          y = 0;
        }
        this.menuOpen = true;
        this.anInt1304 = 0;
        this.menuClickX = x2;
        this.menuClickY = y;
        this.anInt1307 = width;
        this.anInt1308 = height + 1;
      }
      if (this.clickX > 553 && this.clickY > 205 && this.clickX < 743 && this.clickY < 466) {
        let x2 = this.clickX - 553 - (width / 2 | 0);
        if (x2 < 0) {
          x2 = 0;
        } else if (x2 + width > 190) {
          x2 = 190 - width;
        }
        let y = this.clickY - 205;
        if (y < 0) {
          y = 0;
        } else if (y + height > 261) {
          y = 261 - height;
        }
        this.menuOpen = true;
        this.anInt1304 = 1;
        this.menuClickX = x2;
        this.menuClickY = y;
        this.anInt1307 = width;
        this.anInt1308 = height + 1;
      }
      if (this.clickX > 17 && this.clickY > 357 && this.clickX < 496 && this.clickY < 453) {
        let x2 = this.clickX - 17 - (width / 2 | 0);
        if (x2 < 0) {
          x2 = 0;
        } else if (x2 + width > 479) {
          x2 = 479 - width;
        }
        let y = this.clickY - 357;
        if (y < 0) {
          y = 0;
        } else if (y + height > 96) {
          y = 96 - height;
        }
        this.menuOpen = true;
        this.anInt1304 = 2;
        this.menuClickX = x2;
        this.menuClickY = y;
        this.anInt1307 = width;
        this.anInt1308 = height + 1;
      }
    }
    walk(flag, flag1, dstY, srcY, k, l, packetType, j1, dstX, l1, i2, srcX) {
      const byte0 = 104;
      const byte1 = 104;
      for (let x2 = 0; x2 < byte0; x2++) {
        {
          for (let y = 0; y < byte1; y++) {
            {
              this.anIntArrayArray885[x2][y] = 0;
              this.cost[x2][y] = 99999999;
            }
          }
        }
      }
      let curX = srcX;
      let curY = srcY;
      this.anIntArrayArray885[srcX][srcY] = 99;
      this.cost[srcX][srcY] = 0;
      let k3 = 0;
      let l3 = 0;
      this.anIntArray1123[k3] = srcX;
      this.anIntArray1124[k3++] = srcY;
      let flag2 = false;
      const i4 = this.anIntArray1123.length;
      const masks = this.currentCollisionMap[this.plane].adjacency;
      while (l3 !== k3) {
        {
          curX = this.anIntArray1123[l3];
          curY = this.anIntArray1124[l3];
          l3 = (l3 + 1) % i4;
          if (curX === dstX && curY === dstY) {
            flag2 = true;
            break;
          }
          if (j1 !== 0) {
            if ((j1 < 5 || j1 === 10) && this.currentCollisionMap[this.plane].reachedWall(curX, curY, dstX, dstY, j1 - 1, i2)) {
              flag2 = true;
              break;
            }
            if (j1 < 10 && this.currentCollisionMap[this.plane].reachedWallDecoration(curX, curY, dstX, dstY, j1 - 1, i2)) {
              flag2 = true;
              break;
            }
          }
          if (k !== 0 && l !== 0 && this.currentCollisionMap[this.plane].reachedFacingObject(curX, curY, dstX, dstY, k, l, l1)) {
            flag2 = true;
            break;
          }
          const nextCost = this.cost[curX][curY] + 1;
          if (curX > 0 && this.anIntArrayArray885[curX - 1][curY] === 0 && (masks[curX - 1][curY] & 19398920) === 0) {
            this.anIntArray1123[k3] = curX - 1;
            this.anIntArray1124[k3] = curY;
            k3 = (k3 + 1) % i4;
            this.anIntArrayArray885[curX - 1][curY] = 2;
            this.cost[curX - 1][curY] = nextCost;
          }
          if (curX < byte0 - 1 && this.anIntArrayArray885[curX + 1][curY] === 0 && (masks[curX + 1][curY] & 19399040) === 0) {
            this.anIntArray1123[k3] = curX + 1;
            this.anIntArray1124[k3] = curY;
            k3 = (k3 + 1) % i4;
            this.anIntArrayArray885[curX + 1][curY] = 8;
            this.cost[curX + 1][curY] = nextCost;
          }
          if (curY > 0 && this.anIntArrayArray885[curX][curY - 1] === 0 && (masks[curX][curY - 1] & 19398914) === 0) {
            this.anIntArray1123[k3] = curX;
            this.anIntArray1124[k3] = curY - 1;
            k3 = (k3 + 1) % i4;
            this.anIntArrayArray885[curX][curY - 1] = 1;
            this.cost[curX][curY - 1] = nextCost;
          }
          if (curY < byte1 - 1 && this.anIntArrayArray885[curX][curY + 1] === 0 && (masks[curX][curY + 1] & 19398944) === 0) {
            this.anIntArray1123[k3] = curX;
            this.anIntArray1124[k3] = curY + 1;
            k3 = (k3 + 1) % i4;
            this.anIntArrayArray885[curX][curY + 1] = 4;
            this.cost[curX][curY + 1] = nextCost;
          }
          if (curX > 0 && curY > 0 && this.anIntArrayArray885[curX - 1][curY - 1] === 0 && (masks[curX - 1][curY - 1] & 19398926) === 0 && (masks[curX - 1][curY] & 19398920) === 0 && (masks[curX][curY - 1] & 19398914) === 0) {
            this.anIntArray1123[k3] = curX - 1;
            this.anIntArray1124[k3] = curY - 1;
            k3 = (k3 + 1) % i4;
            this.anIntArrayArray885[curX - 1][curY - 1] = 3;
            this.cost[curX - 1][curY - 1] = nextCost;
          }
          if (curX < byte0 - 1 && curY > 0 && this.anIntArrayArray885[curX + 1][curY - 1] === 0 && (masks[curX + 1][curY - 1] & 19399043) === 0 && (masks[curX + 1][curY] & 19399040) === 0 && (masks[curX][curY - 1] & 19398914) === 0) {
            this.anIntArray1123[k3] = curX + 1;
            this.anIntArray1124[k3] = curY - 1;
            k3 = (k3 + 1) % i4;
            this.anIntArrayArray885[curX + 1][curY - 1] = 9;
            this.cost[curX + 1][curY - 1] = nextCost;
          }
          if (curX > 0 && curY < byte1 - 1 && this.anIntArrayArray885[curX - 1][curY + 1] === 0 && (masks[curX - 1][curY + 1] & 19398968) === 0 && (masks[curX - 1][curY] & 19398920) === 0 && (masks[curX][curY + 1] & 19398944) === 0) {
            this.anIntArray1123[k3] = curX - 1;
            this.anIntArray1124[k3] = curY + 1;
            k3 = (k3 + 1) % i4;
            this.anIntArrayArray885[curX - 1][curY + 1] = 6;
            this.cost[curX - 1][curY + 1] = nextCost;
          }
          if (curX < byte0 - 1 && curY < byte1 - 1 && this.anIntArrayArray885[curX + 1][curY + 1] === 0 && (masks[curX + 1][curY + 1] & 19399136) === 0 && (masks[curX + 1][curY] & 19399040) === 0 && (masks[curX][curY + 1] & 19398944) === 0) {
            this.anIntArray1123[k3] = curX + 1;
            this.anIntArray1124[k3] = curY + 1;
            k3 = (k3 + 1) % i4;
            this.anIntArrayArray885[curX + 1][curY + 1] = 12;
            this.cost[curX + 1][curY + 1] = nextCost;
          }
        }
      }
      this.anInt1126 = 0;
      if (!flag2) {
        if (flag) {
          let l4 = 1e3;
          let j5 = 100;
          const byte2 = 10;
          for (let i6 = dstX - byte2; i6 <= dstX + byte2; i6++) {
            {
              for (let k6 = dstY - byte2; k6 <= dstY + byte2; k6++) {
                if (i6 >= 0 && k6 >= 0 && i6 < 104 && k6 < 104 && this.cost[i6][k6] < 100) {
                  let i7 = 0;
                  if (i6 < dstX) {
                    i7 = dstX - i6;
                  } else if (i6 > dstX + k - 1) {
                    i7 = i6 - (dstX + k - 1);
                  }
                  let j7 = 0;
                  if (k6 < dstY) {
                    j7 = dstY - k6;
                  } else if (k6 > dstY + l - 1) {
                    j7 = k6 - (dstY + l - 1);
                  }
                  const k7 = i7 * i7 + j7 * j7;
                  if (k7 < l4 || k7 === l4 && this.cost[i6][k6] < j5) {
                    l4 = k7;
                    j5 = this.cost[i6][k6];
                    curX = i6;
                    curY = k6;
                  }
                }
              }
            }
          }
          if (l4 === 1e3) {
            return false;
          }
          if (curX === srcX && curY === srcY) {
            return false;
          }
          this.anInt1126 = 1;
        } else {
          return false;
        }
      }
      l3 = 0;
      if (flag1) {
        this.startUp();
      }
      this.anIntArray1123[l3] = curX;
      this.anIntArray1124[l3++] = curY;
      let k5;
      for (let i5 = k5 = this.anIntArrayArray885[curX][curY]; curX !== srcX || curY !== srcY; i5 = this.anIntArrayArray885[curX][curY]) {
        {
          if (i5 !== k5) {
            k5 = i5;
            this.anIntArray1123[l3] = curX;
            this.anIntArray1124[l3++] = curY;
          }
          if ((i5 & 2) !== 0) {
            curX++;
          } else if ((i5 & 8) !== 0) {
            curX--;
          }
          if ((i5 & 1) !== 0) {
            curY++;
          } else if ((i5 & 4) !== 0) {
            curY--;
          }
        }
      }
      if (l3 > 0) {
        let j4 = l3;
        if (j4 > 25) {
          j4 = 25;
        }
        l3--;
        const l5 = this.anIntArray1123[l3];
        const j6 = this.anIntArray1124[l3];
        if (packetType === 0) {
          this.outBuffer.putOpcode(28);
          this.outBuffer.putByte(j4 + j4 + 3);
        }
        if (packetType === 1) {
          this.outBuffer.putOpcode(213);
          this.outBuffer.putByte(j4 + j4 + 3 + 14);
        }
        if (packetType === 2) {
          this.outBuffer.putOpcode(247);
          this.outBuffer.putByte(j4 + j4 + 3);
        }
        this.outBuffer.putLEShortAdded(l5 + this.nextTopLeftTileX);
        this.outBuffer.putByte(this.keyStatus[5] !== 1 ? 0 : 1);
        this.outBuffer.putLEShortAdded(j6 + this.nextTopRightTileY);
        this.destinationX = this.anIntArray1123[0];
        this.destinationY = this.anIntArray1124[0];
        for (let l6 = 1; l6 < j4; l6++) {
          {
            l3--;
            this.outBuffer.putByte(this.anIntArray1123[l3] - l5);
            this.outBuffer.putByteSubtracted(this.anIntArray1124[l3] - j6);
          }
        }
        return true;
      }
      return packetType !== 1;
    }
    menuHasAddFriend(i, byte0) {
      if (i < 0) {
        return false;
      }
      let j = this.menuActionTypes[i];
      if (byte0 !== 97) {
        throw Error("NullPointerException");
      }
      if (j >= 2e3) {
        j -= 2e3;
      }
      return j === 762;
    }
    processRightClick(i) {
      if (this.activeInterfaceType !== 0) {
        return;
      }
      this.menuActionTexts[0] = "Cancel";
      this.menuActionTypes[0] = 1016;
      this.menuActionRow = 1;
      if (i >= 0) {
        this.anInt1004 = this.incomingRandom.nextInt() | 0;
      }
      if (this.anInt1053 !== -1) {
        this.anInt915 = 0;
        this.anInt1315 = 0;
        this.method66(0, Widget.forId(this.anInt1053), 0, 0, 0, this.mouseX, 23658, this.mouseY);
        if (this.anInt915 !== this.anInt1302) {
          this.anInt1302 = this.anInt915;
        }
        if (this.anInt1315 !== this.anInt1129) {
          this.anInt1129 = this.anInt1315;
        }
        return;
      }
      this.method111(this.anInt1178);
      this.anInt915 = 0;
      this.anInt1315 = 0;
      if (this.mouseX > 4 && this.mouseY > 4 && this.mouseX < 516 && this.mouseY < 338) {
        if (this.openInterfaceId !== -1) {
          this.method66(4, Widget.forId(this.openInterfaceId), 0, 0, 4, this.mouseX, 23658, this.mouseY);
        } else {
          this.method43(7 | 0);
        }
      }
      if (this.anInt915 !== this.anInt1302) {
        this.anInt1302 = this.anInt915;
      }
      if (this.anInt1315 !== this.anInt1129) {
        this.anInt1129 = this.anInt1315;
      }
      this.anInt915 = 0;
      this.anInt1315 = 0;
      if (this.mouseX > 553 && this.mouseY > 205 && this.mouseX < 743 && this.mouseY < 466) {
        if (this.anInt1089 !== -1) {
          this.method66(205, Widget.forId(this.anInt1089), 1, 0, 553, this.mouseX, 23658, this.mouseY);
        } else if (this.anIntArray1081[this.anInt1285] !== -1) {
          this.method66(205, Widget.forId(this.anIntArray1081[this.anInt1285]), 1, 0, 553, this.mouseX, 23658, this.mouseY);
        }
      }
      if (this.anInt915 !== this.anInt1280) {
        this.redrawTabArea = true;
        this.anInt1280 = this.anInt915;
      }
      if (this.anInt1315 !== this.anInt1044) {
        this.redrawTabArea = true;
        this.anInt1044 = this.anInt1315;
      }
      this.anInt915 = 0;
      this.anInt1315 = 0;
      if (this.mouseX > 17 && this.mouseY > 357 && this.mouseX < 496 && this.mouseY < 453) {
        if (this.backDialogueId !== -1) {
          this.method66(357, Widget.forId(this.backDialogueId), 2, 0, 17, this.mouseX, 23658, this.mouseY);
        } else if (this.dialogueId !== -1) {
          this.method66(357, Widget.forId(this.dialogueId), 3, 0, 17, this.mouseX, 23658, this.mouseY);
        } else if (this.mouseY < 434 && this.mouseX < 426 && this.inputType === 0) {
          this.method113(466, this.mouseX - 17, this.mouseY - 357);
        }
      }
      if ((this.backDialogueId !== -1 || this.dialogueId !== -1) && this.anInt915 !== this.anInt1106) {
        this.redrawChatbox = true;
        this.anInt1106 = this.anInt915;
      }
      if ((this.backDialogueId !== -1 || this.dialogueId !== -1) && this.anInt1315 !== this.anInt1284) {
        this.redrawChatbox = true;
        this.anInt1284 = this.anInt1315;
      }
      for (let flag = false; !flag; ) {
        {
          flag = true;
          for (let j = 0; j < this.menuActionRow - 1; j++) {
            if (this.menuActionTypes[j] < 1e3 && this.menuActionTypes[j + 1] > 1e3) {
              const s = this.menuActionTexts[j];
              this.menuActionTexts[j] = this.menuActionTexts[j + 1];
              this.menuActionTexts[j + 1] = s;
              let k = this.menuActionTypes[j];
              this.menuActionTypes[j] = this.menuActionTypes[j + 1];
              this.menuActionTypes[j + 1] = k;
              k = this.firstMenuOperand[j];
              this.firstMenuOperand[j] = this.firstMenuOperand[j + 1];
              this.firstMenuOperand[j + 1] = k;
              k = this.secondMenuOperand[j];
              this.secondMenuOperand[j] = this.secondMenuOperand[j + 1];
              this.secondMenuOperand[j + 1] = k;
              k = this.selectedMenuActions[j];
              this.selectedMenuActions[j] = this.selectedMenuActions[j + 1];
              this.selectedMenuActions[j + 1] = k;
              flag = false;
            }
          }
        }
      }
    }
    method113(i, j, k) {
      let l = 0;
      i = 44 / i | 0;
      for (let i1 = 0; i1 < 100; i1++) {
        {
          if (this.chatMessages[i1] == null) {
            continue;
          }
          const j1 = this.chatTypes[i1];
          const k1 = 70 - l * 14 + this.anInt851 + 4;
          if (k1 < -20) {
            break;
          }
          let s = this.chatPlayerNames[i1];
          if (s != null && ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(
            s,
            "@cr1@"
          )) {
            s = s.substring(5);
          }
          if (s != null && ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(
            s,
            "@cr2@"
          )) {
            s = s.substring(5);
          }
          if (j1 === 0) {
            l++;
          }
          if ((j1 === 1 || j1 === 2) && (j1 === 1 || this.publicChatMode === 0 || this.publicChatMode === 1 && this.method148(13292, s))) {
            if (k > k1 - 14 && k <= k1 && !((o1, o2) => {
              if (o1 && o1.equals) {
                return o1.equals(o2);
              } else {
                return o1 === o2;
              }
            })(s, _Game.localPlayer.playerName)) {
              if (this.playerRights >= 1) {
                this.menuActionTexts[this.menuActionRow] = "Report abuse @whi@" + s;
                this.menuActionTypes[this.menuActionRow] = 507;
                this.menuActionRow++;
              }
              this.menuActionTexts[this.menuActionRow] = "Add ignore @whi@" + s;
              this.menuActionTypes[this.menuActionRow] = 574;
              this.menuActionRow++;
              this.menuActionTexts[this.menuActionRow] = "Add friend @whi@" + s;
              this.menuActionTypes[this.menuActionRow] = 762;
              this.menuActionRow++;
            }
            l++;
          }
          if ((j1 === 3 || j1 === 7) && this.anInt1223 === 0 && (j1 === 7 || this.privateChatMode === 0 || this.privateChatMode === 1 && this.method148(13292, s))) {
            if (k > k1 - 14 && k <= k1) {
              if (this.playerRights >= 1) {
                this.menuActionTexts[this.menuActionRow] = "Report abuse @whi@" + s;
                this.menuActionTypes[this.menuActionRow] = 507;
                this.menuActionRow++;
              }
              this.menuActionTexts[this.menuActionRow] = "Add ignore @whi@" + s;
              this.menuActionTypes[this.menuActionRow] = 574;
              this.menuActionRow++;
              this.menuActionTexts[this.menuActionRow] = "Add friend @whi@" + s;
              this.menuActionTypes[this.menuActionRow] = 762;
              this.menuActionRow++;
            }
            l++;
          }
          if (j1 === 4 && (this.tradeMode === 0 || this.tradeMode === 1 && this.method148(13292, s))) {
            if (k > k1 - 14 && k <= k1) {
              this.menuActionTexts[this.menuActionRow] = "Accept trade @whi@" + s;
              this.menuActionTypes[this.menuActionRow] = 544;
              this.menuActionRow++;
            }
            l++;
          }
          if ((j1 === 5 || j1 === 6) && this.anInt1223 === 0 && this.privateChatMode < 2) {
            l++;
          }
          if (j1 === 8 && (this.tradeMode === 0 || this.tradeMode === 1 && this.method148(13292, s))) {
            if (k > k1 - 14 && k <= k1) {
              this.menuActionTexts[this.menuActionRow] = "Accept challenge @whi@" + s;
              this.menuActionTypes[this.menuActionRow] = 695;
              this.menuActionRow++;
            }
            l++;
          }
        }
      }
    }
    method43(byte0) {
      if (this.itemSelected === 0 && this.widgetSelected === 0) {
        this.menuActionTexts[this.menuActionRow] = "Walk here";
        this.menuActionTypes[this.menuActionRow] = 14;
        this.firstMenuOperand[this.menuActionRow] = this.mouseX;
        this.secondMenuOperand[this.menuActionRow] = this.mouseY;
        this.menuActionRow++;
      }
      let i = -1;
      if (byte0 !== 7) {
        this.opcode = -1;
      }
      for (let j = 0; j < Model.anInt1708; j++) {
        {
          const k = Model.anIntArray1709[j];
          const l = k & 127;
          const i1 = k >> 7 & 127;
          const j1 = k >> 29 & 3;
          const k1 = k >> 14 & 32767;
          if (k === i) {
            continue;
          }
          i = k;
          if (j1 === 2 && this.currentScene.method271(this.plane, l, i1, k) >= 0) {
            let class47 = GameObjectDefinition.getDefinition(k1);
            if (class47.childrenIds != null) {
              class47 = class47.getChildDefinition();
            }
            if (class47 == null) {
              continue;
            }
            if (this.itemSelected === 1) {
              this.menuActionTexts[this.menuActionRow] = "Use " + this.aString1150 + " with @cya@" + class47.name;
              this.menuActionTypes[this.menuActionRow] = 467;
              this.selectedMenuActions[this.menuActionRow] = k;
              this.firstMenuOperand[this.menuActionRow] = l;
              this.secondMenuOperand[this.menuActionRow] = i1;
              this.menuActionRow++;
            } else if (this.widgetSelected === 1) {
              if ((this.anInt1173 & 4) === 4) {
                this.menuActionTexts[this.menuActionRow] = this.selectedWidgetName + " @cya@" + class47.name;
                this.menuActionTypes[this.menuActionRow] = 376;
                this.selectedMenuActions[this.menuActionRow] = k;
                this.firstMenuOperand[this.menuActionRow] = l;
                this.secondMenuOperand[this.menuActionRow] = i1;
                this.menuActionRow++;
              }
            } else {
              if (class47.options != null) {
                for (let l1 = 4; l1 >= 0; l1--) {
                  if (class47.options[l1] != null) {
                    this.menuActionTexts[this.menuActionRow] = class47.options[l1] + " @cya@" + class47.name;
                    if (l1 === 0) {
                      this.menuActionTypes[this.menuActionRow] = 35;
                    }
                    if (l1 === 1) {
                      this.menuActionTypes[this.menuActionRow] = 389;
                    }
                    if (l1 === 2) {
                      this.menuActionTypes[this.menuActionRow] = 888;
                    }
                    if (l1 === 3) {
                      this.menuActionTypes[this.menuActionRow] = 892;
                    }
                    if (l1 === 4) {
                      this.menuActionTypes[this.menuActionRow] = 1280;
                    }
                    this.selectedMenuActions[this.menuActionRow] = k;
                    this.firstMenuOperand[this.menuActionRow] = l;
                    this.secondMenuOperand[this.menuActionRow] = i1;
                    this.menuActionRow++;
                  }
                }
              }
              this.menuActionTexts[this.menuActionRow] = "Examine @cya@" + class47.name;
              this.menuActionTypes[this.menuActionRow] = 1412;
              this.selectedMenuActions[this.menuActionRow] = class47.id << 14;
              this.firstMenuOperand[this.menuActionRow] = l;
              this.secondMenuOperand[this.menuActionRow] = i1;
              this.menuActionRow++;
            }
          }
          if (j1 === 1) {
            const class50_sub1_sub4_sub3_sub1 = this.npcs[k1];
            if (class50_sub1_sub4_sub3_sub1.npcDefinition.boundaryDimension === 1 && (class50_sub1_sub4_sub3_sub1.worldX & 127) === 64 && (class50_sub1_sub4_sub3_sub1.worldY & 127) === 64) {
              for (let i2 = 0; i2 < this.anInt1133; i2++) {
                {
                  const class50_sub1_sub4_sub3_sub1_1 = this.npcs[this.anIntArray1134[i2]];
                  if (class50_sub1_sub4_sub3_sub1_1 != null && class50_sub1_sub4_sub3_sub1_1 !== class50_sub1_sub4_sub3_sub1 && class50_sub1_sub4_sub3_sub1_1.npcDefinition.boundaryDimension === 1 && class50_sub1_sub4_sub3_sub1_1.worldX === class50_sub1_sub4_sub3_sub1.worldX && class50_sub1_sub4_sub3_sub1_1.worldY === class50_sub1_sub4_sub3_sub1.worldY) {
                    this.method82(
                      class50_sub1_sub4_sub3_sub1_1.npcDefinition,
                      i1,
                      l,
                      this.anIntArray1134[i2],
                      -76 | 0
                    );
                  }
                }
              }
              for (let k2 = 0; k2 < this.localPlayerCount; k2++) {
                {
                  const class50_sub1_sub4_sub3_sub2_1 = this.players[this.playerList[k2]];
                  if (class50_sub1_sub4_sub3_sub2_1 != null && class50_sub1_sub4_sub3_sub2_1.worldX === class50_sub1_sub4_sub3_sub1.worldX && class50_sub1_sub4_sub3_sub2_1.worldY === class50_sub1_sub4_sub3_sub1.worldY) {
                    this.method38(this.playerList[k2], i1, l, class50_sub1_sub4_sub3_sub2_1, 0);
                  }
                }
              }
            }
            this.method82(class50_sub1_sub4_sub3_sub1.npcDefinition, i1, l, k1, -76 | 0);
          }
          if (j1 === 0) {
            const class50_sub1_sub4_sub3_sub2 = this.players[k1];
            if ((class50_sub1_sub4_sub3_sub2.worldX & 127) === 64 && (class50_sub1_sub4_sub3_sub2.worldY & 127) === 64) {
              for (let j2 = 0; j2 < this.anInt1133; j2++) {
                {
                  const class50_sub1_sub4_sub3_sub1_2 = this.npcs[this.anIntArray1134[j2]];
                  if (class50_sub1_sub4_sub3_sub1_2 != null && class50_sub1_sub4_sub3_sub1_2.npcDefinition.boundaryDimension === 1 && class50_sub1_sub4_sub3_sub1_2.worldX === class50_sub1_sub4_sub3_sub2.worldX && class50_sub1_sub4_sub3_sub1_2.worldY === class50_sub1_sub4_sub3_sub2.worldY) {
                    this.method82(
                      class50_sub1_sub4_sub3_sub1_2.npcDefinition,
                      i1,
                      l,
                      this.anIntArray1134[j2],
                      -76 | 0
                    );
                  }
                }
              }
              for (let l2 = 0; l2 < this.localPlayerCount; l2++) {
                {
                  const class50_sub1_sub4_sub3_sub2_2 = this.players[this.playerList[l2]];
                  if (class50_sub1_sub4_sub3_sub2_2 != null && class50_sub1_sub4_sub3_sub2_2 !== class50_sub1_sub4_sub3_sub2 && class50_sub1_sub4_sub3_sub2_2.worldX === class50_sub1_sub4_sub3_sub2.worldX && class50_sub1_sub4_sub3_sub2_2.worldY === class50_sub1_sub4_sub3_sub2.worldY) {
                    this.method38(this.playerList[l2], i1, l, class50_sub1_sub4_sub3_sub2_2, 0);
                  }
                }
              }
            }
            this.method38(k1, i1, l, class50_sub1_sub4_sub3_sub2, 0);
          }
          if (j1 === 3) {
            const class6 = this.groundItems[this.plane][l][i1];
            if (class6 != null) {
              for (let class50_sub1_sub4_sub1 = class6.last(); class50_sub1_sub4_sub1 != null; class50_sub1_sub4_sub1 = class6.previous()) {
                {
                  const class16 = ItemDefinition.lookup(class50_sub1_sub4_sub1.itemId);
                  if (this.itemSelected === 1) {
                    this.menuActionTexts[this.menuActionRow] = "Use " + this.aString1150 + " with @lre@" + class16.name;
                    this.menuActionTypes[this.menuActionRow] = 100;
                    this.selectedMenuActions[this.menuActionRow] = class50_sub1_sub4_sub1.itemId;
                    this.firstMenuOperand[this.menuActionRow] = l;
                    this.secondMenuOperand[this.menuActionRow] = i1;
                    this.menuActionRow++;
                  } else if (this.widgetSelected === 1) {
                    if ((this.anInt1173 & 1) === 1) {
                      this.menuActionTexts[this.menuActionRow] = this.selectedWidgetName + " @lre@" + class16.name;
                      this.menuActionTypes[this.menuActionRow] = 199;
                      this.selectedMenuActions[this.menuActionRow] = class50_sub1_sub4_sub1.itemId;
                      this.firstMenuOperand[this.menuActionRow] = l;
                      this.secondMenuOperand[this.menuActionRow] = i1;
                      this.menuActionRow++;
                    }
                  } else {
                    for (let i3 = 4; i3 >= 0; i3--) {
                      if (class16.groundActions != null && class16.groundActions[i3] != null) {
                        this.menuActionTexts[this.menuActionRow] = class16.groundActions[i3] + " @lre@" + class16.name;
                        if (i3 === 0) {
                          this.menuActionTypes[this.menuActionRow] = 68;
                        }
                        if (i3 === 1) {
                          this.menuActionTypes[this.menuActionRow] = 26;
                        }
                        if (i3 === 2) {
                          this.menuActionTypes[this.menuActionRow] = 684;
                        }
                        if (i3 === 3) {
                          this.menuActionTypes[this.menuActionRow] = 930;
                        }
                        if (i3 === 4) {
                          this.menuActionTypes[this.menuActionRow] = 270;
                        }
                        this.selectedMenuActions[this.menuActionRow] = class50_sub1_sub4_sub1.itemId;
                        this.firstMenuOperand[this.menuActionRow] = l;
                        this.secondMenuOperand[this.menuActionRow] = i1;
                        this.menuActionRow++;
                      } else if (i3 === 2) {
                        this.menuActionTexts[this.menuActionRow] = "Take @lre@" + class16.name;
                        this.menuActionTypes[this.menuActionRow] = 684;
                        this.selectedMenuActions[this.menuActionRow] = class50_sub1_sub4_sub1.itemId;
                        this.firstMenuOperand[this.menuActionRow] = l;
                        this.secondMenuOperand[this.menuActionRow] = i1;
                        this.menuActionRow++;
                      }
                    }
                    this.menuActionTexts[this.menuActionRow] = "Examine @lre@" + class16.name;
                    this.menuActionTypes[this.menuActionRow] = 1564;
                    this.selectedMenuActions[this.menuActionRow] = class50_sub1_sub4_sub1.itemId;
                    this.firstMenuOperand[this.menuActionRow] = l;
                    this.secondMenuOperand[this.menuActionRow] = i1;
                    this.menuActionRow++;
                  }
                }
              }
            }
          }
        }
      }
    }
    method38(i, j, k, class50_sub1_sub4_sub3_sub2, l) {
      if (class50_sub1_sub4_sub3_sub2 === _Game.localPlayer) {
        return;
      }
      if (this.menuActionRow >= 400) {
        return;
      }
      if (l !== 0) {
        _Game.aBoolean963 = !_Game.aBoolean963;
      }
      let s;
      if (class50_sub1_sub4_sub3_sub2.anInt1759 === 0) {
        s = class50_sub1_sub4_sub3_sub2.playerName + _Game.getCombatLevelColour(_Game.localPlayer.combatLevel, class50_sub1_sub4_sub3_sub2.combatLevel) + " (level-" + class50_sub1_sub4_sub3_sub2.combatLevel + ")";
      } else {
        s = class50_sub1_sub4_sub3_sub2.playerName + " (skill-" + class50_sub1_sub4_sub3_sub2.anInt1759 + ")";
      }
      if (this.itemSelected === 1) {
        this.menuActionTexts[this.menuActionRow] = "Use " + this.aString1150 + " with @whi@" + s;
        this.menuActionTypes[this.menuActionRow] = 596;
        this.selectedMenuActions[this.menuActionRow] = i;
        this.firstMenuOperand[this.menuActionRow] = k;
        this.secondMenuOperand[this.menuActionRow] = j;
        this.menuActionRow++;
      } else if (this.widgetSelected === 1) {
        if ((this.anInt1173 & 8) === 8) {
          this.menuActionTexts[this.menuActionRow] = this.selectedWidgetName + " @whi@" + s;
          this.menuActionTypes[this.menuActionRow] = 918;
          this.selectedMenuActions[this.menuActionRow] = i;
          this.firstMenuOperand[this.menuActionRow] = k;
          this.secondMenuOperand[this.menuActionRow] = j;
          this.menuActionRow++;
        }
      } else {
        for (let i1 = 4; i1 >= 0; i1--) {
          if (this.aStringArray1069[i1] != null) {
            this.menuActionTexts[this.menuActionRow] = this.aStringArray1069[i1] + " @whi@" + s;
            let c2 = "\0";
            if (((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(
              this.aStringArray1069[i1],
              "attack"
            )) {
              if (class50_sub1_sub4_sub3_sub2.combatLevel > _Game.localPlayer.combatLevel) {
                c2 = "\u07D0";
              }
              if (_Game.localPlayer.teamId !== 0 && class50_sub1_sub4_sub3_sub2.teamId !== 0) {
                if (_Game.localPlayer.teamId === class50_sub1_sub4_sub3_sub2.teamId) {
                  c2 = "\u07D0";
                } else {
                  c2 = "\0";
                }
              }
            } else if (this.aBooleanArray1070[i1]) {
              c2 = "\u07D0";
            }
            if (i1 === 0) {
              this.menuActionTypes[this.menuActionRow] = 200 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            }
            if (i1 === 1) {
              this.menuActionTypes[this.menuActionRow] = 493 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            }
            if (i1 === 2) {
              this.menuActionTypes[this.menuActionRow] = 408 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            }
            if (i1 === 3) {
              this.menuActionTypes[this.menuActionRow] = 677 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            }
            if (i1 === 4) {
              this.menuActionTypes[this.menuActionRow] = 876 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
            }
            this.selectedMenuActions[this.menuActionRow] = i;
            this.firstMenuOperand[this.menuActionRow] = k;
            this.secondMenuOperand[this.menuActionRow] = j;
            this.menuActionRow++;
          }
        }
      }
      for (let j1 = 0; j1 < this.menuActionRow; j1++) {
        if (this.menuActionTypes[j1] === 14) {
          this.menuActionTexts[j1] = "Walk here @whi@" + s;
          return;
        }
      }
    }
    method82(class37, i, j, k, byte0) {
      if (byte0 !== -76) {
        this.groundItems = null;
      }
      if (this.menuActionRow >= 400) {
        return;
      }
      if (class37.childrenIds != null) {
        class37 = class37.getChildDefinition();
      }
      if (class37 == null) {
        return;
      }
      if (!class37.clickable) {
        return;
      }
      let s = class37.name;
      if (class37.combatLevel !== 0) {
        s = s + _Game.getCombatLevelColour(_Game.localPlayer.combatLevel, class37.combatLevel) + " (level-" + class37.combatLevel + ")";
      }
      if (this.itemSelected === 1) {
        this.menuActionTexts[this.menuActionRow] = "Use " + this.aString1150 + " with @yel@" + s;
        this.menuActionTypes[this.menuActionRow] = 347;
        this.selectedMenuActions[this.menuActionRow] = k;
        this.firstMenuOperand[this.menuActionRow] = j;
        this.secondMenuOperand[this.menuActionRow] = i;
        this.menuActionRow++;
        return;
      }
      if (this.widgetSelected === 1) {
        if ((this.anInt1173 & 2) === 2) {
          this.menuActionTexts[this.menuActionRow] = this.selectedWidgetName + " @yel@" + s;
          this.menuActionTypes[this.menuActionRow] = 67;
          this.selectedMenuActions[this.menuActionRow] = k;
          this.firstMenuOperand[this.menuActionRow] = j;
          this.secondMenuOperand[this.menuActionRow] = i;
          this.menuActionRow++;
          return;
        }
      } else {
        if (class37.actions != null) {
          for (let l = 4; l >= 0; l--) {
            if (class37.actions[l] != null && !((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(
              class37.actions[l],
              "attack"
            )) {
              this.menuActionTexts[this.menuActionRow] = class37.actions[l] + " @yel@" + s;
              if (l === 0) {
                this.menuActionTypes[this.menuActionRow] = 318;
              }
              if (l === 1) {
                this.menuActionTypes[this.menuActionRow] = 921;
              }
              if (l === 2) {
                this.menuActionTypes[this.menuActionRow] = 118;
              }
              if (l === 3) {
                this.menuActionTypes[this.menuActionRow] = 553;
              }
              if (l === 4) {
                this.menuActionTypes[this.menuActionRow] = 432;
              }
              this.selectedMenuActions[this.menuActionRow] = k;
              this.firstMenuOperand[this.menuActionRow] = j;
              this.secondMenuOperand[this.menuActionRow] = i;
              this.menuActionRow++;
            }
          }
        }
        if (class37.actions != null) {
          for (let i1 = 4; i1 >= 0; i1--) {
            if (class37.actions[i1] != null && ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(
              class37.actions[i1],
              "attack"
            )) {
              let c2 = "\0";
              if (class37.combatLevel > _Game.localPlayer.combatLevel) {
                c2 = "\u07D0";
              }
              this.menuActionTexts[this.menuActionRow] = class37.actions[i1] + " @yel@" + s;
              if (i1 === 0) {
                this.menuActionTypes[this.menuActionRow] = 318 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
              }
              if (i1 === 1) {
                this.menuActionTypes[this.menuActionRow] = 921 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
              }
              if (i1 === 2) {
                this.menuActionTypes[this.menuActionRow] = 118 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
              }
              if (i1 === 3) {
                this.menuActionTypes[this.menuActionRow] = 553 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
              }
              if (i1 === 4) {
                this.menuActionTypes[this.menuActionRow] = 432 + ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2);
              }
              this.selectedMenuActions[this.menuActionRow] = k;
              this.firstMenuOperand[this.menuActionRow] = j;
              this.secondMenuOperand[this.menuActionRow] = i;
              this.menuActionRow++;
            }
          }
        }
        this.menuActionTexts[this.menuActionRow] = "Examine @yel@" + s;
        this.menuActionTypes[this.menuActionRow] = 1668;
        this.selectedMenuActions[this.menuActionRow] = k;
        this.firstMenuOperand[this.menuActionRow] = j;
        this.secondMenuOperand[this.menuActionRow] = i;
        this.menuActionRow++;
      }
    }
    method111(i) {
      i = 21 / i | 0;
      if (this.anInt1223 === 0) {
        return;
      }
      let j = 0;
      if (this.systemUpdateTime !== 0) {
        j = 1;
      }
      for (let k = 0; k < 100; k++) {
        if (this.chatMessages[k] != null) {
          const l = this.chatTypes[k];
          let s = this.chatPlayerNames[k];
          if (s != null && ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(
            s,
            "@cr1@"
          )) {
            s = s.substring(5);
          }
          if (s != null && ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(
            s,
            "@cr2@"
          )) {
            s = s.substring(5);
          }
          if ((l === 3 || l === 7) && (l === 7 || this.privateChatMode === 0 || this.privateChatMode === 1 && this.method148(13292, s))) {
            const i1 = 329 - j * 13;
            if (this.mouseX > 4 && this.mouseY - 4 > i1 - 10 && this.mouseY - 4 <= i1 + 3) {
              let j1 = this.fontNormal.getStringEffectWidth("From:  " + s + this.chatMessages[k]) + 25;
              if (j1 > 450) {
                j1 = 450;
              }
              if (this.mouseX < 4 + j1) {
                if (this.playerRights >= 1) {
                  this.menuActionTexts[this.menuActionRow] = "Report abuse @whi@" + s;
                  this.menuActionTypes[this.menuActionRow] = 2507;
                  this.menuActionRow++;
                }
                this.menuActionTexts[this.menuActionRow] = "Add ignore @whi@" + s;
                this.menuActionTypes[this.menuActionRow] = 2574;
                this.menuActionRow++;
                this.menuActionTexts[this.menuActionRow] = "Add friend @whi@" + s;
                this.menuActionTypes[this.menuActionRow] = 2762;
                this.menuActionRow++;
              }
            }
            if (++j >= 5) {
              return;
            }
          }
          if ((l === 5 || l === 6) && this.privateChatMode < 2 && ++j >= 5) {
            return;
          }
        }
      }
    }
    method148(i, s) {
      if (s == null) {
        return false;
      }
      for (let j = 0; j < this.friendsCount; j++) {
        if (((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(s, this.friendUsernames[j])) {
          return true;
        }
      }
      if (i !== 13292) {
        this.aBoolean1014 = !this.aBoolean1014;
      }
      return ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(
        s,
        _Game.localPlayer.playerName
      );
    }
    method66(i, class13, j, k, l, i1, j1, k1) {
      if (j1 !== 23658) {
        return;
      }
      if (class13.type !== 0 || class13.children == null || class13.hiddenUntilHovered) {
        return;
      }
      if (i1 < l || k1 < i || i1 > l + class13.width || k1 > i + class13.height) {
        return;
      }
      const l1 = class13.children.length;
      for (let i2 = 0; i2 < l1; i2++) {
        {
          let j2 = class13.childrenX[i2] + l;
          let k2 = class13.childrenY[i2] + i - k;
          const child = Widget.forId(class13.children[i2]);
          j2 += child.anInt228;
          k2 += child.anInt259;
          if ((child.hoveredPopup >= 0 || child.disabledHoveredColor !== 0) && i1 >= j2 && k1 >= k2 && i1 < j2 + child.width && k1 < k2 + child.height) {
            if (child.hoveredPopup >= 0) {
              this.anInt915 = child.hoveredPopup;
            } else {
              this.anInt915 = child.id;
            }
          }
          if (child.type === 8 && i1 >= j2 && k1 >= k2 && i1 < j2 + child.width && k1 < k2 + child.height) {
            this.anInt1315 = child.id;
          }
          if (child.type === 0) {
            this.method66(k2, child, j, child.anInt231, j2, i1, 23658, k1);
            if (child.scrollLimit > child.height) {
              this.method42(child.scrollLimit, k2, child, 102 | 0, k1, j, i1, child.height, j2 + child.width);
            }
          } else {
            if (child.actionType === 1 && i1 >= j2 && k1 >= k2 && i1 < j2 + child.width && k1 < k2 + child.height) {
              let flag = false;
              if (child.contentType !== 0) {
                flag = this.processFriendListClick(child);
              }
              if (!flag) {
                this.menuActionTexts[this.menuActionRow] = child.tooltip;
                this.menuActionTypes[this.menuActionRow] = 352;
                this.secondMenuOperand[this.menuActionRow] = child.id;
                this.menuActionRow++;
              }
            }
            if (child.actionType === 2 && this.widgetSelected === 0 && i1 >= j2 && k1 >= k2 && i1 < j2 + child.width && k1 < k2 + child.height) {
              let circumfix = child.optionCircumfix;
              if (circumfix.indexOf(" ") !== -1) {
                circumfix = circumfix.substring(0, circumfix.indexOf(" "));
              }
              this.menuActionTexts[this.menuActionRow] = circumfix + " @gre@" + child.optionText;
              this.menuActionTypes[this.menuActionRow] = Actions.USABLE_WIDGET;
              this.secondMenuOperand[this.menuActionRow] = child.id;
              this.menuActionRow++;
            }
            if (child.actionType === 3 && i1 >= j2 && k1 >= k2 && i1 < j2 + child.width && k1 < k2 + child.height) {
              this.menuActionTexts[this.menuActionRow] = "Close";
              if (j === 3) {
                this.menuActionTypes[this.menuActionRow] = 55;
              } else {
                this.menuActionTypes[this.menuActionRow] = Actions.CLOSE_WIDGETS;
              }
              this.secondMenuOperand[this.menuActionRow] = child.id;
              this.menuActionRow++;
            }
            if (child.actionType === 4 && i1 >= j2 && k1 >= k2 && i1 < j2 + child.width && k1 < k2 + child.height) {
              this.menuActionTexts[this.menuActionRow] = child.tooltip;
              this.menuActionTypes[this.menuActionRow] = 890;
              this.secondMenuOperand[this.menuActionRow] = child.id;
              this.menuActionRow++;
            }
            if (child.actionType === 5 && i1 >= j2 && k1 >= k2 && i1 < j2 + child.width && k1 < k2 + child.height) {
              this.menuActionTexts[this.menuActionRow] = child.tooltip;
              this.menuActionTypes[this.menuActionRow] = 518;
              this.secondMenuOperand[this.menuActionRow] = child.id;
              this.menuActionRow++;
            }
            if (child.actionType === 6 && !this.aBoolean1239 && i1 >= j2 && k1 >= k2 && i1 < j2 + child.width && k1 < k2 + child.height) {
              this.menuActionTexts[this.menuActionRow] = child.tooltip;
              this.menuActionTypes[this.menuActionRow] = Actions.CLICK_TO_CONTINUE;
              this.secondMenuOperand[this.menuActionRow] = child.id;
              this.menuActionRow++;
            }
            if (child.type === 2) {
              let l2 = 0;
              for (let i3 = 0; i3 < child.height; i3++) {
                {
                  for (let j3 = 0; j3 < child.width; j3++) {
                    {
                      let k3 = j2 + j3 * (32 + child.itemSpritePadsX);
                      let l3 = k2 + i3 * (32 + child.itemSpritePadsY);
                      if (l2 < 20) {
                        k3 += child.imageX[l2];
                        l3 += child.imageY[l2];
                      }
                      if (i1 >= k3 && k1 >= l3 && i1 < k3 + 32 && k1 < l3 + 32) {
                        this.mouseInvInterfaceIndex = l2;
                        this.lastActiveInvInterface = child.id;
                        if (child.items[l2] > 0) {
                          const definition = ItemDefinition.lookup(child.items[l2] - 1);
                          if (this.itemSelected === 1 && child.isInventory) {
                            if (child.id !== this.anInt1148 || l2 !== this.anInt1147) {
                              this.menuActionTexts[this.menuActionRow] = "Use " + this.aString1150 + " with @lre@" + definition.name;
                              this.menuActionTypes[this.menuActionRow] = 903;
                              this.selectedMenuActions[this.menuActionRow] = definition.id;
                              this.firstMenuOperand[this.menuActionRow] = l2;
                              this.secondMenuOperand[this.menuActionRow] = child.id;
                              this.menuActionRow++;
                            }
                          } else if (this.widgetSelected === 1 && child.isInventory) {
                            if ((this.anInt1173 & 16) === 16) {
                              this.menuActionTexts[this.menuActionRow] = this.selectedWidgetName + " @lre@" + definition.name;
                              this.menuActionTypes[this.menuActionRow] = 361;
                              this.selectedMenuActions[this.menuActionRow] = definition.id;
                              this.firstMenuOperand[this.menuActionRow] = l2;
                              this.secondMenuOperand[this.menuActionRow] = child.id;
                              this.menuActionRow++;
                            }
                          } else {
                            if (child.isInventory) {
                              for (let i4 = 4; i4 >= 3; i4--) {
                                if (definition.inventoryActions != null && definition.inventoryActions[i4] != null) {
                                  this.menuActionTexts[this.menuActionRow] = definition.inventoryActions[i4] + " @lre@" + definition.name;
                                  if (i4 === 3) {
                                    this.menuActionTypes[this.menuActionRow] = 227;
                                  }
                                  if (i4 === 4) {
                                    this.menuActionTypes[this.menuActionRow] = 891;
                                  }
                                  this.selectedMenuActions[this.menuActionRow] = definition.id;
                                  this.firstMenuOperand[this.menuActionRow] = l2;
                                  this.secondMenuOperand[this.menuActionRow] = child.id;
                                  this.menuActionRow++;
                                } else if (i4 === 4) {
                                  this.menuActionTexts[this.menuActionRow] = "Drop @lre@" + definition.name;
                                  this.menuActionTypes[this.menuActionRow] = 891;
                                  this.selectedMenuActions[this.menuActionRow] = definition.id;
                                  this.firstMenuOperand[this.menuActionRow] = l2;
                                  this.secondMenuOperand[this.menuActionRow] = child.id;
                                  this.menuActionRow++;
                                }
                              }
                            }
                            if (child.itemUsable) {
                              this.menuActionTexts[this.menuActionRow] = "Use @lre@" + definition.name;
                              this.menuActionTypes[this.menuActionRow] = 52;
                              this.selectedMenuActions[this.menuActionRow] = definition.id;
                              this.firstMenuOperand[this.menuActionRow] = l2;
                              this.secondMenuOperand[this.menuActionRow] = child.id;
                              this.menuActionRow++;
                            }
                            if (child.isInventory && definition.inventoryActions != null) {
                              for (let j4 = 2; j4 >= 0; j4--) {
                                if (definition.inventoryActions[j4] != null) {
                                  this.menuActionTexts[this.menuActionRow] = definition.inventoryActions[j4] + " @lre@" + definition.name;
                                  if (j4 === 0) {
                                    this.menuActionTypes[this.menuActionRow] = 961;
                                  }
                                  if (j4 === 1) {
                                    this.menuActionTypes[this.menuActionRow] = 399;
                                  }
                                  if (j4 === 2) {
                                    this.menuActionTypes[this.menuActionRow] = 324;
                                  }
                                  this.selectedMenuActions[this.menuActionRow] = definition.id;
                                  this.firstMenuOperand[this.menuActionRow] = l2;
                                  this.secondMenuOperand[this.menuActionRow] = child.id;
                                  this.menuActionRow++;
                                }
                              }
                            }
                            if (child.options != null) {
                              for (let k4 = 4; k4 >= 0; k4--) {
                                if (child.options[k4] != null) {
                                  this.menuActionTexts[this.menuActionRow] = child.options[k4] + " @lre@" + definition.name;
                                  if (k4 === 0) {
                                    this.menuActionTypes[this.menuActionRow] = 9;
                                  }
                                  if (k4 === 1) {
                                    this.menuActionTypes[this.menuActionRow] = 225;
                                  }
                                  if (k4 === 2) {
                                    this.menuActionTypes[this.menuActionRow] = 444;
                                  }
                                  if (k4 === 3) {
                                    this.menuActionTypes[this.menuActionRow] = 564;
                                  }
                                  if (k4 === 4) {
                                    this.menuActionTypes[this.menuActionRow] = 894;
                                  }
                                  this.selectedMenuActions[this.menuActionRow] = definition.id;
                                  this.firstMenuOperand[this.menuActionRow] = l2;
                                  this.secondMenuOperand[this.menuActionRow] = child.id;
                                  this.menuActionRow++;
                                }
                              }
                            }
                            this.menuActionTexts[this.menuActionRow] = "Examine @lre@" + definition.name;
                            this.menuActionTypes[this.menuActionRow] = Actions.EXAMINE_ITEM;
                            this.selectedMenuActions[this.menuActionRow] = definition.id;
                            this.firstMenuOperand[this.menuActionRow] = l2;
                            this.secondMenuOperand[this.menuActionRow] = child.id;
                            this.menuActionRow++;
                          }
                        }
                      }
                      l2++;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    processFriendListClick(widget) {
      let row = widget.contentType;
      if (row >= 1 && row <= 200 || row >= 701 && row <= 900) {
        if (row >= 801) {
          row -= 701;
        } else if (row >= 701) {
          row -= 601;
        } else if (row >= 101) {
          row -= 101;
        } else {
          row--;
        }
        this.menuActionTexts[this.menuActionRow] = "Remove @whi@" + this.friendUsernames[row];
        this.menuActionTypes[this.menuActionRow] = Actions.REMOVE_FRIEND;
        this.menuActionRow++;
        this.menuActionTexts[this.menuActionRow] = "Message @whi@" + this.friendUsernames[row];
        this.menuActionTypes[this.menuActionRow] = Actions.PRIVATE_MESSAGE;
        this.menuActionRow++;
        return true;
      }
      if (row >= 401 && row <= 500) {
        this.menuActionTexts[this.menuActionRow] = "Remove @whi@" + widget.disabledText;
        this.menuActionTypes[this.menuActionRow] = Actions.REMOVE_FRIEND;
        this.menuActionRow++;
        return true;
      } else {
        return false;
      }
    }
    method42(i, j, class13, byte0, k, l, i1, j1, k1) {
      if (this.aBoolean1127) {
        this.anInt1303 = 32;
      } else {
        this.anInt1303 = 0;
      }
      this.aBoolean1127 = false;
      if (byte0 !== 102) {
        for (let l1 = 1; l1 > 0; l1++) {
        }
      }
      if (i1 >= k1 && i1 < k1 + 16 && k >= j && k < j + 16) {
        class13.anInt231 -= this.anInt1094 * 4;
        if (l === 1) {
          this.redrawTabArea = true;
        }
        if (l === 2 || l === 3) {
          this.redrawChatbox = true;
        }
        return;
      }
      if (i1 >= k1 && i1 < k1 + 16 && k >= j + j1 - 16 && k < j + j1) {
        class13.anInt231 += this.anInt1094 * 4;
        if (l === 1) {
          this.redrawTabArea = true;
        }
        if (l === 2 || l === 3) {
          this.redrawChatbox = true;
        }
        return;
      }
      if (i1 >= k1 - this.anInt1303 && i1 < k1 + 16 + this.anInt1303 && k >= j + 16 && k < j + j1 - 16 && this.anInt1094 > 0) {
        let i2 = (j1 - 32) * j1 / i | 0;
        if (i2 < 8) {
          i2 = 8;
        }
        const j2 = k - j - 16 - (i2 / 2 | 0);
        const k2 = j1 - 32 - i2;
        class13.anInt231 = (i - j1) * j2 / k2 | 0;
        if (l === 1) {
          this.redrawTabArea = true;
        }
        if (l === 2 || l === 3) {
          this.redrawChatbox = true;
        }
        this.aBoolean1127 = true;
      }
    }
    processActorOverheadText() {
      for (let i = -1; i < this.localPlayerCount; i++) {
        {
          const index = i === -1 ? this.thisPlayerId : this.playerList[i];
          const player2 = this.players[index];
          if (player2 != null && player2.textCycle > 0) {
            player2.textCycle--;
            if (player2.textCycle === 0) {
              player2.forcedChat = null;
            }
          }
        }
      }
      for (let i = 0; i < this.anInt1133; i++) {
        {
          const index = this.anIntArray1134[i];
          const npc = this.npcs[index];
          if (npc != null && npc.textCycle > 0) {
            npc.textCycle--;
            if (npc.textCycle === 0) {
              npc.forcedChat = null;
            }
          }
        }
      }
    }
    method67(i) {
      for (let j = 0; j < this.anInt1133; j++) {
        {
          const k = this.anIntArray1134[j];
          const class50_sub1_sub4_sub3_sub1 = this.npcs[k];
          if (class50_sub1_sub4_sub3_sub1 != null) {
            this.method68(
              class50_sub1_sub4_sub3_sub1.npcDefinition.boundaryDimension,
              -97 | 0,
              class50_sub1_sub4_sub3_sub1
            );
          }
        }
      }
      if (i !== -37214) {
        this.outBuffer.putByte(41);
      }
    }
    method68(i, byte0, actor) {
      if (actor.worldX < 128 || actor.worldY < 128 || actor.worldX >= 13184 || actor.worldY >= 13184) {
        actor.emoteAnimation = -1;
        actor.graphic = -1;
        actor.anInt1606 = 0;
        actor.anInt1607 = 0;
        actor.worldX = actor.pathX[0] * 128 + actor.boundaryDimension * 64;
        actor.worldY = actor.pathY[0] * 128 + actor.boundaryDimension * 64;
        actor.resetPath();
      }
      if (actor === _Game.localPlayer && (actor.worldX < 1536 || actor.worldY < 1536 || actor.worldX >= 11776 || actor.worldY >= 11776)) {
        actor.emoteAnimation = -1;
        actor.graphic = -1;
        actor.anInt1606 = 0;
        actor.anInt1607 = 0;
        actor.worldX = actor.pathX[0] * 128 + actor.boundaryDimension * 64;
        actor.worldY = actor.pathY[0] * 128 + actor.boundaryDimension * 64;
        actor.resetPath();
      }
      if (actor.anInt1606 > _Game.pulseCycle) {
        this.method69(actor, true);
      } else if (actor.anInt1607 >= _Game.pulseCycle) {
        this.method70(actor, -31135);
      } else {
        this.method71(actor, 0);
      }
      this.method72(8 | 0, actor);
      this.method73(actor, -136);
      if (byte0 === -97) {
      }
    }
    method72(byte0, class50_sub1_sub4_sub3) {
      if (byte0 !== 8) {
        this.anInt928 = this.incomingRandom.nextInt() | 0;
      }
      if (class50_sub1_sub4_sub3.anInt1600 === 0) {
        return;
      }
      if (class50_sub1_sub4_sub3.anInt1609 !== -1 && class50_sub1_sub4_sub3.anInt1609 < 32768) {
        const class50_sub1_sub4_sub3_sub1 = this.npcs[class50_sub1_sub4_sub3.anInt1609];
        if (class50_sub1_sub4_sub3_sub1 != null) {
          const l = class50_sub1_sub4_sub3.worldX - class50_sub1_sub4_sub3_sub1.worldX;
          const j1 = class50_sub1_sub4_sub3.worldY - class50_sub1_sub4_sub3_sub1.worldY;
          if (l !== 0 || j1 !== 0) {
            class50_sub1_sub4_sub3.nextStepOrientation = (Math.atan2(l, j1) * 325.949 | 0) & 2047;
          }
        }
      }
      if (class50_sub1_sub4_sub3.anInt1609 >= 32768) {
        let i = class50_sub1_sub4_sub3.anInt1609 - 32768;
        if (i === this.thisPlayerServerId) {
          i = this.thisPlayerId;
        }
        const class50_sub1_sub4_sub3_sub2 = this.players[i];
        if (class50_sub1_sub4_sub3_sub2 != null) {
          const k1 = class50_sub1_sub4_sub3.worldX - class50_sub1_sub4_sub3_sub2.worldX;
          const l1 = class50_sub1_sub4_sub3.worldY - class50_sub1_sub4_sub3_sub2.worldY;
          if (k1 !== 0 || l1 !== 0) {
            class50_sub1_sub4_sub3.nextStepOrientation = (Math.atan2(k1, l1) * 325.949 | 0) & 2047;
          }
        }
      }
      if ((class50_sub1_sub4_sub3.anInt1598 !== 0 || class50_sub1_sub4_sub3.anInt1599 !== 0) && (class50_sub1_sub4_sub3.pathLength === 0 || class50_sub1_sub4_sub3.anInt1623 > 0)) {
        const j = class50_sub1_sub4_sub3.worldX - (class50_sub1_sub4_sub3.anInt1598 - this.nextTopLeftTileX - this.nextTopLeftTileX) * 64;
        const i1 = class50_sub1_sub4_sub3.worldY - (class50_sub1_sub4_sub3.anInt1599 - this.nextTopRightTileY - this.nextTopRightTileY) * 64;
        if (j !== 0 || i1 !== 0) {
          class50_sub1_sub4_sub3.nextStepOrientation = (Math.atan2(j, i1) * 325.949 | 0) & 2047;
        }
        class50_sub1_sub4_sub3.anInt1598 = 0;
        class50_sub1_sub4_sub3.anInt1599 = 0;
      }
      const k = class50_sub1_sub4_sub3.nextStepOrientation - class50_sub1_sub4_sub3.anInt1612 & 2047;
      if (k !== 0) {
        if (k < class50_sub1_sub4_sub3.anInt1600 || k > 2048 - class50_sub1_sub4_sub3.anInt1600) {
          class50_sub1_sub4_sub3.anInt1612 = class50_sub1_sub4_sub3.nextStepOrientation;
        } else if (k > 1024) {
          class50_sub1_sub4_sub3.anInt1612 -= class50_sub1_sub4_sub3.anInt1600;
        } else {
          class50_sub1_sub4_sub3.anInt1612 += class50_sub1_sub4_sub3.anInt1600;
        }
        class50_sub1_sub4_sub3.anInt1612 &= 2047;
        if (class50_sub1_sub4_sub3.movementAnimation === class50_sub1_sub4_sub3.idleAnimation && class50_sub1_sub4_sub3.anInt1612 !== class50_sub1_sub4_sub3.nextStepOrientation) {
          if (class50_sub1_sub4_sub3.standTurnAnimationId !== -1) {
            class50_sub1_sub4_sub3.movementAnimation = class50_sub1_sub4_sub3.standTurnAnimationId;
            return;
          }
          class50_sub1_sub4_sub3.movementAnimation = class50_sub1_sub4_sub3.walkAnimationId;
        }
      }
    }
    method73(class50_sub1_sub4_sub3, i) {
      while (i >= 0) {
        this.anInt1328 = this.incomingRandom.nextInt() | 0;
      }
      class50_sub1_sub4_sub3.aBoolean1592 = false;
      if (class50_sub1_sub4_sub3.movementAnimation !== -1) {
        const class14 = AnimationSequence.animations[class50_sub1_sub4_sub3.movementAnimation];
        class50_sub1_sub4_sub3.anInt1590++;
        if (class50_sub1_sub4_sub3.displayedMovementFrames < class14.frameCount && class50_sub1_sub4_sub3.anInt1590 > class14.getFrameLength(class50_sub1_sub4_sub3.displayedMovementFrames)) {
          class50_sub1_sub4_sub3.anInt1590 = 1;
          class50_sub1_sub4_sub3.displayedMovementFrames++;
        }
        if (class50_sub1_sub4_sub3.displayedMovementFrames >= class14.frameCount) {
          class50_sub1_sub4_sub3.anInt1590 = 1;
          class50_sub1_sub4_sub3.displayedMovementFrames = 0;
        }
      }
      if (class50_sub1_sub4_sub3.graphic !== -1 && _Game.pulseCycle >= class50_sub1_sub4_sub3.anInt1617) {
        if (class50_sub1_sub4_sub3.currentAnimation < 0) {
          class50_sub1_sub4_sub3.currentAnimation = 0;
        }
        const class14_1 = SpotAnimation.cache[class50_sub1_sub4_sub3.graphic].sequences;
        class50_sub1_sub4_sub3.anInt1616++;
        if (class50_sub1_sub4_sub3.currentAnimation < class14_1.frameCount && class50_sub1_sub4_sub3.anInt1616 > class14_1.getFrameLength(class50_sub1_sub4_sub3.currentAnimation)) {
          class50_sub1_sub4_sub3.anInt1616 = 1;
          class50_sub1_sub4_sub3.currentAnimation++;
        }
        if (class50_sub1_sub4_sub3.currentAnimation >= class14_1.frameCount && (class50_sub1_sub4_sub3.currentAnimation < 0 || class50_sub1_sub4_sub3.currentAnimation >= class14_1.frameCount)) {
          class50_sub1_sub4_sub3.graphic = -1;
        }
      }
      if (class50_sub1_sub4_sub3.emoteAnimation !== -1 && class50_sub1_sub4_sub3.animationDelay <= 1) {
        const class14_2 = AnimationSequence.animations[class50_sub1_sub4_sub3.emoteAnimation];
        if (class14_2.anInt305 === 1 && class50_sub1_sub4_sub3.anInt1613 > 0 && class50_sub1_sub4_sub3.anInt1606 <= _Game.pulseCycle && class50_sub1_sub4_sub3.anInt1607 < _Game.pulseCycle) {
          class50_sub1_sub4_sub3.animationDelay = 1;
          return;
        }
      }
      if (class50_sub1_sub4_sub3.emoteAnimation !== -1 && class50_sub1_sub4_sub3.animationDelay === 0) {
        const class14_3 = AnimationSequence.animations[class50_sub1_sub4_sub3.emoteAnimation];
        class50_sub1_sub4_sub3.anInt1626++;
        if (class50_sub1_sub4_sub3.displayedEmoteFrames < class14_3.frameCount && class50_sub1_sub4_sub3.anInt1626 > class14_3.getFrameLength(class50_sub1_sub4_sub3.displayedEmoteFrames)) {
          class50_sub1_sub4_sub3.anInt1626 = 1;
          class50_sub1_sub4_sub3.displayedEmoteFrames++;
        }
        if (class50_sub1_sub4_sub3.displayedEmoteFrames >= class14_3.frameCount) {
          class50_sub1_sub4_sub3.displayedEmoteFrames -= class14_3.frameStep;
          class50_sub1_sub4_sub3.anInt1628++;
          if (class50_sub1_sub4_sub3.anInt1628 >= class14_3.anInt304) {
            class50_sub1_sub4_sub3.emoteAnimation = -1;
          }
          if (class50_sub1_sub4_sub3.displayedEmoteFrames < 0 || class50_sub1_sub4_sub3.displayedEmoteFrames >= class14_3.frameCount) {
            class50_sub1_sub4_sub3.emoteAnimation = -1;
          }
        }
        class50_sub1_sub4_sub3.aBoolean1592 = class14_3.aBoolean300;
      }
      if (class50_sub1_sub4_sub3.animationDelay > 0) {
        class50_sub1_sub4_sub3.animationDelay--;
      }
    }
    method71(class50_sub1_sub4_sub3, i) {
      class50_sub1_sub4_sub3.movementAnimation = class50_sub1_sub4_sub3.idleAnimation;
      if (class50_sub1_sub4_sub3.pathLength === 0) {
        class50_sub1_sub4_sub3.anInt1623 = 0;
        return;
      }
      if (class50_sub1_sub4_sub3.emoteAnimation !== -1 && class50_sub1_sub4_sub3.animationDelay === 0) {
        const class14 = AnimationSequence.animations[class50_sub1_sub4_sub3.emoteAnimation];
        if (class50_sub1_sub4_sub3.anInt1613 > 0 && class14.anInt305 === 0) {
          class50_sub1_sub4_sub3.anInt1623++;
          return;
        }
        if (class50_sub1_sub4_sub3.anInt1613 <= 0 && class14.priority === 0) {
          class50_sub1_sub4_sub3.anInt1623++;
          return;
        }
      }
      const j = class50_sub1_sub4_sub3.worldX;
      const k = class50_sub1_sub4_sub3.worldY;
      const l = class50_sub1_sub4_sub3.pathX[class50_sub1_sub4_sub3.pathLength - 1] * 128 + class50_sub1_sub4_sub3.boundaryDimension * 64;
      const i1 = class50_sub1_sub4_sub3.pathY[class50_sub1_sub4_sub3.pathLength - 1] * 128 + class50_sub1_sub4_sub3.boundaryDimension * 64;
      if (l - j > 256 || l - j < -256 || i1 - k > 256 || i1 - k < -256) {
        class50_sub1_sub4_sub3.worldX = l;
        class50_sub1_sub4_sub3.worldY = i1;
        return;
      }
      if (j < l) {
        if (k < i1) {
          class50_sub1_sub4_sub3.nextStepOrientation = 1280;
        } else if (k > i1) {
          class50_sub1_sub4_sub3.nextStepOrientation = 1792;
        } else {
          class50_sub1_sub4_sub3.nextStepOrientation = 1536;
        }
      } else if (j > l) {
        if (k < i1) {
          class50_sub1_sub4_sub3.nextStepOrientation = 768;
        } else if (k > i1) {
          class50_sub1_sub4_sub3.nextStepOrientation = 256;
        } else {
          class50_sub1_sub4_sub3.nextStepOrientation = 512;
        }
      } else if (k < i1) {
        class50_sub1_sub4_sub3.nextStepOrientation = 1024;
      } else {
        class50_sub1_sub4_sub3.nextStepOrientation = 0;
      }
      let j1 = class50_sub1_sub4_sub3.nextStepOrientation - class50_sub1_sub4_sub3.anInt1612 & 2047;
      if (j1 > 1024) {
        j1 -= 2048;
      }
      let k1 = class50_sub1_sub4_sub3.turnAroundAnimationId;
      if (i !== 0) {
        this.outBuffer.putByte(34);
      }
      if (j1 >= -256 && j1 <= 256) {
        k1 = class50_sub1_sub4_sub3.walkAnimationId;
      } else if (j1 >= 256 && j1 < 768) {
        k1 = class50_sub1_sub4_sub3.turnLeftAnimationId;
      } else if (j1 >= -768 && j1 <= -256) {
        k1 = class50_sub1_sub4_sub3.turnRightAnimationId;
      }
      if (k1 === -1) {
        k1 = class50_sub1_sub4_sub3.walkAnimationId;
      }
      class50_sub1_sub4_sub3.movementAnimation = k1;
      let l1 = 4;
      if (class50_sub1_sub4_sub3.anInt1612 !== class50_sub1_sub4_sub3.nextStepOrientation && class50_sub1_sub4_sub3.anInt1609 === -1 && class50_sub1_sub4_sub3.anInt1600 !== 0) {
        l1 = 2;
      }
      if (class50_sub1_sub4_sub3.pathLength > 2) {
        l1 = 6;
      }
      if (class50_sub1_sub4_sub3.pathLength > 3) {
        l1 = 8;
      }
      if (class50_sub1_sub4_sub3.anInt1623 > 0 && class50_sub1_sub4_sub3.pathLength > 1) {
        l1 = 8;
        class50_sub1_sub4_sub3.anInt1623--;
      }
      if (class50_sub1_sub4_sub3.runningQueue[class50_sub1_sub4_sub3.pathLength - 1]) {
        l1 <<= 1;
      }
      if (l1 >= 8 && class50_sub1_sub4_sub3.movementAnimation === class50_sub1_sub4_sub3.walkAnimationId && class50_sub1_sub4_sub3.runAnimationId !== -1) {
        class50_sub1_sub4_sub3.movementAnimation = class50_sub1_sub4_sub3.runAnimationId;
      }
      if (j < l) {
        class50_sub1_sub4_sub3.worldX += l1;
        if (class50_sub1_sub4_sub3.worldX > l) {
          class50_sub1_sub4_sub3.worldX = l;
        }
      } else if (j > l) {
        class50_sub1_sub4_sub3.worldX -= l1;
        if (class50_sub1_sub4_sub3.worldX < l) {
          class50_sub1_sub4_sub3.worldX = l;
        }
      }
      if (k < i1) {
        class50_sub1_sub4_sub3.worldY += l1;
        if (class50_sub1_sub4_sub3.worldY > i1) {
          class50_sub1_sub4_sub3.worldY = i1;
        }
      } else if (k > i1) {
        class50_sub1_sub4_sub3.worldY -= l1;
        if (class50_sub1_sub4_sub3.worldY < i1) {
          class50_sub1_sub4_sub3.worldY = i1;
        }
      }
      if (class50_sub1_sub4_sub3.worldX === l && class50_sub1_sub4_sub3.worldY === i1) {
        class50_sub1_sub4_sub3.pathLength--;
        if (class50_sub1_sub4_sub3.anInt1613 > 0) {
          class50_sub1_sub4_sub3.anInt1613--;
        }
      }
    }
    method69(class50_sub1_sub4_sub3, flag) {
      if (!flag) {
        _Game.aBoolean963 = !_Game.aBoolean963;
      }
      const i = class50_sub1_sub4_sub3.anInt1606 - _Game.pulseCycle;
      const j = class50_sub1_sub4_sub3.anInt1602 * 128 + class50_sub1_sub4_sub3.boundaryDimension * 64;
      const k = class50_sub1_sub4_sub3.anInt1604 * 128 + class50_sub1_sub4_sub3.boundaryDimension * 64;
      class50_sub1_sub4_sub3.worldX += (j - class50_sub1_sub4_sub3.worldX) / i | 0;
      class50_sub1_sub4_sub3.worldY += (k - class50_sub1_sub4_sub3.worldY) / i | 0;
      class50_sub1_sub4_sub3.anInt1623 = 0;
      if (class50_sub1_sub4_sub3.anInt1608 === 0) {
        class50_sub1_sub4_sub3.nextStepOrientation = 1024;
      }
      if (class50_sub1_sub4_sub3.anInt1608 === 1) {
        class50_sub1_sub4_sub3.nextStepOrientation = 1536;
      }
      if (class50_sub1_sub4_sub3.anInt1608 === 2) {
        class50_sub1_sub4_sub3.nextStepOrientation = 0;
      }
      if (class50_sub1_sub4_sub3.anInt1608 === 3) {
        class50_sub1_sub4_sub3.nextStepOrientation = 512;
      }
    }
    method70(class50_sub1_sub4_sub3, i) {
      if (class50_sub1_sub4_sub3.anInt1607 === _Game.pulseCycle || class50_sub1_sub4_sub3.emoteAnimation === -1 || class50_sub1_sub4_sub3.animationDelay !== 0 || class50_sub1_sub4_sub3.anInt1626 + 1 > AnimationSequence.animations[class50_sub1_sub4_sub3.emoteAnimation].getFrameLength(
        class50_sub1_sub4_sub3.displayedEmoteFrames
      )) {
        const j = class50_sub1_sub4_sub3.anInt1607 - class50_sub1_sub4_sub3.anInt1606;
        const k = _Game.pulseCycle - class50_sub1_sub4_sub3.anInt1606;
        const l = class50_sub1_sub4_sub3.anInt1602 * 128 + class50_sub1_sub4_sub3.boundaryDimension * 64;
        const i1 = class50_sub1_sub4_sub3.anInt1604 * 128 + class50_sub1_sub4_sub3.boundaryDimension * 64;
        const j1 = class50_sub1_sub4_sub3.anInt1603 * 128 + class50_sub1_sub4_sub3.boundaryDimension * 64;
        const k1 = class50_sub1_sub4_sub3.anInt1605 * 128 + class50_sub1_sub4_sub3.boundaryDimension * 64;
        class50_sub1_sub4_sub3.worldX = (l * (j - k) + j1 * k) / j | 0;
        class50_sub1_sub4_sub3.worldY = (i1 * (j - k) + k1 * k) / j | 0;
      }
      class50_sub1_sub4_sub3.anInt1623 = 0;
      if (class50_sub1_sub4_sub3.anInt1608 === 0) {
        class50_sub1_sub4_sub3.nextStepOrientation = 1024;
      }
      if (class50_sub1_sub4_sub3.anInt1608 === 1) {
        class50_sub1_sub4_sub3.nextStepOrientation = 1536;
      }
      if (class50_sub1_sub4_sub3.anInt1608 === 2) {
        class50_sub1_sub4_sub3.nextStepOrientation = 0;
      }
      if (class50_sub1_sub4_sub3.anInt1608 === 3) {
        class50_sub1_sub4_sub3.nextStepOrientation = 512;
      }
      class50_sub1_sub4_sub3.anInt1612 = class50_sub1_sub4_sub3.nextStepOrientation;
      if (i === -31135) {
      }
    }
    method100(i) {
      for (let j = -1; j < this.localPlayerCount; j++) {
        {
          let k;
          if (j === -1) {
            k = this.thisPlayerId;
          } else {
            k = this.playerList[j];
          }
          const class50_sub1_sub4_sub3_sub2 = this.players[k];
          if (class50_sub1_sub4_sub3_sub2 != null) {
            this.method68(1, -97 | 0, class50_sub1_sub4_sub3_sub2);
          }
        }
      }
      if (i < this.anInt1222 || i > this.anInt1222) {
        for (let l = 1; l > 0; l++) {
        }
      }
    }
    dropClient() {
      if (this.anInt873 > 0) {
        this.logout();
        return;
      }
      this.method125("Please wait - attempting to reestablish", "Connection lost");
      this.minimapState = 0;
      this.destinationX = 0;
      const class17 = this.gameConnection;
      this.loggedIn = false;
      this.anInt850 = 0;
      this.login(this.username, this.password, true);
      if (!this.loggedIn) {
        this.logout();
      }
      try {
        class17.close();
        return;
      } catch (_ex) {
        return;
      }
    }
    method116(j, abyte0) {
      if (abyte0 == null) {
        return true;
      } else {
        return SignLink.saveWave(abyte0, j);
      }
    }
    method152() {
      for (let index = 0; index < this.currentSound; index++) {
        {
          let flag1 = false;
          try {
            const stream = SoundTrack.data(this.sound[index], this.soundType[index]);
            new SoundPlayer(
              null,
              this.soundVolume[index],
              this.soundDelay[index]
            );
            if (new Date().getTime() + ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(stream.currentPosition / 22 | 0) > this.aLong1172 + ((n) => n < 0 ? Math.ceil(n) : Math.floor(n))(this.anInt1257 / 22 | 0)) {
              this.anInt1257 = stream.currentPosition;
              this.aLong1172 = new Date().getTime();
              if (this.method116(stream.currentPosition, Array.from(stream.buffer))) {
                this.anInt1272 = this.sound[index];
                this.anInt935 = this.soundType[index];
              } else {
                flag1 = true;
              }
            }
          } catch (exception) {
            if (SignLink.__reportError) {
              this.outBuffer.putOpcode(80);
              this.outBuffer.putShort(this.sound[index] & 32767);
            } else {
              this.outBuffer.putOpcode(80);
              this.outBuffer.putShort(-1);
            }
          }
          if (!flag1 || this.soundDelay[index] === -5) {
            this.currentSound--;
            for (let j = index; j < this.currentSound; j++) {
              {
                this.sound[j] = this.sound[j + 1];
                this.soundType[j] = this.soundType[j + 1];
                this.soundDelay[j] = this.soundDelay[j + 1];
                this.soundVolume[j] = this.soundVolume[j + 1];
              }
            }
            index--;
          } else {
            this.soundDelay[index] = -5;
          }
        }
      }
      if (this.previousSong > 0) {
        this.previousSong -= 20;
        if (this.previousSong < 0) {
          this.previousSong = 0;
        }
        if (this.previousSong === 0 && this.musicEnabled && !_Game.lowMemory) {
          console.log("HEREEEE");
          this.nextSong = this.currentSong;
          this.songChanging = true;
          this.onDemandRequester.request(2, this.nextSong);
        }
      }
    }
    method36(i) {
      if (i !== 16220) {
        this.anInt1328 = 458;
      }
      if (this.loadingStage === 2) {
        for (let spawnObjectNode = this.aClass6_1261.first(); spawnObjectNode != null; spawnObjectNode = this.aClass6_1261.next()) {
          {
            if (spawnObjectNode.anInt1390 > 0) {
              spawnObjectNode.anInt1390--;
            }
            if (spawnObjectNode.anInt1390 === 0) {
              if (spawnObjectNode.anInt1387 < 0 || Region.method170(spawnObjectNode.anInt1389, this.aByte1143, spawnObjectNode.anInt1387)) {
                this.method45(
                  spawnObjectNode.anInt1388,
                  spawnObjectNode.anInt1393,
                  spawnObjectNode.anInt1387,
                  spawnObjectNode.anInt1394,
                  spawnObjectNode.anInt1391,
                  spawnObjectNode.anInt1389,
                  1 | 0,
                  spawnObjectNode.anInt1392
                );
                spawnObjectNode.remove();
              }
            } else {
              if (spawnObjectNode.anInt1395 > 0) {
                spawnObjectNode.anInt1395--;
              }
              if (spawnObjectNode.anInt1395 === 0 && spawnObjectNode.anInt1393 >= 1 && spawnObjectNode.anInt1394 >= 1 && spawnObjectNode.anInt1393 <= 102 && spawnObjectNode.anInt1394 <= 102 && (spawnObjectNode.anInt1384 < 0 || Region.method170(spawnObjectNode.anInt1386, this.aByte1143, spawnObjectNode.anInt1384))) {
                this.method45(
                  spawnObjectNode.anInt1385,
                  spawnObjectNode.anInt1393,
                  spawnObjectNode.anInt1384,
                  spawnObjectNode.anInt1394,
                  spawnObjectNode.anInt1391,
                  spawnObjectNode.anInt1386,
                  1 | 0,
                  spawnObjectNode.anInt1392
                );
                spawnObjectNode.anInt1395 = -1;
                if (spawnObjectNode.anInt1384 === spawnObjectNode.anInt1387 && spawnObjectNode.anInt1387 === -1) {
                  spawnObjectNode.remove();
                } else if (spawnObjectNode.anInt1384 === spawnObjectNode.anInt1387 && spawnObjectNode.anInt1385 === spawnObjectNode.anInt1388 && spawnObjectNode.anInt1386 === spawnObjectNode.anInt1389) {
                  spawnObjectNode.remove();
                }
              }
            }
          }
        }
      }
    }
    method45(i, j, k, l, i1, j1, byte0, k1) {
      if (byte0 !== this.aByte1066) {
        this.anInt1175 = -380;
      }
      if (j >= 1 && l >= 1 && j <= 102 && l <= 102) {
        if (_Game.lowMemory && i1 !== this.plane) {
          return;
        }
        let l1 = 0;
        if (k1 === 0) {
          l1 = this.currentScene.method267(i1, j, l);
        }
        if (k1 === 1) {
          l1 = this.currentScene.method268(j, 4 | 0, i1, l);
        }
        if (k1 === 2) {
          l1 = this.currentScene.method269(i1, j, l);
        }
        if (k1 === 3) {
          l1 = this.currentScene.getFloorDecorationHash(i1, j, l);
        }
        if (l1 !== 0) {
          const l2 = this.currentScene.method271(i1, j, l, l1);
          const i2 = l1 >> 14 & 32767;
          const j2 = l2 & 31;
          const k2 = l2 >> 6;
          if (k1 === 0) {
            this.currentScene.method258(l, i1, j, true);
            const class47 = GameObjectDefinition.getDefinition(i2);
            if (class47.solid) {
              this.currentCollisionMap[i1].unmarkWall(k2, j, l, j2, class47.walkable);
            }
          }
          if (k1 === 1) {
            this.currentScene.method259(false, j, l, i1);
          }
          if (k1 === 2) {
            this.currentScene.method260(l, i1, -779, j);
            const class47_1 = GameObjectDefinition.getDefinition(i2);
            if (j + class47_1.sizeX > 103 || l + class47_1.sizeX > 103 || j + class47_1.sizeY > 103 || l + class47_1.sizeY > 103) {
              return;
            }
            if (class47_1.solid) {
              this.currentCollisionMap[i1].unmarkSolidOccupant(
                this.anInt1055,
                l,
                j,
                k2,
                class47_1.sizeY,
                class47_1.walkable,
                class47_1.sizeX
              );
            }
          }
          if (k1 === 3) {
            this.currentScene.method261(j, l, true, i1);
            const class47_2 = GameObjectDefinition.getDefinition(i2);
            if (class47_2.solid && class47_2.actionsBoolean) {
              this.currentCollisionMap[i1].unmarkConcealed(j, l);
            }
          }
        }
        if (k >= 0) {
          let i3 = i1;
          if (i3 < 3 && (this.currentSceneTileFlags[1][j][l] & 2) === 2) {
            i3++;
          }
          Region.method165(k, i3, j1, l, this.currentCollisionMap[i1], i, j, 0, i1, this.currentScene, this.anIntArrayArrayArray891);
        }
      }
    }
    async parseIncomingPacket() {
      if (this.gameConnection == null) {
        return false;
      }
      try {
        let available = this.gameConnection.getAvailable();
        if (available === 0) {
          return false;
        }
        if (this.opcode === -1) {
          await this.gameConnection.read$byte_A$int$int(this.buffer.buffer, 0, 1);
          this.opcode = this.buffer.buffer[0] & 255;
          if (this.incomingRandom != null) {
            this.opcode = this.opcode - this.incomingRandom.nextInt() & 255;
          }
          this.packetSize = PacketConstants.PACKET_SIZES[this.opcode];
          available--;
        }
        if (this.packetSize === -1) {
          if (available > 0) {
            await this.gameConnection.read$byte_A$int$int(this.buffer.buffer, 0, 1);
            this.packetSize = this.buffer.buffer[0] & 255;
            available--;
          } else {
            return false;
          }
        }
        if (this.packetSize === -2) {
          if (available > 1) {
            await this.gameConnection.read$byte_A$int$int(this.buffer.buffer, 0, 2);
            this.buffer.currentPosition = 0;
            this.packetSize = this.buffer.getUnsignedLEShort();
            available -= 2;
          } else {
            return false;
          }
        }
        if (available < this.packetSize) {
          return false;
        }
        this.buffer.currentPosition = 0;
        await this.gameConnection.read$byte_A$int$int(this.buffer.buffer, 0, this.packetSize);
        this.timeoutCounter = 0;
        this.thirdLastOpcode = this.secondLastOpcode;
        this.secondLastOpcode = this.lastOpcode;
        this.lastOpcode = this.opcode;
        if (this.opcode === 166) {
          const l = this.buffer.method552();
          const l10 = this.buffer.method552();
          const interfaceId = this.buffer.getUnsignedLEShort();
          const class13_5 = Widget.forId(interfaceId);
          class13_5.anInt228 = l10;
          class13_5.anInt259 = l;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 186) {
          const i1 = this.buffer.method550();
          const interfaceId = this.buffer.getLittleShortA();
          const l16 = this.buffer.method550();
          const i22 = this.buffer.method549();
          Widget.forId(interfaceId).rotationX = i1;
          Widget.forId(interfaceId).rotationY = i22;
          Widget.forId(interfaceId).zoom = l16;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 216) {
          const j1 = this.buffer.getLittleShortA();
          const interfaceId = this.buffer.getLittleShortA();
          Widget.forId(interfaceId).modelType = 1;
          Widget.forId(interfaceId).modelId = j1;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 26) {
          const k1 = this.buffer.getUnsignedLEShort();
          const k11 = this.buffer.getUnsignedByte();
          const i17 = this.buffer.getUnsignedLEShort();
          if (i17 === 65535) {
            if (this.currentSound < 50) {
              this.sound[this.currentSound] = k1 | 0;
              this.soundType[this.currentSound] = k11;
              this.soundDelay[this.currentSound] = 0;
              this.currentSound++;
            }
          } else if (this.aBoolean1301 && !_Game.lowMemory && this.currentSound < 50) {
            this.sound[this.currentSound] = k1;
            this.soundType[this.currentSound] = k11;
            this.soundDelay[this.currentSound] = i17 + SoundTrack.trackDelays[k1];
            this.currentSound++;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 182) {
          const l1 = this.buffer.method550();
          const byte0 = this.buffer.getSignedByteSubtracted();
          this.anIntArray1005[l1] = byte0;
          if (this.widgetSettings[l1] !== byte0) {
            this.widgetSettings[l1] = byte0;
            this.updateVarp(0, l1);
            this.redrawTabArea = true;
            if (this.dialogueId !== -1) {
              this.redrawChatbox = true;
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 13) {
          for (let i2 = 0; i2 < this.players.length; i2++) {
            if (this.players[i2] != null) {
              this.players[i2].emoteAnimation = -1;
            }
          }
          for (let l11 = 0; l11 < this.npcs.length; l11++) {
            if (this.npcs[l11] != null) {
              this.npcs[l11].emoteAnimation = -1;
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 156) {
          this.minimapState = this.buffer.getUnsignedByte();
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 162) {
          const j2 = this.buffer.method550();
          const interfaceId = this.buffer.method549();
          Widget.forId(interfaceId).modelType = 2;
          Widget.forId(interfaceId).modelId = j2;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 109) {
          const k2 = this.buffer.getUnsignedLEShort();
          this.method112(36 | 0, k2);
          if (this.anInt1089 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt1089);
            this.anInt1089 = -1;
            this.redrawTabArea = true;
            this.aBoolean950 = true;
          }
          if (this.anInt1053 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt1053);
            this.anInt1053 = -1;
            this.aBoolean1046 = true;
          }
          if (this.anInt960 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt960);
            this.anInt960 = -1;
          }
          if (this.openInterfaceId !== -1) {
            this.method44(_Game.aBoolean1190, this.openInterfaceId);
            this.openInterfaceId = -1;
          }
          if (this.backDialogueId !== k2) {
            this.method44(_Game.aBoolean1190, this.backDialogueId);
            this.backDialogueId = k2;
          }
          this.aBoolean1239 = false;
          this.redrawChatbox = true;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 220) {
          let songID = this.buffer.getLittleShortA();
          if (songID === 65535) {
            songID = -1;
          }
          if (songID !== this.currentSong && this.musicEnabled && !_Game.lowMemory && this.previousSong === 0) {
            this.nextSong = songID;
            this.songChanging = true;
            this.onDemandRequester.request(2, this.nextSong);
          }
          this.currentSong = songID;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 249) {
          const fileId = this.buffer.method549();
          const j12 = this.buffer.method554();
          if (this.musicEnabled && !_Game.lowMemory) {
            this.nextSong = fileId;
            this.songChanging = false;
            this.onDemandRequester.request(2, this.nextSong);
            this.previousSong = j12;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 158) {
          const j3 = this.buffer.method552();
          if (j3 !== this.dialogueId) {
            this.method44(_Game.aBoolean1190, this.dialogueId);
            this.dialogueId = j3;
          }
          this.redrawChatbox = true;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 218) {
          const interfaceId = this.buffer.getUnsignedLEShort();
          const rgb = this.buffer.method550();
          const j17 = rgb >> 10 & 31;
          const j22 = rgb >> 5 & 31;
          const l24 = rgb & 31;
          Widget.forId(interfaceId).disabledColor = (j17 << 19) + (j22 << 11) + (l24 << 3);
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 157) {
          const slot = this.buffer.getByteNegated();
          let option = this.buffer.getString();
          const alwaysOnTop = this.buffer.getUnsignedByte();
          if (slot >= 1 && slot <= 5) {
            if (((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(option, "null")) {
              option = null;
            }
            this.aStringArray1069[slot - 1] = option;
            this.aBooleanArray1070[slot - 1] = alwaysOnTop === 0;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 6) {
          this.messagePromptRaised = false;
          this.inputType = 2;
          this.inputInputMessage = "";
          this.redrawChatbox = true;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 201) {
          this.publicChatMode = this.buffer.getUnsignedByte();
          this.privateChatMode = this.buffer.getUnsignedByte();
          this.tradeMode = this.buffer.getUnsignedByte();
          this.aBoolean1212 = true;
          this.redrawChatbox = true;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 199) {
          this.anInt1197 = this.buffer.getUnsignedByte();
          if (this.anInt1197 === 1) {
            this.anInt1226 = this.buffer.getUnsignedLEShort();
          }
          if (this.anInt1197 >= 2 && this.anInt1197 <= 6) {
            if (this.anInt1197 === 2) {
              this.anInt847 = 64;
              this.anInt848 = 64;
            }
            if (this.anInt1197 === 3) {
              this.anInt847 = 0;
              this.anInt848 = 64;
            }
            if (this.anInt1197 === 4) {
              this.anInt847 = 128;
              this.anInt848 = 64;
            }
            if (this.anInt1197 === 5) {
              this.anInt847 = 64;
              this.anInt848 = 0;
            }
            if (this.anInt1197 === 6) {
              this.anInt847 = 64;
              this.anInt848 = 128;
            }
            this.anInt1197 = 2;
            this.anInt844 = this.buffer.getUnsignedLEShort();
            this.anInt845 = this.buffer.getUnsignedLEShort();
            this.anInt846 = this.buffer.getUnsignedByte();
          }
          if (this.anInt1197 === 10) {
            this.anInt1151 = this.buffer.getUnsignedLEShort();
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 167) {
          this.oriented = true;
          this.anInt993 = this.buffer.getUnsignedByte();
          this.anInt994 = this.buffer.getUnsignedByte();
          this.anInt995 = this.buffer.getUnsignedLEShort();
          this.anInt996 = this.buffer.getUnsignedByte();
          this.anInt997 = this.buffer.getUnsignedByte();
          if (this.anInt997 >= 100) {
            const i4 = this.anInt993 * 128 + 64;
            const l12 = this.anInt994 * 128 + 64;
            const l17 = this.getTileHeight(l12, i4, 9 | 0, this.plane) - this.anInt995;
            const k22 = i4 - this.cameraX;
            const i25 = l17 - this.cameraZ;
            const k27 = l12 - this.cameraY;
            const i30 = Math.sqrt(k22 * k22 + k27 * k27) | 0;
            this.cameraPitch = (Math.atan2(i25, i30) * 325.949 | 0) & 2047;
            this.cameraYaw = (Math.atan2(k22, k27) * -325.949 | 0) & 2047;
            if (this.cameraPitch < 128) {
              this.cameraPitch = 128;
            }
            if (this.cameraPitch > 383) {
              this.cameraPitch = 383;
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 5) {
          this.logout();
          this.opcode = -1;
          return false;
        }
        if (this.opcode === 115) {
          const j4 = this.buffer.method557();
          const i13 = this.buffer.method549();
          this.anIntArray1005[i13] = j4;
          if (this.widgetSettings[i13] !== j4) {
            this.widgetSettings[i13] = j4;
            this.updateVarp(0, i13);
            this.redrawTabArea = true;
            if (this.dialogueId !== -1) {
              this.redrawChatbox = true;
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 29) {
          if (this.anInt1089 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt1089);
            this.anInt1089 = -1;
            this.redrawTabArea = true;
            this.aBoolean950 = true;
          }
          if (this.backDialogueId !== -1) {
            this.method44(_Game.aBoolean1190, this.backDialogueId);
            this.backDialogueId = -1;
            this.redrawChatbox = true;
          }
          if (this.anInt1053 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt1053);
            this.anInt1053 = -1;
            this.aBoolean1046 = true;
          }
          if (this.anInt960 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt960);
            this.anInt960 = -1;
          }
          if (this.openInterfaceId !== -1) {
            this.method44(_Game.aBoolean1190, this.openInterfaceId);
            this.openInterfaceId = -1;
          }
          if (this.inputType !== 0) {
            this.inputType = 0;
            this.redrawChatbox = true;
          }
          this.aBoolean1239 = false;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 76) {
          this.anInt1083 = this.buffer.method549();
          this.anInt1075 = this.buffer.getLittleShortA();
          this.buffer.getUnsignedLEShort();
          this.anInt1208 = this.buffer.getUnsignedLEShort();
          this.anInt1170 = this.buffer.method549();
          this.anInt1273 = this.buffer.method550();
          this.anInt1215 = this.buffer.method550();
          this.anInt992 = this.buffer.getUnsignedLEShort();
          this.lastAddress = this.buffer.method555();
          this.anInt1034 = this.buffer.getLittleShortA();
          this.buffer.getByteAdded();
          SignLink.dnsLookup(TextUtils.decodeAddress(this.lastAddress));
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 63) {
          const message = this.buffer.getString();
          if (((str, searchString) => {
            const pos = str.length - searchString.length;
            const lastIndex = str.indexOf(searchString, pos);
            return lastIndex !== -1 && lastIndex === pos;
          })(message, ":tradereq:")) {
            const s3 = message.substring(0, message.indexOf(":"));
            const l18 = TextUtils.nameToLong(s3);
            let flag1 = false;
            for (let l27 = 0; l27 < this.ignoresCount; l27++) {
              {
                if (!this.ignores[l27].eq(l18)) {
                  continue;
                }
                flag1 = true;
                break;
              }
            }
            if (!flag1 && !this.inTutorialIsland) {
              this.addChatMessage(s3, "wishes to trade with you.", 4);
            }
          } else if (((str, searchString) => {
            const pos = str.length - searchString.length;
            const lastIndex = str.indexOf(searchString, pos);
            return lastIndex !== -1 && lastIndex === pos;
          })(message, ":duelreq:")) {
            const s4 = message.substring(0, message.indexOf(":"));
            const l19 = TextUtils.nameToLong(s4);
            let flag2 = false;
            for (let i28 = 0; i28 < this.ignoresCount; i28++) {
              {
                if (!this.ignores[i28].eq(l19)) {
                  continue;
                }
                flag2 = true;
                break;
              }
            }
            if (!flag2 && !this.inTutorialIsland) {
              this.addChatMessage(s4, "wishes to duel with you.", 8);
            }
          } else if (((str, searchString) => {
            const pos = str.length - searchString.length;
            const lastIndex = str.indexOf(searchString, pos);
            return lastIndex !== -1 && lastIndex === pos;
          })(message, ":chalreq:")) {
            const s5 = message.substring(0, message.indexOf(":"));
            const l20 = TextUtils.nameToLong(s5);
            let flag3 = false;
            for (let j28 = 0; j28 < this.ignoresCount; j28++) {
              {
                if (!this.ignores[j28].eq(l20)) {
                  continue;
                }
                flag3 = true;
                break;
              }
            }
            if (!flag3 && !this.inTutorialIsland) {
              const s8 = message.substring(message.indexOf(":") + 1, message.length - 9);
              this.addChatMessage(s5, s8, 8);
            }
          } else {
            this.addChatMessage("", message, 0);
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 50) {
          const k4 = this.buffer.getSignedShort();
          if (k4 >= 0) {
            this.method112(36 | 0, k4);
          }
          if (k4 !== this.anInt1279) {
            this.method44(_Game.aBoolean1190, this.anInt1279);
            this.anInt1279 = k4;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 82) {
          const flag = this.buffer.getUnsignedByte() === 1;
          const interfaceId = this.buffer.getUnsignedLEShort();
          Widget.forId(interfaceId).hiddenUntilHovered = flag;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 174) {
          if (this.anInt1285 === 12) {
            this.redrawTabArea = true;
          }
          this.anInt1030 = this.buffer.getSignedShort();
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 233) {
          this.anInt1319 = this.buffer.getUnsignedByte();
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 61) {
          this.destinationX = 0;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 128) {
          const l4 = this.buffer.method550();
          const k13 = this.buffer.getLittleShortA();
          if (this.backDialogueId !== -1) {
            this.method44(_Game.aBoolean1190, this.backDialogueId);
            this.backDialogueId = -1;
            this.redrawChatbox = true;
          }
          if (this.anInt1053 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt1053);
            this.anInt1053 = -1;
            this.aBoolean1046 = true;
          }
          if (this.anInt960 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt960);
            this.anInt960 = -1;
          }
          if (this.openInterfaceId !== l4) {
            this.method44(_Game.aBoolean1190, this.openInterfaceId);
            this.openInterfaceId = l4;
          }
          if (this.anInt1089 !== k13) {
            this.method44(_Game.aBoolean1190, this.anInt1089);
            this.anInt1089 = k13;
          }
          if (this.inputType !== 0) {
            this.inputType = 0;
            this.redrawChatbox = true;
          }
          this.redrawTabArea = true;
          this.aBoolean950 = true;
          this.aBoolean1239 = false;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 67) {
          const i5 = this.buffer.getUnsignedByte();
          const l13 = this.buffer.getUnsignedByte();
          const i18 = this.buffer.getUnsignedByte();
          const l22 = this.buffer.getUnsignedByte();
          this.aBooleanArray927[i5] = true;
          this.anIntArray1105[i5] = l13;
          this.anIntArray852[i5] = i18;
          this.anIntArray991[i5] = l22;
          this.quakeTimes[i5] = 0;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 134) {
          this.redrawTabArea = true;
          const interfaceId = this.buffer.getUnsignedLEShort();
          const inter = Widget.forId(interfaceId);
          while (this.buffer.currentPosition < this.packetSize) {
            {
              const slot = this.buffer.getSmart();
              const id = this.buffer.getUnsignedLEShort();
              let amount = this.buffer.getUnsignedByte();
              if (amount === 255) {
                amount = this.buffer.getInt();
              }
              if (slot >= 0 && slot < inter.items.length) {
                inter.items[slot] = id;
                inter.itemAmounts[slot] = amount;
              }
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 78) {
          const friend = this.buffer.getLong();
          const nodeId = this.buffer.getUnsignedByte();
          let s7 = TextUtils.formatName(TextUtils.longToName(friend));
          for (let k25 = 0; k25 < this.friendsCount; k25++) {
            {
              if (!friend.eq(this.friends[k25])) {
                continue;
              }
              if (this.friendWorlds[k25] !== nodeId) {
                this.friendWorlds[k25] = nodeId;
                this.redrawTabArea = true;
                if (nodeId > 0) {
                  this.addChatMessage("", s7 + " has logged in.", 5);
                }
                if (nodeId === 0) {
                  this.addChatMessage("", s7 + " has logged out.", 5);
                }
              }
              s7 = null;
              break;
            }
          }
          if (s7 != null && this.friendsCount < 200) {
            this.friends[this.friendsCount] = friend;
            this.friendUsernames[this.friendsCount] = s7;
            this.friendWorlds[this.friendsCount] = nodeId;
            this.friendsCount++;
            this.redrawTabArea = true;
          }
          for (let flag5 = false; !flag5; ) {
            {
              flag5 = true;
              for (let j30 = 0; j30 < this.friendsCount - 1; j30++) {
                if (this.friendWorlds[j30] !== _Game.world && this.friendWorlds[j30 + 1] === _Game.world || this.friendWorlds[j30] === 0 && this.friendWorlds[j30 + 1] !== 0) {
                  const l31 = this.friendWorlds[j30];
                  this.friendWorlds[j30] = this.friendWorlds[j30 + 1];
                  this.friendWorlds[j30 + 1] = l31;
                  const s10 = this.friendUsernames[j30];
                  this.friendUsernames[j30] = this.friendUsernames[j30 + 1];
                  this.friendUsernames[j30 + 1] = s10;
                  const l33 = this.friends[j30];
                  this.friends[j30] = this.friends[j30 + 1];
                  this.friends[j30 + 1] = l33;
                  this.redrawTabArea = true;
                  flag5 = false;
                }
              }
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 58) {
          this.messagePromptRaised = false;
          this.inputType = 1;
          this.inputInputMessage = "";
          this.redrawChatbox = true;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 252) {
          this.anInt1285 = this.buffer.getByteNegated();
          this.redrawTabArea = true;
          this.aBoolean950 = true;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 40) {
          this.placementY = this.buffer.getByteSubtracted();
          this.placementX = this.buffer.getByteNegated();
          for (let k5 = this.placementX; k5 < this.placementX + 8; k5++) {
            {
              for (let i14 = this.placementY; i14 < this.placementY + 8; i14++) {
                if (this.groundItems[this.plane][k5][i14] != null) {
                  this.groundItems[this.plane][k5][i14] = null;
                  this.processGroundItems(k5, i14);
                }
              }
            }
          }
          for (let spawnObjectNode = this.aClass6_1261.first(); spawnObjectNode != null; spawnObjectNode = this.aClass6_1261.next()) {
            if (spawnObjectNode.anInt1393 >= this.placementX && spawnObjectNode.anInt1393 < this.placementX + 8 && spawnObjectNode.anInt1394 >= this.placementY && spawnObjectNode.anInt1394 < this.placementY + 8 && spawnObjectNode.anInt1391 === this.plane) {
              spawnObjectNode.anInt1390 = 0;
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 255) {
          const interfaceId = this.buffer.getLittleShortA();
          Widget.forId(interfaceId).modelType = 3;
          if (_Game.localPlayer.npcDefinition == null) {
            Widget.forId(interfaceId).modelId = (_Game.localPlayer.appearanceColors[0] << 25) + (_Game.localPlayer.appearanceColors[4] << 20) + (_Game.localPlayer.appearance[0] << 15) + (_Game.localPlayer.appearance[8] << 10) + (_Game.localPlayer.appearance[11] << 5) + _Game.localPlayer.appearance[1];
          } else {
            Widget.forId(interfaceId).modelId = 305419896 + _Game.localPlayer.npcDefinition.id | 0;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 135) {
          const l6 = this.buffer.getLong();
          const i19 = this.buffer.getInt();
          const j23 = this.buffer.getUnsignedByte();
          let flag4 = false;
          for (let k28 = 0; k28 < 100; k28++) {
            {
              if (this.anIntArray1258[k28] !== i19) {
                continue;
              }
              flag4 = true;
              break;
            }
          }
          if (j23 <= 1) {
            for (let k30 = 0; k30 < this.ignoresCount; k30++) {
              {
                if (!this.ignores[k30].eq(l6)) {
                  continue;
                }
                flag4 = true;
                break;
              }
            }
          }
          if (!flag4 && !this.inTutorialIsland) {
            try {
              this.anIntArray1258[this.anInt1152] = i19;
              this.anInt1152 = (this.anInt1152 + 1) % 100;
              let s9 = ChatEncoder.get(this.packetSize - 13, this.buffer);
              if (j23 !== 3) {
                s9 = ChatCensor.censorString(s9);
              }
              if (j23 === 2 || j23 === 3) {
                this.addChatMessage("@cr2@" + TextUtils.formatName(TextUtils.longToName(l6)), s9, 7);
              } else if (j23 === 1) {
                this.addChatMessage("@cr1@" + TextUtils.formatName(TextUtils.longToName(l6)), s9, 7);
              } else {
                this.addChatMessage(TextUtils.formatName(TextUtils.longToName(l6)), s9, 3);
              }
              console.log("more chat");
            } catch (exception1) {
              SignLink.reportError("cde1");
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 183) {
          this.placementX = this.buffer.getUnsignedByte();
          this.placementY = this.buffer.getByteAdded();
          while (this.buffer.currentPosition < this.packetSize) {
            {
              const j6 = this.buffer.getUnsignedByte();
              this.parsePlacementPacket(this.buffer, j6);
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 159) {
          const interfaceId = this.buffer.getLittleShortA();
          this.method112(36 | 0, interfaceId);
          if (this.anInt1089 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt1089);
            this.anInt1089 = -1;
            this.redrawTabArea = true;
            this.aBoolean950 = true;
          }
          if (this.backDialogueId !== -1) {
            this.method44(_Game.aBoolean1190, this.backDialogueId);
            this.backDialogueId = -1;
            this.redrawChatbox = true;
          }
          if (this.anInt1053 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt1053);
            this.anInt1053 = -1;
            this.aBoolean1046 = true;
          }
          if (this.anInt960 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt960);
            this.anInt960 = -1;
          }
          if (this.openInterfaceId !== interfaceId) {
            this.method44(_Game.aBoolean1190, this.openInterfaceId);
            this.openInterfaceId = interfaceId;
          }
          if (this.inputType !== 0) {
            this.inputType = 0;
            this.redrawChatbox = true;
          }
          this.aBoolean1239 = false;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 246) {
          const i7 = this.buffer.getLittleShortA();
          this.method112(36 | 0, i7);
          if (this.backDialogueId !== -1) {
            this.method44(_Game.aBoolean1190, this.backDialogueId);
            this.backDialogueId = -1;
            this.redrawChatbox = true;
          }
          if (this.anInt1053 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt1053);
            this.anInt1053 = -1;
            this.aBoolean1046 = true;
          }
          if (this.anInt960 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt960);
            this.anInt960 = -1;
          }
          if (this.openInterfaceId !== -1) {
            this.method44(_Game.aBoolean1190, this.openInterfaceId);
            this.openInterfaceId = -1;
          }
          if (this.anInt1089 !== i7) {
            this.method44(_Game.aBoolean1190, this.anInt1089);
            this.anInt1089 = i7;
          }
          if (this.inputType !== 0) {
            this.inputType = 0;
            this.redrawChatbox = true;
          }
          this.redrawTabArea = true;
          this.aBoolean950 = true;
          this.aBoolean1239 = false;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 49) {
          this.redrawTabArea = true;
          const j7 = this.buffer.getByteNegated();
          const j14 = this.buffer.getUnsignedByte();
          const j19 = this.buffer.getInt();
          this.anIntArray843[j7] = j19;
          this.anIntArray1029[j7] = j14;
          this.anIntArray1054[j7] = 1;
          for (let k23 = 0; k23 < 98; k23++) {
            if (j19 >= _Game.SKILL_EXPERIENCE[k23]) {
              this.anIntArray1054[j7] = k23 + 2;
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 206) {
          this.redrawTabArea = true;
          const interfaceId = this.buffer.getUnsignedLEShort();
          const inter = Widget.forId(interfaceId);
          const items = this.buffer.getUnsignedLEShort();
          for (let item = 0; item < items; item++) {
            {
              inter.items[item] = this.buffer.getLittleShortA();
              let amount = this.buffer.getByteNegated();
              if (amount === 255) {
                amount = this.buffer.method555();
              }
              inter.itemAmounts[item] = amount;
            }
          }
          for (let i26 = items; i26 < inter.items.length; i26++) {
            {
              inter.items[i26] = 0;
              inter.itemAmounts[i26] = 0;
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 222 || this.opcode === 53) {
          let tmpChunkX = this.chunkX;
          let tmpChunkY = this.chunkY;
          if (this.opcode === 222) {
            tmpChunkY = this.buffer.getUnsignedLEShort();
            tmpChunkX = this.buffer.getLittleShortA();
            this.aBoolean1163 = false;
          }
          if (this.opcode === 53) {
            tmpChunkX = this.buffer.method550();
            this.buffer.initBitAccess();
            for (let z = 0; z < 4; z++) {
              {
                for (let x2 = 0; x2 < 13; x2++) {
                  {
                    for (let y = 0; y < 13; y++) {
                      {
                        const flag = this.buffer.getBits(1);
                        if (flag === 1) {
                          this.constructedMapPalette[z][x2][y] = this.buffer.getBits(26);
                        } else {
                          this.constructedMapPalette[z][x2][y] = -1;
                        }
                      }
                    }
                  }
                }
              }
            }
            this.buffer.finishBitAccess();
            tmpChunkY = this.buffer.method550();
            this.aBoolean1163 = true;
          }
          if (this.chunkX === tmpChunkX && this.chunkY === tmpChunkY && this.loadingStage === 2) {
            this.opcode = -1;
            return true;
          }
          this.chunkX = tmpChunkX;
          this.chunkY = tmpChunkY;
          this.nextTopLeftTileX = (this.chunkX - 6) * 8;
          this.nextTopRightTileY = (this.chunkY - 6) * 8;
          this.aBoolean1067 = false;
          if (((this.chunkX / 8 | 0) === 48 || (this.chunkX / 8 | 0) === 49) && (this.chunkY / 8 | 0) === 48) {
            this.aBoolean1067 = true;
          }
          if ((this.chunkX / 8 | 0) === 48 && (this.chunkY / 8 | 0) === 148) {
            this.aBoolean1067 = true;
          }
          this.loadingStage = 1;
          this.aLong1229 = new Date().getTime();
          this.method125(null, "Loading - please wait.");
          if (this.opcode === 222) {
            let count = 0;
            for (let fileX = (this.chunkX - 6) / 8 | 0; fileX <= ((this.chunkX + 6) / 8 | 0); fileX++) {
              {
                for (let fileY = (this.chunkY - 6) / 8 | 0; fileY <= ((this.chunkY + 6) / 8 | 0); fileY++) {
                  count++;
                }
              }
            }
            this.aByteArrayArray838 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(null);
              }
              return a;
            })(count);
            this.aByteArrayArray1232 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(null);
              }
              return a;
            })(count);
            this.coordinates = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(count);
            this.anIntArray857 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(count);
            this.anIntArray858 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(count);
            count = 0;
            for (let fileX = (this.chunkX - 6) / 8 | 0; fileX <= ((this.chunkX + 6) / 8 | 0); fileX++) {
              {
                for (let fileY = (this.chunkY - 6) / 8 | 0; fileY <= ((this.chunkY + 6) / 8 | 0); fileY++) {
                  {
                    this.coordinates[count] = (fileX << 8) + fileY;
                    if (this.aBoolean1067 && (fileY === 49 || fileY === 149 || fileY === 147 || fileX === 50 || fileX === 49 && fileY === 47)) {
                      this.anIntArray857[count] = -1;
                      this.anIntArray858[count] = -1;
                      count++;
                    } else {
                      const l30 = this.anIntArray857[count] = this.onDemandRequester.regId(0, fileX, fileY, 0);
                      if (l30 !== -1) {
                        this.onDemandRequester.request(3, l30);
                      }
                      const i32 = this.anIntArray858[count] = this.onDemandRequester.regId(0, fileX, fileY, 1);
                      if (i32 !== -1) {
                        this.onDemandRequester.request(3, i32);
                      }
                      count++;
                    }
                  }
                }
              }
            }
          }
          if (this.opcode === 53) {
            let uniqueCount = 0;
            const fileIndices = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(676);
            for (let tileZ = 0; tileZ < 4; tileZ++) {
              {
                for (let tileX = 0; tileX < 13; tileX++) {
                  {
                    for (let tileY = 0; tileY < 13; tileY++) {
                      {
                        const data = this.constructedMapPalette[tileZ][tileX][tileY];
                        if (data !== -1) {
                          const chunkX = data >> 14 & 1023;
                          const chunkY = data >> 3 & 2047;
                          let fileIndex = ((chunkX / 8 | 0) << 8) + (chunkY / 8 | 0);
                          for (let pos = 0; pos < uniqueCount; pos++) {
                            {
                              if (fileIndices[pos] !== fileIndex) {
                                continue;
                              }
                              fileIndex = -1;
                              break;
                            }
                          }
                          if (fileIndex !== -1) {
                            fileIndices[uniqueCount++] = fileIndex;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            this.aByteArrayArray838 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(null);
              }
              return a;
            })(uniqueCount);
            this.aByteArrayArray1232 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(null);
              }
              return a;
            })(uniqueCount);
            this.coordinates = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(uniqueCount);
            this.anIntArray857 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(uniqueCount);
            this.anIntArray858 = ((s) => {
              const a = [];
              while (s-- > 0) {
                a.push(0);
              }
              return a;
            })(uniqueCount);
            for (let pos = 0; pos < uniqueCount; pos++) {
              {
                const j31 = this.coordinates[pos] = fileIndices[pos];
                const fileX = j31 >> 8 & 255;
                const fileY = j31 & 255;
                const i34 = this.anIntArray857[pos] = this.onDemandRequester.regId(0, fileX, fileY, 0);
                if (i34 !== -1) {
                  this.onDemandRequester.request(3, i34);
                }
                const k34 = this.anIntArray858[pos] = this.onDemandRequester.regId(0, fileX, fileY, 1);
                if (k34 !== -1) {
                  this.onDemandRequester.request(3, k34);
                }
              }
            }
          }
          const deltaX = this.nextTopLeftTileX - this.topLeftTileX;
          const deltaY = this.nextTopRightTileY - this.topLeftTileY;
          this.topLeftTileX = this.nextTopLeftTileX;
          this.topLeftTileY = this.nextTopRightTileY;
          for (let id = 0; id < 16384; id++) {
            {
              const npc = this.npcs[id];
              if (npc != null) {
                for (let pos = 0; pos < 10; pos++) {
                  {
                    npc.pathX[pos] -= deltaX;
                    npc.pathY[pos] -= deltaY;
                  }
                }
                npc.worldX -= deltaX * 128;
                npc.worldY -= deltaY * 128;
              }
            }
          }
          for (let id = 0; id < this.anInt968; id++) {
            {
              const player2 = this.players[id];
              if (player2 != null) {
                for (let pos = 0; pos < 10; pos++) {
                  {
                    player2.pathX[pos] -= deltaX;
                    player2.pathY[pos] -= deltaY;
                  }
                }
                player2.worldX -= deltaX * 128;
                player2.worldY -= deltaY * 128;
              }
            }
          }
          this.aBoolean1209 = true;
          let byte1 = 0;
          let byte2 = 104;
          let byte3 = 1;
          if (deltaX < 0) {
            byte1 = 103;
            byte2 = -1;
            byte3 = -1;
          }
          let byte4 = 0;
          let byte5 = 104;
          let byte6 = 1;
          if (deltaY < 0) {
            byte4 = 103;
            byte5 = -1;
            byte6 = -1;
          }
          for (let i35 = byte1; i35 !== byte2; i35 += byte3) {
            {
              for (let j35 = byte4; j35 !== byte5; j35 += byte6) {
                {
                  const k35 = i35 + deltaX;
                  const l35 = j35 + deltaY;
                  for (let i36 = 0; i36 < 4; i36++) {
                    if (k35 >= 0 && l35 >= 0 && k35 < 104 && l35 < 104) {
                      this.groundItems[i36][i35][j35] = this.groundItems[i36][k35][l35];
                    } else {
                      this.groundItems[i36][i35][j35] = null;
                    }
                  }
                }
              }
            }
          }
          for (let spawnObjectNode_1 = this.aClass6_1261.first(); spawnObjectNode_1 != null; spawnObjectNode_1 = this.aClass6_1261.next()) {
            {
              spawnObjectNode_1.anInt1393 -= deltaX;
              spawnObjectNode_1.anInt1394 -= deltaY;
              if (spawnObjectNode_1.anInt1393 < 0 || spawnObjectNode_1.anInt1394 < 0 || spawnObjectNode_1.anInt1393 >= 104 || spawnObjectNode_1.anInt1394 >= 104) {
                spawnObjectNode_1.remove();
              }
            }
          }
          if (this.destinationX !== 0) {
            this.destinationX -= deltaX;
            this.destinationY -= deltaY;
          }
          this.oriented = false;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 190) {
          this.systemUpdateTime = this.buffer.method549() * 30;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 41 || this.opcode === 121 || this.opcode === 203 || this.opcode === 106 || this.opcode === 59 || this.opcode === 181 || this.opcode === 208 || this.opcode === 107 || this.opcode === 142 || this.opcode === 88 || this.opcode === 152) {
          this.parsePlacementPacket(this.buffer, this.opcode);
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 125) {
          if (this.anInt1285 === 12) {
            this.redrawTabArea = true;
          }
          this.anInt1324 = this.buffer.getUnsignedByte();
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 21) {
          const scale = this.buffer.getUnsignedLEShort();
          const itemId = this.buffer.method549();
          const interfaceId = this.buffer.getLittleShortA();
          if (itemId === 65535) {
            Widget.forId(interfaceId).modelType = 0;
            this.opcode = -1;
            return true;
          } else {
            const class16 = ItemDefinition.lookup(itemId);
            Widget.forId(interfaceId).modelType = 4;
            Widget.forId(interfaceId).modelId = itemId;
            Widget.forId(interfaceId).rotationX = class16.modelRotationX;
            Widget.forId(interfaceId).rotationY = class16.modelRotationY;
            Widget.forId(interfaceId).zoom = class16.modelScale * 100 / scale | 0;
            this.opcode = -1;
            return true;
          }
        }
        if (this.opcode === 3) {
          this.oriented = true;
          this.anInt874 = this.buffer.getUnsignedByte();
          this.anInt875 = this.buffer.getUnsignedByte();
          this.anInt876 = this.buffer.getUnsignedLEShort();
          this.anInt877 = this.buffer.getUnsignedByte();
          this.anInt878 = this.buffer.getUnsignedByte();
          if (this.anInt878 >= 100) {
            this.cameraX = this.anInt874 * 128 + 64;
            this.cameraY = this.anInt875 * 128 + 64;
            this.cameraZ = this.getTileHeight(this.cameraY, this.cameraX, 9 | 0, this.plane) - this.anInt876;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 2) {
          const interfaceId = this.buffer.getLittleShortA();
          const i15 = this.buffer.method553();
          const class13_3 = Widget.forId(interfaceId);
          if (class13_3.disabledAnimation !== i15 || i15 === -1) {
            class13_3.disabledAnimation = i15;
            class13_3.anInt235 = 0;
            class13_3.anInt227 = 0;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 71) {
          this.method48(this.buffer, this.aBoolean1038, this.packetSize);
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 226) {
          this.ignoresCount = this.packetSize / 8 | 0;
          for (let k8 = 0; k8 < this.ignoresCount; k8++) {
            this.ignores[k8] = this.buffer.getLong();
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 10) {
          const l8 = this.buffer.getByteSubtracted();
          let j15 = this.buffer.method550();
          if (j15 === 65535) {
            j15 = -1;
          }
          if (this.anIntArray1081[l8] !== j15) {
            this.method44(_Game.aBoolean1190, this.anIntArray1081[l8]);
            this.anIntArray1081[l8] = j15;
          }
          this.redrawTabArea = true;
          this.aBoolean950 = true;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 219) {
          const interfaceId = this.buffer.method549();
          const class13_2 = Widget.forId(interfaceId);
          for (let k21 = 0; k21 < class13_2.items.length; k21++) {
            {
              class13_2.items[k21] = -1;
              class13_2.items[k21] = 0;
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 238) {
          this.anInt1213 = this.buffer.getUnsignedByte();
          if (this.anInt1213 === this.anInt1285) {
            if (this.anInt1213 === 3) {
              this.anInt1285 = 1;
            } else {
              this.anInt1285 = 3;
            }
            this.redrawTabArea = true;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 148) {
          this.oriented = false;
          for (let j9 = 0; j9 < 5; j9++) {
            this.aBooleanArray927[j9] = false;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 126) {
          this.playerMembers = this.buffer.getUnsignedByte();
          this.thisPlayerServerId = this.buffer.method549();
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 75) {
          this.placementX = this.buffer.getByteNegated();
          this.placementY = this.buffer.getByteAdded();
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 253) {
          const k9 = this.buffer.method549();
          const k15 = this.buffer.method550();
          this.method112(36 | 0, k15);
          if (k9 !== -1) {
            this.method112(36 | 0, k9);
          }
          if (this.openInterfaceId !== -1) {
            this.method44(_Game.aBoolean1190, this.openInterfaceId);
            this.openInterfaceId = -1;
          }
          if (this.anInt1089 !== -1) {
            this.method44(_Game.aBoolean1190, this.anInt1089);
            this.anInt1089 = -1;
          }
          if (this.backDialogueId !== -1) {
            this.method44(_Game.aBoolean1190, this.backDialogueId);
            this.backDialogueId = -1;
          }
          if (this.anInt1053 !== k15) {
            this.method44(_Game.aBoolean1190, this.anInt1053);
            this.anInt1053 = k15;
          }
          if (this.anInt960 !== k15) {
            this.method44(_Game.aBoolean1190, this.anInt960);
            this.anInt960 = k9;
          }
          this.inputType = 0;
          this.aBoolean1239 = false;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 251) {
          this.friendListStatus = this.buffer.getUnsignedByte();
          this.redrawTabArea = true;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 18) {
          const l9 = this.buffer.getUnsignedLEShort();
          const interfaceId = this.buffer.method550();
          const l21 = this.buffer.method549();
          Widget.forId(interfaceId).anInt218 = (l9 << 16) + l21;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 90) {
          this.updatePlayers(this.packetSize, this.buffer);
          this.aBoolean1209 = false;
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 113) {
          for (let i10 = 0; i10 < this.widgetSettings.length; i10++) {
            if (this.widgetSettings[i10] !== this.anIntArray1005[i10]) {
              this.widgetSettings[i10] = this.anIntArray1005[i10];
              this.updateVarp(0, i10);
              this.redrawTabArea = true;
            }
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 232) {
          const j10 = this.buffer.getLittleShortA();
          const s6 = this.buffer.getString();
          Widget.forId(j10).disabledText = s6;
          if (Widget.forId(j10).parentId === this.anIntArray1081[this.anInt1285]) {
            this.redrawTabArea = true;
          }
          this.opcode = -1;
          return true;
        }
        if (this.opcode === 200) {
          const interfaceId = this.buffer.getUnsignedLEShort();
          let i16 = this.buffer.getLittleShortA();
          const class13_4 = Widget.forId(interfaceId);
          if (class13_4 != null && class13_4.type === 0) {
            if (i16 < 0) {
              i16 = 0;
            }
            if (i16 > class13_4.scrollLimit - class13_4.height) {
              i16 = class13_4.scrollLimit - class13_4.height;
            }
            class13_4.anInt231 = i16;
          }
          this.opcode = -1;
          return true;
        }
        SignLink.reportError(
          "T1 - " + this.opcode + "," + this.packetSize + " - " + this.secondLastOpcode + "," + this.thirdLastOpcode
        );
        this.logout();
      } catch (__e) {
        if (__e != null && __e instanceof Error) {
          const exception = __e;
          let s1 = "T2 - " + this.opcode + "," + this.secondLastOpcode + "," + this.thirdLastOpcode + " - " + this.packetSize + "," + (this.nextTopLeftTileX + _Game.localPlayer.pathX[0]) + "," + (this.nextTopRightTileY + _Game.localPlayer.pathY[0]) + " - ";
          for (let j16 = 0; j16 < this.packetSize && j16 < 50; j16++) {
            s1 = s1 + this.buffer.buffer[j16] + ",";
          }
          SignLink.reportError(s1);
          this.logout();
          console.error(exception.message, exception);
        }
      }
      return true;
    }
    method48(class50_sub1_sub2, flag, i) {
      this.loggedIn = flag && this.loggedIn;
      this.removePlayerCount = 0;
      this.updatedPlayerCount = 0;
      this.method46(i, -58 | 0, class50_sub1_sub2);
      this.method132(class50_sub1_sub2, i, false);
      this.method62(class50_sub1_sub2, i, 838);
      for (let j = 0; j < this.removePlayerCount; j++) {
        {
          const k = this.removePlayers[j];
          if (this.npcs[k].pulseCycle !== _Game.pulseCycle) {
            this.npcs[k].npcDefinition = null;
            this.npcs[k] = null;
          }
        }
      }
      if (class50_sub1_sub2.currentPosition !== i) {
        SignLink.reportError(
          this.username + " size mismatch in getnpcpos - coord:" + class50_sub1_sub2.currentPosition + " psize:" + i
        );
        throw Error("eek");
      }
      for (let l = 0; l < this.anInt1133; l++) {
        if (this.npcs[this.anIntArray1134[l]] == null) {
          SignLink.reportError(this.username + " null entry in npc list - coord:" + l + " size:" + this.anInt1133);
          throw Error("eek");
        }
      }
    }
    updatePlayers(size, buffer) {
      this.removePlayerCount = 0;
      this.updatedPlayerCount = 0;
      this.updateLocalPlayerMovement(buffer);
      this.updateOtherPlayerMovement(buffer);
      this.addNewPlayers(size, buffer);
      this.parsePlayerBlocks(buffer);
      for (let i = 0; i < this.removePlayerCount; i++) {
        {
          const index = this.removePlayers[i];
          if (this.players[index].pulseCycle !== _Game.pulseCycle) {
            this.players[index] = null;
          }
        }
      }
      if (buffer.currentPosition !== size) {
        SignLink.reportError("Error packet size mismatch in getplayer coord:" + buffer.currentPosition + " psize:" + size);
        throw Error("eek");
      }
      for (let i = 0; i < this.localPlayerCount; i++) {
        {
          if (this.players[this.playerList[i]] == null) {
            SignLink.reportError(this.username + " null entry in pl list - coord:" + i + " size:" + this.localPlayerCount);
            throw Error("eek");
          }
        }
      }
    }
    parsePlayerBlocks(buffer) {
      for (let i = 0; i < this.updatedPlayerCount; i++) {
        {
          const id = this.updatedPlayers[i];
          const player2 = this.players[id];
          let mask = buffer.getUnsignedByte();
          if ((mask & 32) !== 0) {
            mask += buffer.getUnsignedByte() << 8;
          }
          this.parsePlayerBlock(id, player2, mask, buffer);
        }
      }
    }
    addChatMessage(name, message, type) {
      if (type === 0 && this.dialogueId !== -1) {
        this.clickToContinueString = message;
        this.clickType = 0;
      }
      if (this.backDialogueId === -1) {
        this.redrawChatbox = true;
      }
      for (let index = 99; index > 0; index--) {
        {
          this.chatTypes[index] = this.chatTypes[index - 1];
          this.chatPlayerNames[index] = this.chatPlayerNames[index - 1];
          this.chatMessages[index] = this.chatMessages[index - 1];
        }
      }
      this.chatTypes[0] = type;
      this.chatPlayerNames[0] = name;
      this.chatMessages[0] = message;
    }
    parsePlayerBlock(id, player2, mask, buffer) {
      if ((mask & 8) !== 0) {
        let animation = buffer.getUnsignedLEShort();
        if (animation === 65535) {
          animation = -1;
        }
        const delay = buffer.getByteSubtracted();
        if (animation === player2.emoteAnimation && animation !== -1) {
          const mode = AnimationSequence.animations[animation].anInt307;
          if (mode === 1) {
            player2.displayedEmoteFrames = 0;
            player2.anInt1626 = 0;
            player2.animationDelay = delay;
            player2.anInt1628 = 0;
          }
          if (mode === 2) {
            player2.anInt1628 = 0;
          }
        } else if (animation === -1 || player2.emoteAnimation === -1 || AnimationSequence.animations[animation].anInt301 >= AnimationSequence.animations[player2.emoteAnimation].anInt301) {
          player2.emoteAnimation = animation;
          player2.displayedEmoteFrames = 0;
          player2.anInt1626 = 0;
          player2.animationDelay = delay;
          player2.anInt1628 = 0;
          player2.anInt1613 = player2.pathLength;
        }
      }
      if ((mask & 16) !== 0) {
        player2.forcedChat = buffer.getString();
        if (((c2) => c2.charCodeAt == null ? c2 : c2.charCodeAt(0))(player2.forcedChat.charAt(0)) == "~".charCodeAt(0)) {
          player2.forcedChat = player2.forcedChat.substring(1);
          this.addChatMessage(player2.playerName, player2.forcedChat, 2);
        } else if (player2 === _Game.localPlayer) {
          this.addChatMessage(player2.playerName, player2.forcedChat, 2);
        }
        player2.textColour = 0;
        player2.textEffect = 0;
        player2.textCycle = 150;
      }
      if ((mask & 256) !== 0) {
        player2.anInt1602 = buffer.getByteAdded();
        player2.anInt1604 = buffer.getByteNegated();
        player2.anInt1603 = buffer.getByteSubtracted();
        player2.anInt1605 = buffer.getUnsignedByte();
        player2.anInt1606 = buffer.getUnsignedLEShort() + _Game.pulseCycle;
        player2.anInt1607 = buffer.method550() + _Game.pulseCycle;
        player2.anInt1608 = buffer.getUnsignedByte();
        player2.resetPath();
      }
      if ((mask & 1) !== 0) {
        player2.anInt1609 = buffer.method550();
        if (player2.anInt1609 === 65535) {
          player2.anInt1609 = -1;
        }
      }
      if ((mask & 2) !== 0) {
        player2.anInt1598 = buffer.getUnsignedLEShort();
        player2.anInt1599 = buffer.getUnsignedLEShort();
      }
      if ((mask & 512) !== 0) {
        player2.graphic = buffer.method550();
        const heightAndDelay = buffer.method556();
        player2.spotAnimationDelay = heightAndDelay >> 16;
        player2.anInt1617 = _Game.pulseCycle + (heightAndDelay & 65535);
        player2.currentAnimation = 0;
        player2.anInt1616 = 0;
        if (player2.anInt1617 > _Game.pulseCycle) {
          player2.currentAnimation = -1;
        }
        if (player2.graphic === 65535) {
          player2.graphic = -1;
        }
      }
      if ((mask & 4) !== 0) {
        const size = buffer.getUnsignedByte();
        const bytes = ((s) => {
          const a = [];
          while (s-- > 0) {
            a.push(0);
          }
          return a;
        })(size);
        const appearance = new Buffer3(bytes);
        buffer.getBytesReverse(bytes, 0, size);
        this.cachedAppearances[id] = appearance;
        player2.updateAppearance(appearance);
      }
      if ((mask & 1024) !== 0) {
        const damage = buffer.getByteAdded();
        const type = buffer.getByteSubtracted();
        player2.updateHits(type, damage, _Game.pulseCycle);
        player2.endCycle = _Game.pulseCycle + 300;
        player2.anInt1596 = buffer.getByteNegated();
        player2.anInt1597 = buffer.getUnsignedByte();
      }
      if ((mask & 64) !== 0) {
        const effectsAndColour = buffer.getUnsignedLEShort();
        const rights = buffer.getByteNegated();
        const length = buffer.getByteAdded();
        const currentPosition = buffer.currentPosition;
        if (player2.playerName != null && player2.visible) {
          const nameLong = TextUtils.nameToLong(player2.playerName);
          let ignored = false;
          if (rights <= 1) {
            for (let i = 0; i < this.ignoresCount; i++) {
              {
                if (!this.ignores[i].eq(nameLong)) {
                  continue;
                }
                ignored = true;
                break;
              }
            }
          }
          if (!ignored && !this.inTutorialIsland) {
            try {
              this.chatBuffer.currentPosition = 0;
              buffer.getBytesAdded(this.chatBuffer.buffer, 0, length);
              this.chatBuffer.currentPosition = 0;
              const message = ChatCensor.censorString(ChatEncoder.get(length, this.chatBuffer));
              player2.forcedChat = message;
              player2.textColour = effectsAndColour >> 8;
              player2.textEffect = effectsAndColour & 255;
              player2.textCycle = 150;
              if (rights === 2 || rights === 3) {
                this.addChatMessage("@cr2@" + player2.playerName, message, 1);
              } else if (rights === 1) {
                this.addChatMessage("@cr1@" + player2.playerName, message, 1);
              } else {
                this.addChatMessage(player2.playerName, message, 2);
              }
            } catch (exception) {
              SignLink.reportError("cde2");
            }
          }
        }
        buffer.currentPosition = currentPosition + length;
      }
      if ((mask & 128) !== 0) {
        const damage = buffer.getByteSubtracted();
        const type = buffer.getByteNegated();
        player2.updateHits(type, damage, _Game.pulseCycle);
        player2.endCycle = _Game.pulseCycle + 300;
        player2.anInt1596 = buffer.getByteSubtracted();
        player2.anInt1597 = buffer.getUnsignedByte();
      }
    }
    addNewPlayers(size, buffer) {
      while (buffer.bitPosition + 10 < size * 8) {
        {
          const id = buffer.getBits(11);
          if (id === 2047) {
            break;
          }
          if (this.players[id] == null) {
            this.players[id] = new Player();
            if (this.cachedAppearances[id] != null) {
              this.players[id].updateAppearance(this.cachedAppearances[id]);
            }
          }
          this.playerList[this.localPlayerCount++] = id;
          const player2 = this.players[id];
          player2.pulseCycle = _Game.pulseCycle;
          let x2 = buffer.getBits(5);
          if (x2 > 15) {
            x2 -= 32;
          }
          const updated = buffer.getBits(1);
          if (updated === 1) {
            this.updatedPlayers[this.updatedPlayerCount++] = id;
          }
          const discardQueue = buffer.getBits(1);
          let y = buffer.getBits(5);
          if (y > 15) {
            y -= 32;
          }
          player2.setPosition(_Game.localPlayer.pathX[0] + x2, _Game.localPlayer.pathY[0] + y, discardQueue === 1);
        }
      }
      buffer.finishBitAccess();
    }
    updateOtherPlayerMovement(buffer) {
      const playerCount = buffer.getBits(8);
      if (playerCount < this.localPlayerCount) {
        for (let i = playerCount; i < this.localPlayerCount; i++) {
          this.removePlayers[this.removePlayerCount++] = this.playerList[i];
        }
      }
      if (playerCount > this.localPlayerCount) {
        SignLink.reportError(this.username + " Too many players");
        throw Error("eek");
      }
      this.localPlayerCount = 0;
      for (let i = 0; i < playerCount; i++) {
        {
          const id = this.playerList[i];
          const player2 = this.players[id];
          const updated = buffer.getBits(1);
          if (updated === 0) {
            this.playerList[this.localPlayerCount++] = id;
            player2.pulseCycle = _Game.pulseCycle;
          } else {
            const moveType = buffer.getBits(2);
            if (moveType === 0) {
              this.playerList[this.localPlayerCount++] = id;
              player2.pulseCycle = _Game.pulseCycle;
              this.updatedPlayers[this.updatedPlayerCount++] = id;
            } else if (moveType === 1) {
              this.playerList[this.localPlayerCount++] = id;
              player2.pulseCycle = _Game.pulseCycle;
              const direction = buffer.getBits(3);
              player2.move(direction, false);
              const blockUpdateRequired = buffer.getBits(1);
              if (blockUpdateRequired === 1) {
                this.updatedPlayers[this.updatedPlayerCount++] = id;
              }
            } else if (moveType === 2) {
              this.playerList[this.localPlayerCount++] = id;
              player2.pulseCycle = _Game.pulseCycle;
              const direction1 = buffer.getBits(3);
              player2.move(direction1, true);
              const direction2 = buffer.getBits(3);
              player2.move(direction2, true);
              const updateRequired = buffer.getBits(1);
              if (updateRequired === 1) {
                this.updatedPlayers[this.updatedPlayerCount++] = id;
              }
            } else if (moveType === 3) {
              this.removePlayers[this.removePlayerCount++] = id;
            }
          }
        }
      }
    }
    updateLocalPlayerMovement(buffer) {
      buffer.initBitAccess();
      const moved = buffer.getBits(1);
      if (moved === 0) {
        return;
      }
      const moveType = buffer.getBits(2);
      if (moveType === 0) {
        this.updatedPlayers[this.updatedPlayerCount++] = this.thisPlayerId;
        return;
      }
      if (moveType === 1) {
        const direction = buffer.getBits(3);
        _Game.localPlayer.move(direction, false);
        const blockUpdateRequired = buffer.getBits(1);
        if (blockUpdateRequired === 1) {
          this.updatedPlayers[this.updatedPlayerCount++] = this.thisPlayerId;
        }
        return;
      }
      if (moveType === 2) {
        const direction1 = buffer.getBits(3);
        _Game.localPlayer.move(direction1, true);
        const direction2 = buffer.getBits(3);
        _Game.localPlayer.move(direction2, true);
        const blockUpdateRequired = buffer.getBits(1);
        if (blockUpdateRequired === 1) {
          this.updatedPlayers[this.updatedPlayerCount++] = this.thisPlayerId;
        }
        return;
      }
      if (moveType === 3) {
        const discardWalkingQueue = buffer.getBits(1);
        this.plane = buffer.getBits(2);
        const localY = buffer.getBits(7);
        const localX = buffer.getBits(7);
        const blockUpdateRequired = buffer.getBits(1);
        if (blockUpdateRequired === 1) {
          this.updatedPlayers[this.updatedPlayerCount++] = this.thisPlayerId;
        }
        _Game.localPlayer.setPosition(localX, localY, discardWalkingQueue === 1);
      }
    }
    method62(class50_sub1_sub2, i, j) {
      j = 24 / j | 0;
      for (let k = 0; k < this.updatedPlayerCount; k++) {
        {
          const l = this.updatedPlayers[k];
          const class50_sub1_sub4_sub3_sub1 = this.npcs[l];
          const i1 = class50_sub1_sub2.getUnsignedByte();
          if ((i1 & 1) !== 0) {
            class50_sub1_sub4_sub3_sub1.npcDefinition = ActorDefinition.getDefinition(class50_sub1_sub2.method550());
            class50_sub1_sub4_sub3_sub1.boundaryDimension = class50_sub1_sub4_sub3_sub1.npcDefinition.boundaryDimension;
            class50_sub1_sub4_sub3_sub1.anInt1600 = class50_sub1_sub4_sub3_sub1.npcDefinition.degreesToTurn;
            class50_sub1_sub4_sub3_sub1.walkAnimationId = class50_sub1_sub4_sub3_sub1.npcDefinition.walkAnimationId;
            class50_sub1_sub4_sub3_sub1.turnAroundAnimationId = class50_sub1_sub4_sub3_sub1.npcDefinition.turnAroundAnimationId;
            class50_sub1_sub4_sub3_sub1.turnRightAnimationId = class50_sub1_sub4_sub3_sub1.npcDefinition.turnRightAnimationId;
            class50_sub1_sub4_sub3_sub1.turnLeftAnimationId = class50_sub1_sub4_sub3_sub1.npcDefinition.turnLeftAnimationId;
            class50_sub1_sub4_sub3_sub1.idleAnimation = class50_sub1_sub4_sub3_sub1.npcDefinition.standAnimationId;
          }
          if ((i1 & 64) !== 0) {
            class50_sub1_sub4_sub3_sub1.anInt1609 = class50_sub1_sub2.method549();
            if (class50_sub1_sub4_sub3_sub1.anInt1609 === 65535) {
              class50_sub1_sub4_sub3_sub1.anInt1609 = -1;
            }
          }
          if ((i1 & 128) !== 0) {
            const j1 = class50_sub1_sub2.getByteAdded();
            const j2 = class50_sub1_sub2.getByteAdded();
            class50_sub1_sub4_sub3_sub1.updateHits(j2, j1, _Game.pulseCycle);
            class50_sub1_sub4_sub3_sub1.endCycle = _Game.pulseCycle + 300;
            class50_sub1_sub4_sub3_sub1.anInt1596 = class50_sub1_sub2.getUnsignedByte();
            class50_sub1_sub4_sub3_sub1.anInt1597 = class50_sub1_sub2.getByteSubtracted();
          }
          if ((i1 & 4) !== 0) {
            class50_sub1_sub4_sub3_sub1.graphic = class50_sub1_sub2.getUnsignedLEShort();
            const k1 = class50_sub1_sub2.method556();
            class50_sub1_sub4_sub3_sub1.spotAnimationDelay = k1 >> 16;
            class50_sub1_sub4_sub3_sub1.anInt1617 = _Game.pulseCycle + (k1 & 65535);
            class50_sub1_sub4_sub3_sub1.currentAnimation = 0;
            class50_sub1_sub4_sub3_sub1.anInt1616 = 0;
            if (class50_sub1_sub4_sub3_sub1.anInt1617 > _Game.pulseCycle) {
              class50_sub1_sub4_sub3_sub1.currentAnimation = -1;
            }
            if (class50_sub1_sub4_sub3_sub1.graphic === 65535) {
              class50_sub1_sub4_sub3_sub1.graphic = -1;
            }
          }
          if ((i1 & 32) !== 0) {
            class50_sub1_sub4_sub3_sub1.forcedChat = class50_sub1_sub2.getString();
            class50_sub1_sub4_sub3_sub1.textCycle = 100;
          }
          if ((i1 & 8) !== 0) {
            class50_sub1_sub4_sub3_sub1.anInt1598 = class50_sub1_sub2.getLittleShortA();
            class50_sub1_sub4_sub3_sub1.anInt1599 = class50_sub1_sub2.method549();
          }
          if ((i1 & 2) !== 0) {
            let l1 = class50_sub1_sub2.getUnsignedLEShort();
            if (l1 === 65535) {
              l1 = -1;
            }
            const k2 = class50_sub1_sub2.getByteSubtracted();
            if (l1 === class50_sub1_sub4_sub3_sub1.emoteAnimation && l1 !== -1) {
              const i3 = AnimationSequence.animations[l1].anInt307;
              if (i3 === 1) {
                class50_sub1_sub4_sub3_sub1.displayedEmoteFrames = 0;
                class50_sub1_sub4_sub3_sub1.anInt1626 = 0;
                class50_sub1_sub4_sub3_sub1.animationDelay = k2;
                class50_sub1_sub4_sub3_sub1.anInt1628 = 0;
              }
              if (i3 === 2) {
                class50_sub1_sub4_sub3_sub1.anInt1628 = 0;
              }
            } else if (l1 === -1 || class50_sub1_sub4_sub3_sub1.emoteAnimation === -1 || AnimationSequence.animations[l1].anInt301 >= AnimationSequence.animations[class50_sub1_sub4_sub3_sub1.emoteAnimation].anInt301) {
              class50_sub1_sub4_sub3_sub1.emoteAnimation = l1;
              class50_sub1_sub4_sub3_sub1.displayedEmoteFrames = 0;
              class50_sub1_sub4_sub3_sub1.anInt1626 = 0;
              class50_sub1_sub4_sub3_sub1.animationDelay = k2;
              class50_sub1_sub4_sub3_sub1.anInt1628 = 0;
              class50_sub1_sub4_sub3_sub1.anInt1613 = class50_sub1_sub4_sub3_sub1.pathLength;
            }
          }
          if ((i1 & 16) !== 0) {
            const i2 = class50_sub1_sub2.getByteSubtracted();
            const l2 = class50_sub1_sub2.getByteSubtracted();
            class50_sub1_sub4_sub3_sub1.updateHits(l2, i2, _Game.pulseCycle);
            class50_sub1_sub4_sub3_sub1.endCycle = _Game.pulseCycle + 300;
            class50_sub1_sub4_sub3_sub1.anInt1596 = class50_sub1_sub2.getUnsignedByte();
            class50_sub1_sub4_sub3_sub1.anInt1597 = class50_sub1_sub2.getByteNegated();
          }
        }
      }
    }
    method132(class50_sub1_sub2, i, flag) {
      if (flag) {
        this.anInt1140 = 287;
      }
      while (class50_sub1_sub2.bitPosition + 21 < i * 8) {
        {
          const j = class50_sub1_sub2.getBits(14);
          if (j === 16383) {
            break;
          }
          if (this.npcs[j] == null) {
            this.npcs[j] = new Npc();
          }
          const npc = this.npcs[j];
          this.anIntArray1134[this.anInt1133++] = j;
          npc.pulseCycle = _Game.pulseCycle;
          const k = class50_sub1_sub2.getBits(1);
          if (k === 1) {
            this.updatedPlayers[this.updatedPlayerCount++] = j;
          }
          let l = class50_sub1_sub2.getBits(5);
          if (l > 15) {
            l -= 32;
          }
          let i1 = class50_sub1_sub2.getBits(5);
          if (i1 > 15) {
            i1 -= 32;
          }
          const j1 = class50_sub1_sub2.getBits(1);
          npc.npcDefinition = ActorDefinition.getDefinition(class50_sub1_sub2.getBits(13));
          npc.boundaryDimension = npc.npcDefinition.boundaryDimension;
          npc.anInt1600 = npc.npcDefinition.degreesToTurn;
          npc.walkAnimationId = npc.npcDefinition.walkAnimationId;
          npc.turnAroundAnimationId = npc.npcDefinition.turnAroundAnimationId;
          npc.turnRightAnimationId = npc.npcDefinition.turnRightAnimationId;
          npc.turnLeftAnimationId = npc.npcDefinition.turnLeftAnimationId;
          npc.idleAnimation = npc.npcDefinition.standAnimationId;
          npc.setPosition(_Game.localPlayer.pathX[0] + i1, _Game.localPlayer.pathY[0] + l, j1 === 1);
        }
      }
      class50_sub1_sub2.finishBitAccess();
    }
    method46(i, byte0, buffer) {
      buffer.initBitAccess();
      const j = buffer.getBits(8);
      if (byte0 !== this.aByte1317) {
        this.anInt1281 = -460;
      }
      if (j < this.anInt1133) {
        for (let k = j; k < this.anInt1133; k++) {
          this.removePlayers[this.removePlayerCount++] = this.anIntArray1134[k];
        }
      }
      if (j > this.anInt1133) {
        SignLink.reportError(this.username + " Too many npcs");
        throw Error("eek");
      }
      this.anInt1133 = 0;
      for (let l = 0; l < j; l++) {
        {
          const i1 = this.anIntArray1134[l];
          const npc = this.npcs[i1];
          const updateRequired = buffer.getBits(1);
          if (updateRequired === 0) {
            this.anIntArray1134[this.anInt1133++] = i1;
            npc.pulseCycle = _Game.pulseCycle;
          } else {
            const moveType = buffer.getBits(2);
            if (moveType === 0) {
              this.anIntArray1134[this.anInt1133++] = i1;
              npc.pulseCycle = _Game.pulseCycle;
              this.updatedPlayers[this.updatedPlayerCount++] = i1;
            } else if (moveType === 1) {
              this.anIntArray1134[this.anInt1133++] = i1;
              npc.pulseCycle = _Game.pulseCycle;
              const direction = buffer.getBits(3);
              npc.move(direction, false);
              const blockUpdateRequired = buffer.getBits(1);
              if (blockUpdateRequired === 1) {
                this.updatedPlayers[this.updatedPlayerCount++] = i1;
              }
            } else if (moveType === 2) {
              this.anIntArray1134[this.anInt1133++] = i1;
              npc.pulseCycle = _Game.pulseCycle;
              const direction1 = buffer.getBits(3);
              npc.move(direction1, true);
              const direction2 = buffer.getBits(3);
              npc.move(direction2, true);
              const blockUpdateRequired = buffer.getBits(1);
              if (blockUpdateRequired === 1) {
                this.updatedPlayers[this.updatedPlayerCount++] = i1;
              }
            } else if (moveType === 3) {
              this.removePlayers[this.removePlayerCount++] = i1;
            }
          }
        }
      }
    }
    method145(flag, i, j, k, l, i1, j1, k1, l1, i2) {
      let spawnObjectNode = null;
      for (let spawnObjectNode_1 = this.aClass6_1261.first(); spawnObjectNode_1 != null; spawnObjectNode_1 = this.aClass6_1261.next()) {
        {
          if (spawnObjectNode_1.anInt1391 !== i || spawnObjectNode_1.anInt1393 !== j || spawnObjectNode_1.anInt1394 !== i2 || spawnObjectNode_1.anInt1392 !== l1) {
            continue;
          }
          spawnObjectNode = spawnObjectNode_1;
          break;
        }
      }
      if (spawnObjectNode == null) {
        spawnObjectNode = new SpawnObjectNode();
        spawnObjectNode.anInt1391 = i;
        spawnObjectNode.anInt1392 = l1;
        spawnObjectNode.anInt1393 = j;
        spawnObjectNode.anInt1394 = i2;
        this.method140(-61 | 0, spawnObjectNode);
        this.aClass6_1261.insertBack(spawnObjectNode);
      }
      spawnObjectNode.anInt1384 = j1;
      spawnObjectNode.anInt1386 = i1;
      spawnObjectNode.anInt1385 = k;
      spawnObjectNode.anInt1395 = k1;
      spawnObjectNode.anInt1390 = l;
      this.loggedIn = flag && this.loggedIn;
    }
    parsePlacementPacket(buf, opcode) {
      if (opcode === 203) {
        const k = buf.getUnsignedLEShort();
        const j3 = buf.getUnsignedByte();
        const i6 = j3 >> 2;
        const rotation = j3 & 3;
        const k11 = this.anIntArray1032[i6];
        let byte0 = buf.getSignedByteNegated();
        const offset = buf.getByteAdded();
        const x2 = this.placementX + (offset >> 4 & 7);
        const y = this.placementY + (offset & 7);
        let byte1 = buf.getSignedByteAdded();
        const l19 = buf.method550();
        const id = buf.method549();
        let byte2 = buf.getSignedByte();
        let byte3 = buf.getSignedByteAdded();
        const l21 = buf.getUnsignedLEShort();
        let player2;
        if (id === this.thisPlayerServerId) {
          player2 = _Game.localPlayer;
        } else {
          player2 = this.players[id];
        }
        if (player2 != null) {
          const class47 = GameObjectDefinition.getDefinition(k);
          const i22 = this.anIntArrayArrayArray891[this.plane][x2][y];
          const j22 = this.anIntArrayArrayArray891[this.plane][x2 + 1][y];
          const k22 = this.anIntArrayArrayArray891[this.plane][x2 + 1][y + 1];
          const l22 = this.anIntArrayArrayArray891[this.plane][x2][y + 1];
          const class50_sub1_sub4_sub4 = class47.getGameObjectModel(i6, rotation, i22, j22, k22, l22, -1);
          if (class50_sub1_sub4_sub4 != null) {
            this.method145(true, this.plane, x2, 0, l19 + 1, 0, -1, l21 + 1, k11, y);
            player2.objectAppearanceStartTick = l21 + _Game.pulseCycle;
            player2.objectAppearanceEndTick = l19 + _Game.pulseCycle;
            player2.playerModel = class50_sub1_sub4_sub4;
            let i23 = class47.sizeX;
            let j23 = class47.sizeY;
            if (rotation === 1 || rotation === 3) {
              i23 = class47.sizeY;
              j23 = class47.sizeX;
            }
            player2.anInt1743 = x2 * 128 + i23 * 64;
            player2.anInt1745 = y * 128 + j23 * 64;
            player2.anInt1744 = this.getTileHeight(player2.anInt1745, player2.anInt1743, 9 | 0, this.plane);
            if (byte1 > byte0) {
              const byte4 = byte1;
              byte1 = byte0;
              byte0 = byte4;
            }
            if (byte3 > byte2) {
              const byte5 = byte3;
              byte3 = byte2;
              byte2 = byte5;
            }
            player2.anInt1768 = x2 + byte1;
            player2.anInt1770 = x2 + byte0;
            player2.anInt1769 = y + byte3;
            player2.anInt1771 = y + byte2;
          }
        }
      }
      if (opcode === 106) {
        const offset = buf.getByteAdded();
        const x2 = this.placementX + (offset >> 4 & 7);
        const y = this.placementY + (offset & 7);
        const amount = buf.getLittleShortA();
        const id = buf.method550();
        const playerId = buf.method550();
        if (x2 >= 0 && y >= 0 && x2 < 104 && y < 104 && playerId !== this.thisPlayerServerId) {
          const item = new Item();
          item.itemId = id;
          item.itemCount = amount;
          if (this.groundItems[this.plane][x2][y] == null) {
            this.groundItems[this.plane][x2][y] = new LinkedList();
          }
          this.groundItems[this.plane][x2][y].insertBack(item);
          this.processGroundItems(x2, y);
        }
        return;
      }
      if (opcode === 142) {
        const i1 = buf.getUnsignedLEShort();
        const l3 = buf.getByteAdded();
        let k6 = l3 >> 2;
        const j9 = l3 & 3;
        const i12 = this.anIntArray1032[k6];
        const j14 = buf.getUnsignedByte();
        const x2 = this.placementX + (j14 >> 4 & 7);
        const y = this.placementY + (j14 & 7);
        if (x2 >= 0 && y >= 0 && x2 < 103 && y < 103) {
          const l18 = this.anIntArrayArrayArray891[this.plane][x2][y];
          const j19 = this.anIntArrayArrayArray891[this.plane][x2 + 1][y];
          const i20 = this.anIntArrayArrayArray891[this.plane][x2 + 1][y + 1];
          const l20 = this.anIntArrayArrayArray891[this.plane][x2][y + 1];
          if (i12 === 0) {
            const wall = this.currentScene.method263(this.plane, 17734, x2, y);
            if (wall != null) {
              const k21 = wall.hash >> 14 & 32767;
              if (k6 === 2) {
                wall.aRenderable769 = new GameObject(k21, 4 + j9, 2, j19, i20, l18, l20, i1, false);
                wall.aRenderable770 = new GameObject(k21, j9 + 1 & 3, 2, j19, i20, l18, l20, i1, false);
              } else {
                wall.aRenderable769 = new GameObject(k21, j9, k6, j19, i20, l18, l20, i1, false);
              }
            }
          }
          if (i12 === 1) {
            const wallDecoration = this.currentScene.method264(this.plane, y, x2, false);
            if (wallDecoration != null) {
              wallDecoration.renderable = new GameObject(
                wallDecoration.hash >> 14 & 32767,
                0,
                4,
                j19,
                i20,
                l18,
                l20,
                i1,
                false
              );
            }
          }
          if (i12 === 2) {
            const sceneSpawnRequest = this.currentScene.method265(x2, 32 | 0, y, this.plane);
            if (k6 === 11) {
              k6 = 10;
            }
            if (sceneSpawnRequest != null) {
              sceneSpawnRequest.renderable = new GameObject(
                sceneSpawnRequest.hash >> 14 & 32767,
                j9,
                k6,
                j19,
                i20,
                l18,
                l20,
                i1,
                false
              );
            }
          }
          if (i12 === 3) {
            const floorDecoration = this.currentScene.method266(this.plane, y, 0, x2);
            if (floorDecoration != null) {
              floorDecoration.renderable = new GameObject(
                floorDecoration.hash >> 14 & 32767,
                j9,
                22,
                j19,
                i20,
                l18,
                l20,
                i1,
                false
              );
            }
          }
        }
        return;
      }
      if (opcode === 107) {
        const id = buf.getUnsignedLEShort();
        const offset = buf.getByteNegated();
        const x2 = this.placementX + (offset >> 4 & 7);
        const y = this.placementY + (offset & 7);
        const amount = buf.method550();
        if (x2 >= 0 && y >= 0 && x2 < 104 && y < 104) {
          const item = new Item();
          item.itemId = id;
          item.itemCount = amount;
          if (this.groundItems[this.plane][x2][y] == null) {
            this.groundItems[this.plane][x2][y] = new LinkedList();
          }
          this.groundItems[this.plane][x2][y].insertBack(item);
          this.processGroundItems(x2, y);
        }
        return;
      }
      if (opcode === 121) {
        const offset = buf.getUnsignedByte();
        const x2 = this.placementX + (offset >> 4 & 7);
        const y = this.placementY + (offset & 7);
        const id = buf.getUnsignedLEShort();
        const amount = buf.getUnsignedLEShort();
        const newAmount = buf.getUnsignedLEShort();
        if (x2 >= 0 && y >= 0 && x2 < 104 && y < 104) {
          const list = this.groundItems[this.plane][x2][y];
          if (list != null) {
            for (let item = list.first(); item != null; item = list.next()) {
              {
                if (item.itemId !== (id & 32767) || item.itemCount !== amount) {
                  continue;
                }
                item.itemCount = newAmount;
                break;
              }
            }
            this.processGroundItems(x2, y);
          }
        }
        return;
      }
      if (opcode === 181) {
        const offset = buf.getUnsignedByte();
        let x2 = this.placementX + (offset >> 4 & 7);
        let y = this.placementY + (offset & 7);
        let i10 = x2 + buf.getSignedByte();
        let l12 = y + buf.getSignedByte();
        const l14 = buf.getSignedShort();
        const k16 = buf.getUnsignedLEShort();
        const i18 = buf.getUnsignedByte() * 4;
        const i19 = buf.getUnsignedByte() * 4;
        const k19 = buf.getUnsignedLEShort();
        const j20 = buf.getUnsignedLEShort();
        const i21 = buf.getUnsignedByte();
        const j21 = buf.getUnsignedByte();
        if (x2 >= 0 && y >= 0 && x2 < 104 && y < 104 && i10 >= 0 && l12 >= 0 && i10 < 104 && l12 < 104 && k16 !== 65535) {
          x2 = x2 * 128 + 64;
          y = y * 128 + 64;
          i10 = i10 * 128 + 64;
          l12 = l12 * 128 + 64;
          const class50_sub1_sub4_sub2 = new Projectile(
            this.plane,
            i19,
            j21,
            y,
            k16,
            j20 + _Game.pulseCycle,
            i21,
            l14,
            this.getTileHeight(y, x2, 9 | 0, this.plane) - i18,
            x2,
            k19 + _Game.pulseCycle
          );
          class50_sub1_sub4_sub2.trackTarget(
            i10,
            l12,
            this.getTileHeight(l12, i10, 9 | 0, this.plane) - i19,
            k19 + _Game.pulseCycle
          );
          this.aClass6_1282.insertBack(class50_sub1_sub4_sub2);
        }
        return;
      }
      if (opcode === 41) {
        const offset = buf.getUnsignedByte();
        const x2 = this.placementX + (offset >> 4 & 7);
        const y = this.placementY + (offset & 7);
        const soundId = buf.getUnsignedLEShort();
        const i13 = buf.getUnsignedByte();
        const i15 = i13 >> 4 & 15;
        const type = i13 & 7;
        if (_Game.localPlayer.pathX[0] >= x2 - i15 && _Game.localPlayer.pathX[0] <= x2 + i15 && _Game.localPlayer.pathY[0] >= y - i15 && _Game.localPlayer.pathY[0] <= y + i15 && this.aBoolean1301 && !_Game.lowMemory && this.currentSound < 50) {
          this.sound[this.currentSound] = soundId;
          this.soundType[this.currentSound] = type;
          this.soundDelay[this.currentSound] = SoundTrack.trackDelays[soundId];
          this.currentSound++;
        }
      }
      if (opcode === 59) {
        const j2 = buf.getUnsignedByte();
        let i5 = this.placementX + (j2 >> 4 & 7);
        let l7 = this.placementY + (j2 & 7);
        const k10 = buf.getUnsignedLEShort();
        const j13 = buf.getUnsignedByte();
        const j15 = buf.getUnsignedLEShort();
        if (i5 >= 0 && l7 >= 0 && i5 < 104 && l7 < 104) {
          i5 = i5 * 128 + 64;
          l7 = l7 * 128 + 64;
          const gameAnimableObject = new GameAnimableObject(
            this.plane,
            _Game.pulseCycle,
            j15,
            k10,
            this.getTileHeight(l7, i5, 9 | 0, this.plane) - j13,
            l7,
            i5
          );
          this.aClass6_1210.insertBack(gameAnimableObject);
        }
        return;
      }
      if (opcode === 152) {
        const k2 = buf.getByteNegated();
        const j5 = k2 >> 2;
        const i8 = k2 & 3;
        const l10 = this.anIntArray1032[j5];
        const k13 = buf.getLittleShortA();
        const k15 = buf.getByteAdded();
        const i17 = this.placementX + (k15 >> 4 & 7);
        const j18 = this.placementY + (k15 & 7);
        if (i17 >= 0 && j18 >= 0 && i17 < 104 && j18 < 104) {
          this.method145(true, this.plane, i17, i8, -1, j5, k13, 0, l10, j18);
        }
        return;
      }
      if (opcode === 208) {
        const id = buf.method550();
        const offset = buf.getByteAdded();
        const x2 = this.placementX + (offset >> 4 & 7);
        const y = this.placementY + (offset & 7);
        if (x2 >= 0 && y >= 0 && x2 < 104 && y < 104) {
          const list = this.groundItems[this.plane][x2][y];
          if (list != null) {
            for (let item = list.first(); item != null; item = list.next()) {
              {
                if (item.itemId !== (id & 32767)) {
                  continue;
                }
                item.remove();
                break;
              }
            }
            if (list.first() == null) {
              this.groundItems[this.plane][x2][y] = null;
            }
            this.processGroundItems(x2, y);
          }
        }
        return;
      }
      if (opcode === 88) {
        const i3 = buf.getByteSubtracted();
        const l5 = this.placementX + (i3 >> 4 & 7);
        const k8 = this.placementY + (i3 & 7);
        const j11 = buf.getByteSubtracted();
        const l13 = j11 >> 2;
        const l15 = j11 & 3;
        const j17 = this.anIntArray1032[l13];
        if (l5 >= 0 && k8 >= 0 && l5 < 104 && k8 < 104) {
          this.method145(true, this.plane, l5, l15, -1, l13, -1, 0, j17, k8);
        }
      }
    }
    logout() {
      try {
        if (this.gameConnection != null) {
          this.gameConnection.close();
        }
      } catch (_ex) {
      }
      this.gameConnection = null;
      this.loggedIn = false;
      this.loginScreenState = 0;
      this.username = "";
      this.password = "";
      this.resetModelCaches();
      this.currentScene.method241();
      for (let plane = 0; plane < 4; plane++) {
        this.currentCollisionMap[plane].reset();
      }
      this.stopMidi();
      this.currentSong = -1;
      this.nextSong = -1;
      this.previousSong = 0;
    }
    method143(byte0) {
      if (byte0 !== -40) {
        _Game.aBoolean1207 = !_Game.aBoolean1207;
      }
      if (_Game.lowMemory && this.loadingStage === 2 && Region.onBuildTimePlane !== this.plane) {
        this.method125(null, "Loading - please wait.");
        this.loadingStage = 1;
        this.aLong1229 = new Date().getTime();
      }
      if (this.loadingStage === 1) {
        const i = this.method144(5);
        if (i !== 0 && new Date().getTime() - this.aLong1229 > 36e4) {
          SignLink.reportError(
            this.username + " glcfb serverseed_meh ," + i + "," + _Game.lowMemory + "," + this.stores[0] + "," + this.onDemandRequester.immediateRequestsCount() + "," + this.plane + "," + this.chunkX + "," + this.chunkY
          );
          this.aLong1229 = new Date().getTime();
        }
      }
      if (this.loadingStage === 2 && this.plane !== this.anInt1276) {
        this.anInt1276 = this.plane;
        this.renderViewport(this.plane);
      }
    }
    method150(i, j, k, l, i1, j1) {
      let k1 = this.currentScene.method267(j, k, i);
      i1 = 62 / i1 | 0;
      if (k1 !== 0) {
        const l1 = this.currentScene.method271(j, k, i, k1);
        const k2 = l1 >> 6 & 3;
        const i3 = l1 & 31;
        let k3 = j1;
        if (k1 > 0) {
          k3 = l;
        }
        const ai = this.minimapImage.pixels;
        const k4 = 24624 + k * 4 + (103 - i) * 512 * 4;
        const i5 = k1 >> 14 & 32767;
        const class47_2 = GameObjectDefinition.getDefinition(i5);
        if (class47_2.anInt795 !== -1) {
          const class50_sub1_sub1_sub3_2 = this.mapscenes[class47_2.anInt795];
          if (class50_sub1_sub1_sub3_2 != null) {
            const i6 = (class47_2.sizeX * 4 - class50_sub1_sub1_sub3_2.width) / 2 | 0;
            const j6 = (class47_2.sizeY * 4 - class50_sub1_sub1_sub3_2.height) / 2 | 0;
            class50_sub1_sub1_sub3_2.drawImage(48 + k * 4 + i6, 48 + (104 - i - class47_2.sizeY) * 4 + j6);
          }
        } else {
          if (i3 === 0 || i3 === 2) {
            if (k2 === 0) {
              ai[k4] = k3;
              ai[k4 + 512] = k3;
              ai[k4 + 1024] = k3;
              ai[k4 + 1536] = k3;
            } else if (k2 === 1) {
              ai[k4] = k3;
              ai[k4 + 1] = k3;
              ai[k4 + 2] = k3;
              ai[k4 + 3] = k3;
            } else if (k2 === 2) {
              ai[k4 + 3] = k3;
              ai[k4 + 3 + 512] = k3;
              ai[k4 + 3 + 1024] = k3;
              ai[k4 + 3 + 1536] = k3;
            } else if (k2 === 3) {
              ai[k4 + 1536] = k3;
              ai[k4 + 1536 + 1] = k3;
              ai[k4 + 1536 + 2] = k3;
              ai[k4 + 1536 + 3] = k3;
            }
          }
          if (i3 === 3) {
            if (k2 === 0) {
              ai[k4] = k3;
            } else if (k2 === 1) {
              ai[k4 + 3] = k3;
            } else if (k2 === 2) {
              ai[k4 + 3 + 1536] = k3;
            } else if (k2 === 3) {
              ai[k4 + 1536] = k3;
            }
          }
          if (i3 === 2) {
            if (k2 === 3) {
              ai[k4] = k3;
              ai[k4 + 512] = k3;
              ai[k4 + 1024] = k3;
              ai[k4 + 1536] = k3;
            } else if (k2 === 0) {
              ai[k4] = k3;
              ai[k4 + 1] = k3;
              ai[k4 + 2] = k3;
              ai[k4 + 3] = k3;
            } else if (k2 === 1) {
              ai[k4 + 3] = k3;
              ai[k4 + 3 + 512] = k3;
              ai[k4 + 3 + 1024] = k3;
              ai[k4 + 3 + 1536] = k3;
            } else if (k2 === 2) {
              ai[k4 + 1536] = k3;
              ai[k4 + 1536 + 1] = k3;
              ai[k4 + 1536 + 2] = k3;
              ai[k4 + 1536 + 3] = k3;
            }
          }
        }
      }
      k1 = this.currentScene.method269(j, k, i);
      if (k1 !== 0) {
        const i2 = this.currentScene.method271(j, k, i, k1);
        const l2 = i2 >> 6 & 3;
        const j3 = i2 & 31;
        const l3 = k1 >> 14 & 32767;
        const class47_1 = GameObjectDefinition.getDefinition(l3);
        if (class47_1.anInt795 !== -1) {
          const class50_sub1_sub1_sub3_1 = this.mapscenes[class47_1.anInt795];
          if (class50_sub1_sub1_sub3_1 != null) {
            const j5 = (class47_1.sizeX * 4 - class50_sub1_sub1_sub3_1.width) / 2 | 0;
            const k5 = (class47_1.sizeY * 4 - class50_sub1_sub1_sub3_1.height) / 2 | 0;
            class50_sub1_sub1_sub3_1.drawImage(48 + k * 4 + j5, 48 + (104 - i - class47_1.sizeY) * 4 + k5);
          }
        } else if (j3 === 9) {
          let l4 = 15658734;
          if (k1 > 0) {
            l4 = 15597568;
          }
          const ai1 = this.minimapImage.pixels;
          const l5 = 24624 + k * 4 + (103 - i) * 512 * 4;
          if (l2 === 0 || l2 === 2) {
            ai1[l5 + 1536] = l4;
            ai1[l5 + 1024 + 1] = l4;
            ai1[l5 + 512 + 2] = l4;
            ai1[l5 + 3] = l4;
          } else {
            ai1[l5] = l4;
            ai1[l5 + 512 + 1] = l4;
            ai1[l5 + 1024 + 2] = l4;
            ai1[l5 + 1536 + 3] = l4;
          }
        }
      }
      k1 = this.currentScene.getFloorDecorationHash(j, k, i);
      if (k1 !== 0) {
        const j2 = k1 >> 14 & 32767;
        const class47 = GameObjectDefinition.getDefinition(j2);
        if (class47.anInt795 !== -1) {
          const class50_sub1_sub1_sub3 = this.mapscenes[class47.anInt795];
          if (class50_sub1_sub1_sub3 != null) {
            const i4 = (class47.sizeX * 4 - class50_sub1_sub1_sub3.width) / 2 | 0;
            const j4 = (class47.sizeY * 4 - class50_sub1_sub1_sub3.height) / 2 | 0;
            class50_sub1_sub1_sub3.drawImage(48 + k * 4 + i4, 48 + (104 - i - class47.sizeY) * 4 + j4);
          }
        }
      }
    }
    renderViewport(plane) {
      const pixels = this.minimapImage.pixels;
      const pixelAmount = pixels.length;
      for (let pixel = 0; pixel < pixelAmount; pixel++) {
        pixels[pixel] = 0;
      }
      for (let viewportY = 1; viewportY < 103; viewportY++) {
        {
          let drawPoint = 24628 + (103 - viewportY) * 512 * 4;
          for (let viewportX = 1; viewportX < 103; viewportX++) {
            {
              if ((this.currentSceneTileFlags[plane][viewportX][viewportY] & 24) === 0) {
                this.currentScene.renderMinimapDot(pixels, drawPoint, 512, plane, viewportX, viewportY);
              }
              if (plane < 3 && (this.currentSceneTileFlags[plane + 1][viewportX][viewportY] & 8) !== 0) {
                this.currentScene.renderMinimapDot(pixels, drawPoint, 512, plane + 1, viewportX, viewportY);
              }
              drawPoint += 4;
            }
          }
        }
      }
      const primaryColour = (238 + (Math.random() * 20 | 0) - 10 << 16) + (238 + (Math.random() * 20 | 0) - 10 << 8) + (238 + (Math.random() * 20 | 0) - 10);
      const secondaryColour = 238 + (Math.random() * 20 | 0) - 10 << 16;
      this.minimapImage.createRasterizer();
      for (let viewportY = 1; viewportY < 103; viewportY++) {
        {
          for (let viewportX = 1; viewportX < 103; viewportX++) {
            {
              if ((this.currentSceneTileFlags[plane][viewportX][viewportY] & 24) === 0) {
                this.method150(viewportY, plane, viewportX, secondaryColour, 563, primaryColour);
              }
              if (plane < 3 && (this.currentSceneTileFlags[plane + 1][viewportX][viewportY] & 8) !== 0) {
                this.method150(viewportY, plane + 1, viewportX, secondaryColour, 563, primaryColour);
              }
            }
          }
        }
      }
      if (this.aClass18_1158 != null) {
        this.aClass18_1158.createRasterizer();
        Rasterizer3D.lineOffsets = this.anIntArray1002;
      }
      _Game.anInt1082++;
      if (_Game.anInt1082 > 177) {
        _Game.anInt1082 = 0;
        this.outBuffer.putOpcode(173);
        this.outBuffer.putTriByte(2657152);
      }
      this.minimapHintCount = 0;
      for (let viewportX = 0; viewportX < 104; viewportX++) {
        {
          for (let viewportY = 0; viewportY < 104; viewportY++) {
            {
              let floorHash = this.currentScene.getFloorDecorationHash(this.plane, viewportX, viewportY);
              if (floorHash !== 0) {
                floorHash = floorHash >> 14 & 32767;
                const icon = GameObjectDefinition.getDefinition(floorHash).icon;
                if (icon >= 0) {
                  let drawPointX = viewportX;
                  let drawPointY = viewportY;
                  if (icon !== 22 && icon !== 29 && icon !== 34 && icon !== 36 && icon !== 46 && icon !== 47 && icon !== 48) {
                    const regionWidth = 104;
                    const regionHeight = 104;
                    const flags = this.currentCollisionMap[this.plane].adjacency;
                    for (let off = 0; off < 10; off++) {
                      {
                        const randPlane = Math.random() * 4 | 0;
                        if (randPlane === 0 && drawPointX > 0 && drawPointX > viewportX - 3 && (flags[drawPointX - 1][drawPointY] & 19398920) === 0) {
                          drawPointX--;
                        }
                        if (randPlane === 1 && drawPointX < regionWidth - 1 && drawPointX < viewportX + 3 && (flags[drawPointX + 1][drawPointY] & 19399040) === 0) {
                          drawPointX++;
                        }
                        if (randPlane === 2 && drawPointY > 0 && drawPointY > viewportY - 3 && (flags[drawPointX][drawPointY - 1] & 19398914) === 0) {
                          drawPointY--;
                        }
                        if (randPlane === 3 && drawPointY < regionHeight - 1 && drawPointY < viewportY + 3 && (flags[drawPointX][drawPointY + 1] & 19398944) === 0) {
                          drawPointY++;
                        }
                      }
                    }
                  }
                  this.minimapHint[this.minimapHintCount] = this.worldMapHintIcons[icon];
                  this.minimapHintX[this.minimapHintCount] = drawPointX;
                  this.minimapHintY[this.minimapHintCount] = drawPointY;
                  this.minimapHintCount++;
                }
              }
            }
          }
        }
      }
    }
    method144(i) {
      for (let j = 0; j < this.aByteArrayArray838.length; j++) {
        {
          if (this.aByteArrayArray838[j] == null && this.anIntArray857[j] !== -1) {
            return -1;
          }
          if (this.aByteArrayArray1232[j] == null && this.anIntArray858[j] !== -1) {
            return -2;
          }
        }
      }
      let flag = true;
      if (i < 5 || i > 5) {
        this.aBoolean953 = !this.aBoolean953;
      }
      for (let k = 0; k < this.aByteArrayArray838.length; k++) {
        {
          const abyte0 = this.aByteArrayArray1232[k];
          if (abyte0 != null) {
            let l = (this.coordinates[k] >> 8) * 64 - this.nextTopLeftTileX;
            let i1 = (this.coordinates[k] & 255) * 64 - this.nextTopRightTileY;
            if (this.aBoolean1163) {
              l = 10;
              i1 = 10;
            }
            flag = Region.method181(l, i1, abyte0, 24515) && flag;
          }
        }
      }
      if (!flag) {
        return -3;
      }
      if (this.aBoolean1209) {
        return -4;
      } else {
        this.loadingStage = 2;
        Region.onBuildTimePlane = this.plane;
        this.method93(175);
        this.outBuffer.putOpcode(6);
        return 0;
      }
    }
    resetModelCaches() {
      GameObjectDefinition.modelCache.removeAll();
      GameObjectDefinition.animatedModelCache.removeAll();
      ActorDefinition.modelCache.removeAll();
      ItemDefinition.modelCache.removeAll();
      ItemDefinition.rgbImageCache.removeAll();
      Player.modelCache.removeAll();
      SpotAnimation.modelCache.removeAll();
    }
    method93(i) {
      try {
        this.anInt1276 = -1;
        this.aClass6_1210.getNodeCount();
        this.aClass6_1282.getNodeCount();
        Rasterizer3D.method495(71 | 0);
        this.resetModelCaches();
        this.currentScene.method241();
        for (let plane = 0; plane < 4; plane++) {
          this.currentCollisionMap[plane].reset();
        }
        for (let i1 = 0; i1 < 4; i1++) {
          {
            for (let l1 = 0; l1 < 104; l1++) {
              {
                for (let k2 = 0; k2 < 104; k2++) {
                  this.currentSceneTileFlags[i1][l1][k2] = 0;
                }
              }
            }
          }
        }
        const class8 = new Region(this.currentSceneTileFlags, 104, 104, this.anIntArrayArrayArray891);
        const l2 = this.aByteArrayArray838.length;
        this.outBuffer.putOpcode(40);
        if (!this.aBoolean1163) {
          for (let j3 = 0; j3 < l2; j3++) {
            {
              const j4 = (this.coordinates[j3] >> 8) * 64 - this.nextTopLeftTileX;
              const l5 = (this.coordinates[j3] & 255) * 64 - this.nextTopRightTileY;
              const abyte0 = this.aByteArrayArray838[j3];
              if (abyte0 != null) {
                class8.method174(l5, false, (this.chunkY - 6) * 8, j4, abyte0, (this.chunkX - 6) * 8, this.currentCollisionMap);
              }
            }
          }
          for (let k4 = 0; k4 < l2; k4++) {
            {
              const i6 = (this.coordinates[k4] >> 8) * 64 - this.nextTopLeftTileX;
              const l7 = (this.coordinates[k4] & 255) * 64 - this.nextTopRightTileY;
              const abyte2 = this.aByteArrayArray838[k4];
              if (abyte2 == null && this.chunkY < 800) {
                class8.initiateVertexHeights(i6, 64, l7, 64);
              }
            }
          }
          this.outBuffer.putOpcode(40);
          for (let j6 = 0; j6 < l2; j6++) {
            {
              const abyte1 = this.aByteArrayArray1232[j6];
              if (abyte1 != null) {
                const l8 = (this.coordinates[j6] >> 8) * 64 - this.nextTopLeftTileX;
                const k9 = (this.coordinates[j6] & 255) * 64 - this.nextTopRightTileY;
                class8.method179(k9, this.currentCollisionMap, l8, -571, this.currentScene, abyte1);
              }
            }
          }
        }
        if (this.aBoolean1163) {
          for (let k3 = 0; k3 < 4; k3++) {
            {
              for (let l4 = 0; l4 < 13; l4++) {
                {
                  for (let k6 = 0; k6 < 13; k6++) {
                    {
                      let flag = false;
                      const i9 = this.constructedMapPalette[k3][l4][k6];
                      if (i9 !== -1) {
                        const l9 = i9 >> 24 & 3;
                        const j10 = i9 >> 1 & 3;
                        const l10 = i9 >> 14 & 1023;
                        const j11 = i9 >> 3 & 2047;
                        const l11 = ((l10 / 8 | 0) << 8) + (j11 / 8 | 0);
                        for (let j12 = 0; j12 < this.coordinates.length; j12++) {
                          {
                            if (this.coordinates[j12] !== l11 || this.aByteArrayArray838[j12] == null) {
                              continue;
                            }
                            class8.method168(
                              j10,
                              (j11 & 7) * 8,
                              false,
                              this.aByteArrayArray838[j12],
                              k3,
                              l9,
                              l4 * 8,
                              this.currentCollisionMap,
                              k6 * 8,
                              (l10 & 7) * 8
                            );
                            flag = true;
                            break;
                          }
                        }
                      }
                      if (!flag) {
                        class8.method166(this.anInt1072, k3, k6 * 8, l4 * 8);
                      }
                    }
                  }
                }
              }
            }
          }
          for (let i5 = 0; i5 < 13; i5++) {
            {
              for (let l6 = 0; l6 < 13; l6++) {
                {
                  const i8 = this.constructedMapPalette[0][i5][l6];
                  if (i8 === -1) {
                    class8.initiateVertexHeights(i5 * 8, 8, l6 * 8, 8);
                  }
                }
              }
            }
          }
          this.outBuffer.putOpcode(40);
          for (let i7 = 0; i7 < 4; i7++) {
            {
              for (let j8 = 0; j8 < 13; j8++) {
                {
                  for (let j9 = 0; j9 < 13; j9++) {
                    {
                      const i10 = this.constructedMapPalette[i7][j8][j9];
                      if (i10 !== -1) {
                        const k10 = i10 >> 24 & 3;
                        const i11 = i10 >> 1 & 3;
                        const k11 = i10 >> 14 & 1023;
                        const i12 = i10 >> 3 & 2047;
                        const k12 = ((k11 / 8 | 0) << 8) + (i12 / 8 | 0);
                        for (let l12 = 0; l12 < this.coordinates.length; l12++) {
                          {
                            if (this.coordinates[l12] !== k12 || this.aByteArrayArray1232[l12] == null) {
                              continue;
                            }
                            class8.method172(
                              i7,
                              this.currentCollisionMap,
                              this.currentScene,
                              false,
                              this.aByteArrayArray1232[l12],
                              j9 * 8,
                              i11,
                              (k11 & 7) * 8,
                              j8 * 8,
                              (i12 & 7) * 8,
                              k10
                            );
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        this.outBuffer.putOpcode(40);
        class8.createRegionScene(this.currentCollisionMap, this.currentScene);
        if (this.aClass18_1158 != null) {
          this.aClass18_1158.createRasterizer();
          Rasterizer3D.lineOffsets = this.anIntArray1002;
        }
        this.outBuffer.putOpcode(40);
        let l3 = Region.lowestPlane;
        if (l3 > this.plane) {
          l3 = this.plane;
        }
        if (l3 < this.plane - 1) {
          l3 = this.plane - 1;
        }
        if (_Game.lowMemory) {
          this.currentScene.method242(Region.lowestPlane);
        } else {
          this.currentScene.method242(0);
        }
        for (let j5 = 0; j5 < 104; j5++) {
          {
            for (let j7 = 0; j7 < 104; j7++) {
              this.processGroundItems(j5, j7);
            }
          }
        }
        this.method18(3 | 0);
      } catch (exception) {
      }
      GameObjectDefinition.modelCache.removeAll();
      this.outBuffer.putOpcode(78);
      this.outBuffer.putInt(1057001181);
      if (_Game.lowMemory) {
        const k = this.onDemandRequester.fileCount(0);
        for (let j1 = 0; j1 < k; j1++) {
          {
            const i2 = this.onDemandRequester.modelId(j1);
            if ((i2 & 121) === 0) {
              Model.resetModel(j1);
            }
          }
        }
      }
      Rasterizer3D.method496(20);
      this.onDemandRequester.immediateRequestCount();
      let l = ((this.chunkX - 6) / 8 | 0) - 1;
      let k1 = ((this.chunkX + 6) / 8 | 0) + 1;
      let j2 = ((this.chunkY - 6) / 8 | 0) - 1;
      let i3 = ((this.chunkY + 6) / 8 | 0) + 1;
      i = 94 / i | 0;
      if (this.aBoolean1067) {
        l = 49;
        k1 = 50;
        j2 = 49;
        i3 = 50;
      }
      for (let i4 = l; i4 <= k1; i4++) {
        {
          for (let k5 = j2; k5 <= i3; k5++) {
            if (i4 === l || i4 === k1 || k5 === j2 || k5 === i3) {
              const k7 = this.onDemandRequester.regId(0, i4, k5, 0);
              if (k7 !== -1) {
                this.onDemandRequester.passiveRequest(k7, 3);
              }
              const k8 = this.onDemandRequester.regId(0, i4, k5, 1);
              if (k8 !== -1) {
                this.onDemandRequester.passiveRequest(k8, 3);
              }
            }
          }
        }
      }
    }
    method18(byte0) {
      if (byte0 !== 3) {
        return;
      }
      for (let spawnObjectNode = this.aClass6_1261.first(); spawnObjectNode != null; spawnObjectNode = this.aClass6_1261.next()) {
        if (spawnObjectNode.anInt1390 === -1) {
          spawnObjectNode.anInt1395 = 0;
          this.method140(-61 | 0, spawnObjectNode);
        } else {
          spawnObjectNode.remove();
        }
      }
    }
    method140(byte0, spawnObjectNode) {
      let i = 0;
      let j = -1;
      let k = 0;
      let l = 0;
      if (byte0 !== -61) {
        this.outBuffer.putByte(175);
      }
      if (spawnObjectNode.anInt1392 === 0) {
        i = this.currentScene.method267(spawnObjectNode.anInt1391, spawnObjectNode.anInt1393, spawnObjectNode.anInt1394);
      }
      if (spawnObjectNode.anInt1392 === 1) {
        i = this.currentScene.method268(
          spawnObjectNode.anInt1393,
          4 | 0,
          spawnObjectNode.anInt1391,
          spawnObjectNode.anInt1394
        );
      }
      if (spawnObjectNode.anInt1392 === 2) {
        i = this.currentScene.method269(spawnObjectNode.anInt1391, spawnObjectNode.anInt1393, spawnObjectNode.anInt1394);
      }
      if (spawnObjectNode.anInt1392 === 3) {
        i = this.currentScene.getFloorDecorationHash(spawnObjectNode.anInt1391, spawnObjectNode.anInt1393, spawnObjectNode.anInt1394);
      }
      if (i !== 0) {
        const i1 = this.currentScene.method271(
          spawnObjectNode.anInt1391,
          spawnObjectNode.anInt1393,
          spawnObjectNode.anInt1394,
          i
        );
        j = i >> 14 & 32767;
        k = i1 & 31;
        l = i1 >> 6;
      }
      spawnObjectNode.anInt1387 = j;
      spawnObjectNode.anInt1389 = k;
      spawnObjectNode.anInt1388 = l;
    }
    processGroundItems(x2, y) {
      const linkedList = this.groundItems[this.plane][x2][y];
      if (linkedList == null) {
        this.currentScene.clearGroundItem(this.plane, x2, y);
        return;
      }
      let maxValue = -99999999;
      let mostValuable = null;
      for (let item = linkedList.first(); item != null; item = linkedList.next()) {
        {
          const definition = ItemDefinition.lookup(item.itemId);
          let value = definition.value;
          if (definition.stackable) {
            value *= item.itemCount + 1;
          }
          if (value > maxValue) {
            maxValue = value;
            mostValuable = item;
          }
        }
      }
      linkedList.addFirst(mostValuable);
      let first = null;
      let second = null;
      for (let item = linkedList.first(); item != null; item = linkedList.next()) {
        {
          if (item.itemId !== mostValuable.itemId && first == null) {
            first = item;
          }
          if (item.itemId !== mostValuable.itemId && item.itemId !== first.itemId && second == null) {
            second = item;
          }
        }
      }
      const key = x2 + (y << 7) + 1610612736;
      this.currentScene.addItemPile(
        this.getTileHeight(y * 128 + 64, x2 * 128 + 64, 9 | 0, this.plane),
        this.plane,
        mostValuable,
        first,
        key,
        second,
        2,
        y,
        x2
      );
    }
    getTileHeight(i, j, byte0, k) {
      const l = j >> 7;
      const i1 = i >> 7;
      if (l < 0 || i1 < 0 || l > 103 || i1 > 103) {
        return 0;
      }
      let j1 = k;
      if (j1 < 3 && (this.currentSceneTileFlags[1][l][i1] & 2) === 2) {
        j1++;
      }
      const k1 = j & 127;
      const l1 = i & 127;
      if (byte0 !== 9) {
        this.aBoolean953 = !this.aBoolean953;
      }
      const i2 = this.anIntArrayArrayArray891[j1][l][i1] * (128 - k1) + this.anIntArrayArrayArray891[j1][l + 1][i1] * k1 >> 7;
      const j2 = this.anIntArrayArrayArray891[j1][l][i1 + 1] * (128 - k1) + this.anIntArrayArrayArray891[j1][l + 1][i1 + 1] * k1 >> 7;
      return i2 * (128 - l1) + j2 * l1 >> 7;
    }
    method125(s, s1) {
      if (this.aClass18_1158 != null) {
        this.aClass18_1158.createRasterizer();
        Rasterizer3D.lineOffsets = this.anIntArray1002;
        let j = 151;
        if (s != null) {
          j -= 7;
        }
        this.fontNormal.drawStringLeft(s1, 257, j, 0);
        this.fontNormal.drawStringLeft(s1, 256, j - 1, 16777215);
        j += 15;
        if (s != null) {
          this.fontNormal.drawStringLeft(s, 257, j, 0);
          this.fontNormal.drawStringLeft(s, 256, j - 1, 16777215);
        }
        this.aClass18_1158.drawGraphics(4, 4, this.gameGraphics);
        return;
      }
      if (this.imageProducer != null) {
        this.imageProducer.createRasterizer();
        Rasterizer3D.lineOffsets = this.anIntArray1003;
        let k = 251;
        const c2 = "\u012C";
        const byte0 = 50;
        Rasterizer.drawFilledRectangle(
          383 - (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0),
          k - 5 - (byte0 / 2 | 0),
          c2.charCodeAt(0),
          byte0,
          0
        );
        Rasterizer.drawUnfilledRectangle(
          383 - (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0),
          k - 5 - (byte0 / 2 | 0),
          c2.charCodeAt(0),
          byte0,
          16777215
        );
        if (s != null) {
          k -= 7;
        }
        this.fontNormal.drawStringLeft(s1, 383, k, 0);
        this.fontNormal.drawStringLeft(s1, 382, k - 1, 16777215);
        k += 15;
        if (s != null) {
          this.fontNormal.drawStringLeft(s, 383, k, 0);
          this.fontNormal.drawStringLeft(s, 382, k - 1, 16777215);
        }
        this.imageProducer.drawGraphics(0, 0, this.gameGraphics);
      }
    }
    method112(byte0, i) {
      if (byte0 !== 36) {
        this.outBuffer.putByte(6);
      }
      const class13 = Widget.forId(i);
      for (let j = 0; j < class13.children.length; j++) {
        {
          if (class13.children[j] === -1) {
            break;
          }
          const class13_1 = Widget.forId(class13.children[j]);
          if (class13_1.type === 1) {
            this.method112(36 | 0, class13_1.id);
          }
          class13_1.anInt235 = 0;
          class13_1.anInt227 = 0;
        }
      }
    }
    updateVarp(i, j) {
      this.packetSize += i;
      const action = Varp.cache[j].anInt712;
      if (action === 0) {
        return;
      }
      const config = this.widgetSettings[j];
      if (action === 1) {
        if (config === 1) {
          Rasterizer3D.method501(0.9);
        }
        if (config === 2) {
          Rasterizer3D.method501(0.8);
        }
        if (config === 3) {
          Rasterizer3D.method501(0.7);
        }
        if (config === 4) {
          Rasterizer3D.method501(0.6);
        }
        ItemDefinition.rgbImageCache.removeAll();
        this.aBoolean1046 = true;
      }
      if (action === 3) {
        console.log(action);
        const flag = this.musicEnabled;
        if (config === 0) {
          this.adjustMidiVolume$boolean$byte$int(this.musicEnabled, 8 | 0, 0);
          this.musicEnabled = true;
        }
        if (config === 1) {
          this.adjustMidiVolume$boolean$byte$int(this.musicEnabled, 8 | 0, -400);
          this.musicEnabled = true;
        }
        if (config === 2) {
          this.adjustMidiVolume$boolean$byte$int(this.musicEnabled, 8 | 0, -800);
          this.musicEnabled = true;
        }
        if (config === 3) {
          this.adjustMidiVolume$boolean$byte$int(this.musicEnabled, 8 | 0, -1200);
          this.musicEnabled = true;
        }
        if (config === 4) {
          this.musicEnabled = false;
        }
        if (this.musicEnabled !== flag && !_Game.lowMemory) {
          if (this.musicEnabled) {
            this.nextSong = this.currentSong;
            this.songChanging = true;
            this.onDemandRequester.request(2, this.nextSong);
          } else {
            this.stopMidi();
          }
          this.previousSong = 0;
        }
      }
      if (action === 4) {
        SoundPlayer.setVolume(config);
        if (config === 0) {
          this.aBoolean1301 = true;
          this.setWaveVolume(0);
        }
        if (config === 1) {
          this.aBoolean1301 = true;
          this.setWaveVolume(-400);
        }
        if (config === 2) {
          this.aBoolean1301 = true;
          this.setWaveVolume(-800);
        }
        if (config === 3) {
          this.aBoolean1301 = true;
          this.setWaveVolume(-1200);
        }
        if (config === 4) {
          this.aBoolean1301 = false;
        }
      }
      if (action === 5) {
        this.anInt1300 = config;
      }
      if (action === 6) {
        this.anInt998 = config;
      }
      if (action === 8) {
        this.anInt1223 = config;
        this.redrawChatbox = true;
      }
      if (action === 9) {
        this.anInt955 = config;
      }
    }
    adjustMidiVolume$boolean$byte$int(flag, byte0, volume) {
      SignLink.midiVolume = volume;
      if (flag) {
        const convertedVolume = (volume + 1300) / 10;
        console.log(flag, byte0, volume, convertedVolume);
        this.midiPlayer.setVolume(convertedVolume);
      }
    }
    stopMidi() {
      this.midiPlayer.stop();
      SignLink.fadeMidi = 0;
      SignLink.midi = "stop";
    }
    setWaveVolume(j) {
      SignLink.waveVolume = j;
    }
    method44(flag, i) {
      if (!flag) {
        return;
      } else {
        Widget.method200(i);
        return;
      }
    }
    method25() {
      this.aBoolean1277 = true;
      for (let j = 0; j < 7; j++) {
        {
          this.characterEditIdentityKits[j] = -1;
          for (let k = 0; k < IdentityKit.count; k++) {
            {
              if (IdentityKit.cache[k].widgetDisplayed || IdentityKit.cache[k].partId !== j + (this.characterEditChangeGenger ? 0 : 7)) {
                continue;
              }
              this.characterEditIdentityKits[j] = k;
              break;
            }
          }
        }
      }
    }
    async method122() {
      if (this.chatboxProducingGraphicsBuffer != null) {
        return;
      } else {
        await this.method141();
        this.imageProducer = null;
        this.aClass18_1198 = null;
        this.aClass18_1199 = null;
        this.aClass18_1200 = null;
        this.flameLeftBackground = null;
        this.flameRightBackground = null;
        this.aClass18_1203 = null;
        this.aClass18_1204 = null;
        this.aClass18_1205 = null;
        this.aClass18_1206 = null;
        this.chatboxProducingGraphicsBuffer = new ProducingGraphicsBuffer(479, 96);
        this.aClass18_1157 = new ProducingGraphicsBuffer(172, 156);
        Rasterizer.resetPixels();
        this.minimapBackgroundImage.drawImage(0, 0);
        this.aClass18_1156 = new ProducingGraphicsBuffer(190, 261);
        this.aClass18_1158 = new ProducingGraphicsBuffer(512, 334);
        Rasterizer.resetPixels();
        this.aClass18_1108 = new ProducingGraphicsBuffer(496, 50);
        this.aClass18_1109 = new ProducingGraphicsBuffer(269, 37);
        this.aClass18_1110 = new ProducingGraphicsBuffer(249, 45);
        this.aBoolean1046 = true;
        this.aClass18_1158.createRasterizer();
        Rasterizer3D.lineOffsets = this.anIntArray1002;
        return;
      }
    }
    async method141() {
      this.startedRenderingFlames = false;
      while (this.isRenderingFlames) {
        this.startedRenderingFlames = false;
        await sleep(50);
      }
      this.titleboxImage = null;
      this.titleboxButtonImage = null;
      this.titleFlameEmblem = null;
      this.anIntArray1310 = null;
      this.anIntArray1311 = null;
      this.anIntArray1312 = null;
      this.anIntArray1313 = null;
      this.anIntArray1176 = null;
      this.anIntArray1177 = null;
      this.anIntArray1084 = null;
      this.anIntArray1085 = null;
      this.anImageRGB1226 = null;
      this.anImageRGB1227 = null;
    }
    async startUp() {
      if (Configuration.JAGGRAB_ENABLED)
        await this.requestArchiveCrcs();
      await this.drawLoadingText(20, "Starting up");
      await this.initStores();
      this.initArchives();
      this.initTypeFaces();
      await this.prepareTitleBackground();
      await this.prepareTitle();
      const configArchive = this.requestArchive(2, "config", this.archiveHashes[2], 30, "config");
      const archiveInterface = this.requestArchive(3, "interface", this.archiveHashes[3], 35, "interface");
      const archiveMedia = this.requestArchive(4, "media", this.archiveHashes[4], 40, "2d gameGraphics");
      const textureArchive = this.requestArchive(6, "textures", this.archiveHashes[6], 45, "textures");
      const chatArchive = this.requestArchive(7, "wordenc", this.archiveHashes[7], 50, "chat system");
      const soundArchive = this.requestArchive(8, "sounds", this.archiveHashes[8], 55, "sound effects");
      this.currentSceneTileFlags = array3d(4, 104, 104, 0);
      this.anIntArrayArrayArray891 = array3d(4, 105, 105, 0);
      this.currentScene = new Scene(this.anIntArrayArrayArray891, 104, 4, 104, 5);
      for (let j = 0; j < 4; j++) {
        this.currentCollisionMap[j] = new CollisionMap(104, 104);
      }
      this.minimapImage = ImageRGB.from(512, 512);
      const versionListArchive = this.requestArchive(5, "versionlist", this.archiveHashes[5], 60, "update list");
      this.drawLoadingText(60, "Connecting to update server");
      this.onDemandRequester = new OnDemandRequester();
      this.onDemandRequester.init(versionListArchive, this);
      Animation.method235(this.onDemandRequester.animCount());
      Model.init(this.onDemandRequester.fileCount(0), this.onDemandRequester);
      const soundFontUrl = "./A320U.sf2";
      this.midiPlayer = new MIDIPlayer();
      this.midiPlayer.loadSoundFont(await (await fetch(soundFontUrl)).arrayBuffer());
      if (!_Game.lowMemory) {
        this.nextSong = 0;
        try {
          this.nextSong = 0;
        } catch (ignored) {
          console.error(ignored);
        }
        this.songChanging = true;
        this.onDemandRequester.request(2, this.nextSong);
        while (this.onDemandRequester.immediateRequestsCount() > 0) {
          {
            this.processOnDemandQueue(false);
            try {
              await sleep(100);
            } catch (ignored) {
            }
            if (this.onDemandRequester.requestFails > 3) {
              this.loadError("ondemand");
              return;
            }
          }
        }
      }
      await this.drawLoadingText(65, "Requesting animations");
      let fileRequestCount = this.onDemandRequester.fileCount(1);
      for (let i = 0; i < fileRequestCount; i++) {
        this.onDemandRequester.request(1, i);
      }
      while (this.onDemandRequester.immediateRequestsCount() > 0) {
        const total = fileRequestCount - this.onDemandRequester.immediateRequestsCount();
        if (total > 0) {
          this.drawLoadingText(65, "Loading animations - " + (total * 100 / fileRequestCount | 0) + "%");
        }
        this.processOnDemandQueue(false);
        await sleep(100);
        if (this.onDemandRequester.requestFails > 3) {
          this.loadError("ondemand");
          return;
        }
      }
      this.drawLoadingText(70, "Requesting models");
      fileRequestCount = this.onDemandRequester.fileCount(0);
      for (let i = 0; i < fileRequestCount; i++) {
        {
          const id = this.onDemandRequester.modelId(i);
          if ((id & 1) !== 0) {
            this.onDemandRequester.request(0, i);
          }
        }
      }
      fileRequestCount = this.onDemandRequester.immediateRequestsCount();
      while (this.onDemandRequester.immediateRequestsCount() > 0) {
        {
          const total = fileRequestCount - this.onDemandRequester.immediateRequestsCount();
          if (total > 0) {
            this.drawLoadingText(70, "Loading models - " + (total * 100 / fileRequestCount | 0) + "%");
          }
          this.processOnDemandQueue(false);
          await sleep(100);
        }
      }
      if (this.stores[0] != null) {
        await this.drawLoadingText(75, "Requesting maps");
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 47, 48, 0));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 47, 48, 1));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 48, 48, 0));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 48, 48, 1));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 49, 48, 0));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 49, 48, 1));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 47, 47, 0));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 47, 47, 1));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 48, 47, 0));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 48, 47, 1));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 48, 148, 0));
        this.onDemandRequester.request(3, this.onDemandRequester.regId(0, 48, 148, 1));
        fileRequestCount = this.onDemandRequester.immediateRequestsCount();
        while (this.onDemandRequester.immediateRequestsCount() > 0) {
          {
            const total = fileRequestCount - this.onDemandRequester.immediateRequestsCount();
            if (total > 0) {
              await this.drawLoadingText(75, "Loading maps - " + (total * 100 / fileRequestCount | 0) + "%");
            }
            this.processOnDemandQueue(false);
            try {
              await sleep(100);
            } catch (ignored) {
            }
          }
        }
      }
      fileRequestCount = this.onDemandRequester.fileCount(0);
      for (let i = 0; i < fileRequestCount; i++) {
        {
          const id = this.onDemandRequester.modelId(i);
          let priority = 0;
          if ((id & 8) !== 0) {
            priority = 10;
          } else if ((id & 32) !== 0) {
            priority = 9;
          } else if ((id & 16) !== 0) {
            priority = 8;
          } else if ((id & 64) !== 0) {
            priority = 7;
          } else if ((id & 128) !== 0) {
            priority = 6;
          } else if ((id & 2) !== 0) {
            priority = 5;
          } else if ((id & 4) !== 0) {
            priority = 4;
          }
          if ((id & 1) !== 0) {
            priority = 3;
          }
          if (priority !== 0) {
            this.onDemandRequester.setPriority(priority, 0, i);
          }
        }
      }
      this.onDemandRequester.preloadRegions(_Game.memberServer);
      if (!_Game.lowMemory) {
        fileRequestCount = this.onDemandRequester.fileCount(2);
        for (let i = 1; i < fileRequestCount; i++) {
          {
            if (this.onDemandRequester.midiIdEqualsOne(i)) {
              this.onDemandRequester.setPriority(1 | 0, 2, i);
            }
          }
        }
      }
      fileRequestCount = this.onDemandRequester.fileCount(0);
      for (let i = 0; i < fileRequestCount; i++) {
        {
          const id = this.onDemandRequester.modelId(i);
          if (id === 0 && this.onDemandRequester.anInt1350 < 200) {
            this.onDemandRequester.setPriority(1 | 0, 0, i);
          }
        }
      }
      await this.drawLoadingText(80, "Unpacking media");
      this.inventoryBackgroundImage = new IndexedImage(archiveMedia, "invback", 0);
      this.chatboxBackgroundImage = new IndexedImage(archiveMedia, "chatback", 0);
      this.minimapBackgroundImage = new IndexedImage(archiveMedia, "mapback", 0);
      this.anIndexedImage1052 = new IndexedImage(archiveMedia, "backbase1", 0);
      this.anIndexedImage1053 = new IndexedImage(archiveMedia, "backbase2", 0);
      this.anIndexedImage1054 = new IndexedImage(archiveMedia, "backhmid1", 0);
      for (let i = 0; i < 13; i++) {
        this.tabIcon[i] = new IndexedImage(archiveMedia, "sideicons", i);
      }
      this.minimapCompass = ImageRGB.fromArchive(archiveMedia, "compass", 0);
      this.minimapEdge = ImageRGB.fromArchive(archiveMedia, "mapedge", 0);
      this.minimapEdge.trim();
      for (let i = 0; i < 72; i++) {
        this.mapscenes[i] = new IndexedImage(archiveMedia, "mapscene", i);
      }
      for (let i = 0; i < 70; i++) {
        this.worldMapHintIcons[i] = ImageRGB.fromArchive(archiveMedia, "mapfunction", i);
      }
      for (let i = 0; i < 5; i++) {
        this.hitmarks[i] = ImageRGB.fromArchive(archiveMedia, "hitmarks", i);
      }
      for (let i = 0; i < 6; i++) {
        this.headiconsPks[i] = ImageRGB.fromArchive(archiveMedia, "headicons_pk", i);
      }
      for (let i = 0; i < 9; i++) {
        this.headiconsPrayers[i] = ImageRGB.fromArchive(archiveMedia, "headicons_prayer", i);
      }
      for (let i = 0; i < 6; i++) {
        this.headiconsHints[i] = ImageRGB.fromArchive(archiveMedia, "headicons_hint", i);
      }
      this.aClass50_Sub1_Sub1_Sub1_1086 = ImageRGB.fromArchive(archiveMedia, "overlay_multiway", 0);
      this.mapFlagMarker = ImageRGB.fromArchive(archiveMedia, "mapmarker", 0);
      this.aClass50_Sub1_Sub1_Sub1_1037 = ImageRGB.fromArchive(archiveMedia, "mapmarker", 1);
      for (let i = 0; i < 8; i++) {
        this.cursorCross[i] = ImageRGB.fromArchive(archiveMedia, "cross", i);
      }
      this.mapdotItem = ImageRGB.fromArchive(archiveMedia, "mapdots", 0);
      this.mapdotActor = ImageRGB.fromArchive(archiveMedia, "mapdots", 1);
      this.mapdotPlayer = ImageRGB.fromArchive(archiveMedia, "mapdots", 2);
      this.mapdotFriend = ImageRGB.fromArchive(archiveMedia, "mapdots", 3);
      this.mapdotTeammate = ImageRGB.fromArchive(archiveMedia, "mapdots", 4);
      this.scrollbarUp = new IndexedImage(archiveMedia, "scrollbar", 0);
      this.scrollbarDown = new IndexedImage(archiveMedia, "scrollbar", 1);
      this.aClass50_Sub1_Sub1_Sub3_880 = new IndexedImage(archiveMedia, "redstone1", 0);
      this.aClass50_Sub1_Sub1_Sub3_881 = new IndexedImage(archiveMedia, "redstone2", 0);
      this.aClass50_Sub1_Sub1_Sub3_882 = new IndexedImage(archiveMedia, "redstone3", 0);
      this.aClass50_Sub1_Sub1_Sub3_883 = new IndexedImage(archiveMedia, "redstone1", 0);
      this.aClass50_Sub1_Sub1_Sub3_883.flipHorizontal();
      this.aClass50_Sub1_Sub1_Sub3_884 = new IndexedImage(archiveMedia, "redstone2", 0);
      this.aClass50_Sub1_Sub1_Sub3_884.flipHorizontal();
      this.aClass50_Sub1_Sub1_Sub3_983 = new IndexedImage(archiveMedia, "redstone1", 0);
      this.aClass50_Sub1_Sub1_Sub3_983.flipVertical();
      this.aClass50_Sub1_Sub1_Sub3_984 = new IndexedImage(archiveMedia, "redstone2", 0);
      this.aClass50_Sub1_Sub1_Sub3_984.flipVertical();
      this.aClass50_Sub1_Sub1_Sub3_985 = new IndexedImage(archiveMedia, "redstone3", 0);
      this.aClass50_Sub1_Sub1_Sub3_985.flipVertical();
      this.aClass50_Sub1_Sub1_Sub3_986 = new IndexedImage(archiveMedia, "redstone1", 0);
      this.aClass50_Sub1_Sub1_Sub3_986.flipHorizontal();
      this.aClass50_Sub1_Sub1_Sub3_986.flipVertical();
      this.aClass50_Sub1_Sub1_Sub3_987 = new IndexedImage(archiveMedia, "redstone2", 0);
      this.aClass50_Sub1_Sub1_Sub3_987.flipHorizontal();
      this.aClass50_Sub1_Sub1_Sub3_987.flipVertical();
      for (let i = 0; i < 2; i++) {
        this.moderatorIcon[i] = new IndexedImage(archiveMedia, "mod_icons", i);
      }
      let image = ImageRGB.fromArchive(archiveMedia, "backleft1", 0);
      this.aClass18_906 = new ProducingGraphicsBuffer(image.width, image.height);
      image.drawInverse(0, 0);
      image = ImageRGB.fromArchive(archiveMedia, "backleft2", 0);
      this.aClass18_907 = new ProducingGraphicsBuffer(image.width, image.height);
      image.drawInverse(0, 0);
      image = ImageRGB.fromArchive(archiveMedia, "backright1", 0);
      this.aClass18_908 = new ProducingGraphicsBuffer(image.width, image.height);
      image.drawInverse(0, 0);
      image = ImageRGB.fromArchive(archiveMedia, "backright2", 0);
      this.aClass18_909 = new ProducingGraphicsBuffer(image.width, image.height);
      image.drawInverse(0, 0);
      image = ImageRGB.fromArchive(archiveMedia, "backtop1", 0);
      this.aClass18_910 = new ProducingGraphicsBuffer(image.width, image.height);
      image.drawInverse(0, 0);
      image = ImageRGB.fromArchive(archiveMedia, "backvmid1", 0);
      this.aClass18_911 = new ProducingGraphicsBuffer(image.width, image.height);
      image.drawInverse(0, 0);
      image = ImageRGB.fromArchive(archiveMedia, "backvmid2", 0);
      this.aClass18_912 = new ProducingGraphicsBuffer(image.width, image.height);
      image.drawInverse(0, 0);
      image = ImageRGB.fromArchive(archiveMedia, "backvmid3", 0);
      this.aClass18_913 = new ProducingGraphicsBuffer(image.width, image.height);
      image.drawInverse(0, 0);
      image = ImageRGB.fromArchive(archiveMedia, "backhmid2", 0);
      this.aClass18_914 = new ProducingGraphicsBuffer(image.width, image.height);
      image.drawInverse(0, 0);
      const offset = (Math.random() * 41 | 0) - 20;
      const red = (Math.random() * 21 - 10 | 0) + offset;
      const green = (Math.random() * 21 - 10 | 0) + offset;
      const blue = (Math.random() * 21 - 10 | 0) + offset;
      for (let i = 0; i < 100; i++) {
        {
          if (this.worldMapHintIcons[i] != null) {
            this.worldMapHintIcons[i].adjustRGB(red, green, blue);
          }
          if (this.mapscenes[i] != null) {
            this.mapscenes[i].mixPalette(red, green, blue);
          }
        }
      }
      await this.drawLoadingText(83, "Unpacking textures");
      Rasterizer3D.loadIndexedImages(textureArchive);
      Rasterizer3D.method501(0.8);
      Rasterizer3D.method496(20);
      this.drawLoadingText(86, "Unpacking config");
      AnimationSequence.load(configArchive);
      GameObjectDefinition.load(configArchive);
      FloorDefinition.load(configArchive);
      ItemDefinition.load(configArchive);
      ActorDefinition.load(configArchive);
      IdentityKit.load(configArchive);
      SpotAnimation.load(configArchive);
      Varp.load(configArchive);
      Varbit.load(configArchive);
      ItemDefinition.memberServer = _Game.memberServer;
      if (!_Game.lowMemory) {
        this.drawLoadingText(90, "Unpacking sounds");
        const bytes = soundArchive.getFile("sounds.dat");
        const buffer = new Buffer3(bytes);
        SoundTrack.load(buffer);
      }
      await this.drawLoadingText(95, "Unpacking interfaces");
      const typefaces = [this.fontSmall, this.fontNormal, this.fontBold, this.fontFancy];
      Widget.load(archiveInterface, typefaces, archiveMedia);
      await this.drawLoadingText(100, "Preparing game engine");
      for (let y = 0; y < 33; y++) {
        {
          let minWidth = 999;
          let maxWidth = 0;
          for (let x2 = 0; x2 < 34; x2++) {
            {
              if (this.minimapBackgroundImage.pixels[x2 + y * this.minimapBackgroundImage.width] === 0) {
                if (minWidth === 999) {
                  minWidth = x2;
                }
                continue;
              }
              if (minWidth === 999) {
                continue;
              }
              maxWidth = x2;
              break;
            }
          }
          this.anIntArray1180[y] = minWidth;
          this.anIntArray1286[y] = maxWidth - minWidth;
        }
      }
      for (let y = 5; y < 156; y++) {
        {
          let minWidth = 999;
          let maxWidth = 0;
          for (let x2 = 25; x2 < 172; x2++) {
            {
              if (this.minimapBackgroundImage.pixels[x2 + y * this.minimapBackgroundImage.width] === 0 && (x2 > 34 || y > 34)) {
                if (minWidth === 999) {
                  minWidth = x2;
                }
                continue;
              }
              if (minWidth === 999) {
                continue;
              }
              maxWidth = x2;
              break;
            }
          }
          this.anIntArray1019[y - 5] = minWidth - 25;
          this.anIntArray920[y - 5] = maxWidth - minWidth;
        }
      }
      Rasterizer3D.method494(765, 503);
      this.anIntArray1003 = Rasterizer3D.lineOffsets;
      Rasterizer3D.method494(479, 96);
      this.chatboxLineOffsets = Rasterizer3D.lineOffsets;
      Rasterizer3D.method494(190, 261);
      this.anIntArray1001 = Rasterizer3D.lineOffsets;
      Rasterizer3D.method494(512, 334);
      this.anIntArray1002 = Rasterizer3D.lineOffsets;
      const ai = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (let i = 0; i < 9; i++) {
        {
          const j9 = 128 + i * 32 + 15;
          const k9 = 600 + j9 * 3;
          const l9 = Rasterizer3D.SINE[j9];
          ai[i] = k9 * l9 >> 16;
        }
      }
      Scene.method277(500, 800, 512, 334, ai);
      ChatCensor.load(chatArchive);
      this.mouseCapturer = new MouseCapturer(this);
      _Game.parallelExecutor.start(this.mouseCapturer);
      GameObject.client = this;
      GameObjectDefinition.client = this;
      ActorDefinition.client = this;
    }
    loadError(s) {
      try {
        console.error("Error: " + s);
      } catch (exception) {
        console.error(exception.message, exception);
      }
      this.exit();
    }
    processOnDemandQueue(flag) {
      if (flag) {
        this.opcode = -1;
      }
      do {
        {
          let onDemandDone;
          do {
            {
              onDemandDone = this.onDemandRequester.next();
              if (onDemandDone == null) {
                return;
              }
              if (onDemandDone.type === 0) {
                Model.loadModelHeader(onDemandDone.buffer, onDemandDone.id);
                if ((this.onDemandRequester.modelId(onDemandDone.id) & 98) !== 0) {
                  this.redrawTabArea = true;
                  if (this.backDialogueId !== -1 || this.dialogueId !== -1) {
                    this.redrawChatbox = true;
                  }
                }
              }
              if (onDemandDone.type === 1 && onDemandDone.buffer != null) {
                Animation.method236(onDemandDone.buffer);
              }
              if (onDemandDone.type === 2 && onDemandDone.id === this.nextSong && onDemandDone.buffer != null) {
                this.method24(this.songChanging, onDemandDone.buffer, 659);
              }
              if (onDemandDone.type === 3 && this.loadingStage === 1) {
                for (let i = 0; i < this.aByteArrayArray838.length; i++) {
                  {
                    if (this.anIntArray857[i] === onDemandDone.id) {
                      this.aByteArrayArray838[i] = onDemandDone.buffer;
                      if (onDemandDone.buffer == null) {
                        this.anIntArray857[i] = -1;
                      }
                      break;
                    }
                    if (this.anIntArray858[i] !== onDemandDone.id) {
                      continue;
                    }
                    this.aByteArrayArray1232[i] = onDemandDone.buffer;
                    if (onDemandDone.buffer == null) {
                      this.anIntArray858[i] = -1;
                    }
                    break;
                  }
                }
              }
            }
          } while (onDemandDone.type !== 93 || !this.onDemandRequester.method334(onDemandDone.id, false));
          Region.passiveRequestGameObjectModels(this.onDemandRequester, new Buffer3(onDemandDone.buffer));
        }
      } while (true);
    }
    method24(flag, abyte0, i) {
      if (!this.musicEnabled) {
        return;
      } else {
        this.midiPlayer.loadMidi(Uint8Array.from(abyte0));
        this.midiPlayer.resume();
        return;
      }
    }
    async requestArchiveCrcs() {
      let reconnectionDelay = 5;
      let attempts = 0;
      this.archiveHashes[8] = 0;
      while (this.archiveHashes[8] === 0) {
        {
          let error = "Unknown problem";
          this.drawLoadingText(20, "Connecting to web server");
          const stream = await this.openJaggrabStream("crc" + (Math.random() * 99999999 | 0) + "-" + 377);
          const jaggrab = new Buffer3(Array(40).fill(0));
          await stream.read$byte_A$int$int(jaggrab.buffer, 0, 40);
          stream.close();
          for (let i = 0; i < 9; i++) {
            this.archiveHashes[i] = jaggrab.getInt();
          }
          const expectedCrc = jaggrab.getInt();
          let calculatedCrc = 1234;
          for (let i = 0; i < 9; i++) {
            calculatedCrc = (calculatedCrc << 1) + this.archiveHashes[i];
          }
          if (expectedCrc !== calculatedCrc) {
            error = "Checksum problem";
            this.archiveHashes[8] = 0;
          }
          if (this.archiveHashes[8] === 0) {
            this.drawLoadingText(10, "Error updating archive crcs");
          }
        }
      }
    }
    async openJaggrabStream(request) {
      if (!this.useJaggrab) {
        return null;
      }
      if (this.jaggrabSocket != null) {
        try {
          this.jaggrabSocket.close();
        } catch (ignored) {
        }
        this.jaggrabSocket = null;
      }
      const buffer = `JAGGRAB /${request}

`.split("").map((s) => s.charCodeAt(0));
      this.jaggrabSocket = await this.openSocket(Configuration.JAGGRAB_PORT);
      this.jaggrabSocket.write$byte_A(buffer);
      return this.jaggrabSocket;
    }
    async openSocket(port) {
      const socket = new Socket(Configuration.SERVER_ADDRESS, port);
      await socket.connect();
      return socket;
    }
    async resetTitleScreen() {
      if (this.aClass18_1198 != null) {
        return;
      }
      this.imageProducer = null;
      this.chatboxProducingGraphicsBuffer = null;
      this.aClass18_1157 = null;
      this.aClass18_1156 = null;
      this.aClass18_1158 = null;
      this.aClass18_1108 = null;
      this.aClass18_1109 = null;
      this.flameLeftBackground = new ProducingGraphicsBuffer(128, 265);
      Rasterizer.resetPixels();
      this.flameRightBackground = new ProducingGraphicsBuffer(128, 265);
      Rasterizer.resetPixels();
      this.aClass18_1198 = new ProducingGraphicsBuffer(509, 171);
      Rasterizer.resetPixels();
      this.aClass18_1199 = new ProducingGraphicsBuffer(360, 132);
      Rasterizer.resetPixels();
      this.aClass18_1200 = new ProducingGraphicsBuffer(360, 200);
      Rasterizer.resetPixels();
      this.aClass18_1203 = new ProducingGraphicsBuffer(202, 238);
      Rasterizer.resetPixels();
      this.aClass18_1204 = new ProducingGraphicsBuffer(203, 238);
      Rasterizer.resetPixels();
      this.aClass18_1205 = new ProducingGraphicsBuffer(74, 94);
      Rasterizer.resetPixels();
      this.aClass18_1206 = new ProducingGraphicsBuffer(75, 94);
      Rasterizer.resetPixels();
      if (this.titleArchive != null) {
        await this.prepareTitleBackground();
        await this.prepareTitle();
      }
      this.aBoolean1046 = true;
    }
    async prepareTitle() {
      this.titleboxImage = new IndexedImage(this.titleArchive, "titlebox", 0);
      this.titleboxButtonImage = new IndexedImage(this.titleArchive, "titlebutton", 0);
      this.titleFlameEmblem = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(null);
        }
        return a;
      })(12);
      for (let i = 0; i < 12; i++) {
        this.titleFlameEmblem[i] = new IndexedImage(this.titleArchive, "runes", i);
      }
      this.anImageRGB1226 = ImageRGB.from(128, 265);
      this.anImageRGB1227 = ImageRGB.from(128, 265);
      this.anImageRGB1226.pixels = [...this.flameLeftBackground.pixels];
      this.anImageRGB1227.pixels = [...this.flameRightBackground.pixels];
      this.anIntArray1311 = Array(256).fill(0);
      for (let l = 0; l < 64; l++) {
        this.anIntArray1311[l] = l * 262144;
      }
      for (let i1 = 0; i1 < 64; i1++) {
        this.anIntArray1311[i1 + 64] = 16711680 + 1024 * i1;
      }
      for (let j1 = 0; j1 < 64; j1++) {
        this.anIntArray1311[j1 + 128] = 16776960 + 4 * j1;
      }
      for (let k1 = 0; k1 < 64; k1++) {
        this.anIntArray1311[k1 + 192] = 16777215;
      }
      this.anIntArray1312 = Array(256).fill(0);
      for (let l1 = 0; l1 < 64; l1++) {
        this.anIntArray1312[l1] = l1 * 1024;
      }
      for (let i2 = 0; i2 < 64; i2++) {
        this.anIntArray1312[i2 + 64] = 65280 + 4 * i2;
      }
      for (let j2 = 0; j2 < 64; j2++) {
        this.anIntArray1312[j2 + 128] = 65535 + 262144 * j2;
      }
      for (let k2 = 0; k2 < 64; k2++) {
        this.anIntArray1312[k2 + 192] = 16777215;
      }
      this.anIntArray1313 = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(256);
      for (let l2 = 0; l2 < 64; l2++) {
        this.anIntArray1313[l2] = l2 * 4;
      }
      for (let i3 = 0; i3 < 64; i3++) {
        this.anIntArray1313[i3 + 64] = 255 + 262144 * i3;
      }
      for (let j3 = 0; j3 < 64; j3++) {
        this.anIntArray1313[j3 + 128] = 16711935 + 1024 * j3;
      }
      for (let k3 = 0; k3 < 64; k3++) {
        this.anIntArray1313[k3 + 192] = 16777215;
      }
      this.anIntArray1310 = Array(256).fill(0);
      this.anIntArray1176 = Array(32768).fill(0);
      this.anIntArray1177 = Array(32768).fill(0);
      this.method83(null, 0);
      this.anIntArray1084 = Array(32768).fill(0);
      this.anIntArray1085 = Array(32768).fill(0);
      await this.drawLoadingText(10, "Connecting to fileserver");
      if (!this.startedRenderingFlames) {
        this.shouldRenderFlames = true;
        this.startedRenderingFlames = true;
        this.run();
      }
    }
    async drawLoadingText(i, s) {
      this.anInt1322 = i;
      this.aString1027 = s;
      await this.resetTitleScreen();
      if (this.titleArchive == null) {
        await super.drawLoadingText(i, s);
        return;
      }
      this.aClass18_1200.createRasterizer();
      const c2 = "\u0168";
      const c1 = "\xC8";
      const byte0 = 20;
      this.fontBold.drawStringLeft(
        "RuneScape is loading - please wait...",
        ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
        (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) - 26 - byte0,
        16777215
      );
      const j = (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) - 18 - byte0;
      Rasterizer.drawUnfilledRectangle(
        (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) - 152,
        j,
        304,
        34,
        9179409
      );
      Rasterizer.drawUnfilledRectangle(
        (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) - 151,
        j + 1,
        302,
        32,
        0
      );
      Rasterizer.drawFilledRectangle(
        (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) - 150,
        j + 2,
        i * 3,
        30,
        9179409
      );
      Rasterizer.drawFilledRectangle(
        (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0) - 150 + i * 3,
        j + 2,
        300 - i * 3,
        30,
        0
      );
      this.fontBold.drawStringLeft(
        s,
        ((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c2) / 2 | 0,
        (((c3) => c3.charCodeAt == null ? c3 : c3.charCodeAt(0))(c1) / 2 | 0) + 5 - byte0,
        16777215
      );
      this.aClass18_1200.drawGraphics(202, 171, this.gameGraphics);
      if (this.aBoolean1046) {
        this.aBoolean1046 = false;
        if (!this.startedRenderingFlames) {
          this.flameLeftBackground.drawGraphics(0, 0, this.gameGraphics);
          this.flameRightBackground.drawGraphics(637, 0, this.gameGraphics);
        }
        this.aClass18_1198.drawGraphics(128, 0, this.gameGraphics);
        this.aClass18_1199.drawGraphics(202, 371, this.gameGraphics);
        this.aClass18_1203.drawGraphics(0, 265, this.gameGraphics);
        this.aClass18_1204.drawGraphics(562, 265, this.gameGraphics);
        this.aClass18_1205.drawGraphics(128, 171, this.gameGraphics);
        this.aClass18_1206.drawGraphics(562, 171, this.gameGraphics);
      }
    }
    method83(class50_sub1_sub1_sub3, i) {
      this.packetSize += i;
      const j = 256;
      for (let k = 0; k < this.anIntArray1176.length; k++) {
        this.anIntArray1176[k] = 0;
      }
      for (let l = 0; l < 5e3; l++) {
        {
          const i1 = Math.random() * 128 * j | 0;
          this.anIntArray1176[i1] = Math.random() * 256 | 0;
        }
      }
      for (let j1 = 0; j1 < 20; j1++) {
        {
          for (let k1 = 1; k1 < j - 1; k1++) {
            {
              for (let i2 = 1; i2 < 127; i2++) {
                {
                  const k2 = i2 + (k1 << 7);
                  this.anIntArray1177[k2] = (this.anIntArray1176[k2 - 1] + this.anIntArray1176[k2 + 1] + this.anIntArray1176[k2 - 128] + this.anIntArray1176[k2 + 128]) / 4 | 0;
                }
              }
            }
          }
          const ai = this.anIntArray1176;
          this.anIntArray1176 = this.anIntArray1177;
          this.anIntArray1177 = ai;
        }
      }
      if (class50_sub1_sub1_sub3 != null) {
        let l1 = 0;
        for (let j2 = 0; j2 < class50_sub1_sub1_sub3.height; j2++) {
          {
            for (let l2 = 0; l2 < class50_sub1_sub1_sub3.width; l2++) {
              if (class50_sub1_sub1_sub3.pixels[l1++] !== 0) {
                const i3 = l2 + 16 + class50_sub1_sub1_sub3.xDrawOffset;
                const j3 = j2 + 16 + class50_sub1_sub1_sub3.yDrawOffset;
                const k3 = i3 + (j3 << 7);
                this.anIntArray1176[k3] = 0;
              }
            }
          }
        }
      }
    }
    async run() {
      if (this.shouldRenderFlames) {
        _Game.parallelExecutor.startRaw(this.processFlamesCycle, this);
      } else {
        super.run();
      }
    }
    async processFlamesCycle() {
      this.isRenderingFlames = true;
      try {
        this.flameCycle++;
        this.calculateFlamePositions();
        this.calculateFlamePositions();
        this.renderFlames();
      } catch (ignored) {
      }
      await sleep(50);
      if (this.startedRenderingFlames) {
        return true;
      } else {
        this.isRenderingFlames = false;
        return false;
      }
    }
    calculateFlamePositions() {
      const c2 = 256;
      for (let x2 = 10; x2 < 117; x2++) {
        {
          const rand = Math.random() * 100 | 0;
          if (rand < 50) {
            this.anIntArray1084[x2 + (c2 - 2 << 7)] = 255;
          }
        }
      }
      for (let i = 0; i < 100; i++) {
        {
          const x2 = (Math.random() * 124 | 0) + 2;
          const y = (Math.random() * 128 | 0) + 128;
          const pixel = x2 + (y << 7);
          this.anIntArray1084[pixel] = 192;
        }
      }
      for (let y = 1; y < c2 - 1; y++) {
        {
          for (let x2 = 1; x2 < 127; x2++) {
            {
              const pixel = x2 + (y << 7);
              this.anIntArray1085[pixel] = (this.anIntArray1084[pixel - 1] + this.anIntArray1084[pixel + 1] + this.anIntArray1084[pixel - 128] + this.anIntArray1084[pixel + 128]) / 4 | 0;
            }
          }
        }
      }
      this.anInt1238 += 128;
      if (this.anInt1238 > this.anIntArray1176.length) {
        this.anInt1238 -= this.anIntArray1176.length;
        const rand = Math.random() * 12 | 0;
        this.method83(this.titleFlameEmblem[rand], 0);
      }
      for (let y = 1; y < c2 - 1; y++) {
        {
          for (let x2 = 1; x2 < 127; x2++) {
            {
              const pixel = x2 + (y << 7);
              let i4 = this.anIntArray1085[pixel + 128] - (this.anIntArray1176[pixel + this.anInt1238 & this.anIntArray1176.length - 1] / 5 | 0);
              if (i4 < 0) {
                i4 = 0;
              }
              this.anIntArray1084[pixel] = i4;
            }
          }
        }
      }
      for (let i = 0; i < c2 - 1; i++) {
        this.anIntArray1166[i] = this.anIntArray1166[i + 1];
      }
      this.anIntArray1166[c2 - 1] = Math.sin(_Game.pulseCycle / 14) * 16 + Math.sin(_Game.pulseCycle / 15) * 14 + Math.sin(_Game.pulseCycle / 16) * 12 | 0;
      if (this.anInt1047 > 0) {
        this.anInt1047 -= 4;
      }
      if (this.anInt1048 > 0) {
        this.anInt1048 -= 4;
      }
      if (this.anInt1047 === 0 && this.anInt1048 === 0) {
        const rand = Math.random() * 2e3 | 0;
        if (rand === 0) {
          this.anInt1047 = 1024;
        }
        if (rand === 1) {
          this.anInt1048 = 1024;
        }
      }
    }
    renderFlames() {
      const c2 = 256;
      if (this.anInt1047 > 0) {
        for (let j = 0; j < 256; j++) {
          {
            if (this.anInt1047 > 768) {
              this.anIntArray1310[j] = this.someFlameLogic(
                this.anIntArray1311[j],
                this.anIntArray1312[j],
                1024 - this.anInt1047,
                8
              );
            } else if (this.anInt1047 > 256) {
              this.anIntArray1310[j] = this.anIntArray1312[j];
            } else {
              this.anIntArray1310[j] = this.someFlameLogic(
                this.anIntArray1312[j],
                this.anIntArray1311[j],
                256 - this.anInt1047,
                8
              );
            }
          }
        }
      } else if (this.anInt1048 > 0) {
        for (let k = 0; k < 256; k++) {
          {
            if (this.anInt1048 > 768) {
              this.anIntArray1310[k] = this.someFlameLogic(
                this.anIntArray1311[k],
                this.anIntArray1313[k],
                1024 - this.anInt1048,
                8
              );
            } else if (this.anInt1048 > 256) {
              this.anIntArray1310[k] = this.anIntArray1313[k];
            } else {
              this.anIntArray1310[k] = this.someFlameLogic(
                this.anIntArray1313[k],
                this.anIntArray1311[k],
                256 - this.anInt1048,
                8
              );
            }
          }
        }
      } else {
        this.anIntArray1310 = [...this.anIntArray1311];
      }
      this.flameLeftBackground.pixels = [...this.anImageRGB1226.pixels];
      let j1 = 0;
      let k1 = 1152;
      for (let l1 = 1; l1 < c2 - 1; l1++) {
        {
          const i2 = this.anIntArray1166[l1] * (c2 - l1) / c2 | 0;
          let k2 = 22 + i2;
          if (k2 < 0) {
            k2 = 0;
          }
          j1 += k2;
          for (let i3 = k2; i3 < 128; i3++) {
            {
              let k3 = this.anIntArray1084[j1++];
              if (k3 !== 0) {
                const i4 = k3;
                const k4 = 256 - k3;
                k3 = this.anIntArray1310[k3];
                const i5 = this.flameLeftBackground.pixels[k1];
                this.flameLeftBackground.pixels[k1++] = ((k3 & 16711935) * i4 + (i5 & 16711935) * k4 & -16711936) + ((k3 & 65280) * i4 + (i5 & 65280) * k4 & 16711680) >> 8;
              } else {
                k1++;
              }
            }
          }
          k1 += k2;
        }
      }
      this.flameLeftBackground.drawGraphics(0, 0, this.gameGraphics);
      this.flameRightBackground.pixels = [...this.anImageRGB1227.pixels];
      j1 = 0;
      k1 = 1176;
      for (let l2 = 1; l2 < c2 - 1; l2++) {
        {
          const j3 = this.anIntArray1166[l2] * (c2 - l2) / c2 | 0;
          const l3 = 103 - j3;
          k1 += j3;
          for (let j4 = 0; j4 < l3; j4++) {
            {
              let l4 = this.anIntArray1084[j1++];
              if (l4 !== 0) {
                const j5 = l4;
                const k5 = 256 - l4;
                l4 = this.anIntArray1310[l4];
                const l5 = this.flameRightBackground.pixels[k1];
                this.flameRightBackground.pixels[k1++] = ((l4 & 16711935) * j5 + (l5 & 16711935) * k5 & -16711936) + ((l4 & 65280) * j5 + (l5 & 65280) * k5 & 16711680) >> 8;
              } else {
                k1++;
              }
            }
          }
          j1 += 128 - l3;
          k1 += 128 - l3 - j3;
        }
      }
      this.flameRightBackground.drawGraphics(637, 0, this.gameGraphics);
    }
    someFlameLogic(i, j, k, l) {
      if (l < 8 || l > 8) {
        this.outBuffer.putByte(235);
      }
      const i1 = 256 - k;
      return ((i & 16711935) * i1 + (j & 16711935) * k & -16711936) + ((i & 65280) * i1 + (j & 65280) * k & 16711680) >> 8;
    }
    async initStores() {
      const promises = await Promise.all([
        this.getFile(__default.client_cache["main_file_cache.dat"]),
        this.getFile(__default2.client_cache["main_file_cache.idx0"]),
        this.getFile(__default2.client_cache["main_file_cache.idx1"]),
        this.getFile(__default2.client_cache["main_file_cache.idx2"]),
        this.getFile(__default2.client_cache["main_file_cache.idx3"]),
        this.getFile(__default2.client_cache["main_file_cache.idx4"])
      ]);
      const main = promises[0];
      for (let type = 0; type < 5; type++) {
        this.stores.push(new Index(type + 1, 6e5, main, promises[1 + type]));
      }
      console.log("stores initialized");
    }
    async prepareTitleBackground() {
      const jpgBytes = this.titleArchive.getFile("title.dat");
      let abyte0 = new Int8Array(jpgBytes);
      let class50_sub1_sub1_sub1 = await ImageRGB.fromJpg(abyte0);
      this.flameLeftBackground.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(0, 0);
      this.flameRightBackground.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-637, 0);
      this.aClass18_1198.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-128, 0);
      this.aClass18_1199.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-202, -371);
      this.aClass18_1200.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-202, -171);
      this.aClass18_1203.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(0, -265);
      this.aClass18_1204.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-562, -265);
      this.aClass18_1205.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-128, -171);
      this.aClass18_1206.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-562, -171);
      let ai = ((s) => {
        const a = [];
        while (s-- > 0) {
          a.push(0);
        }
        return a;
      })(class50_sub1_sub1_sub1.width);
      for (let i = 0; i < class50_sub1_sub1_sub1.height; i++) {
        {
          for (let j = 0; j < class50_sub1_sub1_sub1.width; j++) {
            ai[j] = class50_sub1_sub1_sub1.pixels[class50_sub1_sub1_sub1.width - j - 1 + class50_sub1_sub1_sub1.width * i];
          }
          for (let l = 0; l < class50_sub1_sub1_sub1.width; l++) {
            class50_sub1_sub1_sub1.pixels[l + class50_sub1_sub1_sub1.width * i] = ai[l];
          }
        }
      }
      this.flameLeftBackground.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(382, 0);
      this.flameRightBackground.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-255, 0);
      this.aClass18_1198.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(254, 0);
      this.aClass18_1199.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(180, -371);
      this.aClass18_1200.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(180, -171);
      this.aClass18_1203.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(382, -265);
      this.aClass18_1204.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-180, -265);
      this.aClass18_1205.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(254, -171);
      this.aClass18_1206.createRasterizer();
      class50_sub1_sub1_sub1.drawInverse(-180, -171);
      class50_sub1_sub1_sub1 = ImageRGB.fromArchive(this.titleArchive, "logo", 0);
      this.aClass18_1198.createRasterizer();
      class50_sub1_sub1_sub1.drawImage(18, 382 - (class50_sub1_sub1_sub1.width / 2 | 0) - 128);
      class50_sub1_sub1_sub1 = null;
      abyte0 = null;
      ai = null;
    }
    processMenuActions(id) {
      if (id < 0) {
        return;
      }
      const first = this.firstMenuOperand[id];
      const second = this.secondMenuOperand[id];
      let action = this.menuActionTypes[id];
      const clicked = this.selectedMenuActions[id];
      if (action >= 2e3) {
        action -= 2e3;
      }
      if (this.inputType !== 0 && action !== 1016) {
        this.inputType = 0;
        this.redrawChatbox = true;
      }
      if (action === 200) {
        const player2 = this.players[clicked];
        if (player2 != null) {
          this.walk(
            false,
            false,
            player2.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            player2.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(245);
          this.outBuffer.putLEShortAdded(clicked);
        }
      }
      if (action === 227) {
        _Game.anInt1165;
        _Game.anInt1165++;
        if (_Game.anInt1165 >= 62) {
          this.outBuffer.putOpcode(165);
          this.outBuffer.putByte(206);
          _Game.anInt1165 = 0;
        }
        this.outBuffer.putOpcode(228);
        this.outBuffer.putLEShortDup(first);
        this.outBuffer.putShortAdded(clicked);
        this.outBuffer.putShort(second);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 876) {
        const player2 = this.players[clicked];
        if (player2 != null) {
          this.walk(
            false,
            false,
            player2.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            player2.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(45);
          this.outBuffer.putShortAdded(clicked);
        }
      }
      if (action === 921) {
        const npc = this.npcs[clicked];
        if (npc != null) {
          this.walk(false, false, npc.pathY[0], _Game.localPlayer.pathY[0], 1, 1, 2, 0, npc.pathX[0], 0, 0, _Game.localPlayer.pathX[0]);
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(67);
          this.outBuffer.putShortAdded(clicked);
        }
      }
      if (action === 961) {
        _Game.anInt1139 = _Game.anInt1139 + clicked;
        if (_Game.anInt1139 >= 115) {
          this.outBuffer.putOpcode(126);
          this.outBuffer.putByte(125);
          _Game.anInt1139 = 0;
        }
        this.outBuffer.putOpcode(203);
        this.outBuffer.putShortAdded(second);
        this.outBuffer.putLEShortDup(first);
        this.outBuffer.putLEShortDup(clicked);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 467 && this.method80(second, 0, first, clicked)) {
        this.outBuffer.putOpcode(152);
        this.outBuffer.putLEShortDup(clicked >> 14 & 32767);
        this.outBuffer.putLEShortDup(this.anInt1148);
        this.outBuffer.putLEShortDup(this.anInt1149);
        this.outBuffer.putLEShortDup(second + this.nextTopRightTileY);
        this.outBuffer.putShort(this.anInt1147);
        this.outBuffer.putLEShortAdded(first + this.nextTopLeftTileX);
      }
      if (action === 9) {
        this.outBuffer.putOpcode(3);
        this.outBuffer.putShortAdded(clicked);
        this.outBuffer.putShort(second);
        this.outBuffer.putShort(first);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 553) {
        const npc = this.npcs[clicked];
        if (npc != null) {
          this.walk(false, false, npc.pathY[0], _Game.localPlayer.pathY[0], 1, 1, 2, 0, npc.pathX[0], 0, 0, _Game.localPlayer.pathX[0]);
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(42);
          this.outBuffer.putLEShortDup(clicked);
        }
      }
      if (action === 677) {
        const player2 = this.players[clicked];
        if (player2 != null) {
          this.walk(
            false,
            false,
            player2.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            player2.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(116);
          this.outBuffer.putLEShortDup(clicked);
        }
      }
      if (action === Actions.ADD_FRIEND || action === Actions.ADD_IGNORE || action === Actions.REMOVE_FRIEND || action === Actions.REMOVE_IGNORE) {
        const s = this.menuActionTexts[id];
        const l1 = s.indexOf("@whi@");
        if (l1 !== -1) {
          const l3 = TextUtils.nameToLong(s.substring(l1 + 5).trim());
          if (action === Actions.ADD_FRIEND) {
            this.addFriend(l3);
          }
          if (action === Actions.ADD_IGNORE) {
            this.addIgnore(this.anInt1154, l3);
          }
          if (action === Actions.REMOVE_FRIEND) {
            this.removeFriend(l3);
          }
          if (action === Actions.REMOVE_IGNORE) {
            this.removeIgnore(l3);
          }
        }
      }
      if (action === 930) {
        let flag = this.walk(
          false,
          false,
          second,
          _Game.localPlayer.pathY[0],
          0,
          0,
          2,
          0,
          first,
          0,
          0,
          _Game.localPlayer.pathX[0]
        );
        if (!flag) {
          flag = this.walk(false, false, second, _Game.localPlayer.pathY[0], 1, 1, 2, 0, first, 0, 0, _Game.localPlayer.pathX[0]);
        }
        this.anInt1020 = this.clickX;
        this.anInt1021 = this.clickY;
        this.crossType = 2;
        this.crossIndex = 0;
        this.outBuffer.putOpcode(54);
        this.outBuffer.putShortAdded(clicked);
        this.outBuffer.putLEShortDup(second + this.nextTopRightTileY);
        this.outBuffer.putShort(first + this.nextTopLeftTileX);
      }
      if (action === 399) {
        this.outBuffer.putOpcode(24);
        this.outBuffer.putLEShortDup(second);
        this.outBuffer.putLEShortDup(clicked);
        this.outBuffer.putShortAdded(first);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 347) {
        const class50_sub1_sub4_sub3_sub1_2 = this.npcs[clicked];
        if (class50_sub1_sub4_sub3_sub1_2 != null) {
          this.walk(
            false,
            false,
            class50_sub1_sub4_sub3_sub1_2.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            class50_sub1_sub4_sub3_sub1_2.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(57);
          this.outBuffer.putShort(clicked);
          this.outBuffer.putLEShortDup(this.anInt1149);
          this.outBuffer.putLEShortAdded(this.anInt1148);
          this.outBuffer.putShort(this.anInt1147);
        }
      }
      if (action === Actions.TOGGLE_SETTING_WIDGET) {
        this.outBuffer.putOpcode(79);
        this.outBuffer.putShort(second);
        const widget = Widget.forId(second);
        if (widget.opcodes != null && widget.opcodes[0][0] === 5) {
          const setting = widget.opcodes[0][1];
          this.widgetSettings[setting] = 1 - this.widgetSettings[setting];
          this.updateVarp(0, setting);
          this.redrawTabArea = true;
        }
      }
      if (action === 493) {
        const class50_sub1_sub4_sub3_sub2_3 = this.players[clicked];
        if (class50_sub1_sub4_sub3_sub2_3 != null) {
          this.walk(
            false,
            false,
            class50_sub1_sub4_sub3_sub2_3.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            class50_sub1_sub4_sub3_sub2_3.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(233);
          this.outBuffer.putShortAdded(clicked);
        }
      }
      if (action === 14) {
        if (!this.menuOpen) {
          this.currentScene.method279(0, this.clickX - 4, this.clickY - 4);
        } else {
          this.currentScene.method279(0, first - 4, second - 4);
        }
      }
      if (action === 903) {
        this.outBuffer.putOpcode(1);
        this.outBuffer.putShort(clicked);
        this.outBuffer.putLEShortDup(this.anInt1147);
        this.outBuffer.putLEShortDup(this.anInt1149);
        this.outBuffer.putLEShortAdded(this.anInt1148);
        this.outBuffer.putShortAdded(first);
        this.outBuffer.putShortAdded(second);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 361) {
        this.outBuffer.putOpcode(36);
        this.outBuffer.putShort(this.anInt1172);
        this.outBuffer.putShortAdded(second);
        this.outBuffer.putShortAdded(first);
        this.outBuffer.putShortAdded(clicked);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 118) {
        const class50_sub1_sub4_sub3_sub1_3 = this.npcs[clicked];
        if (class50_sub1_sub4_sub3_sub1_3 != null) {
          this.walk(
            false,
            false,
            class50_sub1_sub4_sub3_sub1_3.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            class50_sub1_sub4_sub3_sub1_3.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          _Game.anInt1235 = _Game.anInt1235 + clicked;
          if (_Game.anInt1235 >= 143) {
            this.outBuffer.putOpcode(157);
            this.outBuffer.putInt(0);
            _Game.anInt1235 = 0;
          }
          this.outBuffer.putOpcode(13);
          this.outBuffer.putLEShortAdded(clicked);
        }
      }
      if (action === 376 && this.method80(second, 0, first, clicked)) {
        this.outBuffer.putOpcode(210);
        this.outBuffer.putShort(this.anInt1172);
        this.outBuffer.putLEShortDup(clicked >> 14 & 32767);
        this.outBuffer.putShortAdded(first + this.nextTopLeftTileX);
        this.outBuffer.putLEShortDup(second + this.nextTopRightTileY);
      }
      if (action === 432) {
        const class50_sub1_sub4_sub3_sub1_4 = this.npcs[clicked];
        if (class50_sub1_sub4_sub3_sub1_4 != null) {
          this.walk(
            false,
            false,
            class50_sub1_sub4_sub3_sub1_4.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            class50_sub1_sub4_sub3_sub1_4.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(8);
          this.outBuffer.putLEShortDup(clicked);
        }
      }
      if (action === Actions.CLOSE_WIDGETS) {
        this.closeWidgets();
      }
      if (action === 918) {
        const class50_sub1_sub4_sub3_sub2_4 = this.players[clicked];
        if (class50_sub1_sub4_sub3_sub2_4 != null) {
          this.walk(
            false,
            false,
            class50_sub1_sub4_sub3_sub2_4.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            class50_sub1_sub4_sub3_sub2_4.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(31);
          this.outBuffer.putShort(clicked);
          this.outBuffer.putLEShortDup(this.anInt1172);
        }
      }
      if (action === 67) {
        const class50_sub1_sub4_sub3_sub1_5 = this.npcs[clicked];
        if (class50_sub1_sub4_sub3_sub1_5 != null) {
          this.walk(
            false,
            false,
            class50_sub1_sub4_sub3_sub1_5.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            class50_sub1_sub4_sub3_sub1_5.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(104);
          this.outBuffer.putShortAdded(this.anInt1172);
          this.outBuffer.putLEShortDup(clicked);
        }
      }
      if (action === 68) {
        let flag1 = this.walk(
          false,
          false,
          second,
          _Game.localPlayer.pathY[0],
          0,
          0,
          2,
          0,
          first,
          0,
          0,
          _Game.localPlayer.pathX[0]
        );
        if (!flag1) {
          flag1 = this.walk(false, false, second, _Game.localPlayer.pathY[0], 1, 1, 2, 0, first, 0, 0, _Game.localPlayer.pathX[0]);
        }
        this.anInt1020 = this.clickX;
        this.anInt1021 = this.clickY;
        this.crossType = 2;
        this.crossIndex = 0;
        this.outBuffer.putOpcode(77);
        this.outBuffer.putShortAdded(first + this.nextTopLeftTileX);
        this.outBuffer.putShort(second + this.nextTopRightTileY);
        this.outBuffer.putLEShortAdded(clicked);
      }
      if (action === 684) {
        let flag2 = this.walk(
          false,
          false,
          second,
          _Game.localPlayer.pathY[0],
          0,
          0,
          2,
          0,
          first,
          0,
          0,
          _Game.localPlayer.pathX[0]
        );
        if (!flag2) {
          flag2 = this.walk(false, false, second, _Game.localPlayer.pathY[0], 1, 1, 2, 0, first, 0, 0, _Game.localPlayer.pathX[0]);
        }
        this.anInt1020 = this.clickX;
        this.anInt1021 = this.clickY;
        this.crossType = 2;
        this.crossIndex = 0;
        if ((clicked & 3) === 0) {
          _Game.anInt1052;
        }
        _Game.anInt1052++;
        if (_Game.anInt1052 >= 84) {
          this.outBuffer.putOpcode(222);
          this.outBuffer.putTriByte(11257922);
          _Game.anInt1052 = 0;
        }
        this.outBuffer.putOpcode(71);
        this.outBuffer.putLEShortAdded(clicked);
        this.outBuffer.putLEShortAdded(first + this.nextTopLeftTileX);
        this.outBuffer.putShortAdded(second + this.nextTopRightTileY);
      }
      if (action === Actions.ACCEPT_TRADE || action === Actions.ACCEPT_CHALLENGE) {
        let name = this.menuActionTexts[id];
        const colour = name.indexOf("@whi@");
        if (colour !== -1) {
          name = name.substring(colour + 5).trim();
          const username = TextUtils.formatName(TextUtils.longToName(TextUtils.nameToLong(name)));
          let found = false;
          for (let index = 0; index < this.localPlayerCount; index++) {
            {
              const player2 = this.players[this.playerList[index]];
              if (player2 == null || player2.playerName == null || !((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))(
                player2.playerName,
                username
              )) {
                continue;
              }
              this.walk(
                false,
                false,
                player2.pathY[0],
                _Game.localPlayer.pathY[0],
                1,
                1,
                2,
                0,
                player2.pathX[0],
                0,
                0,
                _Game.localPlayer.pathX[0]
              );
              if (action === Actions.ACCEPT_TRADE) {
                this.outBuffer.putOpcode(116);
                this.outBuffer.putLEShortDup(this.playerList[index]);
              }
              if (action === Actions.ACCEPT_CHALLENGE) {
                this.outBuffer.putOpcode(245);
                this.outBuffer.putLEShortAdded(this.playerList[index]);
              }
              found = true;
              break;
            }
          }
          if (!found) {
            this.addChatMessage("", "Unable to find " + username, 0);
          }
        }
      }
      if (action === 225) {
        this.outBuffer.putOpcode(177);
        this.outBuffer.putShortAdded(first);
        this.outBuffer.putLEShortDup(clicked);
        this.outBuffer.putLEShortDup(second);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === Actions.USABLE_WIDGET) {
        const widget = Widget.forId(second);
        this.widgetSelected = 1;
        this.anInt1172 = second;
        this.anInt1173 = widget.optionAttributes;
        this.itemSelected = 0;
        this.redrawTabArea = true;
        let prefix = widget.optionCircumfix;
        if (prefix.indexOf(" ") !== -1) {
          prefix = prefix.substring(0, prefix.indexOf(" "));
        }
        let suffix = widget.optionCircumfix;
        if (suffix.indexOf(" ") !== -1) {
          suffix = suffix.substring(suffix.indexOf(" ") + 1);
        }
        this.selectedWidgetName = prefix + " " + widget.optionText + " " + suffix;
        if (this.anInt1173 === 16) {
          this.redrawTabArea = true;
          this.anInt1285 = 3;
          this.aBoolean950 = true;
        }
        return;
      }
      if (action === 891) {
        this.outBuffer.putOpcode(4);
        this.outBuffer.putLEShortDup(first);
        this.outBuffer.putLEShortAdded(clicked);
        this.outBuffer.putLEShortAdded(second);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 894) {
        this.outBuffer.putOpcode(158);
        this.outBuffer.putLEShortAdded(first);
        this.outBuffer.putLEShortAdded(clicked);
        this.outBuffer.putLEShortDup(second);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 1280) {
        this.method80(second, 0, first, clicked);
        this.outBuffer.putOpcode(55);
        this.outBuffer.putLEShortDup(clicked >> 14 & 32767);
        this.outBuffer.putLEShortDup(second + this.nextTopRightTileY);
        this.outBuffer.putShort(first + this.nextTopLeftTileX);
      }
      if (action === 35) {
        this.method80(second, 0, first, clicked);
        this.outBuffer.putOpcode(181);
        this.outBuffer.putShortAdded(first + this.nextTopLeftTileX);
        this.outBuffer.putLEShortDup(second + this.nextTopRightTileY);
        this.outBuffer.putLEShortDup(clicked >> 14 & 32767);
      }
      if (action === 888) {
        this.method80(second, 0, first, clicked);
        this.outBuffer.putOpcode(50);
        this.outBuffer.putShortAdded(second + this.nextTopRightTileY);
        this.outBuffer.putLEShortDup(clicked >> 14 & 32767);
        this.outBuffer.putLEShortAdded(first + this.nextTopLeftTileX);
      }
      if (action === 324) {
        this.outBuffer.putOpcode(161);
        this.outBuffer.putLEShortAdded(first);
        this.outBuffer.putLEShortAdded(clicked);
        this.outBuffer.putLEShortDup(second);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === Actions.EXAMINE_ITEM) {
        const definition = ItemDefinition.lookup(clicked);
        const widget = Widget.forId(second);
        let description;
        if (widget != null && widget.itemAmounts[first] >= 1e5) {
          description = widget.itemAmounts[first] + " x " + definition.name;
        } else if (definition.description != null) {
          description = String.fromCharCode.apply(null, definition.description);
        } else {
          description = "It's a " + definition.name + ".";
        }
        this.addChatMessage("", description, 0);
      }
      if (action === 352) {
        const class13_2 = Widget.forId(second);
        let flag7 = true;
        if (class13_2.contentType > 0) {
          flag7 = this.handleWidgetDynamicAction(class13_2);
        }
        if (flag7) {
          this.outBuffer.putOpcode(79);
          this.outBuffer.putShort(second);
        }
      }
      if (action === 1412) {
        const k1 = clicked >> 14 & 32767;
        const class47 = GameObjectDefinition.getDefinition(k1);
        let s9;
        if (class47.description != null) {
          s9 = String.fromCharCode.apply(null, class47.description);
        } else {
          s9 = "It's a " + class47.name + ".";
        }
        this.addChatMessage("", s9, 0);
      }
      if (action === 575 && !this.aBoolean1239) {
        this.outBuffer.putOpcode(226);
        this.outBuffer.putShort(second);
        this.aBoolean1239 = true;
      }
      if (action === 892) {
        this.method80(second, 0, first, clicked);
        this.outBuffer.putOpcode(136);
        this.outBuffer.putShort(first + this.nextTopLeftTileX);
        this.outBuffer.putLEShortDup(second + this.nextTopRightTileY);
        this.outBuffer.putShort(clicked >> 14 & 32767);
      }
      if (action === 270) {
        let flag3 = this.walk(
          false,
          false,
          second,
          _Game.localPlayer.pathY[0],
          0,
          0,
          2,
          0,
          first,
          0,
          0,
          _Game.localPlayer.pathX[0]
        );
        if (!flag3) {
          flag3 = this.walk(false, false, second, _Game.localPlayer.pathY[0], 1, 1, 2, 0, first, 0, 0, _Game.localPlayer.pathX[0]);
        }
        this.anInt1020 = this.clickX;
        this.anInt1021 = this.clickY;
        this.crossType = 2;
        this.crossIndex = 0;
        this.outBuffer.putOpcode(230);
        this.outBuffer.putLEShortDup(clicked);
        this.outBuffer.putShortAdded(first + this.nextTopLeftTileX);
        this.outBuffer.putShort(second + this.nextTopRightTileY);
      }
      if (action === 596) {
        const class50_sub1_sub4_sub3_sub2_5 = this.players[clicked];
        if (class50_sub1_sub4_sub3_sub2_5 != null) {
          this.walk(
            false,
            false,
            class50_sub1_sub4_sub3_sub2_5.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            class50_sub1_sub4_sub3_sub2_5.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(143);
          this.outBuffer.putLEShortDup(this.anInt1149);
          this.outBuffer.putLEShortAdded(this.anInt1147);
          this.outBuffer.putShort(this.anInt1148);
          this.outBuffer.putShortAdded(clicked);
        }
      }
      if (action === 100) {
        let flag4 = this.walk(
          false,
          false,
          second,
          _Game.localPlayer.pathY[0],
          0,
          0,
          2,
          0,
          first,
          0,
          0,
          _Game.localPlayer.pathX[0]
        );
        if (!flag4) {
          flag4 = this.walk(false, false, second, _Game.local.pathY[0], 1, 1, 2, 0, first, 0, 0, _Game.localPlayer.pathX[0]);
        }
        this.anInt1020 = this.clickX;
        this.anInt1021 = this.clickY;
        this.crossType = 2;
        this.crossIndex = 0;
        this.outBuffer.putOpcode(211);
        this.outBuffer.putLEShortAdded(this.anInt1147);
        this.outBuffer.putShortAdded(this.anInt1149);
        this.outBuffer.putLEShortAdded(second + this.nextTopRightTileY);
        this.outBuffer.putLEShortAdded(first + this.nextTopLeftTileX);
        this.outBuffer.putLEShortDup(this.anInt1148);
        this.outBuffer.putLEShortDup(clicked);
      }
      if (action === 1668) {
        const class50_sub1_sub4_sub3_sub1_6 = this.npcs[clicked];
        if (class50_sub1_sub4_sub3_sub1_6 != null) {
          let class37 = class50_sub1_sub4_sub3_sub1_6.npcDefinition;
          if (class37.childrenIds != null) {
            class37 = class37.getChildDefinition();
          }
          if (class37 != null) {
            let s10;
            if (class37.description != null) {
              s10 = String.fromCharCode.apply(null, class37.description);
            } else {
              s10 = "It's a " + class37.name + ".";
            }
            this.addChatMessage("", s10, 0);
          }
        }
      }
      if (action === 26) {
        let flag5 = this.walk(
          false,
          false,
          second,
          _Game.localPlayer.pathY[0],
          0,
          0,
          2,
          0,
          first,
          0,
          0,
          _Game.localPlayer.pathX[0]
        );
        if (!flag5) {
          flag5 = this.walk(false, false, second, _Game.localPlayer.pathY[0], 1, 1, 2, 0, first, 0, 0, _Game.localPlayer.pathX[0]);
        }
        this.anInt1020 = this.clickX;
        this.anInt1021 = this.clickY;
        this.crossType = 2;
        this.crossIndex = 0;
        _Game.anInt1100;
        _Game.anInt1100++;
        if (_Game.anInt1100 >= 120) {
          this.outBuffer.putOpcode(95);
          this.outBuffer.putInt(0);
          _Game.anInt1100 = 0;
        }
        this.outBuffer.putOpcode(100);
        this.outBuffer.putShort(first + this.nextTopLeftTileX);
        this.outBuffer.putShortAdded(second + this.nextTopRightTileY);
        this.outBuffer.putLEShortAdded(clicked);
      }
      if (action === 444) {
        this.outBuffer.putOpcode(91);
        this.outBuffer.putLEShortDup(clicked);
        this.outBuffer.putLEShortAdded(first);
        this.outBuffer.putShort(second);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 507) {
        const string = this.menuActionTexts[id];
        const i_389_ = string.indexOf("@whi@");
        if (i_389_ !== -1) {
          if (this.openInterfaceId === -1) {
            this.closeWidgets();
            this.reportedName = string.substring(i_389_ + 5).trim();
            this.reportMutePlayer = false;
            this.reportAbuseInterfaceID = this.openInterfaceId = Widget.anInt246;
          } else {
            this.addChatMessage("", "Please close the interface you have open before using 'report abuse'", 0);
          }
        }
      }
      if (action === 389) {
        this.method80(second, 0, first, clicked);
        this.outBuffer.putOpcode(241);
        this.outBuffer.putShort(clicked >> 14 & 32767);
        this.outBuffer.putShort(first + this.nextTopLeftTileX);
        this.outBuffer.putShortAdded(second + this.nextTopRightTileY);
      }
      if (action === 564) {
        this.outBuffer.putOpcode(231);
        this.outBuffer.putLEShortAdded(second);
        this.outBuffer.putLEShortDup(first);
        this.outBuffer.putShort(clicked);
        this.atInventoryLoopCycle = 0;
        this.anInt1330 = second;
        this.anInt1331 = first;
        this.atInventoryInterfaceType = 2;
        if (Widget.forId(second).parentId === this.openInterfaceId) {
          this.atInventoryInterfaceType = 1;
        }
        if (Widget.forId(second).parentId === this.backDialogueId) {
          this.atInventoryInterfaceType = 3;
        }
      }
      if (action === 984) {
        const s3 = this.menuActionTexts[id];
        const l2 = s3.indexOf("@whi@");
        if (l2 !== -1) {
          const l4 = TextUtils.nameToLong(s3.substring(l2 + 5).trim());
          let k3 = -1;
          for (let i4 = 0; i4 < this.friendsCount; i4++) {
            {
              if (!this.friends[i4].eq(l4)) {
                continue;
              }
              k3 = i4;
              break;
            }
          }
          if (k3 !== -1 && this.friendWorlds[k3] > 0) {
            this.redrawChatbox = true;
            this.inputType = 0;
            this.messagePromptRaised = true;
            this.chatMessage = "";
            this.friendsListAction = 3;
            this.aLong1141 = this.friends[k3];
            this.chatboxInputMessage = "Enter message to send to " + this.friendUsernames[k3];
          }
        }
      }
      if (action === Actions.RESET_SETTING_WIDGET) {
        this.outBuffer.putOpcode(79);
        this.outBuffer.putShort(second);
        const widget = Widget.forId(second);
        if (widget.opcodes != null && widget.opcodes[0][0] === 5) {
          const operand = widget.opcodes[0][1];
          if (this.widgetSettings[operand] !== widget.conditionValues[0]) {
            this.widgetSettings[operand] = widget.conditionValues[0];
            this.updateVarp(0, operand);
            this.redrawTabArea = true;
          }
        }
      }
      if (action === 318) {
        const class50_sub1_sub4_sub3_sub1_7 = this.npcs[clicked];
        if (class50_sub1_sub4_sub3_sub1_7 != null) {
          this.walk(
            false,
            false,
            class50_sub1_sub4_sub3_sub1_7.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            class50_sub1_sub4_sub3_sub1_7.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(112);
          this.outBuffer.putLEShortDup(clicked);
        }
      }
      if (action === 199) {
        let flag6 = this.walk(
          false,
          false,
          second,
          _Game.localPlayer.pathY[0],
          0,
          0,
          2,
          0,
          first,
          0,
          0,
          _Game.localPlayer.pathX[0]
        );
        if (!flag6) {
          flag6 = this.walk(false, false, second, _Game.localPlayer.pathY[0], 1, 1, 2, 0, first, 0, 0, _Game.localPlayer.pathX[0]);
        }
        this.anInt1020 = this.clickX;
        this.anInt1021 = this.clickY;
        this.crossType = 2;
        this.crossIndex = 0;
        this.outBuffer.putOpcode(83);
        this.outBuffer.putLEShortDup(clicked);
        this.outBuffer.putShort(second + this.nextTopRightTileY);
        this.outBuffer.putLEShortDup(this.anInt1172);
        this.outBuffer.putLEShortAdded(first + this.nextTopLeftTileX);
      }
      if (action === 55) {
        this.method44(_Game.aBoolean1190, this.dialogueId);
        this.dialogueId = -1;
        this.redrawChatbox = true;
      }
      if (action === 52) {
        this.itemSelected = 1;
        this.anInt1147 = first;
        this.anInt1148 = second;
        this.anInt1149 = clicked;
        this.aString1150 = new String(ItemDefinition.lookup(clicked).name).toString();
        this.widgetSelected = 0;
        this.redrawTabArea = true;
        return;
      }
      if (action === 1564) {
        const class16_1 = ItemDefinition.lookup(clicked);
        let s6;
        if (class16_1.description != null) {
          s6 = String.fromCharCode.apply(null, class16_1.description);
        } else {
          s6 = "It's a " + class16_1.name + ".";
        }
        this.addChatMessage("", s6, 0);
      }
      if (action === 408) {
        const class50_sub1_sub4_sub3_sub2_6 = this.players[clicked];
        if (class50_sub1_sub4_sub3_sub2_6 != null) {
          this.walk(
            false,
            false,
            class50_sub1_sub4_sub3_sub2_6.pathY[0],
            _Game.localPlayer.pathY[0],
            1,
            1,
            2,
            0,
            class50_sub1_sub4_sub3_sub2_6.pathX[0],
            0,
            0,
            _Game.localPlayer.pathX[0]
          );
          this.anInt1020 = this.clickX;
          this.anInt1021 = this.clickY;
          this.crossType = 2;
          this.crossIndex = 0;
          this.outBuffer.putOpcode(194);
          this.outBuffer.putLEShortDup(clicked);
        }
      }
      this.itemSelected = 0;
      this.widgetSelected = 0;
      this.redrawTabArea = true;
    }
    handleWidgetDynamicAction(widget) {
      const type = widget.contentType;
      if (this.friendListStatus === 2) {
        if (type === 201) {
          this.redrawChatbox = true;
          this.inputType = 0;
          this.messagePromptRaised = true;
          this.chatMessage = "";
          this.friendsListAction = 1;
          this.chatboxInputMessage = "Enter name of friend to add to list";
        }
        if (type === 202) {
          this.redrawChatbox = true;
          this.inputType = 0;
          this.messagePromptRaised = true;
          this.chatMessage = "";
          this.friendsListAction = 2;
          this.chatboxInputMessage = "Enter name of friend to delete from list";
        }
      }
      if (type === 205) {
        this.anInt873 = 250;
        return true;
      }
      if (type === 501) {
        this.redrawChatbox = true;
        this.inputType = 0;
        this.messagePromptRaised = true;
        this.chatMessage = "";
        this.friendsListAction = 4;
        this.chatboxInputMessage = "Enter name of player to add to list";
      }
      if (type === 502) {
        this.redrawChatbox = true;
        this.inputType = 0;
        this.messagePromptRaised = true;
        this.chatMessage = "";
        this.friendsListAction = 5;
        this.chatboxInputMessage = "Enter name of player to delete from list";
      }
      if (type >= 300 && type <= 313) {
        const k = (type - 300) / 2 | 0;
        const j1 = type & 1;
        let i2 = this.characterEditIdentityKits[k];
        if (i2 !== -1) {
          do {
            {
              if (j1 === 0 && --i2 < 0) {
                i2 = IdentityKit.count - 1;
              }
              if (j1 === 1 && ++i2 >= IdentityKit.count) {
                i2 = 0;
              }
            }
          } while (IdentityKit.cache[i2].widgetDisplayed || IdentityKit.cache[i2].partId !== k + (this.characterEditChangeGenger ? 0 : 7));
          this.characterEditIdentityKits[k] = i2;
          this.aBoolean1277 = true;
        }
      }
      if (type >= 314 && type <= 323) {
        const l = (type - 314) / 2 | 0;
        const k1 = type & 1;
        let j2 = this.characterEditColors[l];
        if (k1 === 0 && --j2 < 0) {
          j2 = _Game.playerColours[l].length - 1;
        }
        if (k1 === 1 && ++j2 >= _Game.playerColours[l].length) {
          j2 = 0;
        }
        this.characterEditColors[l] = j2;
        this.aBoolean1277 = true;
      }
      if (type === 324 && !this.characterEditChangeGenger) {
        this.characterEditChangeGenger = true;
        this.method25();
      }
      if (type === 325 && this.characterEditChangeGenger) {
        this.characterEditChangeGenger = false;
        this.method25();
      }
      if (type === 326) {
        this.outBuffer.putOpcode(163);
        this.outBuffer.putByte(this.characterEditChangeGenger ? 0 : 1);
        for (let i1 = 0; i1 < 7; i1++) {
          this.outBuffer.putByte(this.characterEditIdentityKits[i1]);
        }
        for (let l1 = 0; l1 < 5; l1++) {
          this.outBuffer.putByte(this.characterEditColors[l1]);
        }
        return true;
      }
      if (type === 620) {
        this.reportMutePlayer = !this.reportMutePlayer;
      }
      if (type >= 601 && type <= 613) {
        this.closeWidgets();
        if (this.reportedName.length > 0) {
          this.outBuffer.putOpcode(184);
          this.outBuffer.putLong(TextUtils.nameToLong(this.reportedName));
          this.outBuffer.putByte(type - 601);
          this.outBuffer.putByte(this.reportMutePlayer ? 1 : 0);
        }
      }
      return false;
    }
    closeWidgets() {
      this.outBuffer.putOpcode(110);
      if (this.anInt1089 !== -1) {
        this.method44(_Game.aBoolean1190, this.anInt1089);
        this.anInt1089 = -1;
        this.redrawTabArea = true;
        this.aBoolean1239 = false;
        this.aBoolean950 = true;
      }
      if (this.backDialogueId !== -1) {
        this.method44(_Game.aBoolean1190, this.backDialogueId);
        this.backDialogueId = -1;
        this.redrawChatbox = true;
        this.aBoolean1239 = false;
      }
      if (this.anInt1053 !== -1) {
        this.method44(_Game.aBoolean1190, this.anInt1053);
        this.anInt1053 = -1;
        this.aBoolean1046 = true;
      }
      if (this.anInt960 !== -1) {
        this.method44(_Game.aBoolean1190, this.anInt960);
        this.anInt960 = -1;
      }
      if (this.openInterfaceId !== -1) {
        this.method44(_Game.aBoolean1190, this.openInterfaceId);
        this.openInterfaceId = -1;
      }
    }
    method80(dstY, j, dstX, l) {
      const i1 = l >> 14 & 32767;
      const j1 = this.currentScene.method271(this.plane, dstX, dstY, l);
      if (j1 === -1) {
        return false;
      }
      const objectType = j1 & 31;
      const l1 = j1 >> 6 & 3;
      if (objectType === 10 || objectType === 11 || objectType === 22) {
        const class47 = GameObjectDefinition.getDefinition(i1);
        let i2;
        let j2;
        if (l1 === 0 || l1 === 2) {
          i2 = class47.sizeX;
          j2 = class47.sizeY;
        } else {
          i2 = class47.sizeY;
          j2 = class47.sizeX;
        }
        let k2 = class47.anInt764;
        if (l1 !== 0) {
          k2 = (k2 << l1 & 15) + (k2 >> 4 - l1);
        }
        this.walk(true, false, dstY, _Game.localPlayer.pathY[0], i2, j2, 2, 0, dstX, k2, 0, _Game.localPlayer.pathX[0]);
      } else {
        this.walk(true, false, dstY, _Game.localPlayer.pathY[0], 0, 0, 2, objectType + 1, dstX, 0, l1, _Game.localPlayer.pathX[0]);
      }
      this.anInt1020 = this.clickX;
      this.anInt1021 = this.clickY;
      this.crossType = 2;
      this.crossIndex = 0;
      this.packetSize += j;
      return true;
    }
    removeFriend(l) {
      try {
        if (l.isZero()) {
          return;
        }
        for (let j = 0; j < this.friendsCount; j++) {
          {
            if (!this.friends[j].eq(l)) {
              continue;
            }
            this.friendsCount--;
            this.redrawTabArea = true;
            for (let k = j; k < this.friendsCount; k++) {
              {
                this.friendUsernames[k] = this.friendUsernames[k + 1];
                this.friendWorlds[k] = this.friendWorlds[k + 1];
                this.friends[k] = this.friends[k + 1];
              }
            }
            this.outBuffer.putOpcode(141);
            this.outBuffer.putLong(l);
            break;
          }
        }
      } catch (runtimeexception) {
        SignLink.reportError("38799, " + l + ", " + runtimeexception.toString());
      }
      throw Error();
    }
    removeIgnore(l) {
      try {
        if (l.isZero()) {
          return;
        }
        for (let j = 0; j < this.ignoresCount; j++) {
          {
            if (!this.ignores[j].eq(l)) {
              continue;
            }
            this.ignoresCount--;
            this.redrawTabArea = true;
            for (let k = j; k < this.ignoresCount; k++) {
              this.ignores[k] = this.ignores[k + 1];
            }
            this.outBuffer.putOpcode(160);
            this.outBuffer.putLong(l);
            break;
          }
        }
        return;
      } catch (runtimeexception) {
        SignLink.reportError("45745, " + l + ", " + runtimeexception.toString());
      }
      throw Error();
    }
    addFriend(name) {
      try {
        if (name.isZero()) {
          return;
        }
        if (this.friendsCount >= 100 && this.playerMembers !== 1) {
          this.addChatMessage("", "Your friendlist is full. Max of 100 for free users, and 200 for members", 0);
          return;
        }
        if (this.friendsCount >= 200) {
          this.addChatMessage("", "Your friendlist is full. Max of 100 for free users, and 200 for members", 0);
          return;
        }
        const username = TextUtils.formatName(TextUtils.longToName(name));
        for (let index = 0; index < this.friendsCount; index++) {
          if (this.friends[index].eq(name)) {
            this.addChatMessage("", username + " is already on your friend list", 0);
            return;
          }
        }
        for (let index = 0; index < this.ignoresCount; index++) {
          if (!this.ignores[index].eq(name)) {
            this.addChatMessage("", "Please remove " + username + " from your ignore list first", 0);
            return;
          }
        }
        if (((o1, o2) => {
          if (o1 && o1.equals) {
            return o1.equals(o2);
          } else {
            return o1 === o2;
          }
        })(username, _Game.localPlayer.playerName)) {
          return;
        }
        this.friendUsernames[this.friendsCount] = username;
        this.friends[this.friendsCount] = name;
        this.friendWorlds[this.friendsCount] = 0;
        this.friendsCount++;
        this.redrawTabArea = true;
        this.outBuffer.putOpcode(120);
        this.outBuffer.putLong(name);
        return;
      } catch (runtimeexception) {
        SignLink.reportError("94629, " + name + ", , " + runtimeexception.toString());
      }
      throw Error();
    }
    addIgnore(i, name) {
      try {
        if (name.isZero()) {
          return;
        }
        if (this.ignoresCount >= 100) {
          this.addChatMessage("", "Your ignore list is full. Max of 100 hit", 0);
          return;
        }
        const username = TextUtils.formatName(TextUtils.longToName(name));
        for (let index = 0; index < this.ignoresCount; index++) {
          if (!this.ignores[index].eq(name)) {
            this.addChatMessage("", username + " is already on your ignore list", 0);
            return;
          }
        }
        for (let index = 0; index < this.friendsCount; index++) {
          if (this.friends[index].eq(name)) {
            this.addChatMessage("", "Please remove " + username + " from your friend list first", 0);
            return;
          }
        }
        this.ignores[this.ignoresCount++] = name;
        this.redrawTabArea = true;
        this.outBuffer.putOpcode(217);
        this.outBuffer.putLong(name);
        return;
      } catch (runtimeexception) {
        SignLink.reportError("27939, " + i + ", " + name + ", " + runtimeexception.toString());
      }
      throw Error();
    }
    initArchives() {
      console.log("initArchives");
      this.titleArchive = this.requestArchive(1, "title", this.archiveHashes[1], 25, "title screen");
    }
    initTypeFaces() {
      console.log("initTypeFaces");
      this.fontSmall = new TypeFace(false, this.titleArchive, "p11_full");
      this.fontNormal = new TypeFace(false, this.titleArchive, "p12_full");
      this.fontBold = new TypeFace(false, this.titleArchive, "b12_full");
      this.fontFancy = new TypeFace(true, this.titleArchive, "q8_full");
    }
    requestArchive(id, file, expectedCrc, x2, displayName) {
      return new Archive(this.stores[0].get(id));
    }
    async getFile(fileUrl) {
      const resp = await fetch(fileUrl);
      return resp.arrayBuffer();
    }
  };
  var Game = _Game;
  Game.parallelExecutor = new ParallelExecutor();
  Game.pulseCycle = 0;
  Game.portOffset = 0;
  Game.BITFIELD_MAX_VALUE = init_BITFIELD_MAX_VALUE();
  Game.SKILL_EXPERIENCE = init_SKILL_EXPERIENCE();
  Game.memberServer = true;
  Game.lowMemory = false;
  Game.localPlayer = null;
  Game.playerColours = [
    [6798, 107, 10283, 16, 4797, 7744, 5799, 4634, 33697, 22433, 2983, 54193],
    [8741, 12, 64030, 43162, 7735, 8404, 1701, 38430, 24094, 10153, 56621, 4783, 1341, 16578, 35003, 25239],
    [25238, 8742, 12, 64030, 43162, 7735, 8404, 1701, 38430, 24094, 10153, 56621, 4783, 1341, 16578, 35003],
    [4626, 11146, 6439, 12, 4758, 10270],
    [4550, 4537, 5681, 5673, 5790, 6806, 8076, 4574]
  ];
  Game.SKIN_COLOURS = [9104, 10275, 7595, 3610, 7975, 8526, 918, 38802, 24466, 10145, 58654, 5027, 1457, 16565, 34991, 25486];
  Game.VALID_CHARACTERS = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"\xA3$%^&*()-_=+[{]};:'@#~,<.>/?\\| `;
  Game.anInt1309 = 0;
  Game.accountFlagged = false;
  Game.aBoolean1190 = true;
  Game.anInt1100 = 0;
  Game.anInt1165 = 0;
  Game.anInt1235 = 0;
  Game.anInt1052 = 0;
  Game.anInt1139 = 0;
  Game.anInt841 = 0;
  Game.anInt1230 = 0;
  Game.anInt1013 = 0;
  Game.anInt1049 = 0;
  Game.anInt1162 = 0;
  Game.aBoolean1242 = true;
  Game.aBoolean1207 = false;
  Game.anInt1082 = 0;
  Game.world = 10;
  Game.aBoolean963 = true;
  Game.anInt1160 = 0;
  Game.fps = true;
  Game.anInt1237 = 0;
  Game.anInt1168 = 0;
  Game.anInt978 = 0;
  Game.anInt895 = 0;

  // osrs/GamePlayground.ts
  var game = new Game(document.getElementById("gameCanvas"));
  async function startGame() {
    await game.initializeApplication(765, 503);
  }
  startGame().then(() => {
    console.log("Game stopped!");
  }).catch((error) => {
    console.error(error);
  });
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
